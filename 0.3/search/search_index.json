{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"api/","title":"<code>atomlib</code> API Reference","text":"<p>Top-level exports:</p>"},{"location":"api/#atomlib","title":"<code>atomlib</code>","text":""},{"location":"api/#atomlib.AtomSelection","title":"<code>AtomSelection = t.Union[polars.Series, polars.Expr, ArrayLike]</code>  <code>module-attribute</code>","text":"<p>Polars expression selecting a subset of atoms from an Atoms. Can be used with many Atoms methods.</p>"},{"location":"api/#atomlib.CoordinateFrame","title":"<code>CoordinateFrame = t.Literal['cell', 'cell_frac', 'cell_box', 'ortho', 'ortho_frac', 'ortho_box', 'linear', 'local', 'global']</code>  <code>module-attribute</code>","text":"<p>A coordinate frame to use.</p> <ul> <li><code>cell</code>: Real-space units along crystal axes</li> <li><code>cell_frac</code>: Fraction of unit cells</li> <li><code>cell_box</code>: Fraction of cell box</li> <li><code>ortho</code>: Real-space units along orthogonal cell</li> <li><code>ortho_frac</code>: Fraction of orthogonal cell</li> <li><code>ortho_box</code>: Fraction of orthogonal box</li> <li><code>linear</code>: Angstroms in local coordinate system (without affine transformation)</li> <li><code>local</code>: Angstroms in local coordinate system (with affine transformation)</li> <li><code>global</code>: Angstroms in global coordinate system (with all transformations)</li> </ul> <p>For more information, see the documentation at Coordinate systems, or the example notebook at <code>examples/coords.ipynb</code>.</p>"},{"location":"api/#atomlib.Atoms","title":"<code>Atoms</code>","text":"<p>             Bases: <code>AtomsIOMixin</code>, <code>HasAtoms</code></p> <p>A collection of atoms, absent any implied coordinate system. Implemented as a wrapper around a Polars DataFrame.</p> <p>Must contain the following columns: - x: x position, float - y: y position, float - z: z position, float - elem: atomic number, int - symbol: atomic symbol (may contain charges)</p> <p>In addition, it commonly contains the following columns: - i: Initial atom number - wobble: Isotropic Debye-Waller mean-squared deviation ( = B*3/8pi^2, dimensions of [Length^2]) - frac_occupancy: Fractional occupancy, [0., 1.] - mass: Atomic mass, in g/mol (approx. Da) - v_[xyz]: Atom velocities, dimensions of length/time - atom_type: Numeric atom type, as used by programs like LAMMPS Source code in <code>atomlib/atoms.py</code> <pre><code>class Atoms(AtomsIOMixin, HasAtoms):\n\"\"\"\n    A collection of atoms, absent any implied coordinate system.\n    Implemented as a wrapper around a Polars DataFrame.\n    Must contain the following columns:\n    - x: x position, float\n    - y: y position, float\n    - z: z position, float\n    - elem: atomic number, int\n    - symbol: atomic symbol (may contain charges)\n    In addition, it commonly contains the following columns:\n    - i: Initial atom number\n    - wobble: Isotropic Debye-Waller mean-squared deviation (&lt;u^2&gt; = B*3/8pi^2, dimensions of [Length^2])\n    - frac_occupancy: Fractional occupancy, [0., 1.]\n    - mass: Atomic mass, in g/mol (approx. Da)\n    - v_[xyz]: Atom velocities, dimensions of length/time\n    - atom_type: Numeric atom type, as used by programs like LAMMPS\n    \"\"\"\ndef __init__(self, data: t.Optional[IntoAtoms] = None, columns: t.Optional[t.Sequence[str]] = None,\norient: t.Union[t.Literal['row'], t.Literal['col'], None] = None,\n_unchecked: bool = False):\nself._bbox: t.Optional[BBox3D] = None\nif data is None:\nassert columns is None\nself.inner = polars.DataFrame([\npolars.Series('x', (), dtype=polars.Float64),\npolars.Series('y', (), dtype=polars.Float64),\npolars.Series('z', (), dtype=polars.Float64),\npolars.Series('elem', (), dtype=polars.Int8),\npolars.Series('symbol', (), dtype=polars.Utf8),\n])\nelif isinstance(data, polars.DataFrame):\nself.inner = data\nelif isinstance(data, Atoms):\nself.inner = data.inner\n_unchecked = True\nelse:\nself.inner = polars.DataFrame(data, schema=columns, orient=orient)  # type: ignore\nif not _unchecked:\nmissing: t.Tuple[str, ...] = tuple(set(['symbol', 'elem']) - set(self.columns))\nif len(missing) &gt; 1:\nraise ValueError(\"'Atoms' missing columns 'elem' and/or 'symbol'.\")\n# fill 'symbol' from 'elem' or vice-versa\nif missing == ('symbol',):\nself.inner = self.inner.with_columns(get_sym(self.inner['elem']))\nelif missing == ('elem',):\nself.inner = self.inner.with_columns(get_elem(self.inner['symbol']))\n# cast to standard dtypes\nself.inner = self.inner.with_columns([\nself.inner[col].cast(dtype)\nfor (col, dtype) in _COLUMN_DTYPES.items() if col in self.inner\n])\nself._validate_atoms()\n@staticmethod\ndef empty() -&gt; Atoms:\n\"\"\"\n        Return an empty Atoms with only the mandatory columns.\n        \"\"\"\nreturn Atoms()\ndef _validate_atoms(self):\nmissing = [col for col in ['x', 'y', 'z', 'elem', 'symbol'] if col not in self.columns]\nif len(missing):\nraise ValueError(f\"'Atoms' missing column(s) {', '.join(map(repr, missing))}\")\ndef get_atoms(self, frame: t.Literal['local'] = 'local') -&gt; Atoms:\nif frame != 'local':\nraise ValueError(f\"Atoms without a cell only support the 'local' coordinate frame, not '{frame}'.\")\nreturn self\ndef with_atoms(self, atoms: HasAtoms, frame: t.Literal['local'] = 'local') -&gt; Atoms:\nif frame != 'local':\nraise ValueError(f\"Atoms without a cell only support the 'local' coordinate frame, not '{frame}'.\")\nreturn atoms.get_atoms()\n@classmethod\ndef _combine_metadata(cls: t.Type[Atoms], *atoms: HasAtoms) -&gt; Atoms:\nreturn cls.empty()\ndef bbox(self) -&gt; BBox3D:\n\"\"\"Return the bounding box of all the points in `self`.\"\"\"\nif self._bbox is None:\nself._bbox = BBox3D.from_pts(self.coords())\nreturn self._bbox\ndef __str__(self) -&gt; str:\nreturn f\"Atoms, {self.inner!s}\"\ndef __repr__(self) -&gt; str:\n# real __repr__ that polars doesn't provide\nlines = [\"Atoms([\"]\nfor (col, series) in self.inner.to_dict().items():\nlines.append(f\"    Series({col!r}, {list(series)!r}, {series.dtype!r}),\")\nlines.append(\"])\")\nreturn \"\\n\".join(lines)\ndef _repr_pretty_(self, p, cycle: bool) -&gt; None:\np.text('Atoms(...)') if cycle else p.text(str(self))\n</code></pre>"},{"location":"api/#atomlib.Atoms.columns","title":"<code>columns: t.Sequence[str]</code>  <code>property</code>","text":"<p>Return the columns in <code>self</code>.</p>"},{"location":"api/#atomlib.Atoms.schema","title":"<code>schema: SchemaDict</code>  <code>property</code>","text":"<p>Return the schema of <code>self</code>.</p>"},{"location":"api/#atomlib.Atoms.transform","title":"<code>transform = transform_atoms</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#atomlib.Atoms.crop_atoms","title":"<code>crop_atoms = crop</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#atomlib.Atoms.unique","title":"<code>unique = deduplicate</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#atomlib.Atoms.inner","title":"<code>inner = polars.DataFrame([polars.Series('x', (), dtype=polars.Float64), polars.Series('y', (), dtype=polars.Float64), polars.Series('z', (), dtype=polars.Float64), polars.Series('elem', (), dtype=polars.Int8), polars.Series('symbol', (), dtype=polars.Utf8)])</code>  <code>instance-attribute</code>","text":""},{"location":"api/#atomlib.Atoms.with_column","title":"<code>with_column(column)</code>","text":"<p>Return a copy of <code>self</code> with the given column added.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def with_column(self: HasAtomsT, column: t.Union[polars.Series, polars.Expr]) -&gt; HasAtomsT:\n\"\"\"Return a copy of ``self`` with the given column added.\"\"\"\nreturn self.with_atoms(Atoms(self._get_frame().with_columns((column,)), _unchecked=True))\n</code></pre>"},{"location":"api/#atomlib.Atoms.with_columns","title":"<code>with_columns(exprs, **named_exprs)</code>","text":"<p>Return a copy of <code>self</code> with the given columns added.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def with_columns(self: HasAtomsT,\nexprs: t.Union[t.Literal[None], polars.Series, polars.Expr, t.Sequence[t.Union[polars.Series, polars.Expr]]],\n**named_exprs: t.Union[polars.Expr, polars.Series]) -&gt; HasAtomsT:\n\"\"\"Return a copy of ``self`` with the given columns added.\"\"\"\nreturn self.with_atoms(Atoms(self._get_frame().with_columns(exprs, **named_exprs), _unchecked=True))\n</code></pre>"},{"location":"api/#atomlib.Atoms.get_column","title":"<code>get_column(name)</code>","text":"<p>Get the specified column from <code>self</code>, raising :py:<code>polars.NotFoundError</code> if it's not present.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def get_column(self, name: str) -&gt; polars.Series:\n\"\"\"Get the specified column from ``self``, raising :py:`polars.NotFoundError` if it's not present.\"\"\"\nreturn self._get_frame().get_column(name)\n</code></pre>"},{"location":"api/#atomlib.Atoms.filter","title":"<code>filter(selection=None)</code>","text":"<p>Filter <code>self</code>, removing rows which evaluate to <code>False</code>.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def filter(self: HasAtomsT, selection: t.Optional[AtomSelection] = None) -&gt; HasAtomsT:\n\"\"\"Filter ``self``, removing rows which evaluate to ``False``.\"\"\"\nif selection is None:\nreturn self\nreturn self.with_atoms(Atoms(self._get_frame().filter(_selection_to_expr(selection)), _unchecked=True))\n</code></pre>"},{"location":"api/#atomlib.Atoms.select","title":"<code>select(exprs)</code>","text":"<p>Select <code>exprs</code> from <code>self</code>, and return as a :py:class:<code>polars.DataFrame</code>.</p> <p>Expressions may either be columns or expressions of columns.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def select(self, exprs: t.Union[str, polars.Expr, polars.Series, t.Sequence[t.Union[str, polars.Expr, polars.Series]]]\n) -&gt; polars.DataFrame:\n\"\"\"\n    Select ``exprs`` from ``self``, and return as a :py:class:`polars.DataFrame`.\n    Expressions may either be columns or expressions of columns.\n    \"\"\"\nreturn self._get_frame().select(exprs)\n</code></pre>"},{"location":"api/#atomlib.Atoms.sort","title":"<code>sort(by, descending=False)</code>","text":"Source code in <code>atomlib/atoms.py</code> <pre><code>def sort(self: HasAtomsT, by: t.Union[str, polars.Expr, t.List[str], t.List[polars.Expr]], descending: t.Union[bool, t.List[bool]] = False) -&gt; HasAtomsT:\nreturn self.with_atoms(Atoms(self._get_frame().sort(by, descending=descending), _unchecked=True))\n</code></pre>"},{"location":"api/#atomlib.Atoms.concat","title":"<code>concat(atoms, *, rechunk=True, how='vertical')</code>  <code>classmethod</code>","text":"Source code in <code>atomlib/atoms.py</code> <pre><code>@classmethod\ndef concat(cls: t.Type[HasAtomsT],\natoms: t.Union[HasAtomsT, IntoAtoms, t.Iterable[t.Union[HasAtomsT, IntoAtoms]]], *,\nrechunk: bool = True, how: ConcatMethod = 'vertical') -&gt; HasAtomsT:\n# this method is tricky. It needs to accept raw Atoms, as well as HasAtoms of the\n# same type as ``cls``.\nif _is_abstract(cls):\nraise TypeError(f\"concat() must be called on a concrete class.\")\nif isinstance(atoms, HasAtoms):\natoms = (atoms,)\ndfs = [a.get_atoms('local').inner if isinstance(a, HasAtoms) else Atoms(a).inner for a in atoms]\nrepresentative = cls._combine_metadata(*(a for a in atoms if isinstance(a, HasAtoms)))\nif len(dfs) == 0:\nreturn representative.with_atoms(Atoms.empty(), 'local')\nif how in ('vertical', 'vertical_relaxed'):\n# get order from first member\ncols = dfs[0].columns\ndfs = [df.select(cols) for df in dfs]\nelif how == 'inner':\ncols = reduce(operator.and_, (df.schema.keys() for df in dfs))\nschema = t.cast(SchemaDict, {col: dfs[0].schema[col] for col in cols})\nif len(schema) == 0:\nraise ValueError(f\"Atoms have no columns in common\")\ndfs = [_select_schema(df, schema) for df in dfs]\nhow = 'vertical'\nreturn representative.with_atoms(Atoms(polars.concat(dfs, rechunk=rechunk, how=how)), 'local')\n</code></pre>"},{"location":"api/#atomlib.Atoms.select_schema","title":"<code>select_schema(schema)</code>","text":"<p>Select columns from <code>self</code> and cast to the given schema. Raises :py:<code>TypeError</code> if a column is not found or if it can't be cast.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def select_schema(self, schema: SchemaDict) -&gt; polars.DataFrame:\n\"\"\"\n    Select columns from ``self`` and cast to the given schema.\n    Raises :py:`TypeError` if a column is not found or if it can't be cast.\n    \"\"\"\nreturn _select_schema(self, schema)\n</code></pre>"},{"location":"api/#atomlib.Atoms.try_select","title":"<code>try_select(exprs)</code>","text":"<p>Try to select <code>exprs</code> from <code>self</code>, and return as a <code>DataFrame</code>.</p> <p>Expressions may either be columns or expressions of columns. Return <code>None</code> if any columns are missing.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def try_select(self, exprs: t.Union[str, polars.Expr, polars.Series, t.Sequence[t.Union[str, polars.Expr, polars.Series]]]\n) -&gt; t.Optional[polars.DataFrame]:\n\"\"\"\n    Try to select ``exprs`` from ``self``, and return as a ``DataFrame``.\n    Expressions may either be columns or expressions of columns.\n    Return ``None`` if any columns are missing.\n    \"\"\"\ntry:\nreturn self._get_frame().select(exprs)\nexcept ColumnNotFoundError:\nreturn None\n</code></pre>"},{"location":"api/#atomlib.Atoms.try_get_column","title":"<code>try_get_column(name)</code>","text":"<p>Try to get a column from <code>self</code>, returning <code>None</code> if it doesn't exist.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def try_get_column(self, name: str) -&gt; t.Optional[polars.Series]:\n\"\"\"Try to get a column from `self`, returning `None` if it doesn't exist.\"\"\"\ntry:\nreturn self.get_column(name)\nexcept ColumnNotFoundError:\nreturn None\n</code></pre>"},{"location":"api/#atomlib.Atoms.assert_equal","title":"<code>assert_equal(other)</code>","text":"Source code in <code>atomlib/atoms.py</code> <pre><code>def assert_equal(self, other: t.Any):\nassert isinstance(other, HasAtoms)\nassert self.schema == other.schema\nfor (col, dtype) in self.schema.items():\nif dtype in (polars.Float32, polars.Float64):\nnumpy.testing.assert_array_almost_equal(self[col].view(ignore_nulls=True), other[col].view(ignore_nulls=True), 5)\nelse:\nassert (self[col] == other[col]).all()\n</code></pre>"},{"location":"api/#atomlib.Atoms.bbox_atoms","title":"<code>bbox_atoms()</code>","text":"<p>Return the bounding box of all the atoms in <code>self</code>.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def bbox_atoms(self) -&gt; BBox3D:\n\"\"\"Return the bounding box of all the atoms in ``self``.\"\"\"\nreturn BBox3D.from_pts(self.coords())\n</code></pre>"},{"location":"api/#atomlib.Atoms.transform_atoms","title":"<code>transform_atoms(transform, selection=None, *, transform_velocities=False)</code>","text":"<p>Transform the atoms in <code>self</code> by <code>transform</code>. If <code>selection</code> is given, only transform the atoms in <code>selection</code>.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def transform_atoms(self: HasAtomsT, transform: IntoTransform3D, selection: t.Optional[AtomSelection] = None, *, transform_velocities: bool = False) -&gt; HasAtomsT:\n\"\"\"\n    Transform the atoms in `self` by `transform`.\n    If `selection` is given, only transform the atoms in `selection`.\n    \"\"\"\ntransform = Transform3D.make(transform)\nselection = map_some(lambda s: _selection_to_series(self, s), selection)\ntransformed = self.with_coords(Transform3D.make(transform) @ self.coords(selection), selection)\n# try to transform velocities as well\nif transform_velocities and (velocities := self.velocities(selection)) is not None:\nreturn transformed.with_velocity(transform.transform_vec(velocities), selection)\nreturn transformed\n</code></pre>"},{"location":"api/#atomlib.Atoms.round_near_zero","title":"<code>round_near_zero(tol=1e-14)</code>","text":"<p>Round atom position values near zero to zero.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def round_near_zero(self: HasAtomsT, tol: float = 1e-14) -&gt; HasAtomsT:\n\"\"\"\n    Round atom position values near zero to zero.\n    \"\"\"\nreturn self.with_columns(tuple(\npolars.when(col.abs() &gt;= tol).then(col).otherwise(polars.lit(0.))\nfor col in map(polars.col, ('x', 'y', 'z'))\n))\n</code></pre>"},{"location":"api/#atomlib.Atoms.crop","title":"<code>crop(x_min=-numpy.inf, x_max=numpy.inf, y_min=-numpy.inf, y_max=numpy.inf, z_min=-numpy.inf, z_max=numpy.inf)</code>","text":"<p>Crop, removing all atoms outside of the specified region, inclusive.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def crop(self: HasAtomsT, x_min: float = -numpy.inf, x_max: float = numpy.inf,\ny_min: float = -numpy.inf, y_max: float = numpy.inf,\nz_min: float = -numpy.inf, z_max: float = numpy.inf) -&gt; HasAtomsT:\n\"\"\"\n    Crop, removing all atoms outside of the specified region, inclusive.\n    \"\"\"\nreturn self.filter(\n(polars.col('x') &gt;= x_min) &amp; (polars.col('x') &lt;= x_max) &amp;\n(polars.col('y') &gt;= y_min) &amp; (polars.col('y') &lt;= y_max) &amp;\n(polars.col('z') &gt;= z_min) &amp; (polars.col('z') &lt;= z_max)\n)\n</code></pre>"},{"location":"api/#atomlib.Atoms.deduplicate","title":"<code>deduplicate(tol=0.001, subset=('x', 'y', 'z', 'symbol'), keep='first')</code>","text":"<p>De-duplicate atoms in <code>self</code>. Atoms of the same <code>symbol</code> that are closer than <code>tolerance</code> to each other (by Euclidian distance) will be removed, leaving only the atom specified by <code>keep</code> (defaults to the first atom).</p> <p>If <code>subset</code> is specified, only those columns will be included while assessing duplicates. Floating point columns other than 'x', 'y', and 'z' will not by toleranced.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def deduplicate(self: HasAtomsT, tol: float = 1e-3, subset: t.Iterable[str] = ('x', 'y', 'z', 'symbol'),\nkeep: UniqueKeepStrategy = 'first') -&gt; HasAtomsT:\n\"\"\"\n    De-duplicate atoms in `self`. Atoms of the same `symbol` that are closer than `tolerance`\n    to each other (by Euclidian distance) will be removed, leaving only the atom specified by\n    `keep` (defaults to the first atom).\n    If `subset` is specified, only those columns will be included while assessing duplicates.\n    Floating point columns other than 'x', 'y', and 'z' will not by toleranced.\n    \"\"\"\ncols = set((subset,) if isinstance(subset, str) else subset)\nindices = numpy.arange(len(self))\nspatial_cols = cols.intersection(('x', 'y', 'z'))\ncols -= spatial_cols\nif len(spatial_cols) &gt; 0:\ncoords = self.select(list(spatial_cols)).to_numpy()\nprint(coords.shape)\ntree = scipy.spatial.KDTree(coords)\n# TODO This is a bad algorithm\nwhile True:\nchanged = False\nfor (i, j) in tree.query_pairs(tol, 2.):\n# whenever we encounter a pair, ensure their index matches\ni_i, i_j = indices[[i, j]]\nif i_i != i_j:\nindices[i] = indices[j] = min(i_i, i_j)\nchanged = True\nif not changed:\nbreak\nself = self.with_column(polars.Series('_unique_pts', indices))\ncols.add('_unique_pts')\nframe = self._get_frame().unique(subset=list(cols), keep=keep)\nif len(spatial_cols) &gt; 0:\nframe = frame.drop('_unique_pts')\nreturn self.with_atoms(Atoms(frame, _unchecked=True))\n</code></pre>"},{"location":"api/#atomlib.Atoms.with_bounds","title":"<code>with_bounds(cell_size=None, cell_origin=None)</code>","text":"<p>Return a periodic cell with the given orthogonal cell dimensions.</p> <p>If cell_size is not specified, it will be assumed (and may be incorrect).</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def with_bounds(self, cell_size: t.Optional[VecLike] = None, cell_origin: t.Optional[VecLike] = None) -&gt; 'AtomCell':\n\"\"\"\n    Return a periodic cell with the given orthogonal cell dimensions.\n    If cell_size is not specified, it will be assumed (and may be incorrect).\n    \"\"\"\n# TODO: test this\nfrom .atomcell import AtomCell\nif cell_size is None:\nwarnings.warn(\"Cell boundary unknown. Defaulting to cell BBox\")\ncell_size = self.bbox().size\ncell_origin = self.bbox().min\n# TODO test this origin code\ncell = Cell.from_unit_cell(cell_size)\nif cell_origin is not None:\ncell = cell.transform_cell(AffineTransform3D.translate(to_vec3(cell_origin)))\nreturn AtomCell(self.get_atoms(), cell, frame='local')\n</code></pre>"},{"location":"api/#atomlib.Atoms.coords","title":"<code>coords(selection=None)</code>","text":"<p>Returns a (N, 3) ndarray of atom coordinates (dtype <code>numpy.float64</code>).</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def coords(self, selection: t.Optional[AtomSelection] = None) -&gt; NDArray[numpy.float64]:\n\"\"\"Returns a (N, 3) ndarray of atom coordinates (dtype `numpy.float64`).\"\"\"\n# TODO find a way to get a view\nreturn self.filter(selection).select(('x', 'y', 'z')).to_numpy().astype(numpy.float64)\n</code></pre>"},{"location":"api/#atomlib.Atoms.velocities","title":"<code>velocities(selection=None)</code>","text":"<p>Returns a (N, 3) ndarray of atom velocities (dtype <code>numpy.float64</code>).</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def velocities(self, selection: t.Optional[AtomSelection] = None) -&gt; t.Optional[NDArray[numpy.float64]]:\n\"\"\"Returns a (N, 3) ndarray of atom velocities (dtype `numpy.float64`).\"\"\"\nif selection is not None:\nself = self.filter(selection)\nreturn map_some(lambda df: df.to_numpy().astype(numpy.float64),\nself.try_select(('v_x', 'v_y', 'v_z')))\n</code></pre>"},{"location":"api/#atomlib.Atoms.types","title":"<code>types()</code>","text":"<p>Returns a <code>Series</code> of atom types (dtype polars.Int32).</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def types(self) -&gt; t.Optional[polars.Series]:\n\"\"\"Returns a `Series` of atom types (dtype polars.Int32).\"\"\"\nreturn self.try_get_column('type')\n</code></pre>"},{"location":"api/#atomlib.Atoms.masses","title":"<code>masses()</code>","text":"<p>Returns a <code>Series</code> of atom masses (dtype polars.Float32).</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def masses(self) -&gt; t.Optional[polars.Series]:\n\"\"\"Returns a `Series` of atom masses (dtype polars.Float32).\"\"\"\nreturn self.try_get_column('mass')\n</code></pre>"},{"location":"api/#atomlib.Atoms.add_atom","title":"<code>add_atom(elem, /, x, y=None, z=None, **kwargs)</code>","text":"<p>Return a copy of <code>self</code> with an extra atom.</p> <p>By default, all extra columns present in <code>self</code> must be specified as <code>**kwargs</code>.</p> <p>Try to avoid calling this in a loop (Use :function:<code>Atoms.concat</code> instead).</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def add_atom(self: HasAtomsT, elem: t.Union[int, str], /,\nx: t.Union[ArrayLike, float],\ny: t.Optional[float] = None,\nz: t.Optional[float] = None,\n**kwargs: t.Any) -&gt; HasAtomsT:\n\"\"\"\n    Return a copy of ``self`` with an extra atom.\n    By default, all extra columns present in ``self`` must be specified as ``**kwargs``.\n    Try to avoid calling this in a loop (Use :function:`Atoms.concat` instead).\n    \"\"\"\nif isinstance(elem, int):\nkwargs.update(elem=elem)\nelse:\nkwargs.update(symbol=elem)\nif hasattr(x, '__len__') and len(x) &gt; 1:  # type: ignore\n(x, y, z) = to_vec3(x)\nelif y is None or z is None:\nraise ValueError(f\"Must specify vector of positions or x, y, &amp; z.\")\nsym = get_sym(elem) if isinstance(elem, int) else elem\nd: t.Dict[str, t.Any] = {'x': x, 'y': y, 'z': z, 'symbol': sym, **kwargs}\nreturn self.concat(\n(self, Atoms(d).select_schema(self.schema)),\nhow='vertical'\n)\n</code></pre>"},{"location":"api/#atomlib.Atoms.pos","title":"<code>pos(x=None, y=None, z=None, *, tol=1e-06, **kwargs)</code>","text":"<p>Select all atoms at a given position.</p> <p>Formally, returns all atoms within a cube of radius <code>tol</code> centered at <code>(x,y,z)</code>, exclusive of the cube's surface.</p> <p>Additional parameters given as <code>kwargs</code> will be checked as additional parameters (with strict equality).</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def pos(self,\nx: t.Union[t.Sequence[t.Optional[float]], float, None] = None,\ny: t.Optional[float] = None, z: t.Optional[float] = None, *,\ntol: float = 1e-6, **kwargs: t.Any) -&gt; polars.Expr:\n\"\"\"\n    Select all atoms at a given position.\n    Formally, returns all atoms within a cube of radius ``tol``\n    centered at ``(x,y,z)``, exclusive of the cube's surface.\n    Additional parameters given as ``kwargs`` will be checked\n    as additional parameters (with strict equality).\n    \"\"\"\nif isinstance(x, t.Sequence):\n(x, y, z) = x\ntol = abs(float(tol))\nselection = polars.lit(True)\nif x is not None:\nselection &amp;= (x - tol &lt; polars.col('x')) &amp; (polars.col('x') &lt; x + tol)\nif y is not None:\nselection &amp;= (y - tol &lt; polars.col('y')) &amp; (polars.col('y') &lt; y + tol)\nif z is not None:\nselection &amp;= (z - tol &lt; polars.col('z')) &amp; (polars.col('z') &lt; z + tol)\nfor (col, val) in kwargs.items():\nselection &amp;= (polars.col(col) == val)\nreturn selection\n</code></pre>"},{"location":"api/#atomlib.Atoms.with_index","title":"<code>with_index(index=None)</code>","text":"<p>Returns <code>self</code> with a row index added in column 'i' (dtype polars.Int64). If <code>index</code> is not specified, defaults to an existing index or a new index.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def with_index(self: HasAtomsT, index: t.Optional[AtomValues] = None) -&gt; HasAtomsT:\n\"\"\"\n    Returns `self` with a row index added in column 'i' (dtype polars.Int64).\n    If `index` is not specified, defaults to an existing index or a new index.\n    \"\"\"\nif index is None and 'i' in self.columns:\nreturn self\nif index is None:\nindex = numpy.arange(len(self), dtype=numpy.int64)\nreturn self.with_column(_values_to_expr(index, polars.Int64).alias('i'))\n</code></pre>"},{"location":"api/#atomlib.Atoms.with_wobble","title":"<code>with_wobble(wobble=None)</code>","text":"<p>Return <code>self</code> with the given displacements in column 'wobble' (dtype polars.Float64). If <code>wobble</code> is not specified, defaults to the already-existing wobbles or 0.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def with_wobble(self: HasAtomsT, wobble: t.Optional[AtomValues] = None) -&gt; HasAtomsT:\n\"\"\"\n    Return `self` with the given displacements in column 'wobble' (dtype polars.Float64).\n    If `wobble` is not specified, defaults to the already-existing wobbles or 0.\n    \"\"\"\nif wobble is None and 'wobble' in self.columns:\nreturn self\nwobble = 0. if wobble is None else wobble\nreturn self.with_column(_values_to_expr(wobble, polars.Float64).alias('wobble'))\n</code></pre>"},{"location":"api/#atomlib.Atoms.with_occupancy","title":"<code>with_occupancy(frac_occupancy=None)</code>","text":"<p>Return self with the given fractional occupancies. If <code>frac_occupancy</code> is not specified, defaults to the already-existing occupancies or 1.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def with_occupancy(self: HasAtomsT, frac_occupancy: t.Optional[AtomValues] = None) -&gt; HasAtomsT:\n\"\"\"\n    Return self with the given fractional occupancies. If `frac_occupancy` is not specified,\n    defaults to the already-existing occupancies or 1.\n    \"\"\"\nif frac_occupancy is None and 'frac_occupancy' in self.columns:\nreturn self\nfrac_occupancy = 1. if frac_occupancy is None else frac_occupancy\nreturn self.with_column(_values_to_expr(frac_occupancy, polars.Float64).alias('frac_occupancy'))\n</code></pre>"},{"location":"api/#atomlib.Atoms.apply_wobble","title":"<code>apply_wobble(rng=None)</code>","text":"<p>Displace the atoms in <code>self</code> by the amount in the <code>wobble</code> column. <code>wobble</code> is interpretated as a mean-squared displacement, which is distributed equally over each axis.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def apply_wobble(self: HasAtomsT, rng: t.Union[numpy.random.Generator, int, None] = None) -&gt; HasAtomsT:\n\"\"\"\n    Displace the atoms in `self` by the amount in the `wobble` column.\n    `wobble` is interpretated as a mean-squared displacement, which is distributed\n    equally over each axis.\n    \"\"\"\nif 'wobble' not in self.columns:\nreturn self\nrng = numpy.random.default_rng(seed=rng)\nstddev = self.select((polars.col('wobble') / 3.).sqrt()).to_series().to_numpy()\ncoords = self.coords()\ncoords += stddev[:, None] * rng.standard_normal(coords.shape)\nreturn self.with_coords(coords)\n</code></pre>"},{"location":"api/#atomlib.Atoms.apply_occupancy","title":"<code>apply_occupancy(rng=None)</code>","text":"<p>For each atom in <code>self</code>, use its <code>frac_occupancy</code> to randomly decide whether to remove it.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def apply_occupancy(self: HasAtomsT, rng: t.Union[numpy.random.Generator, int, None] = None) -&gt; HasAtomsT:\n\"\"\"\n    For each atom in `self`, use its `frac_occupancy` to randomly decide whether to remove it.\n    \"\"\"\nif 'frac_occupancy' not in self.columns:\nreturn self\nrng = numpy.random.default_rng(seed=rng)\nfrac = self.select('frac_occupancy').to_series().to_numpy()\nchoice = rng.binomial(1, frac).astype(numpy.bool_)\nreturn self.filter(polars.lit(choice))\n</code></pre>"},{"location":"api/#atomlib.Atoms.with_type","title":"<code>with_type(types=None)</code>","text":"<p>Return <code>self</code> with the given atom types in column 'type'. If <code>types</code> is not specified, use the already existing types or auto-assign them.</p> <p>When auto-assigning, each symbol is given a unique value, case-sensitive. Values are assigned from lowest atomic number to highest. For instance: [\"Ag+\", \"Na\", \"H\", \"Ag\"] =&gt; [3, 11, 1, 2]</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def with_type(self: HasAtomsT, types: t.Optional[AtomValues] = None) -&gt; HasAtomsT:\n\"\"\"\n    Return `self` with the given atom types in column 'type'.\n    If `types` is not specified, use the already existing types or auto-assign them.\n    When auto-assigning, each symbol is given a unique value, case-sensitive.\n    Values are assigned from lowest atomic number to highest.\n    For instance: [\"Ag+\", \"Na\", \"H\", \"Ag\"] =&gt; [3, 11, 1, 2]\n    \"\"\"\nif types is not None:\nreturn self.with_column(_values_to_expr(types, polars.Int32).alias('type'))\nif 'type' in self.columns:\nreturn self\nunique = Atoms(self._get_frame().unique(maintain_order=False, subset=['elem', 'symbol']).sort(['elem', 'symbol']), _unchecked=True)\nnew = self.with_column(polars.Series('type', values=numpy.zeros(len(self)), dtype=polars.Int32))\nlogging.warning(\"Auto-assigning element types\")\nfor (i, (elem, sym)) in enumerate(unique.select(('elem', 'symbol')).rows()):\nprint(f\"Assigning type {i+1} to element '{sym}'\")\nnew = new.with_column(polars.when((polars.col('elem') == elem) &amp; (polars.col('symbol') == sym))\n.then(polars.lit(i+1))\n.otherwise(polars.col('type'))\n.alias('type'))\nassert (new.get_column('type') == 0).sum() == 0\nreturn new\n</code></pre>"},{"location":"api/#atomlib.Atoms.with_mass","title":"<code>with_mass(mass=None)</code>","text":"<p>Return <code>self</code> with the given atom masses in column 'mass'. If <code>mass</code> is not specified, use the already existing masses or auto-assign them.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def with_mass(self: HasAtomsT, mass: t.Optional[ArrayLike] = None) -&gt; HasAtomsT:\n\"\"\"\n    Return `self` with the given atom masses in column 'mass'.\n    If `mass` is not specified, use the already existing masses or auto-assign them.\n    \"\"\"\nif mass is not None:\nreturn self.with_column(_values_to_expr(mass, polars.Float32).alias('mass'))\nif 'mass' in self.columns:\nreturn self\nunique_elems = self.get_column('elem').unique()\nnew = self.with_column(polars.Series('mass', values=numpy.zeros(len(self)), dtype=polars.Float32))\nlogging.warning(\"Auto-assigning element masses\")\nfor elem in unique_elems:\nnew = new.with_column(polars.when(polars.col('elem') == elem)\n.then(polars.lit(get_mass(elem)))\n.otherwise(polars.col('mass'))\n.alias('mass'))\nassert (new.get_column('mass').abs() &lt; 1e-10).sum() == 0\nreturn new\n</code></pre>"},{"location":"api/#atomlib.Atoms.with_symbol","title":"<code>with_symbol(symbols, selection=None)</code>","text":"<p>Return <code>self</code> with the given atomic symbols.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def with_symbol(self: HasAtomsT, symbols: ArrayLike, selection: t.Optional[AtomSelection] = None) -&gt; HasAtomsT:\n\"\"\"\n    Return `self` with the given atomic symbols.\n    \"\"\"\nif selection is not None:\nselection = _selection_to_numpy(self, selection)\nnew_symbols = self.get_column('symbol')\nnew_symbols[selection] = polars.Series(list(numpy.broadcast_to(symbols, len(selection))), dtype=polars.Utf8)\nsymbols = new_symbols\n# TODO better cast here\nsymbols = polars.Series('symbol', list(numpy.broadcast_to(symbols, len(self))), dtype=polars.Utf8)\nreturn self.with_columns((symbols, get_elem(symbols)))\n</code></pre>"},{"location":"api/#atomlib.Atoms.with_coords","title":"<code>with_coords(pts, selection=None)</code>","text":"<p>Return <code>self</code> replaced with the given atomic positions.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def with_coords(self: HasAtomsT, pts: ArrayLike, selection: t.Optional[AtomSelection] = None) -&gt; HasAtomsT:\n\"\"\"\n    Return `self` replaced with the given atomic positions.\n    \"\"\"\nif selection is not None:\nselection = _selection_to_numpy(self, selection)\nnew_pts = self.coords()\npts = numpy.atleast_2d(pts)\nassert pts.shape[-1] == 3\nnew_pts[selection] = pts\npts = new_pts\npts = numpy.broadcast_to(pts, (len(self), 3))\nreturn self.with_columns((\npolars.Series(pts[:, 0], dtype=polars.Float64).alias('x'),\npolars.Series(pts[:, 1], dtype=polars.Float64).alias('y'),\npolars.Series(pts[:, 2], dtype=polars.Float64).alias('z'),\n))\n</code></pre>"},{"location":"api/#atomlib.Atoms.with_velocity","title":"<code>with_velocity(pts=None, selection=None)</code>","text":"<p>Return <code>self</code> replaced with the given atomic velocities. If <code>pts</code> is not specified, use the already existing velocities or zero.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def with_velocity(self: HasAtomsT, pts: t.Optional[ArrayLike] = None,\nselection: t.Optional[AtomSelection] = None) -&gt; HasAtomsT:\n\"\"\"\n    Return `self` replaced with the given atomic velocities.\n    If `pts` is not specified, use the already existing velocities or zero.\n    \"\"\"\nif pts is None:\nif all(col in self.columns for col in ('v_x', 'v_y', 'v_z')):\nreturn self\npts = numpy.zeros((len(self), 3))\nelse:\npts = numpy.broadcast_to(pts, (len(self), 3))\nif selection is None:\nreturn self.with_columns((\npolars.Series(pts[:, 0], dtype=polars.Float64).alias('v_x'),\npolars.Series(pts[:, 1], dtype=polars.Float64).alias('v_y'),\npolars.Series(pts[:, 2], dtype=polars.Float64).alias('v_z'),\n))\nselection = _selection_to_series(self, selection)\nreturn self.__class__(self.with_columns((\nself['v_x'].set_at_idx(selection, pts[:, 0]),  # type: ignore\nself['v_y'].set_at_idx(selection, pts[:, 1]),  # type: ignore\nself['v_z'].set_at_idx(selection, pts[:, 2]),  # type: ignore\n)))\n</code></pre>"},{"location":"api/#atomlib.Atoms.read","title":"<code>read(path, ty=None)</code>  <code>classmethod</code>","text":"<p>Read a structure from a file.</p> <p>Currently, supported file types are 'cif', 'xyz', and 'xsf'. If no <code>ty</code> is specified, it is inferred from the file's extension.</p> Source code in <code>atomlib/mixins.py</code> <pre><code>@classmethod\ndef read(cls: t.Type[HasAtomsT], path: FileOrPath, ty: t.Optional[FileType] = None) -&gt; HasAtomsT:\n\"\"\"\n    Read a structure from a file.\n    Currently, supported file types are 'cif', 'xyz', and 'xsf'.\n    If no `ty` is specified, it is inferred from the file's extension.\n    \"\"\"\nfrom .io import read\nreturn _cast_atoms(read(path, ty), cls)  # type: ignore\n</code></pre>"},{"location":"api/#atomlib.Atoms.read_cif","title":"<code>read_cif(f)</code>  <code>classmethod</code>","text":"<p>Read a structure from a CIF file.</p> Source code in <code>atomlib/mixins.py</code> <pre><code>@classmethod\ndef read_cif(cls: t.Type[HasAtomsT], f: t.Union[FileOrPath, CIF]) -&gt; HasAtomsT:\n\"\"\"Read a structure from a CIF file.\"\"\"\nfrom .io import read_cif\nreturn _cast_atoms(read_cif(f), cls)\n</code></pre>"},{"location":"api/#atomlib.Atoms.read_xyz","title":"<code>read_xyz(f)</code>  <code>classmethod</code>","text":"<p>Read a structure from an XYZ file.</p> Source code in <code>atomlib/mixins.py</code> <pre><code>@classmethod\ndef read_xyz(cls: t.Type[HasAtomsT], f: t.Union[FileOrPath, XYZ]) -&gt; HasAtomsT:\n\"\"\"Read a structure from an XYZ file.\"\"\"\nfrom .io import read_xyz\nreturn _cast_atoms(read_xyz(f), cls)\n</code></pre>"},{"location":"api/#atomlib.Atoms.read_xsf","title":"<code>read_xsf(f)</code>  <code>classmethod</code>","text":"<p>Read a structure from an XSF file.</p> Source code in <code>atomlib/mixins.py</code> <pre><code>@classmethod\ndef read_xsf(cls: t.Type[HasAtomsT], f: t.Union[FileOrPath, XSF]) -&gt; HasAtomsT:\n\"\"\"Read a structure from an XSF file.\"\"\"\nfrom .io import read_xsf\nreturn _cast_atoms(read_xsf(f), cls)\n</code></pre>"},{"location":"api/#atomlib.Atoms.read_cfg","title":"<code>read_cfg(f)</code>  <code>classmethod</code>","text":"<p>Read a structure from a CFG file.</p> Source code in <code>atomlib/mixins.py</code> <pre><code>@classmethod\ndef read_cfg(cls: t.Type[HasAtomsT], f: t.Union[FileOrPath, CFG]) -&gt; HasAtomsT:\n\"\"\"Read a structure from a CFG file.\"\"\"\nfrom .io import read_cfg\nreturn _cast_atoms(read_cfg(f), cls)\n</code></pre>"},{"location":"api/#atomlib.Atoms.write_xyz","title":"<code>write_xyz(f, fmt='exyz')</code>","text":"Source code in <code>atomlib/mixins.py</code> <pre><code>def write_xyz(self, f: FileOrPath, fmt: XYZFormat = 'exyz'):\nfrom .io import write_xyz\nwrite_xyz(self, f, fmt)\n</code></pre>"},{"location":"api/#atomlib.Atoms.write_xsf","title":"<code>write_xsf(f)</code>","text":"Source code in <code>atomlib/mixins.py</code> <pre><code>def write_xsf(self, f: FileOrPath):\nfrom .io import write_xsf\nwrite_xsf(self, f)\n</code></pre>"},{"location":"api/#atomlib.Atoms.write_cfg","title":"<code>write_cfg(f)</code>","text":"Source code in <code>atomlib/mixins.py</code> <pre><code>def write_cfg(self, f: FileOrPath):\nfrom .io import write_cfg\nwrite_cfg(self, f)\n</code></pre>"},{"location":"api/#atomlib.Atoms.write","title":"<code>write(path, ty=None)</code>","text":"<p>Write this structure to a file.</p> <p>A file type may be specified using <code>ty</code>. If no <code>ty</code> is specified, it is inferred from the path's extension.</p> Source code in <code>atomlib/mixins.py</code> <pre><code>def write(self, path: FileOrPath, ty: t.Optional[FileType] = None):\n\"\"\"\n    Write this structure to a file.\n    A file type may be specified using `ty`.\n    If no `ty` is specified, it is inferred from the path's extension.\n    \"\"\"\nfrom .io import write\nwrite(self, path, ty)  # type: ignore\n</code></pre>"},{"location":"api/#atomlib.Atoms.empty","title":"<code>empty()</code>  <code>staticmethod</code>","text":"<p>Return an empty Atoms with only the mandatory columns.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>@staticmethod\ndef empty() -&gt; Atoms:\n\"\"\"\n    Return an empty Atoms with only the mandatory columns.\n    \"\"\"\nreturn Atoms()\n</code></pre>"},{"location":"api/#atomlib.Atoms.get_atoms","title":"<code>get_atoms(frame='local')</code>","text":"Source code in <code>atomlib/atoms.py</code> <pre><code>def get_atoms(self, frame: t.Literal['local'] = 'local') -&gt; Atoms:\nif frame != 'local':\nraise ValueError(f\"Atoms without a cell only support the 'local' coordinate frame, not '{frame}'.\")\nreturn self\n</code></pre>"},{"location":"api/#atomlib.Atoms.with_atoms","title":"<code>with_atoms(atoms, frame='local')</code>","text":"Source code in <code>atomlib/atoms.py</code> <pre><code>def with_atoms(self, atoms: HasAtoms, frame: t.Literal['local'] = 'local') -&gt; Atoms:\nif frame != 'local':\nraise ValueError(f\"Atoms without a cell only support the 'local' coordinate frame, not '{frame}'.\")\nreturn atoms.get_atoms()\n</code></pre>"},{"location":"api/#atomlib.Atoms.bbox","title":"<code>bbox()</code>","text":"<p>Return the bounding box of all the points in <code>self</code>.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def bbox(self) -&gt; BBox3D:\n\"\"\"Return the bounding box of all the points in `self`.\"\"\"\nif self._bbox is None:\nself._bbox = BBox3D.from_pts(self.coords())\nreturn self._bbox\n</code></pre>"},{"location":"api/#atomlib.HasAtoms","title":"<code>HasAtoms</code>","text":"<p>             Bases: <code>ABC</code></p> <p>Abstract class representing any (possibly compound) collection of atoms.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>class HasAtoms(abc.ABC):\n\"\"\"Abstract class representing any (possibly compound) collection of atoms.\"\"\"\n# abstract methods\n@abc.abstractmethod\ndef get_atoms(self, frame: t.Literal['local'] = 'local') -&gt; Atoms:\n\"\"\"Get atoms contained in `self`. This should be a low cost method.\"\"\"\n...\n@abc.abstractmethod\ndef with_atoms(self: HasAtomsT, atoms: HasAtoms, frame: t.Literal['local'] = 'local') -&gt; HasAtomsT:\n...\n@classmethod\n@abc.abstractmethod\ndef _combine_metadata(cls: t.Type[HasAtomsT], *atoms: HasAtoms) -&gt; HasAtomsT:\n\"\"\"\n        When combining multiple ``HasAtoms``, check that they are compatible with each other,\n        and return a 'representative' which best represents the combined metadata.\n        Implementors should treat `Atoms` as acceptable, but having no metadata.\n        \"\"\"\n...\ndef _get_frame(self) -&gt; polars.DataFrame:\nreturn self.get_atoms().inner\n# dataframe methods\n@property\ndef columns(self) -&gt; t.Sequence[str]:\n\"\"\"Return the columns in `self`.\"\"\"\nreturn self._get_frame().columns\n@property\ndef schema(self) -&gt; SchemaDict:\n\"\"\"Return the schema of `self`.\"\"\"\nreturn t.cast(SchemaDict, self._get_frame().schema)\ndef with_column(self: HasAtomsT, column: t.Union[polars.Series, polars.Expr]) -&gt; HasAtomsT:\n\"\"\"Return a copy of ``self`` with the given column added.\"\"\"\nreturn self.with_atoms(Atoms(self._get_frame().with_columns((column,)), _unchecked=True))\ndef with_columns(self: HasAtomsT,\nexprs: t.Union[t.Literal[None], polars.Series, polars.Expr, t.Sequence[t.Union[polars.Series, polars.Expr]]],\n**named_exprs: t.Union[polars.Expr, polars.Series]) -&gt; HasAtomsT:\n\"\"\"Return a copy of ``self`` with the given columns added.\"\"\"\nreturn self.with_atoms(Atoms(self._get_frame().with_columns(exprs, **named_exprs), _unchecked=True))\ndef get_column(self, name: str) -&gt; polars.Series:\n\"\"\"Get the specified column from ``self``, raising :py:`polars.NotFoundError` if it's not present.\"\"\"\nreturn self._get_frame().get_column(name)\ndef filter(self: HasAtomsT, selection: t.Optional[AtomSelection] = None) -&gt; HasAtomsT:\n\"\"\"Filter ``self``, removing rows which evaluate to ``False``.\"\"\"\nif selection is None:\nreturn self\nreturn self.with_atoms(Atoms(self._get_frame().filter(_selection_to_expr(selection)), _unchecked=True))\ndef select(self, exprs: t.Union[str, polars.Expr, polars.Series, t.Sequence[t.Union[str, polars.Expr, polars.Series]]]\n) -&gt; polars.DataFrame:\n\"\"\"\n        Select ``exprs`` from ``self``, and return as a :py:class:`polars.DataFrame`.\n        Expressions may either be columns or expressions of columns.\n        \"\"\"\nreturn self._get_frame().select(exprs)\ndef sort(self: HasAtomsT, by: t.Union[str, polars.Expr, t.List[str], t.List[polars.Expr]], descending: t.Union[bool, t.List[bool]] = False) -&gt; HasAtomsT:\nreturn self.with_atoms(Atoms(self._get_frame().sort(by, descending=descending), _unchecked=True))\n@classmethod\ndef concat(cls: t.Type[HasAtomsT],\natoms: t.Union[HasAtomsT, IntoAtoms, t.Iterable[t.Union[HasAtomsT, IntoAtoms]]], *,\nrechunk: bool = True, how: ConcatMethod = 'vertical') -&gt; HasAtomsT:\n# this method is tricky. It needs to accept raw Atoms, as well as HasAtoms of the\n# same type as ``cls``.\nif _is_abstract(cls):\nraise TypeError(f\"concat() must be called on a concrete class.\")\nif isinstance(atoms, HasAtoms):\natoms = (atoms,)\ndfs = [a.get_atoms('local').inner if isinstance(a, HasAtoms) else Atoms(a).inner for a in atoms]\nrepresentative = cls._combine_metadata(*(a for a in atoms if isinstance(a, HasAtoms)))\nif len(dfs) == 0:\nreturn representative.with_atoms(Atoms.empty(), 'local')\nif how in ('vertical', 'vertical_relaxed'):\n# get order from first member\ncols = dfs[0].columns\ndfs = [df.select(cols) for df in dfs]\nelif how == 'inner':\ncols = reduce(operator.and_, (df.schema.keys() for df in dfs))\nschema = t.cast(SchemaDict, {col: dfs[0].schema[col] for col in cols})\nif len(schema) == 0:\nraise ValueError(f\"Atoms have no columns in common\")\ndfs = [_select_schema(df, schema) for df in dfs]\nhow = 'vertical'\nreturn representative.with_atoms(Atoms(polars.concat(dfs, rechunk=rechunk, how=how)), 'local')\n# some helpers we add\ndef select_schema(self, schema: SchemaDict) -&gt; polars.DataFrame:\n\"\"\"\n        Select columns from ``self`` and cast to the given schema.\n        Raises :py:`TypeError` if a column is not found or if it can't be cast.\n        \"\"\"\nreturn _select_schema(self, schema)\ndef try_select(self, exprs: t.Union[str, polars.Expr, polars.Series, t.Sequence[t.Union[str, polars.Expr, polars.Series]]]\n) -&gt; t.Optional[polars.DataFrame]:\n\"\"\"\n        Try to select ``exprs`` from ``self``, and return as a ``DataFrame``.\n        Expressions may either be columns or expressions of columns.\n        Return ``None`` if any columns are missing.\n        \"\"\"\ntry:\nreturn self._get_frame().select(exprs)\nexcept ColumnNotFoundError:\nreturn None\ndef try_get_column(self, name: str) -&gt; t.Optional[polars.Series]:\n\"\"\"Try to get a column from `self`, returning `None` if it doesn't exist.\"\"\"\ntry:\nreturn self.get_column(name)\nexcept ColumnNotFoundError:\nreturn None\ndef assert_equal(self, other: t.Any):\nassert isinstance(other, HasAtoms)\nassert self.schema == other.schema\nfor (col, dtype) in self.schema.items():\nif dtype in (polars.Float32, polars.Float64):\nnumpy.testing.assert_array_almost_equal(self[col].view(ignore_nulls=True), other[col].view(ignore_nulls=True), 5)\nelse:\nassert (self[col] == other[col]).all()\n# dunders\ndef __len__(self) -&gt; int:\n\"\"\"Return the number of atoms in `self`.\"\"\"\nreturn self._get_frame().__len__()\ndef __contains__(self, col: str) -&gt; bool:\n\"\"\"Return whether `self` contains the given column.\"\"\"\nreturn col in self.columns\ndef __add__(self: HasAtomsT, other: IntoAtoms) -&gt; HasAtomsT:\nreturn self.__class__.concat((self, other), how='inner')\ndef __radd__(self: HasAtomsT, other: IntoAtoms) -&gt; HasAtomsT:\nreturn self.__class__.concat((other, self), how='inner')\n__getitem__ = get_column\n# atoms-specific methods\ndef bbox_atoms(self) -&gt; BBox3D:\n\"\"\"Return the bounding box of all the atoms in ``self``.\"\"\"\nreturn BBox3D.from_pts(self.coords())\nbbox = bbox_atoms\ndef transform_atoms(self: HasAtomsT, transform: IntoTransform3D, selection: t.Optional[AtomSelection] = None, *, transform_velocities: bool = False) -&gt; HasAtomsT:\n\"\"\"\n        Transform the atoms in `self` by `transform`.\n        If `selection` is given, only transform the atoms in `selection`.\n        \"\"\"\ntransform = Transform3D.make(transform)\nselection = map_some(lambda s: _selection_to_series(self, s), selection)\ntransformed = self.with_coords(Transform3D.make(transform) @ self.coords(selection), selection)\n# try to transform velocities as well\nif transform_velocities and (velocities := self.velocities(selection)) is not None:\nreturn transformed.with_velocity(transform.transform_vec(velocities), selection)\nreturn transformed\ntransform = transform_atoms\ndef round_near_zero(self: HasAtomsT, tol: float = 1e-14) -&gt; HasAtomsT:\n\"\"\"\n        Round atom position values near zero to zero.\n        \"\"\"\nreturn self.with_columns(tuple(\npolars.when(col.abs() &gt;= tol).then(col).otherwise(polars.lit(0.))\nfor col in map(polars.col, ('x', 'y', 'z'))\n))\ndef crop(self: HasAtomsT, x_min: float = -numpy.inf, x_max: float = numpy.inf,\ny_min: float = -numpy.inf, y_max: float = numpy.inf,\nz_min: float = -numpy.inf, z_max: float = numpy.inf) -&gt; HasAtomsT:\n\"\"\"\n        Crop, removing all atoms outside of the specified region, inclusive.\n        \"\"\"\nreturn self.filter(\n(polars.col('x') &gt;= x_min) &amp; (polars.col('x') &lt;= x_max) &amp;\n(polars.col('y') &gt;= y_min) &amp; (polars.col('y') &lt;= y_max) &amp;\n(polars.col('z') &gt;= z_min) &amp; (polars.col('z') &lt;= z_max)\n)\ncrop_atoms = crop\ndef deduplicate(self: HasAtomsT, tol: float = 1e-3, subset: t.Iterable[str] = ('x', 'y', 'z', 'symbol'),\nkeep: UniqueKeepStrategy = 'first') -&gt; HasAtomsT:\n\"\"\"\n        De-duplicate atoms in `self`. Atoms of the same `symbol` that are closer than `tolerance`\n        to each other (by Euclidian distance) will be removed, leaving only the atom specified by\n        `keep` (defaults to the first atom).\n        If `subset` is specified, only those columns will be included while assessing duplicates.\n        Floating point columns other than 'x', 'y', and 'z' will not by toleranced.\n        \"\"\"\ncols = set((subset,) if isinstance(subset, str) else subset)\nindices = numpy.arange(len(self))\nspatial_cols = cols.intersection(('x', 'y', 'z'))\ncols -= spatial_cols\nif len(spatial_cols) &gt; 0:\ncoords = self.select(list(spatial_cols)).to_numpy()\nprint(coords.shape)\ntree = scipy.spatial.KDTree(coords)\n# TODO This is a bad algorithm\nwhile True:\nchanged = False\nfor (i, j) in tree.query_pairs(tol, 2.):\n# whenever we encounter a pair, ensure their index matches\ni_i, i_j = indices[[i, j]]\nif i_i != i_j:\nindices[i] = indices[j] = min(i_i, i_j)\nchanged = True\nif not changed:\nbreak\nself = self.with_column(polars.Series('_unique_pts', indices))\ncols.add('_unique_pts')\nframe = self._get_frame().unique(subset=list(cols), keep=keep)\nif len(spatial_cols) &gt; 0:\nframe = frame.drop('_unique_pts')\nreturn self.with_atoms(Atoms(frame, _unchecked=True))\nunique = deduplicate\ndef with_bounds(self, cell_size: t.Optional[VecLike] = None, cell_origin: t.Optional[VecLike] = None) -&gt; 'AtomCell':\n\"\"\"\n        Return a periodic cell with the given orthogonal cell dimensions.\n        If cell_size is not specified, it will be assumed (and may be incorrect).\n        \"\"\"\n# TODO: test this\nfrom .atomcell import AtomCell\nif cell_size is None:\nwarnings.warn(\"Cell boundary unknown. Defaulting to cell BBox\")\ncell_size = self.bbox().size\ncell_origin = self.bbox().min\n# TODO test this origin code\ncell = Cell.from_unit_cell(cell_size)\nif cell_origin is not None:\ncell = cell.transform_cell(AffineTransform3D.translate(to_vec3(cell_origin)))\nreturn AtomCell(self.get_atoms(), cell, frame='local')\n# property getters and setters\ndef coords(self, selection: t.Optional[AtomSelection] = None) -&gt; NDArray[numpy.float64]:\n\"\"\"Returns a (N, 3) ndarray of atom coordinates (dtype `numpy.float64`).\"\"\"\n# TODO find a way to get a view\nreturn self.filter(selection).select(('x', 'y', 'z')).to_numpy().astype(numpy.float64)\ndef velocities(self, selection: t.Optional[AtomSelection] = None) -&gt; t.Optional[NDArray[numpy.float64]]:\n\"\"\"Returns a (N, 3) ndarray of atom velocities (dtype `numpy.float64`).\"\"\"\nif selection is not None:\nself = self.filter(selection)\nreturn map_some(lambda df: df.to_numpy().astype(numpy.float64),\nself.try_select(('v_x', 'v_y', 'v_z')))\ndef types(self) -&gt; t.Optional[polars.Series]:\n\"\"\"Returns a `Series` of atom types (dtype polars.Int32).\"\"\"\nreturn self.try_get_column('type')\ndef masses(self) -&gt; t.Optional[polars.Series]:\n\"\"\"Returns a `Series` of atom masses (dtype polars.Float32).\"\"\"\nreturn self.try_get_column('mass')\n@t.overload\ndef add_atom(self: HasAtomsT, elem: t.Union[int, str], x: ArrayLike, /, *,\ny: None = None, z: None = None,\n**kwargs: t.Any) -&gt; HasAtomsT:\n...\n@t.overload\ndef add_atom(self: HasAtomsT, elem: t.Union[int, str], /,\nx: float, y: float, z: float,\n**kwargs: t.Any) -&gt; HasAtomsT:\n...\ndef add_atom(self: HasAtomsT, elem: t.Union[int, str], /,\nx: t.Union[ArrayLike, float],\ny: t.Optional[float] = None,\nz: t.Optional[float] = None,\n**kwargs: t.Any) -&gt; HasAtomsT:\n\"\"\"\n        Return a copy of ``self`` with an extra atom.\n        By default, all extra columns present in ``self`` must be specified as ``**kwargs``.\n        Try to avoid calling this in a loop (Use :function:`Atoms.concat` instead).\n        \"\"\"\nif isinstance(elem, int):\nkwargs.update(elem=elem)\nelse:\nkwargs.update(symbol=elem)\nif hasattr(x, '__len__') and len(x) &gt; 1:  # type: ignore\n(x, y, z) = to_vec3(x)\nelif y is None or z is None:\nraise ValueError(f\"Must specify vector of positions or x, y, &amp; z.\")\nsym = get_sym(elem) if isinstance(elem, int) else elem\nd: t.Dict[str, t.Any] = {'x': x, 'y': y, 'z': z, 'symbol': sym, **kwargs}\nreturn self.concat(\n(self, Atoms(d).select_schema(self.schema)),\nhow='vertical'\n)\n@t.overload\ndef pos(self, x: t.Sequence[t.Optional[float]], /, *,\ny: None = None, z: None = None,\ntol: float = 1e-6, **kwargs: t.Any) -&gt; polars.Expr:\n...\n@t.overload\ndef pos(self, x: t.Optional[float] = None, y: t.Optional[float] = None, z: t.Optional[float] = None, *,\ntol: float = 1e-6, **kwargs: t.Any) -&gt; polars.Expr:\n...\ndef pos(self,\nx: t.Union[t.Sequence[t.Optional[float]], float, None] = None,\ny: t.Optional[float] = None, z: t.Optional[float] = None, *,\ntol: float = 1e-6, **kwargs: t.Any) -&gt; polars.Expr:\n\"\"\"\n        Select all atoms at a given position.\n        Formally, returns all atoms within a cube of radius ``tol``\n        centered at ``(x,y,z)``, exclusive of the cube's surface.\n        Additional parameters given as ``kwargs`` will be checked\n        as additional parameters (with strict equality).\n        \"\"\"\nif isinstance(x, t.Sequence):\n(x, y, z) = x\ntol = abs(float(tol))\nselection = polars.lit(True)\nif x is not None:\nselection &amp;= (x - tol &lt; polars.col('x')) &amp; (polars.col('x') &lt; x + tol)\nif y is not None:\nselection &amp;= (y - tol &lt; polars.col('y')) &amp; (polars.col('y') &lt; y + tol)\nif z is not None:\nselection &amp;= (z - tol &lt; polars.col('z')) &amp; (polars.col('z') &lt; z + tol)\nfor (col, val) in kwargs.items():\nselection &amp;= (polars.col(col) == val)\nreturn selection\ndef with_index(self: HasAtomsT, index: t.Optional[AtomValues] = None) -&gt; HasAtomsT:\n\"\"\"\n        Returns `self` with a row index added in column 'i' (dtype polars.Int64).\n        If `index` is not specified, defaults to an existing index or a new index.\n        \"\"\"\nif index is None and 'i' in self.columns:\nreturn self\nif index is None:\nindex = numpy.arange(len(self), dtype=numpy.int64)\nreturn self.with_column(_values_to_expr(index, polars.Int64).alias('i'))\ndef with_wobble(self: HasAtomsT, wobble: t.Optional[AtomValues] = None) -&gt; HasAtomsT:\n\"\"\"\n        Return `self` with the given displacements in column 'wobble' (dtype polars.Float64).\n        If `wobble` is not specified, defaults to the already-existing wobbles or 0.\n        \"\"\"\nif wobble is None and 'wobble' in self.columns:\nreturn self\nwobble = 0. if wobble is None else wobble\nreturn self.with_column(_values_to_expr(wobble, polars.Float64).alias('wobble'))\ndef with_occupancy(self: HasAtomsT, frac_occupancy: t.Optional[AtomValues] = None) -&gt; HasAtomsT:\n\"\"\"\n        Return self with the given fractional occupancies. If `frac_occupancy` is not specified,\n        defaults to the already-existing occupancies or 1.\n        \"\"\"\nif frac_occupancy is None and 'frac_occupancy' in self.columns:\nreturn self\nfrac_occupancy = 1. if frac_occupancy is None else frac_occupancy\nreturn self.with_column(_values_to_expr(frac_occupancy, polars.Float64).alias('frac_occupancy'))\ndef apply_wobble(self: HasAtomsT, rng: t.Union[numpy.random.Generator, int, None] = None) -&gt; HasAtomsT:\n\"\"\"\n        Displace the atoms in `self` by the amount in the `wobble` column.\n        `wobble` is interpretated as a mean-squared displacement, which is distributed\n        equally over each axis.\n        \"\"\"\nif 'wobble' not in self.columns:\nreturn self\nrng = numpy.random.default_rng(seed=rng)\nstddev = self.select((polars.col('wobble') / 3.).sqrt()).to_series().to_numpy()\ncoords = self.coords()\ncoords += stddev[:, None] * rng.standard_normal(coords.shape)\nreturn self.with_coords(coords)\ndef apply_occupancy(self: HasAtomsT, rng: t.Union[numpy.random.Generator, int, None] = None) -&gt; HasAtomsT:\n\"\"\"\n        For each atom in `self`, use its `frac_occupancy` to randomly decide whether to remove it.\n        \"\"\"\nif 'frac_occupancy' not in self.columns:\nreturn self\nrng = numpy.random.default_rng(seed=rng)\nfrac = self.select('frac_occupancy').to_series().to_numpy()\nchoice = rng.binomial(1, frac).astype(numpy.bool_)\nreturn self.filter(polars.lit(choice))\ndef with_type(self: HasAtomsT, types: t.Optional[AtomValues] = None) -&gt; HasAtomsT:\n\"\"\"\n        Return `self` with the given atom types in column 'type'.\n        If `types` is not specified, use the already existing types or auto-assign them.\n        When auto-assigning, each symbol is given a unique value, case-sensitive.\n        Values are assigned from lowest atomic number to highest.\n        For instance: [\"Ag+\", \"Na\", \"H\", \"Ag\"] =&gt; [3, 11, 1, 2]\n        \"\"\"\nif types is not None:\nreturn self.with_column(_values_to_expr(types, polars.Int32).alias('type'))\nif 'type' in self.columns:\nreturn self\nunique = Atoms(self._get_frame().unique(maintain_order=False, subset=['elem', 'symbol']).sort(['elem', 'symbol']), _unchecked=True)\nnew = self.with_column(polars.Series('type', values=numpy.zeros(len(self)), dtype=polars.Int32))\nlogging.warning(\"Auto-assigning element types\")\nfor (i, (elem, sym)) in enumerate(unique.select(('elem', 'symbol')).rows()):\nprint(f\"Assigning type {i+1} to element '{sym}'\")\nnew = new.with_column(polars.when((polars.col('elem') == elem) &amp; (polars.col('symbol') == sym))\n.then(polars.lit(i+1))\n.otherwise(polars.col('type'))\n.alias('type'))\nassert (new.get_column('type') == 0).sum() == 0\nreturn new\ndef with_mass(self: HasAtomsT, mass: t.Optional[ArrayLike] = None) -&gt; HasAtomsT:\n\"\"\"\n        Return `self` with the given atom masses in column 'mass'.\n        If `mass` is not specified, use the already existing masses or auto-assign them.\n        \"\"\"\nif mass is not None:\nreturn self.with_column(_values_to_expr(mass, polars.Float32).alias('mass'))\nif 'mass' in self.columns:\nreturn self\nunique_elems = self.get_column('elem').unique()\nnew = self.with_column(polars.Series('mass', values=numpy.zeros(len(self)), dtype=polars.Float32))\nlogging.warning(\"Auto-assigning element masses\")\nfor elem in unique_elems:\nnew = new.with_column(polars.when(polars.col('elem') == elem)\n.then(polars.lit(get_mass(elem)))\n.otherwise(polars.col('mass'))\n.alias('mass'))\nassert (new.get_column('mass').abs() &lt; 1e-10).sum() == 0\nreturn new\ndef with_symbol(self: HasAtomsT, symbols: ArrayLike, selection: t.Optional[AtomSelection] = None) -&gt; HasAtomsT:\n\"\"\"\n        Return `self` with the given atomic symbols.\n        \"\"\"\nif selection is not None:\nselection = _selection_to_numpy(self, selection)\nnew_symbols = self.get_column('symbol')\nnew_symbols[selection] = polars.Series(list(numpy.broadcast_to(symbols, len(selection))), dtype=polars.Utf8)\nsymbols = new_symbols\n# TODO better cast here\nsymbols = polars.Series('symbol', list(numpy.broadcast_to(symbols, len(self))), dtype=polars.Utf8)\nreturn self.with_columns((symbols, get_elem(symbols)))\ndef with_coords(self: HasAtomsT, pts: ArrayLike, selection: t.Optional[AtomSelection] = None) -&gt; HasAtomsT:\n\"\"\"\n        Return `self` replaced with the given atomic positions.\n        \"\"\"\nif selection is not None:\nselection = _selection_to_numpy(self, selection)\nnew_pts = self.coords()\npts = numpy.atleast_2d(pts)\nassert pts.shape[-1] == 3\nnew_pts[selection] = pts\npts = new_pts\npts = numpy.broadcast_to(pts, (len(self), 3))\nreturn self.with_columns((\npolars.Series(pts[:, 0], dtype=polars.Float64).alias('x'),\npolars.Series(pts[:, 1], dtype=polars.Float64).alias('y'),\npolars.Series(pts[:, 2], dtype=polars.Float64).alias('z'),\n))\ndef with_velocity(self: HasAtomsT, pts: t.Optional[ArrayLike] = None,\nselection: t.Optional[AtomSelection] = None) -&gt; HasAtomsT:\n\"\"\"\n        Return `self` replaced with the given atomic velocities.\n        If `pts` is not specified, use the already existing velocities or zero.\n        \"\"\"\nif pts is None:\nif all(col in self.columns for col in ('v_x', 'v_y', 'v_z')):\nreturn self\npts = numpy.zeros((len(self), 3))\nelse:\npts = numpy.broadcast_to(pts, (len(self), 3))\nif selection is None:\nreturn self.with_columns((\npolars.Series(pts[:, 0], dtype=polars.Float64).alias('v_x'),\npolars.Series(pts[:, 1], dtype=polars.Float64).alias('v_y'),\npolars.Series(pts[:, 2], dtype=polars.Float64).alias('v_z'),\n))\nselection = _selection_to_series(self, selection)\nreturn self.__class__(self.with_columns((\nself['v_x'].set_at_idx(selection, pts[:, 0]),  # type: ignore\nself['v_y'].set_at_idx(selection, pts[:, 1]),  # type: ignore\nself['v_z'].set_at_idx(selection, pts[:, 2]),  # type: ignore\n)))\n</code></pre>"},{"location":"api/#atomlib.HasAtoms.columns","title":"<code>columns: t.Sequence[str]</code>  <code>property</code>","text":"<p>Return the columns in <code>self</code>.</p>"},{"location":"api/#atomlib.HasAtoms.schema","title":"<code>schema: SchemaDict</code>  <code>property</code>","text":"<p>Return the schema of <code>self</code>.</p>"},{"location":"api/#atomlib.HasAtoms.bbox","title":"<code>bbox = bbox_atoms</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#atomlib.HasAtoms.transform","title":"<code>transform = transform_atoms</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#atomlib.HasAtoms.crop_atoms","title":"<code>crop_atoms = crop</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#atomlib.HasAtoms.unique","title":"<code>unique = deduplicate</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#atomlib.HasAtoms.get_atoms","title":"<code>get_atoms(frame='local')</code>  <code>abstractmethod</code>","text":"<p>Get atoms contained in <code>self</code>. This should be a low cost method.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>@abc.abstractmethod\ndef get_atoms(self, frame: t.Literal['local'] = 'local') -&gt; Atoms:\n\"\"\"Get atoms contained in `self`. This should be a low cost method.\"\"\"\n...\n</code></pre>"},{"location":"api/#atomlib.HasAtoms.with_atoms","title":"<code>with_atoms(atoms, frame='local')</code>  <code>abstractmethod</code>","text":"Source code in <code>atomlib/atoms.py</code> <pre><code>@abc.abstractmethod\ndef with_atoms(self: HasAtomsT, atoms: HasAtoms, frame: t.Literal['local'] = 'local') -&gt; HasAtomsT:\n...\n</code></pre>"},{"location":"api/#atomlib.HasAtoms.with_column","title":"<code>with_column(column)</code>","text":"<p>Return a copy of <code>self</code> with the given column added.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def with_column(self: HasAtomsT, column: t.Union[polars.Series, polars.Expr]) -&gt; HasAtomsT:\n\"\"\"Return a copy of ``self`` with the given column added.\"\"\"\nreturn self.with_atoms(Atoms(self._get_frame().with_columns((column,)), _unchecked=True))\n</code></pre>"},{"location":"api/#atomlib.HasAtoms.with_columns","title":"<code>with_columns(exprs, **named_exprs)</code>","text":"<p>Return a copy of <code>self</code> with the given columns added.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def with_columns(self: HasAtomsT,\nexprs: t.Union[t.Literal[None], polars.Series, polars.Expr, t.Sequence[t.Union[polars.Series, polars.Expr]]],\n**named_exprs: t.Union[polars.Expr, polars.Series]) -&gt; HasAtomsT:\n\"\"\"Return a copy of ``self`` with the given columns added.\"\"\"\nreturn self.with_atoms(Atoms(self._get_frame().with_columns(exprs, **named_exprs), _unchecked=True))\n</code></pre>"},{"location":"api/#atomlib.HasAtoms.get_column","title":"<code>get_column(name)</code>","text":"<p>Get the specified column from <code>self</code>, raising :py:<code>polars.NotFoundError</code> if it's not present.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def get_column(self, name: str) -&gt; polars.Series:\n\"\"\"Get the specified column from ``self``, raising :py:`polars.NotFoundError` if it's not present.\"\"\"\nreturn self._get_frame().get_column(name)\n</code></pre>"},{"location":"api/#atomlib.HasAtoms.filter","title":"<code>filter(selection=None)</code>","text":"<p>Filter <code>self</code>, removing rows which evaluate to <code>False</code>.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def filter(self: HasAtomsT, selection: t.Optional[AtomSelection] = None) -&gt; HasAtomsT:\n\"\"\"Filter ``self``, removing rows which evaluate to ``False``.\"\"\"\nif selection is None:\nreturn self\nreturn self.with_atoms(Atoms(self._get_frame().filter(_selection_to_expr(selection)), _unchecked=True))\n</code></pre>"},{"location":"api/#atomlib.HasAtoms.select","title":"<code>select(exprs)</code>","text":"<p>Select <code>exprs</code> from <code>self</code>, and return as a :py:class:<code>polars.DataFrame</code>.</p> <p>Expressions may either be columns or expressions of columns.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def select(self, exprs: t.Union[str, polars.Expr, polars.Series, t.Sequence[t.Union[str, polars.Expr, polars.Series]]]\n) -&gt; polars.DataFrame:\n\"\"\"\n    Select ``exprs`` from ``self``, and return as a :py:class:`polars.DataFrame`.\n    Expressions may either be columns or expressions of columns.\n    \"\"\"\nreturn self._get_frame().select(exprs)\n</code></pre>"},{"location":"api/#atomlib.HasAtoms.sort","title":"<code>sort(by, descending=False)</code>","text":"Source code in <code>atomlib/atoms.py</code> <pre><code>def sort(self: HasAtomsT, by: t.Union[str, polars.Expr, t.List[str], t.List[polars.Expr]], descending: t.Union[bool, t.List[bool]] = False) -&gt; HasAtomsT:\nreturn self.with_atoms(Atoms(self._get_frame().sort(by, descending=descending), _unchecked=True))\n</code></pre>"},{"location":"api/#atomlib.HasAtoms.concat","title":"<code>concat(atoms, *, rechunk=True, how='vertical')</code>  <code>classmethod</code>","text":"Source code in <code>atomlib/atoms.py</code> <pre><code>@classmethod\ndef concat(cls: t.Type[HasAtomsT],\natoms: t.Union[HasAtomsT, IntoAtoms, t.Iterable[t.Union[HasAtomsT, IntoAtoms]]], *,\nrechunk: bool = True, how: ConcatMethod = 'vertical') -&gt; HasAtomsT:\n# this method is tricky. It needs to accept raw Atoms, as well as HasAtoms of the\n# same type as ``cls``.\nif _is_abstract(cls):\nraise TypeError(f\"concat() must be called on a concrete class.\")\nif isinstance(atoms, HasAtoms):\natoms = (atoms,)\ndfs = [a.get_atoms('local').inner if isinstance(a, HasAtoms) else Atoms(a).inner for a in atoms]\nrepresentative = cls._combine_metadata(*(a for a in atoms if isinstance(a, HasAtoms)))\nif len(dfs) == 0:\nreturn representative.with_atoms(Atoms.empty(), 'local')\nif how in ('vertical', 'vertical_relaxed'):\n# get order from first member\ncols = dfs[0].columns\ndfs = [df.select(cols) for df in dfs]\nelif how == 'inner':\ncols = reduce(operator.and_, (df.schema.keys() for df in dfs))\nschema = t.cast(SchemaDict, {col: dfs[0].schema[col] for col in cols})\nif len(schema) == 0:\nraise ValueError(f\"Atoms have no columns in common\")\ndfs = [_select_schema(df, schema) for df in dfs]\nhow = 'vertical'\nreturn representative.with_atoms(Atoms(polars.concat(dfs, rechunk=rechunk, how=how)), 'local')\n</code></pre>"},{"location":"api/#atomlib.HasAtoms.select_schema","title":"<code>select_schema(schema)</code>","text":"<p>Select columns from <code>self</code> and cast to the given schema. Raises :py:<code>TypeError</code> if a column is not found or if it can't be cast.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def select_schema(self, schema: SchemaDict) -&gt; polars.DataFrame:\n\"\"\"\n    Select columns from ``self`` and cast to the given schema.\n    Raises :py:`TypeError` if a column is not found or if it can't be cast.\n    \"\"\"\nreturn _select_schema(self, schema)\n</code></pre>"},{"location":"api/#atomlib.HasAtoms.try_select","title":"<code>try_select(exprs)</code>","text":"<p>Try to select <code>exprs</code> from <code>self</code>, and return as a <code>DataFrame</code>.</p> <p>Expressions may either be columns or expressions of columns. Return <code>None</code> if any columns are missing.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def try_select(self, exprs: t.Union[str, polars.Expr, polars.Series, t.Sequence[t.Union[str, polars.Expr, polars.Series]]]\n) -&gt; t.Optional[polars.DataFrame]:\n\"\"\"\n    Try to select ``exprs`` from ``self``, and return as a ``DataFrame``.\n    Expressions may either be columns or expressions of columns.\n    Return ``None`` if any columns are missing.\n    \"\"\"\ntry:\nreturn self._get_frame().select(exprs)\nexcept ColumnNotFoundError:\nreturn None\n</code></pre>"},{"location":"api/#atomlib.HasAtoms.try_get_column","title":"<code>try_get_column(name)</code>","text":"<p>Try to get a column from <code>self</code>, returning <code>None</code> if it doesn't exist.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def try_get_column(self, name: str) -&gt; t.Optional[polars.Series]:\n\"\"\"Try to get a column from `self`, returning `None` if it doesn't exist.\"\"\"\ntry:\nreturn self.get_column(name)\nexcept ColumnNotFoundError:\nreturn None\n</code></pre>"},{"location":"api/#atomlib.HasAtoms.assert_equal","title":"<code>assert_equal(other)</code>","text":"Source code in <code>atomlib/atoms.py</code> <pre><code>def assert_equal(self, other: t.Any):\nassert isinstance(other, HasAtoms)\nassert self.schema == other.schema\nfor (col, dtype) in self.schema.items():\nif dtype in (polars.Float32, polars.Float64):\nnumpy.testing.assert_array_almost_equal(self[col].view(ignore_nulls=True), other[col].view(ignore_nulls=True), 5)\nelse:\nassert (self[col] == other[col]).all()\n</code></pre>"},{"location":"api/#atomlib.HasAtoms.bbox_atoms","title":"<code>bbox_atoms()</code>","text":"<p>Return the bounding box of all the atoms in <code>self</code>.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def bbox_atoms(self) -&gt; BBox3D:\n\"\"\"Return the bounding box of all the atoms in ``self``.\"\"\"\nreturn BBox3D.from_pts(self.coords())\n</code></pre>"},{"location":"api/#atomlib.HasAtoms.transform_atoms","title":"<code>transform_atoms(transform, selection=None, *, transform_velocities=False)</code>","text":"<p>Transform the atoms in <code>self</code> by <code>transform</code>. If <code>selection</code> is given, only transform the atoms in <code>selection</code>.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def transform_atoms(self: HasAtomsT, transform: IntoTransform3D, selection: t.Optional[AtomSelection] = None, *, transform_velocities: bool = False) -&gt; HasAtomsT:\n\"\"\"\n    Transform the atoms in `self` by `transform`.\n    If `selection` is given, only transform the atoms in `selection`.\n    \"\"\"\ntransform = Transform3D.make(transform)\nselection = map_some(lambda s: _selection_to_series(self, s), selection)\ntransformed = self.with_coords(Transform3D.make(transform) @ self.coords(selection), selection)\n# try to transform velocities as well\nif transform_velocities and (velocities := self.velocities(selection)) is not None:\nreturn transformed.with_velocity(transform.transform_vec(velocities), selection)\nreturn transformed\n</code></pre>"},{"location":"api/#atomlib.HasAtoms.round_near_zero","title":"<code>round_near_zero(tol=1e-14)</code>","text":"<p>Round atom position values near zero to zero.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def round_near_zero(self: HasAtomsT, tol: float = 1e-14) -&gt; HasAtomsT:\n\"\"\"\n    Round atom position values near zero to zero.\n    \"\"\"\nreturn self.with_columns(tuple(\npolars.when(col.abs() &gt;= tol).then(col).otherwise(polars.lit(0.))\nfor col in map(polars.col, ('x', 'y', 'z'))\n))\n</code></pre>"},{"location":"api/#atomlib.HasAtoms.crop","title":"<code>crop(x_min=-numpy.inf, x_max=numpy.inf, y_min=-numpy.inf, y_max=numpy.inf, z_min=-numpy.inf, z_max=numpy.inf)</code>","text":"<p>Crop, removing all atoms outside of the specified region, inclusive.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def crop(self: HasAtomsT, x_min: float = -numpy.inf, x_max: float = numpy.inf,\ny_min: float = -numpy.inf, y_max: float = numpy.inf,\nz_min: float = -numpy.inf, z_max: float = numpy.inf) -&gt; HasAtomsT:\n\"\"\"\n    Crop, removing all atoms outside of the specified region, inclusive.\n    \"\"\"\nreturn self.filter(\n(polars.col('x') &gt;= x_min) &amp; (polars.col('x') &lt;= x_max) &amp;\n(polars.col('y') &gt;= y_min) &amp; (polars.col('y') &lt;= y_max) &amp;\n(polars.col('z') &gt;= z_min) &amp; (polars.col('z') &lt;= z_max)\n)\n</code></pre>"},{"location":"api/#atomlib.HasAtoms.deduplicate","title":"<code>deduplicate(tol=0.001, subset=('x', 'y', 'z', 'symbol'), keep='first')</code>","text":"<p>De-duplicate atoms in <code>self</code>. Atoms of the same <code>symbol</code> that are closer than <code>tolerance</code> to each other (by Euclidian distance) will be removed, leaving only the atom specified by <code>keep</code> (defaults to the first atom).</p> <p>If <code>subset</code> is specified, only those columns will be included while assessing duplicates. Floating point columns other than 'x', 'y', and 'z' will not by toleranced.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def deduplicate(self: HasAtomsT, tol: float = 1e-3, subset: t.Iterable[str] = ('x', 'y', 'z', 'symbol'),\nkeep: UniqueKeepStrategy = 'first') -&gt; HasAtomsT:\n\"\"\"\n    De-duplicate atoms in `self`. Atoms of the same `symbol` that are closer than `tolerance`\n    to each other (by Euclidian distance) will be removed, leaving only the atom specified by\n    `keep` (defaults to the first atom).\n    If `subset` is specified, only those columns will be included while assessing duplicates.\n    Floating point columns other than 'x', 'y', and 'z' will not by toleranced.\n    \"\"\"\ncols = set((subset,) if isinstance(subset, str) else subset)\nindices = numpy.arange(len(self))\nspatial_cols = cols.intersection(('x', 'y', 'z'))\ncols -= spatial_cols\nif len(spatial_cols) &gt; 0:\ncoords = self.select(list(spatial_cols)).to_numpy()\nprint(coords.shape)\ntree = scipy.spatial.KDTree(coords)\n# TODO This is a bad algorithm\nwhile True:\nchanged = False\nfor (i, j) in tree.query_pairs(tol, 2.):\n# whenever we encounter a pair, ensure their index matches\ni_i, i_j = indices[[i, j]]\nif i_i != i_j:\nindices[i] = indices[j] = min(i_i, i_j)\nchanged = True\nif not changed:\nbreak\nself = self.with_column(polars.Series('_unique_pts', indices))\ncols.add('_unique_pts')\nframe = self._get_frame().unique(subset=list(cols), keep=keep)\nif len(spatial_cols) &gt; 0:\nframe = frame.drop('_unique_pts')\nreturn self.with_atoms(Atoms(frame, _unchecked=True))\n</code></pre>"},{"location":"api/#atomlib.HasAtoms.with_bounds","title":"<code>with_bounds(cell_size=None, cell_origin=None)</code>","text":"<p>Return a periodic cell with the given orthogonal cell dimensions.</p> <p>If cell_size is not specified, it will be assumed (and may be incorrect).</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def with_bounds(self, cell_size: t.Optional[VecLike] = None, cell_origin: t.Optional[VecLike] = None) -&gt; 'AtomCell':\n\"\"\"\n    Return a periodic cell with the given orthogonal cell dimensions.\n    If cell_size is not specified, it will be assumed (and may be incorrect).\n    \"\"\"\n# TODO: test this\nfrom .atomcell import AtomCell\nif cell_size is None:\nwarnings.warn(\"Cell boundary unknown. Defaulting to cell BBox\")\ncell_size = self.bbox().size\ncell_origin = self.bbox().min\n# TODO test this origin code\ncell = Cell.from_unit_cell(cell_size)\nif cell_origin is not None:\ncell = cell.transform_cell(AffineTransform3D.translate(to_vec3(cell_origin)))\nreturn AtomCell(self.get_atoms(), cell, frame='local')\n</code></pre>"},{"location":"api/#atomlib.HasAtoms.coords","title":"<code>coords(selection=None)</code>","text":"<p>Returns a (N, 3) ndarray of atom coordinates (dtype <code>numpy.float64</code>).</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def coords(self, selection: t.Optional[AtomSelection] = None) -&gt; NDArray[numpy.float64]:\n\"\"\"Returns a (N, 3) ndarray of atom coordinates (dtype `numpy.float64`).\"\"\"\n# TODO find a way to get a view\nreturn self.filter(selection).select(('x', 'y', 'z')).to_numpy().astype(numpy.float64)\n</code></pre>"},{"location":"api/#atomlib.HasAtoms.velocities","title":"<code>velocities(selection=None)</code>","text":"<p>Returns a (N, 3) ndarray of atom velocities (dtype <code>numpy.float64</code>).</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def velocities(self, selection: t.Optional[AtomSelection] = None) -&gt; t.Optional[NDArray[numpy.float64]]:\n\"\"\"Returns a (N, 3) ndarray of atom velocities (dtype `numpy.float64`).\"\"\"\nif selection is not None:\nself = self.filter(selection)\nreturn map_some(lambda df: df.to_numpy().astype(numpy.float64),\nself.try_select(('v_x', 'v_y', 'v_z')))\n</code></pre>"},{"location":"api/#atomlib.HasAtoms.types","title":"<code>types()</code>","text":"<p>Returns a <code>Series</code> of atom types (dtype polars.Int32).</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def types(self) -&gt; t.Optional[polars.Series]:\n\"\"\"Returns a `Series` of atom types (dtype polars.Int32).\"\"\"\nreturn self.try_get_column('type')\n</code></pre>"},{"location":"api/#atomlib.HasAtoms.masses","title":"<code>masses()</code>","text":"<p>Returns a <code>Series</code> of atom masses (dtype polars.Float32).</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def masses(self) -&gt; t.Optional[polars.Series]:\n\"\"\"Returns a `Series` of atom masses (dtype polars.Float32).\"\"\"\nreturn self.try_get_column('mass')\n</code></pre>"},{"location":"api/#atomlib.HasAtoms.add_atom","title":"<code>add_atom(elem, /, x, y=None, z=None, **kwargs)</code>","text":"<p>Return a copy of <code>self</code> with an extra atom.</p> <p>By default, all extra columns present in <code>self</code> must be specified as <code>**kwargs</code>.</p> <p>Try to avoid calling this in a loop (Use :function:<code>Atoms.concat</code> instead).</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def add_atom(self: HasAtomsT, elem: t.Union[int, str], /,\nx: t.Union[ArrayLike, float],\ny: t.Optional[float] = None,\nz: t.Optional[float] = None,\n**kwargs: t.Any) -&gt; HasAtomsT:\n\"\"\"\n    Return a copy of ``self`` with an extra atom.\n    By default, all extra columns present in ``self`` must be specified as ``**kwargs``.\n    Try to avoid calling this in a loop (Use :function:`Atoms.concat` instead).\n    \"\"\"\nif isinstance(elem, int):\nkwargs.update(elem=elem)\nelse:\nkwargs.update(symbol=elem)\nif hasattr(x, '__len__') and len(x) &gt; 1:  # type: ignore\n(x, y, z) = to_vec3(x)\nelif y is None or z is None:\nraise ValueError(f\"Must specify vector of positions or x, y, &amp; z.\")\nsym = get_sym(elem) if isinstance(elem, int) else elem\nd: t.Dict[str, t.Any] = {'x': x, 'y': y, 'z': z, 'symbol': sym, **kwargs}\nreturn self.concat(\n(self, Atoms(d).select_schema(self.schema)),\nhow='vertical'\n)\n</code></pre>"},{"location":"api/#atomlib.HasAtoms.pos","title":"<code>pos(x=None, y=None, z=None, *, tol=1e-06, **kwargs)</code>","text":"<p>Select all atoms at a given position.</p> <p>Formally, returns all atoms within a cube of radius <code>tol</code> centered at <code>(x,y,z)</code>, exclusive of the cube's surface.</p> <p>Additional parameters given as <code>kwargs</code> will be checked as additional parameters (with strict equality).</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def pos(self,\nx: t.Union[t.Sequence[t.Optional[float]], float, None] = None,\ny: t.Optional[float] = None, z: t.Optional[float] = None, *,\ntol: float = 1e-6, **kwargs: t.Any) -&gt; polars.Expr:\n\"\"\"\n    Select all atoms at a given position.\n    Formally, returns all atoms within a cube of radius ``tol``\n    centered at ``(x,y,z)``, exclusive of the cube's surface.\n    Additional parameters given as ``kwargs`` will be checked\n    as additional parameters (with strict equality).\n    \"\"\"\nif isinstance(x, t.Sequence):\n(x, y, z) = x\ntol = abs(float(tol))\nselection = polars.lit(True)\nif x is not None:\nselection &amp;= (x - tol &lt; polars.col('x')) &amp; (polars.col('x') &lt; x + tol)\nif y is not None:\nselection &amp;= (y - tol &lt; polars.col('y')) &amp; (polars.col('y') &lt; y + tol)\nif z is not None:\nselection &amp;= (z - tol &lt; polars.col('z')) &amp; (polars.col('z') &lt; z + tol)\nfor (col, val) in kwargs.items():\nselection &amp;= (polars.col(col) == val)\nreturn selection\n</code></pre>"},{"location":"api/#atomlib.HasAtoms.with_index","title":"<code>with_index(index=None)</code>","text":"<p>Returns <code>self</code> with a row index added in column 'i' (dtype polars.Int64). If <code>index</code> is not specified, defaults to an existing index or a new index.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def with_index(self: HasAtomsT, index: t.Optional[AtomValues] = None) -&gt; HasAtomsT:\n\"\"\"\n    Returns `self` with a row index added in column 'i' (dtype polars.Int64).\n    If `index` is not specified, defaults to an existing index or a new index.\n    \"\"\"\nif index is None and 'i' in self.columns:\nreturn self\nif index is None:\nindex = numpy.arange(len(self), dtype=numpy.int64)\nreturn self.with_column(_values_to_expr(index, polars.Int64).alias('i'))\n</code></pre>"},{"location":"api/#atomlib.HasAtoms.with_wobble","title":"<code>with_wobble(wobble=None)</code>","text":"<p>Return <code>self</code> with the given displacements in column 'wobble' (dtype polars.Float64). If <code>wobble</code> is not specified, defaults to the already-existing wobbles or 0.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def with_wobble(self: HasAtomsT, wobble: t.Optional[AtomValues] = None) -&gt; HasAtomsT:\n\"\"\"\n    Return `self` with the given displacements in column 'wobble' (dtype polars.Float64).\n    If `wobble` is not specified, defaults to the already-existing wobbles or 0.\n    \"\"\"\nif wobble is None and 'wobble' in self.columns:\nreturn self\nwobble = 0. if wobble is None else wobble\nreturn self.with_column(_values_to_expr(wobble, polars.Float64).alias('wobble'))\n</code></pre>"},{"location":"api/#atomlib.HasAtoms.with_occupancy","title":"<code>with_occupancy(frac_occupancy=None)</code>","text":"<p>Return self with the given fractional occupancies. If <code>frac_occupancy</code> is not specified, defaults to the already-existing occupancies or 1.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def with_occupancy(self: HasAtomsT, frac_occupancy: t.Optional[AtomValues] = None) -&gt; HasAtomsT:\n\"\"\"\n    Return self with the given fractional occupancies. If `frac_occupancy` is not specified,\n    defaults to the already-existing occupancies or 1.\n    \"\"\"\nif frac_occupancy is None and 'frac_occupancy' in self.columns:\nreturn self\nfrac_occupancy = 1. if frac_occupancy is None else frac_occupancy\nreturn self.with_column(_values_to_expr(frac_occupancy, polars.Float64).alias('frac_occupancy'))\n</code></pre>"},{"location":"api/#atomlib.HasAtoms.apply_wobble","title":"<code>apply_wobble(rng=None)</code>","text":"<p>Displace the atoms in <code>self</code> by the amount in the <code>wobble</code> column. <code>wobble</code> is interpretated as a mean-squared displacement, which is distributed equally over each axis.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def apply_wobble(self: HasAtomsT, rng: t.Union[numpy.random.Generator, int, None] = None) -&gt; HasAtomsT:\n\"\"\"\n    Displace the atoms in `self` by the amount in the `wobble` column.\n    `wobble` is interpretated as a mean-squared displacement, which is distributed\n    equally over each axis.\n    \"\"\"\nif 'wobble' not in self.columns:\nreturn self\nrng = numpy.random.default_rng(seed=rng)\nstddev = self.select((polars.col('wobble') / 3.).sqrt()).to_series().to_numpy()\ncoords = self.coords()\ncoords += stddev[:, None] * rng.standard_normal(coords.shape)\nreturn self.with_coords(coords)\n</code></pre>"},{"location":"api/#atomlib.HasAtoms.apply_occupancy","title":"<code>apply_occupancy(rng=None)</code>","text":"<p>For each atom in <code>self</code>, use its <code>frac_occupancy</code> to randomly decide whether to remove it.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def apply_occupancy(self: HasAtomsT, rng: t.Union[numpy.random.Generator, int, None] = None) -&gt; HasAtomsT:\n\"\"\"\n    For each atom in `self`, use its `frac_occupancy` to randomly decide whether to remove it.\n    \"\"\"\nif 'frac_occupancy' not in self.columns:\nreturn self\nrng = numpy.random.default_rng(seed=rng)\nfrac = self.select('frac_occupancy').to_series().to_numpy()\nchoice = rng.binomial(1, frac).astype(numpy.bool_)\nreturn self.filter(polars.lit(choice))\n</code></pre>"},{"location":"api/#atomlib.HasAtoms.with_type","title":"<code>with_type(types=None)</code>","text":"<p>Return <code>self</code> with the given atom types in column 'type'. If <code>types</code> is not specified, use the already existing types or auto-assign them.</p> <p>When auto-assigning, each symbol is given a unique value, case-sensitive. Values are assigned from lowest atomic number to highest. For instance: [\"Ag+\", \"Na\", \"H\", \"Ag\"] =&gt; [3, 11, 1, 2]</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def with_type(self: HasAtomsT, types: t.Optional[AtomValues] = None) -&gt; HasAtomsT:\n\"\"\"\n    Return `self` with the given atom types in column 'type'.\n    If `types` is not specified, use the already existing types or auto-assign them.\n    When auto-assigning, each symbol is given a unique value, case-sensitive.\n    Values are assigned from lowest atomic number to highest.\n    For instance: [\"Ag+\", \"Na\", \"H\", \"Ag\"] =&gt; [3, 11, 1, 2]\n    \"\"\"\nif types is not None:\nreturn self.with_column(_values_to_expr(types, polars.Int32).alias('type'))\nif 'type' in self.columns:\nreturn self\nunique = Atoms(self._get_frame().unique(maintain_order=False, subset=['elem', 'symbol']).sort(['elem', 'symbol']), _unchecked=True)\nnew = self.with_column(polars.Series('type', values=numpy.zeros(len(self)), dtype=polars.Int32))\nlogging.warning(\"Auto-assigning element types\")\nfor (i, (elem, sym)) in enumerate(unique.select(('elem', 'symbol')).rows()):\nprint(f\"Assigning type {i+1} to element '{sym}'\")\nnew = new.with_column(polars.when((polars.col('elem') == elem) &amp; (polars.col('symbol') == sym))\n.then(polars.lit(i+1))\n.otherwise(polars.col('type'))\n.alias('type'))\nassert (new.get_column('type') == 0).sum() == 0\nreturn new\n</code></pre>"},{"location":"api/#atomlib.HasAtoms.with_mass","title":"<code>with_mass(mass=None)</code>","text":"<p>Return <code>self</code> with the given atom masses in column 'mass'. If <code>mass</code> is not specified, use the already existing masses or auto-assign them.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def with_mass(self: HasAtomsT, mass: t.Optional[ArrayLike] = None) -&gt; HasAtomsT:\n\"\"\"\n    Return `self` with the given atom masses in column 'mass'.\n    If `mass` is not specified, use the already existing masses or auto-assign them.\n    \"\"\"\nif mass is not None:\nreturn self.with_column(_values_to_expr(mass, polars.Float32).alias('mass'))\nif 'mass' in self.columns:\nreturn self\nunique_elems = self.get_column('elem').unique()\nnew = self.with_column(polars.Series('mass', values=numpy.zeros(len(self)), dtype=polars.Float32))\nlogging.warning(\"Auto-assigning element masses\")\nfor elem in unique_elems:\nnew = new.with_column(polars.when(polars.col('elem') == elem)\n.then(polars.lit(get_mass(elem)))\n.otherwise(polars.col('mass'))\n.alias('mass'))\nassert (new.get_column('mass').abs() &lt; 1e-10).sum() == 0\nreturn new\n</code></pre>"},{"location":"api/#atomlib.HasAtoms.with_symbol","title":"<code>with_symbol(symbols, selection=None)</code>","text":"<p>Return <code>self</code> with the given atomic symbols.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def with_symbol(self: HasAtomsT, symbols: ArrayLike, selection: t.Optional[AtomSelection] = None) -&gt; HasAtomsT:\n\"\"\"\n    Return `self` with the given atomic symbols.\n    \"\"\"\nif selection is not None:\nselection = _selection_to_numpy(self, selection)\nnew_symbols = self.get_column('symbol')\nnew_symbols[selection] = polars.Series(list(numpy.broadcast_to(symbols, len(selection))), dtype=polars.Utf8)\nsymbols = new_symbols\n# TODO better cast here\nsymbols = polars.Series('symbol', list(numpy.broadcast_to(symbols, len(self))), dtype=polars.Utf8)\nreturn self.with_columns((symbols, get_elem(symbols)))\n</code></pre>"},{"location":"api/#atomlib.HasAtoms.with_coords","title":"<code>with_coords(pts, selection=None)</code>","text":"<p>Return <code>self</code> replaced with the given atomic positions.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def with_coords(self: HasAtomsT, pts: ArrayLike, selection: t.Optional[AtomSelection] = None) -&gt; HasAtomsT:\n\"\"\"\n    Return `self` replaced with the given atomic positions.\n    \"\"\"\nif selection is not None:\nselection = _selection_to_numpy(self, selection)\nnew_pts = self.coords()\npts = numpy.atleast_2d(pts)\nassert pts.shape[-1] == 3\nnew_pts[selection] = pts\npts = new_pts\npts = numpy.broadcast_to(pts, (len(self), 3))\nreturn self.with_columns((\npolars.Series(pts[:, 0], dtype=polars.Float64).alias('x'),\npolars.Series(pts[:, 1], dtype=polars.Float64).alias('y'),\npolars.Series(pts[:, 2], dtype=polars.Float64).alias('z'),\n))\n</code></pre>"},{"location":"api/#atomlib.HasAtoms.with_velocity","title":"<code>with_velocity(pts=None, selection=None)</code>","text":"<p>Return <code>self</code> replaced with the given atomic velocities. If <code>pts</code> is not specified, use the already existing velocities or zero.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def with_velocity(self: HasAtomsT, pts: t.Optional[ArrayLike] = None,\nselection: t.Optional[AtomSelection] = None) -&gt; HasAtomsT:\n\"\"\"\n    Return `self` replaced with the given atomic velocities.\n    If `pts` is not specified, use the already existing velocities or zero.\n    \"\"\"\nif pts is None:\nif all(col in self.columns for col in ('v_x', 'v_y', 'v_z')):\nreturn self\npts = numpy.zeros((len(self), 3))\nelse:\npts = numpy.broadcast_to(pts, (len(self), 3))\nif selection is None:\nreturn self.with_columns((\npolars.Series(pts[:, 0], dtype=polars.Float64).alias('v_x'),\npolars.Series(pts[:, 1], dtype=polars.Float64).alias('v_y'),\npolars.Series(pts[:, 2], dtype=polars.Float64).alias('v_z'),\n))\nselection = _selection_to_series(self, selection)\nreturn self.__class__(self.with_columns((\nself['v_x'].set_at_idx(selection, pts[:, 0]),  # type: ignore\nself['v_y'].set_at_idx(selection, pts[:, 1]),  # type: ignore\nself['v_z'].set_at_idx(selection, pts[:, 2]),  # type: ignore\n)))\n</code></pre>"},{"location":"api/#atomlib.Cell","title":"<code>Cell</code>  <code>dataclass</code>","text":"<p>             Bases: <code>HasCell</code></p> <p>Internal class for representing the coordinate systems of a crystal.</p> <p>The overall transformation from crystal coordinates to real-space coordinates is is split into four transformations, applied from bottom to top. First is <code>n_cells</code>, which scales from fractions of a unit cell to fractions of a supercell. Next is <code>cell_size</code>, which scales to real-space units. <code>ortho</code> is an orthogonalization matrix, a det = 1 upper-triangular matrix which transforms crystal axes to an orthogonal coordinate system. Finally, <code>affine</code> contains any remaining transformations to the local coordinate system, which atoms are stored in.</p> Source code in <code>atomlib/cell.py</code> <pre><code>@dataclass(frozen=True, init=False)\nclass Cell(HasCell):\n\"\"\"\n    Internal class for representing the coordinate systems of a crystal.\n    The overall transformation from crystal coordinates to real-space coordinates is\n    is split into four transformations, applied from bottom to top. First is ``n_cells``,\n    which scales from fractions of a unit cell to fractions of a supercell. Next is\n    ``cell_size``, which scales to real-space units. ``ortho`` is an orthogonalization\n    matrix, a det = 1 upper-triangular matrix which transforms crystal axes to\n    an orthogonal coordinate system. Finally, ``affine`` contains any remaining\n    transformations to the local coordinate system, which atoms are stored in.\n    \"\"\"\ndef get_cell(self) -&gt; Cell:\nreturn self\ndef with_cell(self: Cell, cell: Cell) -&gt; Cell:\nreturn cell\n_affine: AffineTransform3D = AffineTransform3D()\n\"\"\"\n    Affine transformation. Holds transformation from 'ortho' to 'local' coordinates,\n    including rotation away from the standard crystal orientation.\n    \"\"\"\n_ortho: LinearTransform3D = LinearTransform3D()\n\"\"\"\n    Orthogonalization transformation. Skews but does not scale the crystal axes to cartesian axes.\n    \"\"\"\n_cell_size: NDArray[numpy.float_]\n\"\"\"Unit cell size.\"\"\"\n_cell_angle: NDArray[numpy.float_] = field(default_factory=lambda: numpy.full(3, numpy.pi/2.))\n\"\"\"Unit cell angles, in radians.\"\"\"\n_n_cells: NDArray[numpy.int_] = field(default_factory=lambda: numpy.ones(3, numpy.int_))\n\"\"\"Number of unit cells.\"\"\"\n_pbc: NDArray[numpy.bool_] = field(default_factory=lambda: numpy.ones(3, numpy.bool_))\n\"\"\"Flags indicating the presence of periodic boundary conditions along each axis.\"\"\"\ndef __init__(self, *,\naffine: t.Optional[AffineTransform3D] = None, ortho: t.Optional[LinearTransform3D] = None,\ncell_size: VecLike, cell_angle: t.Optional[VecLike] = None,\nn_cells: t.Optional[VecLike] = None, pbc: t.Optional[VecLike]):\nobject.__setattr__(self, '_affine', AffineTransform3D() if affine is None else affine)\nobject.__setattr__(self, '_ortho', LinearTransform3D() if ortho is None else ortho)\nobject.__setattr__(self, '_cell_size', to_vec3(cell_size))\nobject.__setattr__(self, '_cell_angle', numpy.full(3, numpy.pi/2.) if cell_angle is None else to_vec3(cell_angle))\nobject.__setattr__(self, '_n_cells', numpy.ones(3, numpy.int_) if n_cells is None else to_vec3(n_cells, numpy.int_))\nobject.__setattr__(self, '_pbc', numpy.ones(3, numpy.bool_) if pbc is None else to_vec3(pbc, numpy.bool_))\n@staticmethod\ndef from_unit_cell(cell_size: VecLike, cell_angle: t.Optional[VecLike] = None, n_cells: t.Optional[VecLike] = None,\npbc: t.Optional[VecLike] = None):\nreturn Cell(\northo=cell_to_ortho([1.]*3, cell_angle),\nn_cells=to_vec3([1]*3 if n_cells is None else n_cells, numpy.int_),\ncell_size=to_vec3(cell_size),\ncell_angle=to_vec3([numpy.pi/2.]*3 if cell_angle is None else cell_angle),\npbc=pbc\n)\n@staticmethod\ndef from_ortho(ortho: AffineTransform3D, n_cells: t.Optional[VecLike] = None, pbc: t.Optional[VecLike] = None):\nlin = ortho.to_linear()\n# decompose into orthogonal and upper triangular\nq, r = numpy.linalg.qr(lin.inner)\n# flip QR decomposition so R has positive diagonals\nsigns = numpy.sign(numpy.diagonal(r))\n# multiply flips to columns of Q, rows of R\nq = q * signs; r = r * signs[:, None]\n#numpy.testing.assert_allclose(q @ r, lin.inner)\nif numpy.linalg.det(q) &lt; 0:\nwarn(\"Crystal is left-handed. This is currently unsupported, and may cause errors.\")\n# currently, behavior is to leave `ortho` proper, and move the inversion into the affine transform\ncell_size, cell_angle = ortho_to_cell(lin)\nreturn Cell(\naffine=LinearTransform3D(q).translate(ortho.translation()),\northo=LinearTransform3D(r / cell_size).round_near_zero(),\ncell_size=cell_size, cell_angle=cell_angle,\nn_cells=to_vec3([1]*3 if n_cells is None else n_cells, numpy.int_),\npbc=pbc,\n)\ndef __str__(self) -&gt; str:\nreturn \"\\n\".join((\nself.__class__.__name__,\nf\"Cell size: {self.cell_size!r}\",\nf\"Cell angle: {self.cell_angle!r}\",\nf\"# cells: {self.cell_angle!r}\",\nf\"pbc: {self.pbc!r}\",\n))\ndef __repr__(self) -&gt; str:\nreturn (\nf\"{self.__class__.__name__}(\"\nf\"ortho={self.ortho}, affine={self.affine}, cell_size={self.cell_size}, \"\nf\"cell_angle={self.cell_angle}, n_cells={self.n_cells}, pbc={self.pbc})\"\n)\ndef _repr_pretty_(self, p, cycle: bool) -&gt; None:\np.text(f\"{self.__class__.__name__}(...)\") if cycle else p.text(str(self))\n</code></pre>"},{"location":"api/#atomlib.Cell.affine","title":"<code>affine: AffineTransform3D</code>  <code>property</code>","text":"<p>Affine transformation. Holds transformation from 'ortho' to 'local' coordinates, including rotation away from the standard crystal orientation.</p>"},{"location":"api/#atomlib.Cell.ortho","title":"<code>ortho: LinearTransform3D</code>  <code>property</code>","text":"<p>Orthogonalization transformation. Skews but does not scale the crystal axes to cartesian axes.</p>"},{"location":"api/#atomlib.Cell.metric","title":"<code>metric: LinearTransform3D</code>  <code>property</code>","text":"<p>Cell metric tensor</p> <p>Returns the dot product between every combination of basis vectors. :math:<code>\\mathbf{a} \\cdot \\mathbf{b} = a_i M_ij b_j</code></p>"},{"location":"api/#atomlib.Cell.cell_size","title":"<code>cell_size: NDArray[numpy.float_]</code>  <code>property</code>","text":"<p>Unit cell size.</p>"},{"location":"api/#atomlib.Cell.cell_angle","title":"<code>cell_angle: NDArray[numpy.float_]</code>  <code>property</code>","text":"<p>Unit cell angles, in radians.</p>"},{"location":"api/#atomlib.Cell.n_cells","title":"<code>n_cells: NDArray[numpy.int_]</code>  <code>property</code>","text":"<p>Number of unit cells.</p>"},{"location":"api/#atomlib.Cell.pbc","title":"<code>pbc: NDArray[numpy.bool_]</code>  <code>property</code>","text":"<p>Flags indicating the presence of periodic boundary conditions along each axis.</p>"},{"location":"api/#atomlib.Cell.ortho_size","title":"<code>ortho_size: NDArray[numpy.float_]</code>  <code>property</code>","text":"<p>Return size of orthogonal unit cell.</p> <p>Equivalent to the diagonal of the orthogonalization matrix.</p>"},{"location":"api/#atomlib.Cell.box_size","title":"<code>box_size: NDArray[numpy.float_]</code>  <code>property</code>","text":"<p>Return size of the cell box.</p> <p>Equivalent to <code>self.n_cells * self.cell_size</code>.</p>"},{"location":"api/#atomlib.Cell.bbox","title":"<code>bbox = bbox_cell</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#atomlib.Cell.get_transform","title":"<code>get_transform(frame_to=None, frame_from=None)</code>","text":"<p>In the two-argument form, get the transform to 'frame_to' from 'frame_from'. In the one-argument form, get the transform from local coordinates to 'frame'.</p> Source code in <code>atomlib/cell.py</code> <pre><code>def get_transform(self, frame_to: t.Optional[CoordinateFrame] = None, frame_from: t.Optional[CoordinateFrame] = None) -&gt; AffineTransform3D:\n\"\"\"\n    In the two-argument form, get the transform to 'frame_to' from 'frame_from'.\n    In the one-argument form, get the transform from local coordinates to 'frame'.\n    \"\"\"\ntransform_from = self._get_transform_to_local(frame_from) if frame_from is not None else AffineTransform3D()\ntransform_to = self._get_transform_to_local(frame_to) if frame_to is not None else AffineTransform3D()\nif frame_from is not None and frame_to is not None and frame_from.lower() == frame_to.lower():\nreturn AffineTransform3D()\nreturn transform_to.inverse() @ transform_from\n</code></pre>"},{"location":"api/#atomlib.Cell.corners","title":"<code>corners(frame='local')</code>","text":"Source code in <code>atomlib/cell.py</code> <pre><code>def corners(self, frame: CoordinateFrame = 'local') -&gt; numpy.ndarray:\ncorners = numpy.array(list(itertools.product((0., 1.), repeat=3)))\nreturn self.get_transform(frame, 'cell_box') @ corners\n</code></pre>"},{"location":"api/#atomlib.Cell.bbox_cell","title":"<code>bbox_cell(frame='local')</code>","text":"<p>Return the bounding box of the cell box in the given coordinate system.</p> Source code in <code>atomlib/cell.py</code> <pre><code>def bbox_cell(self, frame: CoordinateFrame = 'local') -&gt; BBox3D:\n\"\"\"Return the bounding box of the cell box in the given coordinate system.\"\"\"\nreturn BBox3D.from_pts(self.corners(frame))\n</code></pre>"},{"location":"api/#atomlib.Cell.is_orthogonal","title":"<code>is_orthogonal(tol=1e-08)</code>","text":"<p>Returns whether this cell is orthogonal (axes are at right angles.)</p> Source code in <code>atomlib/cell.py</code> <pre><code>def is_orthogonal(self, tol: float = 1e-8) -&gt; bool:\n\"\"\"Returns whether this cell is orthogonal (axes are at right angles.)\"\"\"\nreturn self.ortho.is_diagonal(tol=tol)\n</code></pre>"},{"location":"api/#atomlib.Cell.is_orthogonal_in_local","title":"<code>is_orthogonal_in_local(tol=1e-08)</code>","text":"<p>Returns whether this cell is orthogonal and aligned with the local coordinate system.</p> Source code in <code>atomlib/cell.py</code> <pre><code>def is_orthogonal_in_local(self, tol: float = 1e-8) -&gt; bool:\n\"\"\"Returns whether this cell is orthogonal and aligned with the local coordinate system.\"\"\"\ntransform = (self.affine @ self.ortho).to_linear()\nif not transform.is_scaled_orthogonal(tol):\nreturn False\nnormed = transform.inner / numpy.linalg.norm(transform.inner, axis=-2, keepdims=True)\n# every row of transform must be a +/- 1 times a basis vector (i, j, or k)\nreturn all(\nany(numpy.isclose(numpy.abs(numpy.dot(row, v)), 1., atol=tol) for v in numpy.eye(3))\nfor row in normed\n)\n</code></pre>"},{"location":"api/#atomlib.Cell.to_ortho","title":"<code>to_ortho()</code>","text":"Source code in <code>atomlib/cell.py</code> <pre><code>def to_ortho(self) -&gt; AffineTransform3D:\nreturn self.get_transform('local', 'cell_box')\n</code></pre>"},{"location":"api/#atomlib.Cell.transform_cell","title":"<code>transform_cell(transform, frame='local')</code>","text":"<p>Apply the given transform to the unit cell, and return a new <code>Cell</code>. The transform is applied in coordinate frame 'frame'. Orthogonal and affine transformations are applied to the affine matrix component, while skew and scaling is applied to the orthogonalization matrix/cell_size.</p> Source code in <code>atomlib/cell.py</code> <pre><code>def transform_cell(self: HasCellT, transform: AffineTransform3D, frame: CoordinateFrame = 'local') -&gt; HasCellT:\n\"\"\"\n    Apply the given transform to the unit cell, and return a new `Cell`.\n    The transform is applied in coordinate frame 'frame'.\n    Orthogonal and affine transformations are applied to the affine matrix component,\n    while skew and scaling is applied to the orthogonalization matrix/cell_size.\n    \"\"\"\ntransform = t.cast(AffineTransform3D, self.change_transform(transform, 'local', frame))\nif not transform.to_linear().is_orthogonal():\nraise NotImplementedError()\nreturn self.with_cell(Cell(\naffine=transform @ self.affine,\northo=self.ortho,\ncell_size=self.cell_size,\ncell_angle=self.cell_angle,\nn_cells=self.n_cells,\npbc=self.pbc,\n))\n</code></pre>"},{"location":"api/#atomlib.Cell.strain_orthogonal","title":"<code>strain_orthogonal()</code>","text":"<p>Orthogonalize using strain.</p> <p>Strain is applied such that the x-axis remains fixed, and the y-axis remains in the xy plane. For small displacements, no hydrostatic strain is applied (volume is conserved).</p> Source code in <code>atomlib/cell.py</code> <pre><code>def strain_orthogonal(self: HasCellT) -&gt; HasCellT:\n\"\"\"\n    Orthogonalize using strain.\n    Strain is applied such that the x-axis remains fixed, and the y-axis remains in the xy plane.\n    For small displacements, no hydrostatic strain is applied (volume is conserved).\n    \"\"\"\nreturn self.with_cell(Cell(\naffine=self.affine,\northo=LinearTransform3D(),\ncell_size=self.cell_size,\nn_cells=self.n_cells,\npbc=self.pbc,\n))\n</code></pre>"},{"location":"api/#atomlib.Cell.repeat","title":"<code>repeat(n)</code>","text":"<p>Tile the cell by <code>n</code> in each dimension.</p> Source code in <code>atomlib/cell.py</code> <pre><code>def repeat(self: HasCellT, n: t.Union[int, VecLike]) -&gt; HasCellT:\n\"\"\"Tile the cell by `n` in each dimension.\"\"\"\nns = numpy.broadcast_to(n, 3)\nif not numpy.issubdtype(ns.dtype, numpy.integer):\nraise ValueError(f\"repeat() argument must be an integer or integer array.\")\nreturn self.with_cell(Cell(\naffine=self.affine,\northo=self.ortho,\ncell_size=self.cell_size,\ncell_angle=self.cell_angle,\nn_cells=self.n_cells * numpy.broadcast_to(n, 3),\npbc = self.pbc | (ns &gt; 1)  # assume periodic along repeated directions\n))\n</code></pre>"},{"location":"api/#atomlib.Cell.explode","title":"<code>explode()</code>","text":"<p>Materialize repeated cells as one supercell.</p> Source code in <code>atomlib/cell.py</code> <pre><code>def explode(self: HasCellT) -&gt; HasCellT:\n\"\"\"Materialize repeated cells as one supercell.\"\"\"\nreturn self.with_cell(Cell(\naffine=self.affine,\northo=self.ortho,\ncell_size=self.cell_size*self.n_cells,\ncell_angle=self.cell_angle,\npbc=self.pbc,\n))\n</code></pre>"},{"location":"api/#atomlib.Cell.explode_z","title":"<code>explode_z()</code>","text":"<p>Materialize repeated cells as one supercell in z.</p> Source code in <code>atomlib/cell.py</code> <pre><code>def explode_z(self: HasCellT) -&gt; HasCellT:\n\"\"\"Materialize repeated cells as one supercell in z.\"\"\"\nreturn self.with_cell(Cell(\naffine=self.affine,\northo=self.ortho,\ncell_size=self.cell_size*[1, 1, self.n_cells[2]],\nn_cells=[*self.n_cells[:2], 1],\ncell_angle=self.cell_angle,\npbc=self.pbc,\n))\n</code></pre>"},{"location":"api/#atomlib.Cell.crop","title":"<code>crop(x_min=-numpy.inf, x_max=numpy.inf, y_min=-numpy.inf, y_max=numpy.inf, z_min=-numpy.inf, z_max=numpy.inf, *, frame='local')</code>","text":"<p>Crop 'cell' to the given extents. For a non-orthogonal cell, this must be specified in cell coordinates. This function implicity <code>explode</code>s the cell as well.</p> Source code in <code>atomlib/cell.py</code> <pre><code>def crop(self: HasCellT, x_min: float = -numpy.inf, x_max: float = numpy.inf,\ny_min: float = -numpy.inf, y_max: float = numpy.inf,\nz_min: float = -numpy.inf, z_max: float = numpy.inf, *,\nframe: CoordinateFrame = 'local') -&gt; HasCellT:\n\"\"\"\n    Crop 'cell' to the given extents. For a non-orthogonal\n    cell, this must be specified in cell coordinates. This\n    function implicity `explode`s the cell as well.\n    \"\"\"\nif not frame.lower().startswith('cell'):\nif not self.is_orthogonal():\nraise ValueError(\"Cannot crop a non-orthogonal cell in orthogonal coordinates. Use crop_atoms instead.\")\nmin = to_vec3([x_min, y_min, z_min])\nmax = to_vec3([x_max, y_max, z_max])\n(min, max) = self.get_transform('cell_box', frame).transform([min, max])\nnew_box = BBox3D(min, max) &amp; BBox3D.unit()\ncropped = (new_box.min &gt; 0.) | (new_box.max &lt; 1.)\nreturn self.with_cell(Cell(\naffine=self.affine @ AffineTransform3D.translate(-new_box.min),\northo=self.ortho,\ncell_size=new_box.size * self.cell_size * numpy.where(cropped, self.n_cells, 1),\nn_cells=numpy.where(cropped, 1, self.n_cells),\ncell_angle=self.cell_angle,\npbc=self.pbc &amp; ~cropped  # remove periodicity along cropped directions\n))\n</code></pre>"},{"location":"api/#atomlib.Cell.change_transform","title":"<code>change_transform(transform, frame_to=None, frame_from=None)</code>","text":"<p>Coordinate-change a transformation to 'frame_to' from 'frame_from'.</p> Source code in <code>atomlib/cell.py</code> <pre><code>def change_transform(self, transform: Transform3D,\nframe_to: t.Optional[CoordinateFrame] = None,\nframe_from: t.Optional[CoordinateFrame] = None) -&gt; Transform3D:\n\"\"\"Coordinate-change a transformation to 'frame_to' from 'frame_from'.\"\"\"\nif frame_to == frame_from and frame_to is not None:\nreturn transform\ncoord_change = self.get_transform(frame_to, frame_from)\nreturn coord_change @ transform @ coord_change.inverse()\n</code></pre>"},{"location":"api/#atomlib.Cell.assert_equal","title":"<code>assert_equal(other)</code>","text":"Source code in <code>atomlib/cell.py</code> <pre><code>def assert_equal(self, other: t.Any):\nassert isinstance(other, HasCell) and type(self) == type(other)\nnumpy.testing.assert_array_almost_equal(self.affine.inner, other.affine.inner, 6)\nnumpy.testing.assert_array_almost_equal(self.ortho.inner, other.ortho.inner, 6)\nnumpy.testing.assert_array_almost_equal(self.cell_size, other.cell_size, 6)\nnumpy.testing.assert_array_equal(self.n_cells, other.n_cells)\nnumpy.testing.assert_array_equal(self.pbc, other.pbc)\n</code></pre>"},{"location":"api/#atomlib.Cell.get_cell","title":"<code>get_cell()</code>","text":"Source code in <code>atomlib/cell.py</code> <pre><code>def get_cell(self) -&gt; Cell:\nreturn self\n</code></pre>"},{"location":"api/#atomlib.Cell.with_cell","title":"<code>with_cell(cell)</code>","text":"Source code in <code>atomlib/cell.py</code> <pre><code>def with_cell(self: Cell, cell: Cell) -&gt; Cell:\nreturn cell\n</code></pre>"},{"location":"api/#atomlib.Cell.from_unit_cell","title":"<code>from_unit_cell(cell_size, cell_angle=None, n_cells=None, pbc=None)</code>  <code>staticmethod</code>","text":"Source code in <code>atomlib/cell.py</code> <pre><code>@staticmethod\ndef from_unit_cell(cell_size: VecLike, cell_angle: t.Optional[VecLike] = None, n_cells: t.Optional[VecLike] = None,\npbc: t.Optional[VecLike] = None):\nreturn Cell(\northo=cell_to_ortho([1.]*3, cell_angle),\nn_cells=to_vec3([1]*3 if n_cells is None else n_cells, numpy.int_),\ncell_size=to_vec3(cell_size),\ncell_angle=to_vec3([numpy.pi/2.]*3 if cell_angle is None else cell_angle),\npbc=pbc\n)\n</code></pre>"},{"location":"api/#atomlib.Cell.from_ortho","title":"<code>from_ortho(ortho, n_cells=None, pbc=None)</code>  <code>staticmethod</code>","text":"Source code in <code>atomlib/cell.py</code> <pre><code>@staticmethod\ndef from_ortho(ortho: AffineTransform3D, n_cells: t.Optional[VecLike] = None, pbc: t.Optional[VecLike] = None):\nlin = ortho.to_linear()\n# decompose into orthogonal and upper triangular\nq, r = numpy.linalg.qr(lin.inner)\n# flip QR decomposition so R has positive diagonals\nsigns = numpy.sign(numpy.diagonal(r))\n# multiply flips to columns of Q, rows of R\nq = q * signs; r = r * signs[:, None]\n#numpy.testing.assert_allclose(q @ r, lin.inner)\nif numpy.linalg.det(q) &lt; 0:\nwarn(\"Crystal is left-handed. This is currently unsupported, and may cause errors.\")\n# currently, behavior is to leave `ortho` proper, and move the inversion into the affine transform\ncell_size, cell_angle = ortho_to_cell(lin)\nreturn Cell(\naffine=LinearTransform3D(q).translate(ortho.translation()),\northo=LinearTransform3D(r / cell_size).round_near_zero(),\ncell_size=cell_size, cell_angle=cell_angle,\nn_cells=to_vec3([1]*3 if n_cells is None else n_cells, numpy.int_),\npbc=pbc,\n)\n</code></pre>"},{"location":"api/#atomlib.HasCell","title":"<code>HasCell</code>","text":"Source code in <code>atomlib/cell.py</code> <pre><code>class HasCell:\n# abstract methods\n@abc.abstractmethod\ndef get_cell(self) -&gt; Cell:\n\"\"\"Get the cell contained in ``self``. This should be a low cost method.\"\"\"\n...\n@abc.abstractmethod\ndef with_cell(self: HasCellT, cell: Cell) -&gt; HasCellT:\n\"\"\"Replace the cell in ``self`` with ``cell``.\"\"\"\n...\n# getters\n@property\ndef affine(self) -&gt; AffineTransform3D:\n\"\"\"\n        Affine transformation. Holds transformation from 'ortho' to 'local' coordinates,\n        including rotation away from the standard crystal orientation.\n        \"\"\"\nreturn self.get_cell()._affine\n@property\ndef ortho(self) -&gt; LinearTransform3D:\n\"\"\"\n        Orthogonalization transformation. Skews but does not scale the crystal axes to cartesian axes.\n        \"\"\"\nreturn self.get_cell()._ortho\n@property\ndef metric(self) -&gt; LinearTransform3D:\nr\"\"\"\n        Cell metric tensor\n        Returns the dot product between every combination of basis vectors.\n        :math:`\\mathbf{a} \\cdot \\mathbf{b} = a_i M_ij b_j`\n        \"\"\"\northo = self.get_cell()._ortho.scale(self.cell_size)\nreturn ortho.T @ ortho\n@property\ndef cell_size(self) -&gt; NDArray[numpy.float_]:\n\"\"\"Unit cell size.\"\"\"\nreturn self.get_cell()._cell_size\n@property\ndef cell_angle(self) -&gt; NDArray[numpy.float_]:\n\"\"\"Unit cell angles, in radians.\"\"\"\nreturn self.get_cell()._cell_angle\n@property\ndef n_cells(self) -&gt; NDArray[numpy.int_]:\n\"\"\"Number of unit cells.\"\"\"\nreturn self.get_cell()._n_cells\n@property\ndef pbc(self) -&gt; NDArray[numpy.bool_]:\n\"\"\"Flags indicating the presence of periodic boundary conditions along each axis.\"\"\"\nreturn self.get_cell()._pbc\n@property\ndef ortho_size(self) -&gt; NDArray[numpy.float_]:\n\"\"\"\n        Return size of orthogonal unit cell.\n        Equivalent to the diagonal of the orthogonalization matrix.\n        \"\"\"\nreturn self.cell_size * numpy.diag(self.ortho.inner)\n@property\ndef box_size(self) -&gt; NDArray[numpy.float_]:\n\"\"\"\n        Return size of the cell box.\n        Equivalent to ``self.n_cells * self.cell_size``.\n        \"\"\"\nreturn self.n_cells * self.cell_size\n# get transforms\ndef _get_transform_to_local(self, frame: CoordinateFrame) -&gt; AffineTransform3D:\n\"\"\"Get the transform from 'frame' to local coordinates.\"\"\"\nframe = t.cast(CoordinateFrame, frame.lower())\nif frame == 'local' or frame == 'global':\nreturn LinearTransform3D()\nif frame == 'linear':\nreturn self.affine.to_translation()\nif frame.startswith('cell'):\ntransform = self.affine @ self.ortho\ncell_size = self.cell_size\nelif frame.startswith('ortho'):\ntransform = self.affine\ncell_size = self.ortho_size\nelse:\nraise ValueError(f\"Unknown coordinate frame '{frame}'\")\nif '_' not in frame:\nreturn transform\nend = frame.split('_', 2)[1]\nif end == 'frac':\nreturn transform @ LinearTransform3D.scale(cell_size)\nif end == 'box':\nreturn transform @ LinearTransform3D.scale(cell_size * self.n_cells)\nraise ValueError(f\"Unknown coordinate frame '{frame}'\")\ndef get_transform(self, frame_to: t.Optional[CoordinateFrame] = None, frame_from: t.Optional[CoordinateFrame] = None) -&gt; AffineTransform3D:\n\"\"\"\n        In the two-argument form, get the transform to 'frame_to' from 'frame_from'.\n        In the one-argument form, get the transform from local coordinates to 'frame'.\n        \"\"\"\ntransform_from = self._get_transform_to_local(frame_from) if frame_from is not None else AffineTransform3D()\ntransform_to = self._get_transform_to_local(frame_to) if frame_to is not None else AffineTransform3D()\nif frame_from is not None and frame_to is not None and frame_from.lower() == frame_to.lower():\nreturn AffineTransform3D()\nreturn transform_to.inverse() @ transform_from\ndef corners(self, frame: CoordinateFrame = 'local') -&gt; numpy.ndarray:\ncorners = numpy.array(list(itertools.product((0., 1.), repeat=3)))\nreturn self.get_transform(frame, 'cell_box') @ corners\ndef bbox_cell(self, frame: CoordinateFrame = 'local') -&gt; BBox3D:\n\"\"\"Return the bounding box of the cell box in the given coordinate system.\"\"\"\nreturn BBox3D.from_pts(self.corners(frame))\nbbox = bbox_cell\ndef is_orthogonal(self, tol: float = 1e-8) -&gt; bool:\n\"\"\"Returns whether this cell is orthogonal (axes are at right angles.)\"\"\"\nreturn self.ortho.is_diagonal(tol=tol)\ndef is_orthogonal_in_local(self, tol: float = 1e-8) -&gt; bool:\n\"\"\"Returns whether this cell is orthogonal and aligned with the local coordinate system.\"\"\"\ntransform = (self.affine @ self.ortho).to_linear()\nif not transform.is_scaled_orthogonal(tol):\nreturn False\nnormed = transform.inner / numpy.linalg.norm(transform.inner, axis=-2, keepdims=True)\n# every row of transform must be a +/- 1 times a basis vector (i, j, or k)\nreturn all(\nany(numpy.isclose(numpy.abs(numpy.dot(row, v)), 1., atol=tol) for v in numpy.eye(3))\nfor row in normed\n)\ndef _cell_size_in_local(self) -&gt; Vec3:\n\"\"\"Calculate cell_size in the local coordinate system. Assumes ``self.is_orthogonal_in_local()``.\"\"\"\nreturn numpy.abs(self.get_transform('local', 'ortho').transform_vec(self.cell_size))\ndef _box_size_in_local(self) -&gt; Vec3:\n\"\"\"Calculate box_size in the local coordinate system. Assumes ``self.is_orthogonal_in_local()``.\"\"\"\nreturn numpy.abs(self.get_transform('local', 'ortho').transform_vec(self.box_size))\ndef _n_cells_in_local(self) -&gt; NDArray[numpy.int_]:\n\"\"\"Calculate n_cells after any local rotation. Assumes ``self.is_orthogonal_in_local()``.\"\"\"\nreturn numpy.abs(numpy.round(self.get_transform('local', 'ortho').transform_vec(self.n_cells)).astype(int))\ndef to_ortho(self) -&gt; AffineTransform3D:\nreturn self.get_transform('local', 'cell_box')\ndef transform_cell(self: HasCellT, transform: AffineTransform3D, frame: CoordinateFrame = 'local') -&gt; HasCellT:\n\"\"\"\n        Apply the given transform to the unit cell, and return a new `Cell`.\n        The transform is applied in coordinate frame 'frame'.\n        Orthogonal and affine transformations are applied to the affine matrix component,\n        while skew and scaling is applied to the orthogonalization matrix/cell_size.\n        \"\"\"\ntransform = t.cast(AffineTransform3D, self.change_transform(transform, 'local', frame))\nif not transform.to_linear().is_orthogonal():\nraise NotImplementedError()\nreturn self.with_cell(Cell(\naffine=transform @ self.affine,\northo=self.ortho,\ncell_size=self.cell_size,\ncell_angle=self.cell_angle,\nn_cells=self.n_cells,\npbc=self.pbc,\n))\ndef strain_orthogonal(self: HasCellT) -&gt; HasCellT:\n\"\"\"\n        Orthogonalize using strain.\n        Strain is applied such that the x-axis remains fixed, and the y-axis remains in the xy plane.\n        For small displacements, no hydrostatic strain is applied (volume is conserved).\n        \"\"\"\nreturn self.with_cell(Cell(\naffine=self.affine,\northo=LinearTransform3D(),\ncell_size=self.cell_size,\nn_cells=self.n_cells,\npbc=self.pbc,\n))\ndef repeat(self: HasCellT, n: t.Union[int, VecLike]) -&gt; HasCellT:\n\"\"\"Tile the cell by `n` in each dimension.\"\"\"\nns = numpy.broadcast_to(n, 3)\nif not numpy.issubdtype(ns.dtype, numpy.integer):\nraise ValueError(f\"repeat() argument must be an integer or integer array.\")\nreturn self.with_cell(Cell(\naffine=self.affine,\northo=self.ortho,\ncell_size=self.cell_size,\ncell_angle=self.cell_angle,\nn_cells=self.n_cells * numpy.broadcast_to(n, 3),\npbc = self.pbc | (ns &gt; 1)  # assume periodic along repeated directions\n))\ndef explode(self: HasCellT) -&gt; HasCellT:\n\"\"\"Materialize repeated cells as one supercell.\"\"\"\nreturn self.with_cell(Cell(\naffine=self.affine,\northo=self.ortho,\ncell_size=self.cell_size*self.n_cells,\ncell_angle=self.cell_angle,\npbc=self.pbc,\n))\ndef explode_z(self: HasCellT) -&gt; HasCellT:\n\"\"\"Materialize repeated cells as one supercell in z.\"\"\"\nreturn self.with_cell(Cell(\naffine=self.affine,\northo=self.ortho,\ncell_size=self.cell_size*[1, 1, self.n_cells[2]],\nn_cells=[*self.n_cells[:2], 1],\ncell_angle=self.cell_angle,\npbc=self.pbc,\n))\ndef crop(self: HasCellT, x_min: float = -numpy.inf, x_max: float = numpy.inf,\ny_min: float = -numpy.inf, y_max: float = numpy.inf,\nz_min: float = -numpy.inf, z_max: float = numpy.inf, *,\nframe: CoordinateFrame = 'local') -&gt; HasCellT:\n\"\"\"\n        Crop 'cell' to the given extents. For a non-orthogonal\n        cell, this must be specified in cell coordinates. This\n        function implicity `explode`s the cell as well.\n        \"\"\"\nif not frame.lower().startswith('cell'):\nif not self.is_orthogonal():\nraise ValueError(\"Cannot crop a non-orthogonal cell in orthogonal coordinates. Use crop_atoms instead.\")\nmin = to_vec3([x_min, y_min, z_min])\nmax = to_vec3([x_max, y_max, z_max])\n(min, max) = self.get_transform('cell_box', frame).transform([min, max])\nnew_box = BBox3D(min, max) &amp; BBox3D.unit()\ncropped = (new_box.min &gt; 0.) | (new_box.max &lt; 1.)\nreturn self.with_cell(Cell(\naffine=self.affine @ AffineTransform3D.translate(-new_box.min),\northo=self.ortho,\ncell_size=new_box.size * self.cell_size * numpy.where(cropped, self.n_cells, 1),\nn_cells=numpy.where(cropped, 1, self.n_cells),\ncell_angle=self.cell_angle,\npbc=self.pbc &amp; ~cropped  # remove periodicity along cropped directions\n))\n@t.overload\ndef change_transform(self, transform: AffineTransform3D,\nframe_to: t.Optional[CoordinateFrame] = None,\nframe_from: t.Optional[CoordinateFrame] = None) -&gt; AffineTransform3D:\n...\n@t.overload\ndef change_transform(self, transform: Transform3D,\nframe_to: t.Optional[CoordinateFrame] = None,\nframe_from: t.Optional[CoordinateFrame] = None) -&gt; Transform3D:\n...\ndef change_transform(self, transform: Transform3D,\nframe_to: t.Optional[CoordinateFrame] = None,\nframe_from: t.Optional[CoordinateFrame] = None) -&gt; Transform3D:\n\"\"\"Coordinate-change a transformation to 'frame_to' from 'frame_from'.\"\"\"\nif frame_to == frame_from and frame_to is not None:\nreturn transform\ncoord_change = self.get_transform(frame_to, frame_from)\nreturn coord_change @ transform @ coord_change.inverse()\ndef assert_equal(self, other: t.Any):\nassert isinstance(other, HasCell) and type(self) == type(other)\nnumpy.testing.assert_array_almost_equal(self.affine.inner, other.affine.inner, 6)\nnumpy.testing.assert_array_almost_equal(self.ortho.inner, other.ortho.inner, 6)\nnumpy.testing.assert_array_almost_equal(self.cell_size, other.cell_size, 6)\nnumpy.testing.assert_array_equal(self.n_cells, other.n_cells)\nnumpy.testing.assert_array_equal(self.pbc, other.pbc)\n</code></pre>"},{"location":"api/#atomlib.HasCell.affine","title":"<code>affine: AffineTransform3D</code>  <code>property</code>","text":"<p>Affine transformation. Holds transformation from 'ortho' to 'local' coordinates, including rotation away from the standard crystal orientation.</p>"},{"location":"api/#atomlib.HasCell.ortho","title":"<code>ortho: LinearTransform3D</code>  <code>property</code>","text":"<p>Orthogonalization transformation. Skews but does not scale the crystal axes to cartesian axes.</p>"},{"location":"api/#atomlib.HasCell.metric","title":"<code>metric: LinearTransform3D</code>  <code>property</code>","text":"<p>Cell metric tensor</p> <p>Returns the dot product between every combination of basis vectors. :math:<code>\\mathbf{a} \\cdot \\mathbf{b} = a_i M_ij b_j</code></p>"},{"location":"api/#atomlib.HasCell.cell_size","title":"<code>cell_size: NDArray[numpy.float_]</code>  <code>property</code>","text":"<p>Unit cell size.</p>"},{"location":"api/#atomlib.HasCell.cell_angle","title":"<code>cell_angle: NDArray[numpy.float_]</code>  <code>property</code>","text":"<p>Unit cell angles, in radians.</p>"},{"location":"api/#atomlib.HasCell.n_cells","title":"<code>n_cells: NDArray[numpy.int_]</code>  <code>property</code>","text":"<p>Number of unit cells.</p>"},{"location":"api/#atomlib.HasCell.pbc","title":"<code>pbc: NDArray[numpy.bool_]</code>  <code>property</code>","text":"<p>Flags indicating the presence of periodic boundary conditions along each axis.</p>"},{"location":"api/#atomlib.HasCell.ortho_size","title":"<code>ortho_size: NDArray[numpy.float_]</code>  <code>property</code>","text":"<p>Return size of orthogonal unit cell.</p> <p>Equivalent to the diagonal of the orthogonalization matrix.</p>"},{"location":"api/#atomlib.HasCell.box_size","title":"<code>box_size: NDArray[numpy.float_]</code>  <code>property</code>","text":"<p>Return size of the cell box.</p> <p>Equivalent to <code>self.n_cells * self.cell_size</code>.</p>"},{"location":"api/#atomlib.HasCell.bbox","title":"<code>bbox = bbox_cell</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#atomlib.HasCell.get_cell","title":"<code>get_cell()</code>  <code>abstractmethod</code>","text":"<p>Get the cell contained in <code>self</code>. This should be a low cost method.</p> Source code in <code>atomlib/cell.py</code> <pre><code>@abc.abstractmethod\ndef get_cell(self) -&gt; Cell:\n\"\"\"Get the cell contained in ``self``. This should be a low cost method.\"\"\"\n...\n</code></pre>"},{"location":"api/#atomlib.HasCell.with_cell","title":"<code>with_cell(cell)</code>  <code>abstractmethod</code>","text":"<p>Replace the cell in <code>self</code> with <code>cell</code>.</p> Source code in <code>atomlib/cell.py</code> <pre><code>@abc.abstractmethod\ndef with_cell(self: HasCellT, cell: Cell) -&gt; HasCellT:\n\"\"\"Replace the cell in ``self`` with ``cell``.\"\"\"\n...\n</code></pre>"},{"location":"api/#atomlib.HasCell.get_transform","title":"<code>get_transform(frame_to=None, frame_from=None)</code>","text":"<p>In the two-argument form, get the transform to 'frame_to' from 'frame_from'. In the one-argument form, get the transform from local coordinates to 'frame'.</p> Source code in <code>atomlib/cell.py</code> <pre><code>def get_transform(self, frame_to: t.Optional[CoordinateFrame] = None, frame_from: t.Optional[CoordinateFrame] = None) -&gt; AffineTransform3D:\n\"\"\"\n    In the two-argument form, get the transform to 'frame_to' from 'frame_from'.\n    In the one-argument form, get the transform from local coordinates to 'frame'.\n    \"\"\"\ntransform_from = self._get_transform_to_local(frame_from) if frame_from is not None else AffineTransform3D()\ntransform_to = self._get_transform_to_local(frame_to) if frame_to is not None else AffineTransform3D()\nif frame_from is not None and frame_to is not None and frame_from.lower() == frame_to.lower():\nreturn AffineTransform3D()\nreturn transform_to.inverse() @ transform_from\n</code></pre>"},{"location":"api/#atomlib.HasCell.corners","title":"<code>corners(frame='local')</code>","text":"Source code in <code>atomlib/cell.py</code> <pre><code>def corners(self, frame: CoordinateFrame = 'local') -&gt; numpy.ndarray:\ncorners = numpy.array(list(itertools.product((0., 1.), repeat=3)))\nreturn self.get_transform(frame, 'cell_box') @ corners\n</code></pre>"},{"location":"api/#atomlib.HasCell.bbox_cell","title":"<code>bbox_cell(frame='local')</code>","text":"<p>Return the bounding box of the cell box in the given coordinate system.</p> Source code in <code>atomlib/cell.py</code> <pre><code>def bbox_cell(self, frame: CoordinateFrame = 'local') -&gt; BBox3D:\n\"\"\"Return the bounding box of the cell box in the given coordinate system.\"\"\"\nreturn BBox3D.from_pts(self.corners(frame))\n</code></pre>"},{"location":"api/#atomlib.HasCell.is_orthogonal","title":"<code>is_orthogonal(tol=1e-08)</code>","text":"<p>Returns whether this cell is orthogonal (axes are at right angles.)</p> Source code in <code>atomlib/cell.py</code> <pre><code>def is_orthogonal(self, tol: float = 1e-8) -&gt; bool:\n\"\"\"Returns whether this cell is orthogonal (axes are at right angles.)\"\"\"\nreturn self.ortho.is_diagonal(tol=tol)\n</code></pre>"},{"location":"api/#atomlib.HasCell.is_orthogonal_in_local","title":"<code>is_orthogonal_in_local(tol=1e-08)</code>","text":"<p>Returns whether this cell is orthogonal and aligned with the local coordinate system.</p> Source code in <code>atomlib/cell.py</code> <pre><code>def is_orthogonal_in_local(self, tol: float = 1e-8) -&gt; bool:\n\"\"\"Returns whether this cell is orthogonal and aligned with the local coordinate system.\"\"\"\ntransform = (self.affine @ self.ortho).to_linear()\nif not transform.is_scaled_orthogonal(tol):\nreturn False\nnormed = transform.inner / numpy.linalg.norm(transform.inner, axis=-2, keepdims=True)\n# every row of transform must be a +/- 1 times a basis vector (i, j, or k)\nreturn all(\nany(numpy.isclose(numpy.abs(numpy.dot(row, v)), 1., atol=tol) for v in numpy.eye(3))\nfor row in normed\n)\n</code></pre>"},{"location":"api/#atomlib.HasCell.to_ortho","title":"<code>to_ortho()</code>","text":"Source code in <code>atomlib/cell.py</code> <pre><code>def to_ortho(self) -&gt; AffineTransform3D:\nreturn self.get_transform('local', 'cell_box')\n</code></pre>"},{"location":"api/#atomlib.HasCell.transform_cell","title":"<code>transform_cell(transform, frame='local')</code>","text":"<p>Apply the given transform to the unit cell, and return a new <code>Cell</code>. The transform is applied in coordinate frame 'frame'. Orthogonal and affine transformations are applied to the affine matrix component, while skew and scaling is applied to the orthogonalization matrix/cell_size.</p> Source code in <code>atomlib/cell.py</code> <pre><code>def transform_cell(self: HasCellT, transform: AffineTransform3D, frame: CoordinateFrame = 'local') -&gt; HasCellT:\n\"\"\"\n    Apply the given transform to the unit cell, and return a new `Cell`.\n    The transform is applied in coordinate frame 'frame'.\n    Orthogonal and affine transformations are applied to the affine matrix component,\n    while skew and scaling is applied to the orthogonalization matrix/cell_size.\n    \"\"\"\ntransform = t.cast(AffineTransform3D, self.change_transform(transform, 'local', frame))\nif not transform.to_linear().is_orthogonal():\nraise NotImplementedError()\nreturn self.with_cell(Cell(\naffine=transform @ self.affine,\northo=self.ortho,\ncell_size=self.cell_size,\ncell_angle=self.cell_angle,\nn_cells=self.n_cells,\npbc=self.pbc,\n))\n</code></pre>"},{"location":"api/#atomlib.HasCell.strain_orthogonal","title":"<code>strain_orthogonal()</code>","text":"<p>Orthogonalize using strain.</p> <p>Strain is applied such that the x-axis remains fixed, and the y-axis remains in the xy plane. For small displacements, no hydrostatic strain is applied (volume is conserved).</p> Source code in <code>atomlib/cell.py</code> <pre><code>def strain_orthogonal(self: HasCellT) -&gt; HasCellT:\n\"\"\"\n    Orthogonalize using strain.\n    Strain is applied such that the x-axis remains fixed, and the y-axis remains in the xy plane.\n    For small displacements, no hydrostatic strain is applied (volume is conserved).\n    \"\"\"\nreturn self.with_cell(Cell(\naffine=self.affine,\northo=LinearTransform3D(),\ncell_size=self.cell_size,\nn_cells=self.n_cells,\npbc=self.pbc,\n))\n</code></pre>"},{"location":"api/#atomlib.HasCell.repeat","title":"<code>repeat(n)</code>","text":"<p>Tile the cell by <code>n</code> in each dimension.</p> Source code in <code>atomlib/cell.py</code> <pre><code>def repeat(self: HasCellT, n: t.Union[int, VecLike]) -&gt; HasCellT:\n\"\"\"Tile the cell by `n` in each dimension.\"\"\"\nns = numpy.broadcast_to(n, 3)\nif not numpy.issubdtype(ns.dtype, numpy.integer):\nraise ValueError(f\"repeat() argument must be an integer or integer array.\")\nreturn self.with_cell(Cell(\naffine=self.affine,\northo=self.ortho,\ncell_size=self.cell_size,\ncell_angle=self.cell_angle,\nn_cells=self.n_cells * numpy.broadcast_to(n, 3),\npbc = self.pbc | (ns &gt; 1)  # assume periodic along repeated directions\n))\n</code></pre>"},{"location":"api/#atomlib.HasCell.explode","title":"<code>explode()</code>","text":"<p>Materialize repeated cells as one supercell.</p> Source code in <code>atomlib/cell.py</code> <pre><code>def explode(self: HasCellT) -&gt; HasCellT:\n\"\"\"Materialize repeated cells as one supercell.\"\"\"\nreturn self.with_cell(Cell(\naffine=self.affine,\northo=self.ortho,\ncell_size=self.cell_size*self.n_cells,\ncell_angle=self.cell_angle,\npbc=self.pbc,\n))\n</code></pre>"},{"location":"api/#atomlib.HasCell.explode_z","title":"<code>explode_z()</code>","text":"<p>Materialize repeated cells as one supercell in z.</p> Source code in <code>atomlib/cell.py</code> <pre><code>def explode_z(self: HasCellT) -&gt; HasCellT:\n\"\"\"Materialize repeated cells as one supercell in z.\"\"\"\nreturn self.with_cell(Cell(\naffine=self.affine,\northo=self.ortho,\ncell_size=self.cell_size*[1, 1, self.n_cells[2]],\nn_cells=[*self.n_cells[:2], 1],\ncell_angle=self.cell_angle,\npbc=self.pbc,\n))\n</code></pre>"},{"location":"api/#atomlib.HasCell.crop","title":"<code>crop(x_min=-numpy.inf, x_max=numpy.inf, y_min=-numpy.inf, y_max=numpy.inf, z_min=-numpy.inf, z_max=numpy.inf, *, frame='local')</code>","text":"<p>Crop 'cell' to the given extents. For a non-orthogonal cell, this must be specified in cell coordinates. This function implicity <code>explode</code>s the cell as well.</p> Source code in <code>atomlib/cell.py</code> <pre><code>def crop(self: HasCellT, x_min: float = -numpy.inf, x_max: float = numpy.inf,\ny_min: float = -numpy.inf, y_max: float = numpy.inf,\nz_min: float = -numpy.inf, z_max: float = numpy.inf, *,\nframe: CoordinateFrame = 'local') -&gt; HasCellT:\n\"\"\"\n    Crop 'cell' to the given extents. For a non-orthogonal\n    cell, this must be specified in cell coordinates. This\n    function implicity `explode`s the cell as well.\n    \"\"\"\nif not frame.lower().startswith('cell'):\nif not self.is_orthogonal():\nraise ValueError(\"Cannot crop a non-orthogonal cell in orthogonal coordinates. Use crop_atoms instead.\")\nmin = to_vec3([x_min, y_min, z_min])\nmax = to_vec3([x_max, y_max, z_max])\n(min, max) = self.get_transform('cell_box', frame).transform([min, max])\nnew_box = BBox3D(min, max) &amp; BBox3D.unit()\ncropped = (new_box.min &gt; 0.) | (new_box.max &lt; 1.)\nreturn self.with_cell(Cell(\naffine=self.affine @ AffineTransform3D.translate(-new_box.min),\northo=self.ortho,\ncell_size=new_box.size * self.cell_size * numpy.where(cropped, self.n_cells, 1),\nn_cells=numpy.where(cropped, 1, self.n_cells),\ncell_angle=self.cell_angle,\npbc=self.pbc &amp; ~cropped  # remove periodicity along cropped directions\n))\n</code></pre>"},{"location":"api/#atomlib.HasCell.change_transform","title":"<code>change_transform(transform, frame_to=None, frame_from=None)</code>","text":"<p>Coordinate-change a transformation to 'frame_to' from 'frame_from'.</p> Source code in <code>atomlib/cell.py</code> <pre><code>def change_transform(self, transform: Transform3D,\nframe_to: t.Optional[CoordinateFrame] = None,\nframe_from: t.Optional[CoordinateFrame] = None) -&gt; Transform3D:\n\"\"\"Coordinate-change a transformation to 'frame_to' from 'frame_from'.\"\"\"\nif frame_to == frame_from and frame_to is not None:\nreturn transform\ncoord_change = self.get_transform(frame_to, frame_from)\nreturn coord_change @ transform @ coord_change.inverse()\n</code></pre>"},{"location":"api/#atomlib.HasCell.assert_equal","title":"<code>assert_equal(other)</code>","text":"Source code in <code>atomlib/cell.py</code> <pre><code>def assert_equal(self, other: t.Any):\nassert isinstance(other, HasCell) and type(self) == type(other)\nnumpy.testing.assert_array_almost_equal(self.affine.inner, other.affine.inner, 6)\nnumpy.testing.assert_array_almost_equal(self.ortho.inner, other.ortho.inner, 6)\nnumpy.testing.assert_array_almost_equal(self.cell_size, other.cell_size, 6)\nnumpy.testing.assert_array_equal(self.n_cells, other.n_cells)\nnumpy.testing.assert_array_equal(self.pbc, other.pbc)\n</code></pre>"},{"location":"api/#atomlib.AtomCell","title":"<code>AtomCell</code>  <code>dataclass</code>","text":"<p>             Bases: <code>AtomCellIOMixin</code>, <code>HasAtomCell</code></p> <p>Cell of atoms with known size and periodic boundary conditions.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@dataclass(init=False, repr=False, frozen=True)\nclass AtomCell(AtomCellIOMixin, HasAtomCell):\n\"\"\"\n    Cell of atoms with known size and periodic boundary conditions.\n    \"\"\"\natoms: Atoms\n\"\"\"Atoms in the cell. Stored in 'local' coordinates (i.e. relative to the enclosing group but not relative to box dimensions).\"\"\"\ncell: Cell\n\"\"\"Cell coordinate system.\"\"\"\nframe: CoordinateFrame = 'local'\n\"\"\"Coordinate frame 'atoms' are stored in.\"\"\"\ndef get_cell(self) -&gt; Cell:\nreturn self.cell\ndef with_cell(self: AtomCellT, cell: Cell) -&gt; AtomCellT:\nreturn self.__class__(self.atoms, cell, frame=self.frame, keep_frame=True)\ndef get_atoms(self, frame: t.Optional[CoordinateFrame] = None) -&gt; Atoms:\n\"\"\"Get atoms contained in ``self``, in the given coordinate frame.\"\"\"\nif frame is None or frame == self.get_frame():\nreturn self.atoms\nreturn self.atoms.transform(self.get_transform(frame, self.get_frame()))\ndef with_atoms(self: AtomCellT, atoms: HasAtoms, frame: t.Optional[CoordinateFrame] = None) -&gt; AtomCellT:\nframe = frame if frame is not None else self.frame\nreturn self.__class__(atoms.get_atoms(), cell=self.cell, frame=frame, keep_frame=True)\n#return replace(self, atoms=atoms, frame = frame if frame is not None else self.frame, keep_frame=True)\ndef get_frame(self) -&gt; CoordinateFrame:\n\"\"\"Get the coordinate frame atoms are stored in.\"\"\"\nreturn self.frame\n@classmethod\ndef _combine_metadata(cls: t.Type[AtomCellT], *atoms: HasAtoms, n: t.Optional[int] = None) -&gt; AtomCellT:\n\"\"\"\n        When combining multiple :py:`HasAtoms`, check that they are compatible with each other,\n        and return a 'representative' which best represents the combined metadata.\n        Implementors should treat :py:`Atoms` as acceptable, but having no metadata.\n        \"\"\"\nif n is not None:\nrep = atoms[n]\nif not isinstance(rep, AtomCell):\nraise ValueError(f\"Atoms #{n} has no cell\")\nelse:\natom_cells = [a for a in atoms if isinstance(a, AtomCell)]\nif len(atom_cells) == 0:\nraise TypeError(f\"No AtomCells to combine\")\nrep = atom_cells[0]\nif not all(a.cell == rep.cell for a in atom_cells[1:]):\nraise TypeError(f\"Can't combine AtomCells with different cells\")\nreturn cls(Atoms.empty(), frame=rep.frame, cell=rep.cell)\n@classmethod\ndef from_ortho(cls, atoms: IntoAtoms, ortho: LinearTransform3D, *,\nn_cells: t.Optional[VecLike] = None,\nframe: CoordinateFrame = 'local',\nkeep_frame: bool = False):\n\"\"\"\n        Make an atom cell given a list of atoms and an orthogonalization matrix.\n        Atoms are assumed to be in the coordinate system ``frame``.\n        \"\"\"\ncell = Cell.from_ortho(ortho, n_cells)\nreturn cls(atoms, cell, frame=frame, keep_frame=keep_frame)\n@classmethod\ndef from_unit_cell(cls, atoms: IntoAtoms, cell_size: VecLike,\ncell_angle: t.Optional[VecLike] = None, *,\nn_cells: t.Optional[VecLike] = None,\nframe: CoordinateFrame = 'local',\nkeep_frame: bool = False):\n\"\"\"\n        Make a cell given a list of atoms and unit cell parameters.\n        Atoms are assumed to be in the coordinate system ``frame``.\n        \"\"\"\ncell = Cell.from_unit_cell(cell_size, cell_angle, n_cells=n_cells)\nreturn cls(atoms, cell, frame=frame, keep_frame=keep_frame)\ndef __init__(self, atoms: IntoAtoms, cell: Cell, *,\nframe: CoordinateFrame = 'local',\nkeep_frame: bool = False):\natoms = Atoms(atoms)\n# by default, store in local coordinates\nif not keep_frame and frame != 'local':\natoms = atoms.transform(cell.get_transform('local', frame))\nframe = 'local'\nobject.__setattr__(self, 'atoms', atoms)\nobject.__setattr__(self, 'cell', cell)\nobject.__setattr__(self, 'frame', frame)\nself.__post_init__()\ndef __post_init__(self):\npass\ndef orthogonalize(self) -&gt; OrthoCell:\nif self.is_orthogonal():\nreturn OrthoCell(self.atoms, self.cell, frame=self.frame)\nraise NotImplementedError()\ndef clone(self: AtomCellT) -&gt; AtomCellT:\n\"\"\"Make a deep copy of ``self``.\"\"\"\nreturn self.__class__(**{field.name: copy.deepcopy(getattr(self, field.name)) for field in fields(self)})\ndef assert_equal(self, other: t.Any):\n\"\"\"Assert this structure is equal to \"\"\"\nassert isinstance(other, AtomCell)\nself.cell.assert_equal(other.cell)\nself.get_atoms('local').assert_equal(other.get_atoms('local'))\ndef _str_parts(self) -&gt; t.Iterable[t.Any]:\nreturn (\nf\"Cell size:  {self.cell.cell_size!s}\",\nf\"Cell angle: {self.cell.cell_angle!s}\",\nf\"# Cells: {self.cell.n_cells!s}\",\nf\"Frame: {self.frame}\",\nself.atoms,\n)\ndef __str__(self) -&gt; str:\nreturn \"\\n\".join(map(str, self._str_parts()))\ndef __repr__(self) -&gt; str:\nreturn f\"{self.__class__.__name__}({self.atoms!r}, cell={self.cell!r}, frame={self.frame})\"\ndef _repr_pretty_(self, p, cycle: bool) -&gt; None:\np.text(f'{self.__class__.__name__}(...)') if cycle else p.text(str(self))\n</code></pre>"},{"location":"api/#atomlib.AtomCell.affine","title":"<code>affine: AffineTransform3D</code>  <code>property</code>","text":"<p>Affine transformation. Holds transformation from 'ortho' to 'local' coordinates, including rotation away from the standard crystal orientation.</p>"},{"location":"api/#atomlib.AtomCell.ortho","title":"<code>ortho: LinearTransform3D</code>  <code>property</code>","text":"<p>Orthogonalization transformation. Skews but does not scale the crystal axes to cartesian axes.</p>"},{"location":"api/#atomlib.AtomCell.metric","title":"<code>metric: LinearTransform3D</code>  <code>property</code>","text":"<p>Cell metric tensor</p> <p>Returns the dot product between every combination of basis vectors. :math:<code>\\mathbf{a} \\cdot \\mathbf{b} = a_i M_ij b_j</code></p>"},{"location":"api/#atomlib.AtomCell.cell_size","title":"<code>cell_size: NDArray[numpy.float_]</code>  <code>property</code>","text":"<p>Unit cell size.</p>"},{"location":"api/#atomlib.AtomCell.cell_angle","title":"<code>cell_angle: NDArray[numpy.float_]</code>  <code>property</code>","text":"<p>Unit cell angles, in radians.</p>"},{"location":"api/#atomlib.AtomCell.n_cells","title":"<code>n_cells: NDArray[numpy.int_]</code>  <code>property</code>","text":"<p>Number of unit cells.</p>"},{"location":"api/#atomlib.AtomCell.pbc","title":"<code>pbc: NDArray[numpy.bool_]</code>  <code>property</code>","text":"<p>Flags indicating the presence of periodic boundary conditions along each axis.</p>"},{"location":"api/#atomlib.AtomCell.ortho_size","title":"<code>ortho_size: NDArray[numpy.float_]</code>  <code>property</code>","text":"<p>Return size of orthogonal unit cell.</p> <p>Equivalent to the diagonal of the orthogonalization matrix.</p>"},{"location":"api/#atomlib.AtomCell.box_size","title":"<code>box_size: NDArray[numpy.float_]</code>  <code>property</code>","text":"<p>Return size of the cell box.</p> <p>Equivalent to <code>self.n_cells * self.cell_size</code>.</p>"},{"location":"api/#atomlib.AtomCell.columns","title":"<code>columns: t.Sequence[str]</code>  <code>property</code>","text":"<p>Return the columns in <code>self</code>.</p>"},{"location":"api/#atomlib.AtomCell.schema","title":"<code>schema: SchemaDict</code>  <code>property</code>","text":"<p>Return the schema of <code>self</code>.</p>"},{"location":"api/#atomlib.AtomCell.unique","title":"<code>unique = deduplicate</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#atomlib.AtomCell.atoms","title":"<code>atoms: Atoms</code>  <code>instance-attribute</code>","text":"<p>Atoms in the cell. Stored in 'local' coordinates (i.e. relative to the enclosing group but not relative to box dimensions).</p>"},{"location":"api/#atomlib.AtomCell.cell","title":"<code>cell: Cell</code>  <code>instance-attribute</code>","text":"<p>Cell coordinate system.</p>"},{"location":"api/#atomlib.AtomCell.frame","title":"<code>frame: CoordinateFrame = 'local'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Coordinate frame 'atoms' are stored in.</p>"},{"location":"api/#atomlib.AtomCell.get_transform","title":"<code>get_transform(frame_to=None, frame_from=None)</code>","text":"<p>In the two-argument form, get the transform to 'frame_to' from 'frame_from'. In the one-argument form, get the transform from local coordinates to 'frame'.</p> Source code in <code>atomlib/cell.py</code> <pre><code>def get_transform(self, frame_to: t.Optional[CoordinateFrame] = None, frame_from: t.Optional[CoordinateFrame] = None) -&gt; AffineTransform3D:\n\"\"\"\n    In the two-argument form, get the transform to 'frame_to' from 'frame_from'.\n    In the one-argument form, get the transform from local coordinates to 'frame'.\n    \"\"\"\ntransform_from = self._get_transform_to_local(frame_from) if frame_from is not None else AffineTransform3D()\ntransform_to = self._get_transform_to_local(frame_to) if frame_to is not None else AffineTransform3D()\nif frame_from is not None and frame_to is not None and frame_from.lower() == frame_to.lower():\nreturn AffineTransform3D()\nreturn transform_to.inverse() @ transform_from\n</code></pre>"},{"location":"api/#atomlib.AtomCell.corners","title":"<code>corners(frame='local')</code>","text":"Source code in <code>atomlib/cell.py</code> <pre><code>def corners(self, frame: CoordinateFrame = 'local') -&gt; numpy.ndarray:\ncorners = numpy.array(list(itertools.product((0., 1.), repeat=3)))\nreturn self.get_transform(frame, 'cell_box') @ corners\n</code></pre>"},{"location":"api/#atomlib.AtomCell.bbox_cell","title":"<code>bbox_cell(frame='local')</code>","text":"<p>Return the bounding box of the cell box in the given coordinate system.</p> Source code in <code>atomlib/cell.py</code> <pre><code>def bbox_cell(self, frame: CoordinateFrame = 'local') -&gt; BBox3D:\n\"\"\"Return the bounding box of the cell box in the given coordinate system.\"\"\"\nreturn BBox3D.from_pts(self.corners(frame))\n</code></pre>"},{"location":"api/#atomlib.AtomCell.bbox","title":"<code>bbox(frame='local')</code>","text":"<p>Return the combined bounding box of the cell and atoms in the given coordinate system. To get the cell or atoms bounding box only, use :py:meth:<code>bbox_cell</code> or :py:meth:<code>bbox_atoms</code>.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def bbox(self, frame: CoordinateFrame = 'local') -&gt; BBox3D:\n\"\"\"\n    Return the combined bounding box of the cell and atoms in the given coordinate system.\n    To get the cell or atoms bounding box only, use :py:meth:`bbox_cell` or :py:meth:`bbox_atoms`.\n    \"\"\"\nreturn self.bbox_atoms(frame) | self.bbox_cell(frame)\n</code></pre>"},{"location":"api/#atomlib.AtomCell.is_orthogonal","title":"<code>is_orthogonal(tol=1e-08)</code>","text":"<p>Returns whether this cell is orthogonal (axes are at right angles.)</p> Source code in <code>atomlib/cell.py</code> <pre><code>def is_orthogonal(self, tol: float = 1e-8) -&gt; bool:\n\"\"\"Returns whether this cell is orthogonal (axes are at right angles.)\"\"\"\nreturn self.ortho.is_diagonal(tol=tol)\n</code></pre>"},{"location":"api/#atomlib.AtomCell.is_orthogonal_in_local","title":"<code>is_orthogonal_in_local(tol=1e-08)</code>","text":"<p>Returns whether this cell is orthogonal and aligned with the local coordinate system.</p> Source code in <code>atomlib/cell.py</code> <pre><code>def is_orthogonal_in_local(self, tol: float = 1e-8) -&gt; bool:\n\"\"\"Returns whether this cell is orthogonal and aligned with the local coordinate system.\"\"\"\ntransform = (self.affine @ self.ortho).to_linear()\nif not transform.is_scaled_orthogonal(tol):\nreturn False\nnormed = transform.inner / numpy.linalg.norm(transform.inner, axis=-2, keepdims=True)\n# every row of transform must be a +/- 1 times a basis vector (i, j, or k)\nreturn all(\nany(numpy.isclose(numpy.abs(numpy.dot(row, v)), 1., atol=tol) for v in numpy.eye(3))\nfor row in normed\n)\n</code></pre>"},{"location":"api/#atomlib.AtomCell.to_ortho","title":"<code>to_ortho()</code>","text":"Source code in <code>atomlib/cell.py</code> <pre><code>def to_ortho(self) -&gt; AffineTransform3D:\nreturn self.get_transform('local', 'cell_box')\n</code></pre>"},{"location":"api/#atomlib.AtomCell.transform_cell","title":"<code>transform_cell(transform, frame='local')</code>","text":"<p>Apply the given transform to the unit cell, without changing atom positions. The transform is applied in coordinate frame 'frame'.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def transform_cell(self: HasAtomCellT, transform: AffineTransform3D, frame: CoordinateFrame = 'local') -&gt; HasAtomCellT:\n\"\"\"\n    Apply the given transform to the unit cell, without changing atom positions.\n    The transform is applied in coordinate frame 'frame'.\n    \"\"\"\nreturn self.with_cell(self.get_cell().transform_cell(transform, frame=frame))\n</code></pre>"},{"location":"api/#atomlib.AtomCell.strain_orthogonal","title":"<code>strain_orthogonal()</code>","text":"<p>Orthogonalize using strain.</p> <p>Strain is applied such that the x-axis remains fixed, and the y-axis remains in the xy plane. For small displacements, no hydrostatic strain is applied (volume is conserved).</p> Source code in <code>atomlib/cell.py</code> <pre><code>def strain_orthogonal(self: HasCellT) -&gt; HasCellT:\n\"\"\"\n    Orthogonalize using strain.\n    Strain is applied such that the x-axis remains fixed, and the y-axis remains in the xy plane.\n    For small displacements, no hydrostatic strain is applied (volume is conserved).\n    \"\"\"\nreturn self.with_cell(Cell(\naffine=self.affine,\northo=LinearTransform3D(),\ncell_size=self.cell_size,\nn_cells=self.n_cells,\npbc=self.pbc,\n))\n</code></pre>"},{"location":"api/#atomlib.AtomCell.repeat","title":"<code>repeat(n)</code>","text":"<p>Tile the cell</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def repeat(self: HasAtomCellT, n: t.Union[int, VecLike]) -&gt; HasAtomCellT:\n\"\"\"Tile the cell\"\"\"\nns = numpy.broadcast_to(n, 3)\nif not numpy.issubdtype(ns.dtype, numpy.integer):\nraise ValueError(f\"repeat() argument must be an integer or integer array.\")\ncells = numpy.stack(numpy.meshgrid(*map(numpy.arange, ns))) \\\n        .reshape(3, -1).T.astype(float)\ncells = cells * self.box_size\natoms = self.get_atoms('cell')\natoms = Atoms.concat([\natoms.transform(AffineTransform3D.translate(cell))\nfor cell in cells\n]) #.transform(self.cell.get_transform('local', 'cell_frac'))\nreturn self.with_atoms(atoms, 'cell').with_cell(self.get_cell().repeat(ns))\n</code></pre>"},{"location":"api/#atomlib.AtomCell.explode","title":"<code>explode()</code>","text":"<p>Materialize repeated cells as one supercell.</p> Source code in <code>atomlib/cell.py</code> <pre><code>def explode(self: HasCellT) -&gt; HasCellT:\n\"\"\"Materialize repeated cells as one supercell.\"\"\"\nreturn self.with_cell(Cell(\naffine=self.affine,\northo=self.ortho,\ncell_size=self.cell_size*self.n_cells,\ncell_angle=self.cell_angle,\npbc=self.pbc,\n))\n</code></pre>"},{"location":"api/#atomlib.AtomCell.explode_z","title":"<code>explode_z()</code>","text":"<p>Materialize repeated cells as one supercell in z.</p> Source code in <code>atomlib/cell.py</code> <pre><code>def explode_z(self: HasCellT) -&gt; HasCellT:\n\"\"\"Materialize repeated cells as one supercell in z.\"\"\"\nreturn self.with_cell(Cell(\naffine=self.affine,\northo=self.ortho,\ncell_size=self.cell_size*[1, 1, self.n_cells[2]],\nn_cells=[*self.n_cells[:2], 1],\ncell_angle=self.cell_angle,\npbc=self.pbc,\n))\n</code></pre>"},{"location":"api/#atomlib.AtomCell.crop","title":"<code>crop(x_min=-numpy.inf, x_max=numpy.inf, y_min=-numpy.inf, y_max=numpy.inf, z_min=-numpy.inf, z_max=numpy.inf, *, frame='local')</code>","text":"<p>Crop atoms and cell to the given extents. For a non-orthogonal cell, this must be specified in cell coordinates. This function implicity <code>explode</code>s the cell as well.</p> <p>To crop atoms only, use :py:meth:<code>crop_atoms</code> instead.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def crop(self: HasAtomCellT, x_min: float = -numpy.inf, x_max: float = numpy.inf,\ny_min: float = -numpy.inf, y_max: float = numpy.inf,\nz_min: float = -numpy.inf, z_max: float = numpy.inf, *,\nframe: CoordinateFrame = 'local') -&gt; HasAtomCellT:\n\"\"\"\n    Crop atoms and cell to the given extents. For a non-orthogonal\n    cell, this must be specified in cell coordinates. This\n    function implicity `explode`s the cell as well.\n    To crop atoms only, use :py:meth:`crop_atoms` instead.\n    \"\"\"\ncell = self.get_cell().crop(x_min, x_max, y_min, y_max, z_min, z_max, frame=frame)\natoms = self._transform_atoms_in_frame(frame, lambda atoms: atoms.crop_atoms(x_min, x_max, y_min, y_max, z_min, z_max))\nreturn self.with_cell(cell).with_atoms(atoms)\n</code></pre>"},{"location":"api/#atomlib.AtomCell.change_transform","title":"<code>change_transform(transform, frame_to=None, frame_from=None)</code>","text":"<p>Coordinate-change a transformation to 'frame_to' from 'frame_from'.</p> Source code in <code>atomlib/cell.py</code> <pre><code>def change_transform(self, transform: Transform3D,\nframe_to: t.Optional[CoordinateFrame] = None,\nframe_from: t.Optional[CoordinateFrame] = None) -&gt; Transform3D:\n\"\"\"Coordinate-change a transformation to 'frame_to' from 'frame_from'.\"\"\"\nif frame_to == frame_from and frame_to is not None:\nreturn transform\ncoord_change = self.get_transform(frame_to, frame_from)\nreturn coord_change @ transform @ coord_change.inverse()\n</code></pre>"},{"location":"api/#atomlib.AtomCell.with_column","title":"<code>with_column(column, *, frame=None)</code>","text":"<p>Return a copy of <code>self</code> with the given column added.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef with_column(self: HasAtomCellT, column: t.Union[polars.Series, polars.Expr], *,\nframe: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n\"\"\"Return a copy of ``self`` with the given column added.\"\"\"\n...\n</code></pre>"},{"location":"api/#atomlib.AtomCell.with_columns","title":"<code>with_columns(exprs, *, frame=None, **named_exprs)</code>","text":"<p>Return a copy of <code>self</code> with the given columns added.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def with_columns(self: HasAtomCellT,\nexprs: t.Union[t.Literal[None], polars.Series, polars.Expr, t.Sequence[t.Union[polars.Series, polars.Expr]]], *,\nframe: t.Optional[CoordinateFrame] = None,\n**named_exprs: t.Union[polars.Expr, polars.Series]) -&gt; HasAtomCellT:\n\"\"\"Return a copy of ``self`` with the given columns added.\"\"\"\n...\n</code></pre>"},{"location":"api/#atomlib.AtomCell.get_column","title":"<code>get_column(name)</code>","text":"<p>Get the specified column from <code>self</code>, raising :py:<code>polars.NotFoundError</code> if it's not present.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def get_column(self, name: str) -&gt; polars.Series:\n\"\"\"Get the specified column from ``self``, raising :py:`polars.NotFoundError` if it's not present.\"\"\"\nreturn self._get_frame().get_column(name)\n</code></pre>"},{"location":"api/#atomlib.AtomCell.filter","title":"<code>filter(selection=None, *, frame=None)</code>","text":"<p>Filter <code>self</code>, removing rows which evaluate to <code>False</code>.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef filter(self: HasAtomCellT, selection: t.Optional[AtomSelection] = None, *,\nframe: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n\"\"\"Filter ``self``, removing rows which evaluate to ``False``.\"\"\"\n...\n</code></pre>"},{"location":"api/#atomlib.AtomCell.select","title":"<code>select(exprs, *, frame=None)</code>","text":"<p>Select <code>exprs</code> from <code>self</code>, and return as a :py:class:<code>polars.DataFrame</code>.</p> <p>Expressions may either be columns or expressions of columns.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_get\ndef select(self, exprs: t.Union[str, polars.Expr, polars.Series, t.Sequence[t.Union[str, polars.Expr, polars.Series]]], *,\nframe: t.Optional[CoordinateFrame] = None) -&gt; polars.DataFrame:\n\"\"\"\n    Select ``exprs`` from ``self``, and return as a :py:class:`polars.DataFrame`.\n    Expressions may either be columns or expressions of columns.\n    \"\"\"\n...\n</code></pre>"},{"location":"api/#atomlib.AtomCell.sort","title":"<code>sort(by, descending=False, *, frame=None)</code>","text":"Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef sort(self: HasAtomCellT, by: t.Union[str, polars.Expr, t.List[str], t.List[polars.Expr]],\ndescending: t.Union[bool, t.List[bool]] = False, *,\nframe: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n...\n</code></pre>"},{"location":"api/#atomlib.AtomCell.concat","title":"<code>concat(atoms, *, rechunk=True, how='vertical')</code>  <code>classmethod</code>","text":"Source code in <code>atomlib/atoms.py</code> <pre><code>@classmethod\ndef concat(cls: t.Type[HasAtomsT],\natoms: t.Union[HasAtomsT, IntoAtoms, t.Iterable[t.Union[HasAtomsT, IntoAtoms]]], *,\nrechunk: bool = True, how: ConcatMethod = 'vertical') -&gt; HasAtomsT:\n# this method is tricky. It needs to accept raw Atoms, as well as HasAtoms of the\n# same type as ``cls``.\nif _is_abstract(cls):\nraise TypeError(f\"concat() must be called on a concrete class.\")\nif isinstance(atoms, HasAtoms):\natoms = (atoms,)\ndfs = [a.get_atoms('local').inner if isinstance(a, HasAtoms) else Atoms(a).inner for a in atoms]\nrepresentative = cls._combine_metadata(*(a for a in atoms if isinstance(a, HasAtoms)))\nif len(dfs) == 0:\nreturn representative.with_atoms(Atoms.empty(), 'local')\nif how in ('vertical', 'vertical_relaxed'):\n# get order from first member\ncols = dfs[0].columns\ndfs = [df.select(cols) for df in dfs]\nelif how == 'inner':\ncols = reduce(operator.and_, (df.schema.keys() for df in dfs))\nschema = t.cast(SchemaDict, {col: dfs[0].schema[col] for col in cols})\nif len(schema) == 0:\nraise ValueError(f\"Atoms have no columns in common\")\ndfs = [_select_schema(df, schema) for df in dfs]\nhow = 'vertical'\nreturn representative.with_atoms(Atoms(polars.concat(dfs, rechunk=rechunk, how=how)), 'local')\n</code></pre>"},{"location":"api/#atomlib.AtomCell.select_schema","title":"<code>select_schema(schema)</code>","text":"<p>Select columns from <code>self</code> and cast to the given schema. Raises :py:<code>TypeError</code> if a column is not found or if it can't be cast.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def select_schema(self, schema: SchemaDict) -&gt; polars.DataFrame:\n\"\"\"\n    Select columns from ``self`` and cast to the given schema.\n    Raises :py:`TypeError` if a column is not found or if it can't be cast.\n    \"\"\"\nreturn _select_schema(self, schema)\n</code></pre>"},{"location":"api/#atomlib.AtomCell.try_select","title":"<code>try_select(exprs, *, frame=None)</code>","text":"<p>Try to select <code>exprs</code> from <code>self</code>, and return as a :py:class:<code>polars.DataFrame</code>.</p> <p>Expressions may either be columns or expressions of columns. Return <code>None</code> if any columns are missing.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_get\ndef try_select(self, exprs: t.Union[str, polars.Expr, polars.Series, t.Sequence[t.Union[str, polars.Expr, polars.Series]]], *,\nframe: t.Optional[CoordinateFrame] = None) -&gt; t.Optional[polars.DataFrame]:\n\"\"\"\n    Try to select ``exprs`` from ``self``, and return as a :py:class:`polars.DataFrame`.\n    Expressions may either be columns or expressions of columns.\n    Return ``None`` if any columns are missing.\n    \"\"\"\n...\n</code></pre>"},{"location":"api/#atomlib.AtomCell.try_get_column","title":"<code>try_get_column(name)</code>","text":"<p>Try to get a column from <code>self</code>, returning <code>None</code> if it doesn't exist.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def try_get_column(self, name: str) -&gt; t.Optional[polars.Series]:\n\"\"\"Try to get a column from `self`, returning `None` if it doesn't exist.\"\"\"\ntry:\nreturn self.get_column(name)\nexcept ColumnNotFoundError:\nreturn None\n</code></pre>"},{"location":"api/#atomlib.AtomCell.bbox_atoms","title":"<code>bbox_atoms(frame=None)</code>","text":"<p>Return the bounding box of all the atoms in <code>self</code>, in the given coordinate frame.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def bbox_atoms(self, frame: t.Optional[CoordinateFrame] = None) -&gt; BBox3D:\n\"\"\"Return the bounding box of all the atoms in ``self``, in the given coordinate frame.\"\"\"\nreturn self.get_atoms(frame).bbox()\n</code></pre>"},{"location":"api/#atomlib.AtomCell.transform_atoms","title":"<code>transform_atoms(transform, selection=None, *, frame='local', transform_velocities=False)</code>","text":"<p>Transform the atoms in <code>self</code> by <code>transform</code>. If <code>selection</code> is given, only transform the atoms in <code>selection</code>.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def transform_atoms(self: HasAtomCellT, transform: IntoTransform3D, selection: t.Optional[AtomSelection] = None, *,\nframe: CoordinateFrame = 'local', transform_velocities: bool = False) -&gt; HasAtomCellT:\n\"\"\"\n    Transform the atoms in `self` by `transform`.\n    If `selection` is given, only transform the atoms in `selection`.\n    \"\"\"\ntransform = self.change_transform(Transform3D.make(transform), self.get_frame(), frame)\nreturn self.with_atoms(self.get_atoms(self.get_frame()).transform(transform, selection, transform_velocities=transform_velocities))\n</code></pre>"},{"location":"api/#atomlib.AtomCell.transform","title":"<code>transform(transform, frame='local')</code>","text":"Source code in <code>atomlib/atomcell.py</code> <pre><code>def transform(self: HasAtomCellT, transform: AffineTransform3D, frame: CoordinateFrame = 'local') -&gt; HasAtomCellT:\nif isinstance(transform, Transform3D) and not isinstance(transform, AffineTransform3D):\nraise ValueError(\"Non-affine transforms cannot change the box dimensions. Use 'transform_atoms' instead.\")\n# TODO: cleanup once tests pass\n# coordinate change the transform into atomic coordinates\nnew_cell = self.get_cell().transform_cell(transform, frame)\ntransform = self.get_cell().change_transform(transform, self.get_frame(), frame)\nreturn self.with_atoms(self.get_atoms().transform(transform), self.get_frame()).with_cell(new_cell)\n</code></pre>"},{"location":"api/#atomlib.AtomCell.round_near_zero","title":"<code>round_near_zero(tol=1e-14, *, frame=None)</code>","text":"<p>Round atom position values near zero to zero.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef round_near_zero(self: HasAtomCellT, tol: float = 1e-14, *,\nframe: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n\"\"\"\n    Round atom position values near zero to zero.\n    \"\"\"\n...\n</code></pre>"},{"location":"api/#atomlib.AtomCell.crop_atoms","title":"<code>crop_atoms(x_min=-numpy.inf, x_max=numpy.inf, y_min=-numpy.inf, y_max=numpy.inf, z_min=-numpy.inf, z_max=numpy.inf, *, frame='local')</code>","text":"Source code in <code>atomlib/atomcell.py</code> <pre><code>def crop_atoms(self: HasAtomCellT, x_min: float = -numpy.inf, x_max: float = numpy.inf,\ny_min: float = -numpy.inf, y_max: float = numpy.inf,\nz_min: float = -numpy.inf, z_max: float = numpy.inf, *,\nframe: CoordinateFrame = 'local') -&gt; HasAtomCellT:\natoms = self._transform_atoms_in_frame(frame, lambda atoms: atoms.crop_atoms(x_min, x_max, y_min, y_max, z_min, z_max))\nreturn self.with_atoms(atoms)\n</code></pre>"},{"location":"api/#atomlib.AtomCell.deduplicate","title":"<code>deduplicate(tol=0.001, subset=('x', 'y', 'z', 'symbol'), keep='first')</code>","text":"<p>De-duplicate atoms in <code>self</code>. Atoms of the same <code>symbol</code> that are closer than <code>tolerance</code> to each other (by Euclidian distance) will be removed, leaving only the atom specified by <code>keep</code> (defaults to the first atom).</p> <p>If <code>subset</code> is specified, only those columns will be included while assessing duplicates. Floating point columns other than 'x', 'y', and 'z' will not by toleranced.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def deduplicate(self: HasAtomsT, tol: float = 1e-3, subset: t.Iterable[str] = ('x', 'y', 'z', 'symbol'),\nkeep: UniqueKeepStrategy = 'first') -&gt; HasAtomsT:\n\"\"\"\n    De-duplicate atoms in `self`. Atoms of the same `symbol` that are closer than `tolerance`\n    to each other (by Euclidian distance) will be removed, leaving only the atom specified by\n    `keep` (defaults to the first atom).\n    If `subset` is specified, only those columns will be included while assessing duplicates.\n    Floating point columns other than 'x', 'y', and 'z' will not by toleranced.\n    \"\"\"\ncols = set((subset,) if isinstance(subset, str) else subset)\nindices = numpy.arange(len(self))\nspatial_cols = cols.intersection(('x', 'y', 'z'))\ncols -= spatial_cols\nif len(spatial_cols) &gt; 0:\ncoords = self.select(list(spatial_cols)).to_numpy()\nprint(coords.shape)\ntree = scipy.spatial.KDTree(coords)\n# TODO This is a bad algorithm\nwhile True:\nchanged = False\nfor (i, j) in tree.query_pairs(tol, 2.):\n# whenever we encounter a pair, ensure their index matches\ni_i, i_j = indices[[i, j]]\nif i_i != i_j:\nindices[i] = indices[j] = min(i_i, i_j)\nchanged = True\nif not changed:\nbreak\nself = self.with_column(polars.Series('_unique_pts', indices))\ncols.add('_unique_pts')\nframe = self._get_frame().unique(subset=list(cols), keep=keep)\nif len(spatial_cols) &gt; 0:\nframe = frame.drop('_unique_pts')\nreturn self.with_atoms(Atoms(frame, _unchecked=True))\n</code></pre>"},{"location":"api/#atomlib.AtomCell.with_bounds","title":"<code>with_bounds(cell_size=None, cell_origin=None)</code>","text":"<p>Return a periodic cell with the given orthogonal cell dimensions.</p> <p>If cell_size is not specified, it will be assumed (and may be incorrect).</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def with_bounds(self, cell_size: t.Optional[VecLike] = None, cell_origin: t.Optional[VecLike] = None) -&gt; 'AtomCell':\n\"\"\"\n    Return a periodic cell with the given orthogonal cell dimensions.\n    If cell_size is not specified, it will be assumed (and may be incorrect).\n    \"\"\"\n# TODO: test this\nfrom .atomcell import AtomCell\nif cell_size is None:\nwarnings.warn(\"Cell boundary unknown. Defaulting to cell BBox\")\ncell_size = self.bbox().size\ncell_origin = self.bbox().min\n# TODO test this origin code\ncell = Cell.from_unit_cell(cell_size)\nif cell_origin is not None:\ncell = cell.transform_cell(AffineTransform3D.translate(to_vec3(cell_origin)))\nreturn AtomCell(self.get_atoms(), cell, frame='local')\n</code></pre>"},{"location":"api/#atomlib.AtomCell.coords","title":"<code>coords(selection=None, *, frame=None)</code>","text":"<p>Returns a <code>(N, 3)</code> ndarray of atom coordinates (dtype <code>numpy.float64</code>).</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_get\ndef coords(self, selection: t.Optional[AtomSelection] = None, *, frame: t.Optional[CoordinateFrame] = None) -&gt; NDArray[numpy.float64]:\n\"\"\"Returns a ``(N, 3)`` ndarray of atom coordinates (dtype ``numpy.float64``).\"\"\"\n...\n</code></pre>"},{"location":"api/#atomlib.AtomCell.velocities","title":"<code>velocities(selection=None, *, frame=None)</code>","text":"<p>Returns a <code>(N, 3)</code> ndarray of atom velocities (dtype <code>numpy.float64</code>).</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_get\ndef velocities(self, selection: t.Optional[AtomSelection] = None, *, frame: t.Optional[CoordinateFrame] = None) -&gt; t.Optional[NDArray[numpy.float64]]:\n\"\"\"Returns a ``(N, 3)`` ndarray of atom velocities (dtype ``numpy.float64``).\"\"\"\n...\n</code></pre>"},{"location":"api/#atomlib.AtomCell.types","title":"<code>types()</code>","text":"<p>Returns a <code>Series</code> of atom types (dtype polars.Int32).</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def types(self) -&gt; t.Optional[polars.Series]:\n\"\"\"Returns a `Series` of atom types (dtype polars.Int32).\"\"\"\nreturn self.try_get_column('type')\n</code></pre>"},{"location":"api/#atomlib.AtomCell.masses","title":"<code>masses()</code>","text":"<p>Returns a <code>Series</code> of atom masses (dtype polars.Float32).</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def masses(self) -&gt; t.Optional[polars.Series]:\n\"\"\"Returns a `Series` of atom masses (dtype polars.Float32).\"\"\"\nreturn self.try_get_column('mass')\n</code></pre>"},{"location":"api/#atomlib.AtomCell.add_atom","title":"<code>add_atom(elem, /, x, y=None, z=None, *, frame=None, **kwargs)</code>","text":"<p>Return a copy of <code>self</code> with an extra atom.</p> <p>By default, all extra columns present in <code>self</code> must be specified as <code>**kwargs</code>.</p> <p>Try to avoid calling this in a loop (Use :py:meth:<code>concat</code> instead).</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef add_atom(self: HasAtomCellT, elem: t.Union[int, str], /,  # type: ignore (spurious)\nx: t.Union[ArrayLike, float],\ny: t.Optional[float] = None,\nz: t.Optional[float] = None, *,\nframe: t.Optional[CoordinateFrame] = None,\n**kwargs: t.Any) -&gt; HasAtomCellT:\n\"\"\"\n    Return a copy of ``self`` with an extra atom.\n    By default, all extra columns present in ``self`` must be specified as ``**kwargs``.\n    Try to avoid calling this in a loop (Use :py:meth:`concat` instead).\n    \"\"\"\n...\n</code></pre>"},{"location":"api/#atomlib.AtomCell.pos","title":"<code>pos(x=None, y=None, z=None, *, tol=1e-06, **kwargs)</code>","text":"<p>Select all atoms at a given position.</p> <p>Formally, returns all atoms within a cube of radius <code>tol</code> centered at <code>(x,y,z)</code>, exclusive of the cube's surface.</p> <p>Additional parameters given as <code>kwargs</code> will be checked as additional parameters (with strict equality).</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def pos(self,\nx: t.Union[t.Sequence[t.Optional[float]], float, None] = None,\ny: t.Optional[float] = None, z: t.Optional[float] = None, *,\ntol: float = 1e-6, **kwargs: t.Any) -&gt; polars.Expr:\n\"\"\"\n    Select all atoms at a given position.\n    Formally, returns all atoms within a cube of radius ``tol``\n    centered at ``(x,y,z)``, exclusive of the cube's surface.\n    Additional parameters given as ``kwargs`` will be checked\n    as additional parameters (with strict equality).\n    \"\"\"\nif isinstance(x, t.Sequence):\n(x, y, z) = x\ntol = abs(float(tol))\nselection = polars.lit(True)\nif x is not None:\nselection &amp;= (x - tol &lt; polars.col('x')) &amp; (polars.col('x') &lt; x + tol)\nif y is not None:\nselection &amp;= (y - tol &lt; polars.col('y')) &amp; (polars.col('y') &lt; y + tol)\nif z is not None:\nselection &amp;= (z - tol &lt; polars.col('z')) &amp; (polars.col('z') &lt; z + tol)\nfor (col, val) in kwargs.items():\nselection &amp;= (polars.col(col) == val)\nreturn selection\n</code></pre>"},{"location":"api/#atomlib.AtomCell.with_index","title":"<code>with_index(index=None, *, frame=None)</code>","text":"<p>Returns <code>self</code> with a row index added in column 'i' (dtype polars.Int64). If <code>index</code> is not specified, defaults to an existing index or a new index.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef with_index(self: HasAtomCellT, index: t.Optional[AtomValues] = None, *,\nframe: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n\"\"\"\n    Returns ``self`` with a row index added in column 'i' (dtype polars.Int64).\n    If ``index`` is not specified, defaults to an existing index or a new index.\n    \"\"\"\n...\n</code></pre>"},{"location":"api/#atomlib.AtomCell.with_wobble","title":"<code>with_wobble(wobble=None, *, frame=None)</code>","text":"<p>Return <code>self</code> with the given displacements in column 'wobble' (dtype polars.Float64). If <code>wobble</code> is not specified, defaults to the already-existing wobbles or 0.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef with_wobble(self: HasAtomCellT, wobble: t.Optional[AtomValues] = None, *,\nframe: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n\"\"\"\n    Return ``self`` with the given displacements in column 'wobble' (dtype polars.Float64).\n    If ``wobble`` is not specified, defaults to the already-existing wobbles or 0.\n    \"\"\"\n...\n</code></pre>"},{"location":"api/#atomlib.AtomCell.with_occupancy","title":"<code>with_occupancy(frac_occupancy=None, *, frame=None)</code>","text":"<p>Return self with the given fractional occupancies. If <code>frac_occupancy</code> is not specified, defaults to the already-existing occupancies or 1.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef with_occupancy(self: HasAtomCellT, frac_occupancy: t.Optional[AtomValues] = None, *,\nframe: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n\"\"\"\n    Return self with the given fractional occupancies. If ``frac_occupancy`` is not specified,\n    defaults to the already-existing occupancies or 1.\n    \"\"\"\n...\n</code></pre>"},{"location":"api/#atomlib.AtomCell.apply_wobble","title":"<code>apply_wobble(rng=None, frame=None)</code>","text":"<p>Displace the atoms in <code>self</code> by the amount in the <code>wobble</code> column. <code>wobble</code> is interpretated as a mean-squared displacement, which is distributed equally over each axis.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef apply_wobble(self: HasAtomCellT, rng: t.Union[numpy.random.Generator, int, None] = None,\nframe: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n\"\"\"\n    Displace the atoms in ``self`` by the amount in the `wobble` column.\n    ``wobble`` is interpretated as a mean-squared displacement, which is distributed\n    equally over each axis.\n    \"\"\"\n...\n</code></pre>"},{"location":"api/#atomlib.AtomCell.apply_occupancy","title":"<code>apply_occupancy(rng=None)</code>","text":"<p>For each atom in <code>self</code>, use its <code>frac_occupancy</code> to randomly decide whether to remove it.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def apply_occupancy(self: HasAtomsT, rng: t.Union[numpy.random.Generator, int, None] = None) -&gt; HasAtomsT:\n\"\"\"\n    For each atom in `self`, use its `frac_occupancy` to randomly decide whether to remove it.\n    \"\"\"\nif 'frac_occupancy' not in self.columns:\nreturn self\nrng = numpy.random.default_rng(seed=rng)\nfrac = self.select('frac_occupancy').to_series().to_numpy()\nchoice = rng.binomial(1, frac).astype(numpy.bool_)\nreturn self.filter(polars.lit(choice))\n</code></pre>"},{"location":"api/#atomlib.AtomCell.with_type","title":"<code>with_type(types=None, *, frame=None)</code>","text":"<p>Return <code>self</code> with the given atom types in column 'type'. If <code>types</code> is not specified, use the already existing types or auto-assign them.</p> <p>When auto-assigning, each symbol is given a unique value, case-sensitive. Values are assigned from lowest atomic number to highest. For instance: <code>[\"Ag+\", \"Na\", \"H\", \"Ag\"]</code> =&gt; <code>[3, 11, 1, 2]</code></p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef with_type(self: HasAtomCellT, types: t.Optional[AtomValues] = None, *,\nframe: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n\"\"\"\n    Return ``self`` with the given atom types in column 'type'.\n    If ``types`` is not specified, use the already existing types or auto-assign them.\n    When auto-assigning, each symbol is given a unique value, case-sensitive.\n    Values are assigned from lowest atomic number to highest.\n    For instance: ``[\"Ag+\", \"Na\", \"H\", \"Ag\"]`` =&gt; ``[3, 11, 1, 2]``\n    \"\"\"\n...\n</code></pre>"},{"location":"api/#atomlib.AtomCell.with_mass","title":"<code>with_mass(mass=None, *, frame=None)</code>","text":"<p>Return <code>self</code> with the given atom masses in column 'mass'. If <code>mass</code> is not specified, use the already existing masses or auto-assign them.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef with_mass(self: HasAtomCellT, mass: t.Optional[ArrayLike] = None, *,\nframe: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n\"\"\"\n    Return ``self`` with the given atom masses in column 'mass'.\n    If ``mass`` is not specified, use the already existing masses or auto-assign them.\n    \"\"\"\n...\n</code></pre>"},{"location":"api/#atomlib.AtomCell.with_symbol","title":"<code>with_symbol(symbols, selection=None, *, frame=None)</code>","text":"<p>Return <code>self</code> with the given atomic symbols.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef with_symbol(self: HasAtomCellT, symbols: ArrayLike, selection: t.Optional[AtomSelection] = None, *,\nframe: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n\"\"\"\n    Return ``self`` with the given atomic symbols.\n    \"\"\"\n...\n</code></pre>"},{"location":"api/#atomlib.AtomCell.with_coords","title":"<code>with_coords(pts, selection=None, *, frame=None)</code>","text":"<p>Return <code>self</code> replaced with the given atomic positions.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef with_coords(self: HasAtomCellT, pts: ArrayLike, selection: t.Optional[AtomSelection] = None, *,\nframe: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n\"\"\"\n    Return ``self`` replaced with the given atomic positions.\n    \"\"\"\n...\n</code></pre>"},{"location":"api/#atomlib.AtomCell.with_velocity","title":"<code>with_velocity(pts=None, selection=None, *, frame=None)</code>","text":"<p>Return <code>self</code> replaced with the given atomic velocities. If <code>pts</code> is not specified, use the already existing velocities or zero.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef with_velocity(self: HasAtomCellT, pts: t.Optional[ArrayLike] = None,\nselection: t.Optional[AtomSelection] = None, *,\nframe: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n\"\"\"\n    Return ``self`` replaced with the given atomic velocities.\n    If ``pts`` is not specified, use the already existing velocities or zero.\n    \"\"\"\n...\n</code></pre>"},{"location":"api/#atomlib.AtomCell.get_atomcell","title":"<code>get_atomcell()</code>","text":"Source code in <code>atomlib/atomcell.py</code> <pre><code>def get_atomcell(self) -&gt; AtomCell:\nframe = self.get_frame()\nreturn AtomCell(self.get_atoms(frame), self.get_cell(), frame=frame, keep_frame=True)\n</code></pre>"},{"location":"api/#atomlib.AtomCell.to_frame","title":"<code>to_frame(frame)</code>","text":"<p>Convert the stored Atoms to the given coordinate frame.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def to_frame(self: HasAtomCellT, frame: CoordinateFrame) -&gt; HasAtomCellT:\n\"\"\"Convert the stored Atoms to the given coordinate frame.\"\"\"\nreturn self.with_atoms(self.get_atoms(frame), frame)\n</code></pre>"},{"location":"api/#atomlib.AtomCell.crop_to_box","title":"<code>crop_to_box(eps=1e-05)</code>","text":"Source code in <code>atomlib/atomcell.py</code> <pre><code>def crop_to_box(self: HasAtomCellT, eps: float = 1e-5) -&gt; HasAtomCellT:\natoms = self._transform_atoms_in_frame('cell_box', lambda atoms: atoms.crop_atoms(*([-eps, 1-eps]*3)))\nreturn self.with_atoms(atoms)\n</code></pre>"},{"location":"api/#atomlib.AtomCell.wrap","title":"<code>wrap(eps=1e-05)</code>","text":"<p>Wrap atoms around the cell boundaries.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def wrap(self: HasAtomCellT, eps: float = 1e-5) -&gt; HasAtomCellT:\n\"\"\"Wrap atoms around the cell boundaries.\"\"\"\ndef transform(atoms):\ncoords = atoms.coords()\ncoords = (coords + eps) % 1. - eps\nreturn atoms.with_coords(coords)\nreturn self.with_atoms(self._transform_atoms_in_frame('cell_box', transform))\n</code></pre>"},{"location":"api/#atomlib.AtomCell.repeat_to","title":"<code>repeat_to(size, crop=False)</code>","text":"<p>Repeat the cell so it is at least <code>size</code> along the crystal's axes.</p> <p>If <code>crop</code>, then crop the cell to exactly <code>size</code>. This may break periodicity. <code>crop</code> may be a vector, in which case you can specify cropping only along some axes.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def repeat_to(self: HasAtomCellT, size: VecLike, crop: t.Union[bool, t.Sequence[bool]] = False) -&gt; HasAtomCellT:\n\"\"\"\n    Repeat the cell so it is at least ``size`` along the crystal's axes.\n    If ``crop``, then crop the cell to exactly ``size``. This may break periodicity.\n    ``crop`` may be a vector, in which case you can specify cropping only along some axes.\n    \"\"\"\nsize = to_vec3(size)\ncell_size = self.cell_size * self.n_cells\nrepeat = numpy.maximum(numpy.ceil(size / cell_size).astype(int), 1)\natom_cell = self.repeat(repeat)\ncrop_v = to_vec3(crop, dtype=numpy.bool_)\nif numpy.any(crop_v):\ncrop_x, crop_y, crop_z = crop_v\nreturn atom_cell.crop(\nx_max = size[0] if crop_x else numpy.inf,\ny_max = size[1] if crop_y else numpy.inf,\nz_max = size[2] if crop_z else numpy.inf,\nframe='cell'\n)\nreturn atom_cell\n</code></pre>"},{"location":"api/#atomlib.AtomCell.repeat_x","title":"<code>repeat_x(n)</code>","text":"<p>Tile the cell in the x axis.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def repeat_x(self: HasAtomCellT, n: int) -&gt; HasAtomCellT:\n\"\"\"Tile the cell in the x axis.\"\"\"\nreturn self.repeat((n, 1, 1))\n</code></pre>"},{"location":"api/#atomlib.AtomCell.repeat_y","title":"<code>repeat_y(n)</code>","text":"<p>Tile the cell in the y axis.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def repeat_y(self: HasAtomCellT, n: int) -&gt; HasAtomCellT:\n\"\"\"Tile the cell in the y axis.\"\"\"\nreturn self.repeat((1, n, 1))\n</code></pre>"},{"location":"api/#atomlib.AtomCell.repeat_z","title":"<code>repeat_z(n)</code>","text":"<p>Tile the cell in the z axis.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def repeat_z(self: HasAtomCellT, n: int) -&gt; HasAtomCellT:\n\"\"\"Tile the cell in the z axis.\"\"\"\nreturn self.repeat((1, 1, n))\n</code></pre>"},{"location":"api/#atomlib.AtomCell.repeat_to_x","title":"<code>repeat_to_x(size, crop=False)</code>","text":"<p>Repeat the cell so it is at least size <code>size</code> along the x axis.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def repeat_to_x(self: HasAtomCellT, size: float, crop: bool = False) -&gt; HasAtomCellT:\n\"\"\"Repeat the cell so it is at least size ``size`` along the x axis.\"\"\"\nreturn self.repeat_to([size, 0., 0.], [crop, False, False])\n</code></pre>"},{"location":"api/#atomlib.AtomCell.repeat_to_y","title":"<code>repeat_to_y(size, crop=False)</code>","text":"<p>Repeat the cell so it is at least size <code>size</code> along the y axis.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def repeat_to_y(self: HasAtomCellT, size: float, crop: bool = False) -&gt; HasAtomCellT:\n\"\"\"Repeat the cell so it is at least size ``size`` along the y axis.\"\"\"\nreturn self.repeat_to([0., size, 0.], [False, crop, False])\n</code></pre>"},{"location":"api/#atomlib.AtomCell.repeat_to_z","title":"<code>repeat_to_z(size, crop=False)</code>","text":"<p>Repeat the cell so it is at least size <code>size</code> along the z axis.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def repeat_to_z(self: HasAtomCellT, size: float, crop: bool = False) -&gt; HasAtomCellT:\n\"\"\"Repeat the cell so it is at least size ``size`` along the z axis.\"\"\"\nreturn self.repeat_to([0., 0., size], [False, False, crop])\n</code></pre>"},{"location":"api/#atomlib.AtomCell.repeat_to_aspect","title":"<code>repeat_to_aspect(plane='xy', *, aspect=1.0, min_size=None, max_size=None)</code>","text":"<p>Repeat to optimize the aspect ratio in <code>plane</code>, while staying above <code>min_size</code> and under <code>max_size</code>.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def repeat_to_aspect(self: HasAtomCellT, plane: t.Literal['xy', 'xz', 'yz'] = 'xy', *,\naspect: float = 1., min_size: t.Optional[VecLike] = None,\nmax_size: t.Optional[VecLike] = None) -&gt; HasAtomCellT:\n\"\"\"\n    Repeat to optimize the aspect ratio in ``plane``,\n    while staying above ``min_size`` and under ``max_size``.\n    \"\"\"\nif min_size is None:\nmin_n = numpy.array([1, 1, 1], numpy.int_)\nelse:\nmin_n = numpy.maximum(numpy.ceil(to_vec3(min_size) / self.box_size), 1).astype(numpy.int_)\nif max_size is None:\nmax_n = 3 * min_n\nelse:\nmax_n = numpy.maximum(numpy.floor(to_vec3(max_size) / self.box_size), 1).astype(numpy.int_)\nif plane == 'xy':\nindices = [0, 1]\nelif plane == 'xz':\nindices = [0, 2]\nelif plane == 'yz':\nindices = [1, 2]\nelse:\nraise ValueError(f\"Invalid plane '{plane}'. Exepcted 'xy', 'xz', 'or 'yz'.\")\nna = numpy.arange(min_n[indices[0]], max_n[indices[0]])\nnb = numpy.arange(min_n[indices[1]], max_n[indices[1]])\n(na, nb) = numpy.meshgrid(na, nb)\naspects = na * self.box_size[indices[0]] / (nb * self.box_size[indices[1]])\n# cost function: log(aspect)^2  (so cost(0.5) == cost(2))\nmin_i = numpy.argmin(numpy.log(aspects / aspect)**2)\nrepeat = numpy.array([1, 1, 1], numpy.int_)\nrepeat[indices] = na.flatten()[min_i], nb.flatten()[min_i]\nreturn self.repeat(repeat)\n</code></pre>"},{"location":"api/#atomlib.AtomCell.periodic_duplicate","title":"<code>periodic_duplicate(eps=1e-05)</code>","text":"<p>Add duplicate copies of atoms near periodic boundaries.</p> <p>For instance, an atom at a corner will be duplicated into 8 copies. This is mostly only useful for visualization.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def periodic_duplicate(self: HasAtomCellT, eps: float = 1e-5) -&gt; HasAtomCellT:\n\"\"\"\n    Add duplicate copies of atoms near periodic boundaries.\n    For instance, an atom at a corner will be duplicated into 8 copies.\n    This is mostly only useful for visualization.\n    \"\"\"\nframe_save = self.get_frame()\nself = self.to_frame('cell_box').wrap(eps=eps)\nfor i, ax in enumerate(('x', 'y', 'z')):\nself = self.concat((self,\nself.filter(polars.col(ax).abs() &lt;= eps, frame='cell_box')\n.transform_atoms(AffineTransform3D.translate([1. if i == j else 0. for j in range(3)]), frame='cell_box')\n))\nreturn self.to_frame(frame_save)\n</code></pre>"},{"location":"api/#atomlib.AtomCell.read","title":"<code>read(path, ty=None)</code>  <code>classmethod</code>","text":"<p>Read a structure from a file.</p> <p>Currently, supported file types are 'cif', 'xyz', and 'xsf'. If no <code>ty</code> is specified, it is inferred from the file's extension.</p> Source code in <code>atomlib/mixins.py</code> <pre><code>@classmethod\ndef read(cls: t.Type[HasAtomsT], path: FileOrPath, ty: t.Optional[FileType] = None) -&gt; HasAtomsT:\n\"\"\"\n    Read a structure from a file.\n    Currently, supported file types are 'cif', 'xyz', and 'xsf'.\n    If no `ty` is specified, it is inferred from the file's extension.\n    \"\"\"\nfrom .io import read\nreturn _cast_atoms(read(path, ty), cls)  # type: ignore\n</code></pre>"},{"location":"api/#atomlib.AtomCell.read_cif","title":"<code>read_cif(f)</code>  <code>classmethod</code>","text":"<p>Read a structure from a CIF file.</p> Source code in <code>atomlib/mixins.py</code> <pre><code>@classmethod\ndef read_cif(cls: t.Type[HasAtomsT], f: t.Union[FileOrPath, CIF]) -&gt; HasAtomsT:\n\"\"\"Read a structure from a CIF file.\"\"\"\nfrom .io import read_cif\nreturn _cast_atoms(read_cif(f), cls)\n</code></pre>"},{"location":"api/#atomlib.AtomCell.read_xyz","title":"<code>read_xyz(f)</code>  <code>classmethod</code>","text":"<p>Read a structure from an XYZ file.</p> Source code in <code>atomlib/mixins.py</code> <pre><code>@classmethod\ndef read_xyz(cls: t.Type[HasAtomsT], f: t.Union[FileOrPath, XYZ]) -&gt; HasAtomsT:\n\"\"\"Read a structure from an XYZ file.\"\"\"\nfrom .io import read_xyz\nreturn _cast_atoms(read_xyz(f), cls)\n</code></pre>"},{"location":"api/#atomlib.AtomCell.read_xsf","title":"<code>read_xsf(f)</code>  <code>classmethod</code>","text":"<p>Read a structure from an XSF file.</p> Source code in <code>atomlib/mixins.py</code> <pre><code>@classmethod\ndef read_xsf(cls: t.Type[HasAtomsT], f: t.Union[FileOrPath, XSF]) -&gt; HasAtomsT:\n\"\"\"Read a structure from an XSF file.\"\"\"\nfrom .io import read_xsf\nreturn _cast_atoms(read_xsf(f), cls)\n</code></pre>"},{"location":"api/#atomlib.AtomCell.read_cfg","title":"<code>read_cfg(f)</code>  <code>classmethod</code>","text":"<p>Read a structure from a CFG file.</p> Source code in <code>atomlib/mixins.py</code> <pre><code>@classmethod\ndef read_cfg(cls: t.Type[HasAtomsT], f: t.Union[FileOrPath, CFG]) -&gt; HasAtomsT:\n\"\"\"Read a structure from a CFG file.\"\"\"\nfrom .io import read_cfg\nreturn _cast_atoms(read_cfg(f), cls)\n</code></pre>"},{"location":"api/#atomlib.AtomCell.write_xyz","title":"<code>write_xyz(f, fmt='exyz')</code>","text":"Source code in <code>atomlib/mixins.py</code> <pre><code>def write_xyz(self, f: FileOrPath, fmt: XYZFormat = 'exyz'):\nfrom .io import write_xyz\nwrite_xyz(self, f, fmt)\n</code></pre>"},{"location":"api/#atomlib.AtomCell.write_xsf","title":"<code>write_xsf(f)</code>","text":"Source code in <code>atomlib/mixins.py</code> <pre><code>def write_xsf(self, f: FileOrPath):\nfrom .io import write_xsf\nwrite_xsf(self, f)\n</code></pre>"},{"location":"api/#atomlib.AtomCell.write_cfg","title":"<code>write_cfg(f)</code>","text":"Source code in <code>atomlib/mixins.py</code> <pre><code>def write_cfg(self, f: FileOrPath):\nfrom .io import write_cfg\nwrite_cfg(self, f)\n</code></pre>"},{"location":"api/#atomlib.AtomCell.write","title":"<code>write(path, ty=None)</code>","text":"<p>Write this structure to a file.</p> <p>A file type may be specified using <code>ty</code>. If no <code>ty</code> is specified, it is inferred from the path's extension.</p> Source code in <code>atomlib/mixins.py</code> <pre><code>def write(self, path: FileOrPath, ty: t.Optional[FileType] = None):\n\"\"\"\n    Write this structure to a file.\n    A file type may be specified using `ty`.\n    If no `ty` is specified, it is inferred from the path's extension.\n    \"\"\"\nfrom .io import write\nwrite(self, path, ty)  # type: ignore\n</code></pre>"},{"location":"api/#atomlib.AtomCell.write_mslice","title":"<code>write_mslice(f, template=None, *, slice_thickness=None, scan_points=None, scan_extent=None, noise_sigma=None, conv_angle=None, energy=None, defocus=None, tilt=None, tds=None, n_cells=None)</code>","text":"<p>Write a structure to an mslice file.</p> <p><code>template</code> may be a file, path, or ElementTree containing an existing mslice file. Its structure will be modified to make the final output. If not specified, a default template will be used.</p> <p>Additional options modify simulation properties. If an option is not specified, the template's properties are used.</p> Source code in <code>atomlib/mixins.py</code> <pre><code>def write_mslice(self, f: FileOrPath, template: t.Optional[MSliceFile] = None, *,\nslice_thickness: t.Optional[float] = None,  # angstrom\nscan_points: t.Optional[ArrayLike] = None,\nscan_extent: t.Optional[ArrayLike] = None,\nnoise_sigma: t.Optional[float] = None,  # angstrom\nconv_angle: t.Optional[float] = None,  # mrad\nenergy: t.Optional[float] = None,  # keV\ndefocus: t.Optional[float] = None,  # angstrom\ntilt: t.Optional[t.Tuple[float, float]] = None,  # (mrad, mrad)\ntds: t.Optional[bool] = None,\nn_cells: t.Optional[ArrayLike] = None):\n\"\"\"\n    Write a structure to an mslice file.\n    ``template`` may be a file, path, or ElementTree containing an existing mslice file.\n    Its structure will be modified to make the final output. If not specified, a default\n    template will be used.\n    Additional options modify simulation properties. If an option is not specified, the\n    template's properties are used.\n    \"\"\"\nfrom .io import write_mslice\nreturn write_mslice(self, f, template, slice_thickness=slice_thickness,\nscan_points=scan_points, scan_extent=scan_extent,\nconv_angle=conv_angle, energy=energy, defocus=defocus,\nnoise_sigma=noise_sigma, tilt=tilt, tds=tds, n_cells=n_cells)\n</code></pre>"},{"location":"api/#atomlib.AtomCell.write_qe","title":"<code>write_qe(f, pseudo=None)</code>","text":"Source code in <code>atomlib/mixins.py</code> <pre><code>def write_qe(self, f: FileOrPath, pseudo: t.Optional[t.Mapping[str, str]] = None):\nfrom .io import write_qe\nwrite_qe(self, f, pseudo)\n</code></pre>"},{"location":"api/#atomlib.AtomCell.get_cell","title":"<code>get_cell()</code>","text":"Source code in <code>atomlib/atomcell.py</code> <pre><code>def get_cell(self) -&gt; Cell:\nreturn self.cell\n</code></pre>"},{"location":"api/#atomlib.AtomCell.with_cell","title":"<code>with_cell(cell)</code>","text":"Source code in <code>atomlib/atomcell.py</code> <pre><code>def with_cell(self: AtomCellT, cell: Cell) -&gt; AtomCellT:\nreturn self.__class__(self.atoms, cell, frame=self.frame, keep_frame=True)\n</code></pre>"},{"location":"api/#atomlib.AtomCell.get_atoms","title":"<code>get_atoms(frame=None)</code>","text":"<p>Get atoms contained in <code>self</code>, in the given coordinate frame.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def get_atoms(self, frame: t.Optional[CoordinateFrame] = None) -&gt; Atoms:\n\"\"\"Get atoms contained in ``self``, in the given coordinate frame.\"\"\"\nif frame is None or frame == self.get_frame():\nreturn self.atoms\nreturn self.atoms.transform(self.get_transform(frame, self.get_frame()))\n</code></pre>"},{"location":"api/#atomlib.AtomCell.with_atoms","title":"<code>with_atoms(atoms, frame=None)</code>","text":"Source code in <code>atomlib/atomcell.py</code> <pre><code>def with_atoms(self: AtomCellT, atoms: HasAtoms, frame: t.Optional[CoordinateFrame] = None) -&gt; AtomCellT:\nframe = frame if frame is not None else self.frame\nreturn self.__class__(atoms.get_atoms(), cell=self.cell, frame=frame, keep_frame=True)\n</code></pre>"},{"location":"api/#atomlib.AtomCell.get_frame","title":"<code>get_frame()</code>","text":"<p>Get the coordinate frame atoms are stored in.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def get_frame(self) -&gt; CoordinateFrame:\n\"\"\"Get the coordinate frame atoms are stored in.\"\"\"\nreturn self.frame\n</code></pre>"},{"location":"api/#atomlib.AtomCell.from_ortho","title":"<code>from_ortho(atoms, ortho, *, n_cells=None, frame='local', keep_frame=False)</code>  <code>classmethod</code>","text":"<p>Make an atom cell given a list of atoms and an orthogonalization matrix. Atoms are assumed to be in the coordinate system <code>frame</code>.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@classmethod\ndef from_ortho(cls, atoms: IntoAtoms, ortho: LinearTransform3D, *,\nn_cells: t.Optional[VecLike] = None,\nframe: CoordinateFrame = 'local',\nkeep_frame: bool = False):\n\"\"\"\n    Make an atom cell given a list of atoms and an orthogonalization matrix.\n    Atoms are assumed to be in the coordinate system ``frame``.\n    \"\"\"\ncell = Cell.from_ortho(ortho, n_cells)\nreturn cls(atoms, cell, frame=frame, keep_frame=keep_frame)\n</code></pre>"},{"location":"api/#atomlib.AtomCell.from_unit_cell","title":"<code>from_unit_cell(atoms, cell_size, cell_angle=None, *, n_cells=None, frame='local', keep_frame=False)</code>  <code>classmethod</code>","text":"<p>Make a cell given a list of atoms and unit cell parameters. Atoms are assumed to be in the coordinate system <code>frame</code>.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@classmethod\ndef from_unit_cell(cls, atoms: IntoAtoms, cell_size: VecLike,\ncell_angle: t.Optional[VecLike] = None, *,\nn_cells: t.Optional[VecLike] = None,\nframe: CoordinateFrame = 'local',\nkeep_frame: bool = False):\n\"\"\"\n    Make a cell given a list of atoms and unit cell parameters.\n    Atoms are assumed to be in the coordinate system ``frame``.\n    \"\"\"\ncell = Cell.from_unit_cell(cell_size, cell_angle, n_cells=n_cells)\nreturn cls(atoms, cell, frame=frame, keep_frame=keep_frame)\n</code></pre>"},{"location":"api/#atomlib.AtomCell.orthogonalize","title":"<code>orthogonalize()</code>","text":"Source code in <code>atomlib/atomcell.py</code> <pre><code>def orthogonalize(self) -&gt; OrthoCell:\nif self.is_orthogonal():\nreturn OrthoCell(self.atoms, self.cell, frame=self.frame)\nraise NotImplementedError()\n</code></pre>"},{"location":"api/#atomlib.AtomCell.clone","title":"<code>clone()</code>","text":"<p>Make a deep copy of <code>self</code>.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def clone(self: AtomCellT) -&gt; AtomCellT:\n\"\"\"Make a deep copy of ``self``.\"\"\"\nreturn self.__class__(**{field.name: copy.deepcopy(getattr(self, field.name)) for field in fields(self)})\n</code></pre>"},{"location":"api/#atomlib.AtomCell.assert_equal","title":"<code>assert_equal(other)</code>","text":"<p>Assert this structure is equal to</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def assert_equal(self, other: t.Any):\n\"\"\"Assert this structure is equal to \"\"\"\nassert isinstance(other, AtomCell)\nself.cell.assert_equal(other.cell)\nself.get_atoms('local').assert_equal(other.get_atoms('local'))\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell","title":"<code>HasAtomCell</code>","text":"<p>             Bases: <code>HasAtoms</code>, <code>HasCell</code>, <code>ABC</code></p> Source code in <code>atomlib/atomcell.py</code> <pre><code>class HasAtomCell(HasAtoms, HasCell, abc.ABC):\n@abc.abstractmethod\ndef get_frame(self) -&gt; CoordinateFrame:\n\"\"\"Get the coordinate frame atoms are stored in.\"\"\"\n...\n@abc.abstractmethod\ndef with_atoms(self: HasAtomCellT, atoms: HasAtoms, frame: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n\"\"\"\n        Replace the atoms in ``self``. If no coordinate frame is specified, keep the coordinate frame unchanged.\n        \"\"\"\n...\ndef with_cell(self: HasAtomCellT, cell: Cell) -&gt; HasAtomCellT:\n\"\"\"\n        Replace the cell in ``self``, without touching the atomic coordinates.\n        \"\"\"\nreturn self.to_frame('local').with_cell(cell)\ndef get_atomcell(self) -&gt; AtomCell:\nframe = self.get_frame()\nreturn AtomCell(self.get_atoms(frame), self.get_cell(), frame=frame, keep_frame=True)\n@abc.abstractmethod\ndef get_atoms(self, frame: t.Optional[CoordinateFrame] = None) -&gt; Atoms:\n\"\"\"Get atoms contained in ``self``, in the given coordinate frame.\"\"\"\n...\ndef bbox_atoms(self, frame: t.Optional[CoordinateFrame] = None) -&gt; BBox3D:\n\"\"\"Return the bounding box of all the atoms in ``self``, in the given coordinate frame.\"\"\"\nreturn self.get_atoms(frame).bbox()\ndef bbox(self, frame: CoordinateFrame = 'local') -&gt; BBox3D:\n\"\"\"\n        Return the combined bounding box of the cell and atoms in the given coordinate system.\n        To get the cell or atoms bounding box only, use :py:meth:`bbox_cell` or :py:meth:`bbox_atoms`.\n        \"\"\"\nreturn self.bbox_atoms(frame) | self.bbox_cell(frame)\n# transformation\ndef _transform_atoms_in_frame(self, frame: t.Optional[CoordinateFrame], f: t.Callable[[Atoms], Atoms]) -&gt; Atoms:\n# ugly code\nif frame is None or frame == self.get_frame():\nreturn f(self.get_atoms())\nreturn f(self.get_atoms(frame)).transform(self.get_transform(self.get_frame(), frame))\ndef to_frame(self: HasAtomCellT, frame: CoordinateFrame) -&gt; HasAtomCellT:\n\"\"\"Convert the stored Atoms to the given coordinate frame.\"\"\"\nreturn self.with_atoms(self.get_atoms(frame), frame)\ndef transform_atoms(self: HasAtomCellT, transform: IntoTransform3D, selection: t.Optional[AtomSelection] = None, *,\nframe: CoordinateFrame = 'local', transform_velocities: bool = False) -&gt; HasAtomCellT:\n\"\"\"\n        Transform the atoms in `self` by `transform`.\n        If `selection` is given, only transform the atoms in `selection`.\n        \"\"\"\ntransform = self.change_transform(Transform3D.make(transform), self.get_frame(), frame)\nreturn self.with_atoms(self.get_atoms(self.get_frame()).transform(transform, selection, transform_velocities=transform_velocities))\ndef transform_cell(self: HasAtomCellT, transform: AffineTransform3D, frame: CoordinateFrame = 'local') -&gt; HasAtomCellT:\n\"\"\"\n        Apply the given transform to the unit cell, without changing atom positions.\n        The transform is applied in coordinate frame 'frame'.\n        \"\"\"\nreturn self.with_cell(self.get_cell().transform_cell(transform, frame=frame))\ndef transform(self: HasAtomCellT, transform: AffineTransform3D, frame: CoordinateFrame = 'local') -&gt; HasAtomCellT:\nif isinstance(transform, Transform3D) and not isinstance(transform, AffineTransform3D):\nraise ValueError(\"Non-affine transforms cannot change the box dimensions. Use 'transform_atoms' instead.\")\n# TODO: cleanup once tests pass\n# coordinate change the transform into atomic coordinates\nnew_cell = self.get_cell().transform_cell(transform, frame)\ntransform = self.get_cell().change_transform(transform, self.get_frame(), frame)\nreturn self.with_atoms(self.get_atoms().transform(transform), self.get_frame()).with_cell(new_cell)\n# crop methods\ndef crop(self: HasAtomCellT, x_min: float = -numpy.inf, x_max: float = numpy.inf,\ny_min: float = -numpy.inf, y_max: float = numpy.inf,\nz_min: float = -numpy.inf, z_max: float = numpy.inf, *,\nframe: CoordinateFrame = 'local') -&gt; HasAtomCellT:\n\"\"\"\n        Crop atoms and cell to the given extents. For a non-orthogonal\n        cell, this must be specified in cell coordinates. This\n        function implicity `explode`s the cell as well.\n        To crop atoms only, use :py:meth:`crop_atoms` instead.\n        \"\"\"\ncell = self.get_cell().crop(x_min, x_max, y_min, y_max, z_min, z_max, frame=frame)\natoms = self._transform_atoms_in_frame(frame, lambda atoms: atoms.crop_atoms(x_min, x_max, y_min, y_max, z_min, z_max))\nreturn self.with_cell(cell).with_atoms(atoms)\ndef crop_atoms(self: HasAtomCellT, x_min: float = -numpy.inf, x_max: float = numpy.inf,\ny_min: float = -numpy.inf, y_max: float = numpy.inf,\nz_min: float = -numpy.inf, z_max: float = numpy.inf, *,\nframe: CoordinateFrame = 'local') -&gt; HasAtomCellT:\natoms = self._transform_atoms_in_frame(frame, lambda atoms: atoms.crop_atoms(x_min, x_max, y_min, y_max, z_min, z_max))\nreturn self.with_atoms(atoms)\ndef crop_to_box(self: HasAtomCellT, eps: float = 1e-5) -&gt; HasAtomCellT:\natoms = self._transform_atoms_in_frame('cell_box', lambda atoms: atoms.crop_atoms(*([-eps, 1-eps]*3)))\nreturn self.with_atoms(atoms)\ndef wrap(self: HasAtomCellT, eps: float = 1e-5) -&gt; HasAtomCellT:\n\"\"\"Wrap atoms around the cell boundaries.\"\"\"\ndef transform(atoms):\ncoords = atoms.coords()\ncoords = (coords + eps) % 1. - eps\nreturn atoms.with_coords(coords)\nreturn self.with_atoms(self._transform_atoms_in_frame('cell_box', transform))\n\"\"\"\n    def explode(self: HasAtomCellT) -&gt; HasAtomCellT:\n        \\\"\"\"\nForget any cell repetitions.\nAfterwards, ``self.explode().cell.cell_size == self.cell.box_size``.\n        \\\"\"\"\n        # when we explode, we need to make sure atoms aren't stored in cell coordinates\n        return self.to_frame('local').with_cell(self.get_cell().explode())\n    \"\"\"\ndef _repeat_to_contain(self: HasAtomCellT, pts: numpy.ndarray, pad: int = 0, frame: CoordinateFrame = 'cell_frac') -&gt; HasAtomCellT:\n#print(f\"pts: {pts} in frame {frame}\")\npts = self.get_transform('cell_frac', frame) @ pts\nbbox = BBox3D.unit() | BBox3D.from_pts(pts)\nmin_bounds = numpy.floor(bbox.min).astype(int) - pad\nmax_bounds = numpy.ceil(bbox.max).astype(int) + pad\n#print(f\"tiling to {min_bounds}, {max_bounds}\")\nrepeat = max_bounds - min_bounds\ncells = numpy.stack(numpy.meshgrid(*map(numpy.arange, repeat))).reshape(3, -1).T.astype(float)\natoms = self.get_atoms('cell_frac')\natoms = Atoms.concat([\natoms.transform(AffineTransform3D.translate(cell))\nfor cell in cells\n])\n#print(f\"atoms:\\n{atoms}\")\ncell = self.get_cell().repeat(repeat) \\\n            .transform_cell(AffineTransform3D.translate(min_bounds), 'cell_frac')\nreturn self.with_cell(cell).with_atoms(atoms, 'cell_frac')\ndef repeat(self: HasAtomCellT, n: t.Union[int, VecLike]) -&gt; HasAtomCellT:\n\"\"\"Tile the cell\"\"\"\nns = numpy.broadcast_to(n, 3)\nif not numpy.issubdtype(ns.dtype, numpy.integer):\nraise ValueError(f\"repeat() argument must be an integer or integer array.\")\ncells = numpy.stack(numpy.meshgrid(*map(numpy.arange, ns))) \\\n            .reshape(3, -1).T.astype(float)\ncells = cells * self.box_size\natoms = self.get_atoms('cell')\natoms = Atoms.concat([\natoms.transform(AffineTransform3D.translate(cell))\nfor cell in cells\n]) #.transform(self.cell.get_transform('local', 'cell_frac'))\nreturn self.with_atoms(atoms, 'cell').with_cell(self.get_cell().repeat(ns))\ndef repeat_to(self: HasAtomCellT, size: VecLike, crop: t.Union[bool, t.Sequence[bool]] = False) -&gt; HasAtomCellT:\n\"\"\"\n        Repeat the cell so it is at least ``size`` along the crystal's axes.\n        If ``crop``, then crop the cell to exactly ``size``. This may break periodicity.\n        ``crop`` may be a vector, in which case you can specify cropping only along some axes.\n        \"\"\"\nsize = to_vec3(size)\ncell_size = self.cell_size * self.n_cells\nrepeat = numpy.maximum(numpy.ceil(size / cell_size).astype(int), 1)\natom_cell = self.repeat(repeat)\ncrop_v = to_vec3(crop, dtype=numpy.bool_)\nif numpy.any(crop_v):\ncrop_x, crop_y, crop_z = crop_v\nreturn atom_cell.crop(\nx_max = size[0] if crop_x else numpy.inf,\ny_max = size[1] if crop_y else numpy.inf,\nz_max = size[2] if crop_z else numpy.inf,\nframe='cell'\n)\nreturn atom_cell\ndef repeat_x(self: HasAtomCellT, n: int) -&gt; HasAtomCellT:\n\"\"\"Tile the cell in the x axis.\"\"\"\nreturn self.repeat((n, 1, 1))\ndef repeat_y(self: HasAtomCellT, n: int) -&gt; HasAtomCellT:\n\"\"\"Tile the cell in the y axis.\"\"\"\nreturn self.repeat((1, n, 1))\ndef repeat_z(self: HasAtomCellT, n: int) -&gt; HasAtomCellT:\n\"\"\"Tile the cell in the z axis.\"\"\"\nreturn self.repeat((1, 1, n))\ndef repeat_to_x(self: HasAtomCellT, size: float, crop: bool = False) -&gt; HasAtomCellT:\n\"\"\"Repeat the cell so it is at least size ``size`` along the x axis.\"\"\"\nreturn self.repeat_to([size, 0., 0.], [crop, False, False])\ndef repeat_to_y(self: HasAtomCellT, size: float, crop: bool = False) -&gt; HasAtomCellT:\n\"\"\"Repeat the cell so it is at least size ``size`` along the y axis.\"\"\"\nreturn self.repeat_to([0., size, 0.], [False, crop, False])\ndef repeat_to_z(self: HasAtomCellT, size: float, crop: bool = False) -&gt; HasAtomCellT:\n\"\"\"Repeat the cell so it is at least size ``size`` along the z axis.\"\"\"\nreturn self.repeat_to([0., 0., size], [False, False, crop])\ndef repeat_to_aspect(self: HasAtomCellT, plane: t.Literal['xy', 'xz', 'yz'] = 'xy', *,\naspect: float = 1., min_size: t.Optional[VecLike] = None,\nmax_size: t.Optional[VecLike] = None) -&gt; HasAtomCellT:\n\"\"\"\n        Repeat to optimize the aspect ratio in ``plane``,\n        while staying above ``min_size`` and under ``max_size``.\n        \"\"\"\nif min_size is None:\nmin_n = numpy.array([1, 1, 1], numpy.int_)\nelse:\nmin_n = numpy.maximum(numpy.ceil(to_vec3(min_size) / self.box_size), 1).astype(numpy.int_)\nif max_size is None:\nmax_n = 3 * min_n\nelse:\nmax_n = numpy.maximum(numpy.floor(to_vec3(max_size) / self.box_size), 1).astype(numpy.int_)\nif plane == 'xy':\nindices = [0, 1]\nelif plane == 'xz':\nindices = [0, 2]\nelif plane == 'yz':\nindices = [1, 2]\nelse:\nraise ValueError(f\"Invalid plane '{plane}'. Exepcted 'xy', 'xz', 'or 'yz'.\")\nna = numpy.arange(min_n[indices[0]], max_n[indices[0]])\nnb = numpy.arange(min_n[indices[1]], max_n[indices[1]])\n(na, nb) = numpy.meshgrid(na, nb)\naspects = na * self.box_size[indices[0]] / (nb * self.box_size[indices[1]])\n# cost function: log(aspect)^2  (so cost(0.5) == cost(2))\nmin_i = numpy.argmin(numpy.log(aspects / aspect)**2)\nrepeat = numpy.array([1, 1, 1], numpy.int_)\nrepeat[indices] = na.flatten()[min_i], nb.flatten()[min_i]\nreturn self.repeat(repeat)\ndef periodic_duplicate(self: HasAtomCellT, eps: float = 1e-5) -&gt; HasAtomCellT:\n\"\"\"\n        Add duplicate copies of atoms near periodic boundaries.\n        For instance, an atom at a corner will be duplicated into 8 copies.\n        This is mostly only useful for visualization.\n        \"\"\"\nframe_save = self.get_frame()\nself = self.to_frame('cell_box').wrap(eps=eps)\nfor i, ax in enumerate(('x', 'y', 'z')):\nself = self.concat((self,\nself.filter(polars.col(ax).abs() &lt;= eps, frame='cell_box')\n.transform_atoms(AffineTransform3D.translate([1. if i == j else 0. for j in range(3)]), frame='cell_box')\n))\nreturn self.to_frame(frame_save)\n# add frame to some HasAtoms methods\n@_fwd_atoms_transform\ndef filter(self: HasAtomCellT, selection: t.Optional[AtomSelection] = None, *,\nframe: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n\"\"\"Filter ``self``, removing rows which evaluate to ``False``.\"\"\"\n...\n@_fwd_atoms_get\ndef select(self, exprs: t.Union[str, polars.Expr, polars.Series, t.Sequence[t.Union[str, polars.Expr, polars.Series]]], *,\nframe: t.Optional[CoordinateFrame] = None) -&gt; polars.DataFrame:\n\"\"\"\n        Select ``exprs`` from ``self``, and return as a :py:class:`polars.DataFrame`.\n        Expressions may either be columns or expressions of columns.\n        \"\"\"\n...\n@_fwd_atoms_get\ndef try_select(self, exprs: t.Union[str, polars.Expr, polars.Series, t.Sequence[t.Union[str, polars.Expr, polars.Series]]], *,\nframe: t.Optional[CoordinateFrame] = None) -&gt; t.Optional[polars.DataFrame]:\n\"\"\"\n        Try to select ``exprs`` from ``self``, and return as a :py:class:`polars.DataFrame`.\n        Expressions may either be columns or expressions of columns.\n        Return ``None`` if any columns are missing.\n        \"\"\"\n...\n@_fwd_atoms_transform\ndef sort(self: HasAtomCellT, by: t.Union[str, polars.Expr, t.List[str], t.List[polars.Expr]],\ndescending: t.Union[bool, t.List[bool]] = False, *,\nframe: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n...\n@_fwd_atoms_transform\ndef with_column(self: HasAtomCellT, column: t.Union[polars.Series, polars.Expr], *,\nframe: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n\"\"\"Return a copy of ``self`` with the given column added.\"\"\"\n...\ndef with_columns(self: HasAtomCellT,\nexprs: t.Union[t.Literal[None], polars.Series, polars.Expr, t.Sequence[t.Union[polars.Series, polars.Expr]]], *,\nframe: t.Optional[CoordinateFrame] = None,\n**named_exprs: t.Union[polars.Expr, polars.Series]) -&gt; HasAtomCellT:\n\"\"\"Return a copy of ``self`` with the given columns added.\"\"\"\n...\n@_fwd_atoms_transform\ndef round_near_zero(self: HasAtomCellT, tol: float = 1e-14, *,\nframe: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n\"\"\"\n        Round atom position values near zero to zero.\n        \"\"\"\n...\n@_fwd_atoms_get\ndef coords(self, selection: t.Optional[AtomSelection] = None, *, frame: t.Optional[CoordinateFrame] = None) -&gt; NDArray[numpy.float64]:\n\"\"\"Returns a ``(N, 3)`` ndarray of atom coordinates (dtype ``numpy.float64``).\"\"\"\n...\n@_fwd_atoms_get\ndef velocities(self, selection: t.Optional[AtomSelection] = None, *, frame: t.Optional[CoordinateFrame] = None) -&gt; t.Optional[NDArray[numpy.float64]]:\n\"\"\"Returns a ``(N, 3)`` ndarray of atom velocities (dtype ``numpy.float64``).\"\"\"\n...\n@t.overload\ndef add_atom(self: HasAtomCellT, elem: t.Union[int, str], x: ArrayLike, /, *,\ny: None = None, z: None = None, frame: t.Optional[CoordinateFrame] = None,\n**kwargs: t.Any) -&gt; HasAtomCellT:\n...\n@t.overload\ndef add_atom(self: HasAtomCellT, elem: t.Union[int, str], /,\nx: float, y: float, z: float, *,\nframe: t.Optional[CoordinateFrame] = None,\n**kwargs: t.Any) -&gt; HasAtomCellT:\n...\n@_fwd_atoms_transform\ndef add_atom(self: HasAtomCellT, elem: t.Union[int, str], /,  # type: ignore (spurious)\nx: t.Union[ArrayLike, float],\ny: t.Optional[float] = None,\nz: t.Optional[float] = None, *,\nframe: t.Optional[CoordinateFrame] = None,\n**kwargs: t.Any) -&gt; HasAtomCellT:\n\"\"\"\n        Return a copy of ``self`` with an extra atom.\n        By default, all extra columns present in ``self`` must be specified as ``**kwargs``.\n        Try to avoid calling this in a loop (Use :py:meth:`concat` instead).\n        \"\"\"\n...\n@_fwd_atoms_transform\ndef with_index(self: HasAtomCellT, index: t.Optional[AtomValues] = None, *,\nframe: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n\"\"\"\n        Returns ``self`` with a row index added in column 'i' (dtype polars.Int64).\n        If ``index`` is not specified, defaults to an existing index or a new index.\n        \"\"\"\n...\n@_fwd_atoms_transform\ndef with_wobble(self: HasAtomCellT, wobble: t.Optional[AtomValues] = None, *,\nframe: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n\"\"\"\n        Return ``self`` with the given displacements in column 'wobble' (dtype polars.Float64).\n        If ``wobble`` is not specified, defaults to the already-existing wobbles or 0.\n        \"\"\"\n...\n@_fwd_atoms_transform\ndef with_occupancy(self: HasAtomCellT, frac_occupancy: t.Optional[AtomValues] = None, *,\nframe: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n\"\"\"\n        Return self with the given fractional occupancies. If ``frac_occupancy`` is not specified,\n        defaults to the already-existing occupancies or 1.\n        \"\"\"\n...\n@_fwd_atoms_transform\ndef apply_wobble(self: HasAtomCellT, rng: t.Union[numpy.random.Generator, int, None] = None,\nframe: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n\"\"\"\n        Displace the atoms in ``self`` by the amount in the `wobble` column.\n        ``wobble`` is interpretated as a mean-squared displacement, which is distributed\n        equally over each axis.\n        \"\"\"\n...\n@_fwd_atoms_transform\ndef with_type(self: HasAtomCellT, types: t.Optional[AtomValues] = None, *,\nframe: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n\"\"\"\n        Return ``self`` with the given atom types in column 'type'.\n        If ``types`` is not specified, use the already existing types or auto-assign them.\n        When auto-assigning, each symbol is given a unique value, case-sensitive.\n        Values are assigned from lowest atomic number to highest.\n        For instance: ``[\"Ag+\", \"Na\", \"H\", \"Ag\"]`` =&gt; ``[3, 11, 1, 2]``\n        \"\"\"\n...\n@_fwd_atoms_transform\ndef with_mass(self: HasAtomCellT, mass: t.Optional[ArrayLike] = None, *,\nframe: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n\"\"\"\n        Return ``self`` with the given atom masses in column 'mass'.\n        If ``mass`` is not specified, use the already existing masses or auto-assign them.\n        \"\"\"\n...\n@_fwd_atoms_transform\ndef with_symbol(self: HasAtomCellT, symbols: ArrayLike, selection: t.Optional[AtomSelection] = None, *,\nframe: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n\"\"\"\n        Return ``self`` with the given atomic symbols.\n        \"\"\"\n...\n@_fwd_atoms_transform\ndef with_coords(self: HasAtomCellT, pts: ArrayLike, selection: t.Optional[AtomSelection] = None, *,\nframe: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n\"\"\"\n        Return ``self`` replaced with the given atomic positions.\n        \"\"\"\n...\n@_fwd_atoms_transform\ndef with_velocity(self: HasAtomCellT, pts: t.Optional[ArrayLike] = None,\nselection: t.Optional[AtomSelection] = None, *,\nframe: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n\"\"\"\n        Return ``self`` replaced with the given atomic velocities.\n        If ``pts`` is not specified, use the already existing velocities or zero.\n        \"\"\"\n...\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.affine","title":"<code>affine: AffineTransform3D</code>  <code>property</code>","text":"<p>Affine transformation. Holds transformation from 'ortho' to 'local' coordinates, including rotation away from the standard crystal orientation.</p>"},{"location":"api/#atomlib.HasAtomCell.ortho","title":"<code>ortho: LinearTransform3D</code>  <code>property</code>","text":"<p>Orthogonalization transformation. Skews but does not scale the crystal axes to cartesian axes.</p>"},{"location":"api/#atomlib.HasAtomCell.metric","title":"<code>metric: LinearTransform3D</code>  <code>property</code>","text":"<p>Cell metric tensor</p> <p>Returns the dot product between every combination of basis vectors. :math:<code>\\mathbf{a} \\cdot \\mathbf{b} = a_i M_ij b_j</code></p>"},{"location":"api/#atomlib.HasAtomCell.cell_size","title":"<code>cell_size: NDArray[numpy.float_]</code>  <code>property</code>","text":"<p>Unit cell size.</p>"},{"location":"api/#atomlib.HasAtomCell.cell_angle","title":"<code>cell_angle: NDArray[numpy.float_]</code>  <code>property</code>","text":"<p>Unit cell angles, in radians.</p>"},{"location":"api/#atomlib.HasAtomCell.n_cells","title":"<code>n_cells: NDArray[numpy.int_]</code>  <code>property</code>","text":"<p>Number of unit cells.</p>"},{"location":"api/#atomlib.HasAtomCell.pbc","title":"<code>pbc: NDArray[numpy.bool_]</code>  <code>property</code>","text":"<p>Flags indicating the presence of periodic boundary conditions along each axis.</p>"},{"location":"api/#atomlib.HasAtomCell.ortho_size","title":"<code>ortho_size: NDArray[numpy.float_]</code>  <code>property</code>","text":"<p>Return size of orthogonal unit cell.</p> <p>Equivalent to the diagonal of the orthogonalization matrix.</p>"},{"location":"api/#atomlib.HasAtomCell.box_size","title":"<code>box_size: NDArray[numpy.float_]</code>  <code>property</code>","text":"<p>Return size of the cell box.</p> <p>Equivalent to <code>self.n_cells * self.cell_size</code>.</p>"},{"location":"api/#atomlib.HasAtomCell.columns","title":"<code>columns: t.Sequence[str]</code>  <code>property</code>","text":"<p>Return the columns in <code>self</code>.</p>"},{"location":"api/#atomlib.HasAtomCell.schema","title":"<code>schema: SchemaDict</code>  <code>property</code>","text":"<p>Return the schema of <code>self</code>.</p>"},{"location":"api/#atomlib.HasAtomCell.unique","title":"<code>unique = deduplicate</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#atomlib.HasAtomCell.get_cell","title":"<code>get_cell()</code>  <code>abstractmethod</code>","text":"<p>Get the cell contained in <code>self</code>. This should be a low cost method.</p> Source code in <code>atomlib/cell.py</code> <pre><code>@abc.abstractmethod\ndef get_cell(self) -&gt; Cell:\n\"\"\"Get the cell contained in ``self``. This should be a low cost method.\"\"\"\n...\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.get_transform","title":"<code>get_transform(frame_to=None, frame_from=None)</code>","text":"<p>In the two-argument form, get the transform to 'frame_to' from 'frame_from'. In the one-argument form, get the transform from local coordinates to 'frame'.</p> Source code in <code>atomlib/cell.py</code> <pre><code>def get_transform(self, frame_to: t.Optional[CoordinateFrame] = None, frame_from: t.Optional[CoordinateFrame] = None) -&gt; AffineTransform3D:\n\"\"\"\n    In the two-argument form, get the transform to 'frame_to' from 'frame_from'.\n    In the one-argument form, get the transform from local coordinates to 'frame'.\n    \"\"\"\ntransform_from = self._get_transform_to_local(frame_from) if frame_from is not None else AffineTransform3D()\ntransform_to = self._get_transform_to_local(frame_to) if frame_to is not None else AffineTransform3D()\nif frame_from is not None and frame_to is not None and frame_from.lower() == frame_to.lower():\nreturn AffineTransform3D()\nreturn transform_to.inverse() @ transform_from\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.corners","title":"<code>corners(frame='local')</code>","text":"Source code in <code>atomlib/cell.py</code> <pre><code>def corners(self, frame: CoordinateFrame = 'local') -&gt; numpy.ndarray:\ncorners = numpy.array(list(itertools.product((0., 1.), repeat=3)))\nreturn self.get_transform(frame, 'cell_box') @ corners\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.bbox_cell","title":"<code>bbox_cell(frame='local')</code>","text":"<p>Return the bounding box of the cell box in the given coordinate system.</p> Source code in <code>atomlib/cell.py</code> <pre><code>def bbox_cell(self, frame: CoordinateFrame = 'local') -&gt; BBox3D:\n\"\"\"Return the bounding box of the cell box in the given coordinate system.\"\"\"\nreturn BBox3D.from_pts(self.corners(frame))\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.is_orthogonal","title":"<code>is_orthogonal(tol=1e-08)</code>","text":"<p>Returns whether this cell is orthogonal (axes are at right angles.)</p> Source code in <code>atomlib/cell.py</code> <pre><code>def is_orthogonal(self, tol: float = 1e-8) -&gt; bool:\n\"\"\"Returns whether this cell is orthogonal (axes are at right angles.)\"\"\"\nreturn self.ortho.is_diagonal(tol=tol)\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.is_orthogonal_in_local","title":"<code>is_orthogonal_in_local(tol=1e-08)</code>","text":"<p>Returns whether this cell is orthogonal and aligned with the local coordinate system.</p> Source code in <code>atomlib/cell.py</code> <pre><code>def is_orthogonal_in_local(self, tol: float = 1e-8) -&gt; bool:\n\"\"\"Returns whether this cell is orthogonal and aligned with the local coordinate system.\"\"\"\ntransform = (self.affine @ self.ortho).to_linear()\nif not transform.is_scaled_orthogonal(tol):\nreturn False\nnormed = transform.inner / numpy.linalg.norm(transform.inner, axis=-2, keepdims=True)\n# every row of transform must be a +/- 1 times a basis vector (i, j, or k)\nreturn all(\nany(numpy.isclose(numpy.abs(numpy.dot(row, v)), 1., atol=tol) for v in numpy.eye(3))\nfor row in normed\n)\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.to_ortho","title":"<code>to_ortho()</code>","text":"Source code in <code>atomlib/cell.py</code> <pre><code>def to_ortho(self) -&gt; AffineTransform3D:\nreturn self.get_transform('local', 'cell_box')\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.strain_orthogonal","title":"<code>strain_orthogonal()</code>","text":"<p>Orthogonalize using strain.</p> <p>Strain is applied such that the x-axis remains fixed, and the y-axis remains in the xy plane. For small displacements, no hydrostatic strain is applied (volume is conserved).</p> Source code in <code>atomlib/cell.py</code> <pre><code>def strain_orthogonal(self: HasCellT) -&gt; HasCellT:\n\"\"\"\n    Orthogonalize using strain.\n    Strain is applied such that the x-axis remains fixed, and the y-axis remains in the xy plane.\n    For small displacements, no hydrostatic strain is applied (volume is conserved).\n    \"\"\"\nreturn self.with_cell(Cell(\naffine=self.affine,\northo=LinearTransform3D(),\ncell_size=self.cell_size,\nn_cells=self.n_cells,\npbc=self.pbc,\n))\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.explode","title":"<code>explode()</code>","text":"<p>Materialize repeated cells as one supercell.</p> Source code in <code>atomlib/cell.py</code> <pre><code>def explode(self: HasCellT) -&gt; HasCellT:\n\"\"\"Materialize repeated cells as one supercell.\"\"\"\nreturn self.with_cell(Cell(\naffine=self.affine,\northo=self.ortho,\ncell_size=self.cell_size*self.n_cells,\ncell_angle=self.cell_angle,\npbc=self.pbc,\n))\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.explode_z","title":"<code>explode_z()</code>","text":"<p>Materialize repeated cells as one supercell in z.</p> Source code in <code>atomlib/cell.py</code> <pre><code>def explode_z(self: HasCellT) -&gt; HasCellT:\n\"\"\"Materialize repeated cells as one supercell in z.\"\"\"\nreturn self.with_cell(Cell(\naffine=self.affine,\northo=self.ortho,\ncell_size=self.cell_size*[1, 1, self.n_cells[2]],\nn_cells=[*self.n_cells[:2], 1],\ncell_angle=self.cell_angle,\npbc=self.pbc,\n))\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.change_transform","title":"<code>change_transform(transform, frame_to=None, frame_from=None)</code>","text":"<p>Coordinate-change a transformation to 'frame_to' from 'frame_from'.</p> Source code in <code>atomlib/cell.py</code> <pre><code>def change_transform(self, transform: Transform3D,\nframe_to: t.Optional[CoordinateFrame] = None,\nframe_from: t.Optional[CoordinateFrame] = None) -&gt; Transform3D:\n\"\"\"Coordinate-change a transformation to 'frame_to' from 'frame_from'.\"\"\"\nif frame_to == frame_from and frame_to is not None:\nreturn transform\ncoord_change = self.get_transform(frame_to, frame_from)\nreturn coord_change @ transform @ coord_change.inverse()\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.assert_equal","title":"<code>assert_equal(other)</code>","text":"Source code in <code>atomlib/atoms.py</code> <pre><code>def assert_equal(self, other: t.Any):\nassert isinstance(other, HasAtoms)\nassert self.schema == other.schema\nfor (col, dtype) in self.schema.items():\nif dtype in (polars.Float32, polars.Float64):\nnumpy.testing.assert_array_almost_equal(self[col].view(ignore_nulls=True), other[col].view(ignore_nulls=True), 5)\nelse:\nassert (self[col] == other[col]).all()\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.get_column","title":"<code>get_column(name)</code>","text":"<p>Get the specified column from <code>self</code>, raising :py:<code>polars.NotFoundError</code> if it's not present.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def get_column(self, name: str) -&gt; polars.Series:\n\"\"\"Get the specified column from ``self``, raising :py:`polars.NotFoundError` if it's not present.\"\"\"\nreturn self._get_frame().get_column(name)\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.concat","title":"<code>concat(atoms, *, rechunk=True, how='vertical')</code>  <code>classmethod</code>","text":"Source code in <code>atomlib/atoms.py</code> <pre><code>@classmethod\ndef concat(cls: t.Type[HasAtomsT],\natoms: t.Union[HasAtomsT, IntoAtoms, t.Iterable[t.Union[HasAtomsT, IntoAtoms]]], *,\nrechunk: bool = True, how: ConcatMethod = 'vertical') -&gt; HasAtomsT:\n# this method is tricky. It needs to accept raw Atoms, as well as HasAtoms of the\n# same type as ``cls``.\nif _is_abstract(cls):\nraise TypeError(f\"concat() must be called on a concrete class.\")\nif isinstance(atoms, HasAtoms):\natoms = (atoms,)\ndfs = [a.get_atoms('local').inner if isinstance(a, HasAtoms) else Atoms(a).inner for a in atoms]\nrepresentative = cls._combine_metadata(*(a for a in atoms if isinstance(a, HasAtoms)))\nif len(dfs) == 0:\nreturn representative.with_atoms(Atoms.empty(), 'local')\nif how in ('vertical', 'vertical_relaxed'):\n# get order from first member\ncols = dfs[0].columns\ndfs = [df.select(cols) for df in dfs]\nelif how == 'inner':\ncols = reduce(operator.and_, (df.schema.keys() for df in dfs))\nschema = t.cast(SchemaDict, {col: dfs[0].schema[col] for col in cols})\nif len(schema) == 0:\nraise ValueError(f\"Atoms have no columns in common\")\ndfs = [_select_schema(df, schema) for df in dfs]\nhow = 'vertical'\nreturn representative.with_atoms(Atoms(polars.concat(dfs, rechunk=rechunk, how=how)), 'local')\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.select_schema","title":"<code>select_schema(schema)</code>","text":"<p>Select columns from <code>self</code> and cast to the given schema. Raises :py:<code>TypeError</code> if a column is not found or if it can't be cast.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def select_schema(self, schema: SchemaDict) -&gt; polars.DataFrame:\n\"\"\"\n    Select columns from ``self`` and cast to the given schema.\n    Raises :py:`TypeError` if a column is not found or if it can't be cast.\n    \"\"\"\nreturn _select_schema(self, schema)\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.try_get_column","title":"<code>try_get_column(name)</code>","text":"<p>Try to get a column from <code>self</code>, returning <code>None</code> if it doesn't exist.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def try_get_column(self, name: str) -&gt; t.Optional[polars.Series]:\n\"\"\"Try to get a column from `self`, returning `None` if it doesn't exist.\"\"\"\ntry:\nreturn self.get_column(name)\nexcept ColumnNotFoundError:\nreturn None\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.deduplicate","title":"<code>deduplicate(tol=0.001, subset=('x', 'y', 'z', 'symbol'), keep='first')</code>","text":"<p>De-duplicate atoms in <code>self</code>. Atoms of the same <code>symbol</code> that are closer than <code>tolerance</code> to each other (by Euclidian distance) will be removed, leaving only the atom specified by <code>keep</code> (defaults to the first atom).</p> <p>If <code>subset</code> is specified, only those columns will be included while assessing duplicates. Floating point columns other than 'x', 'y', and 'z' will not by toleranced.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def deduplicate(self: HasAtomsT, tol: float = 1e-3, subset: t.Iterable[str] = ('x', 'y', 'z', 'symbol'),\nkeep: UniqueKeepStrategy = 'first') -&gt; HasAtomsT:\n\"\"\"\n    De-duplicate atoms in `self`. Atoms of the same `symbol` that are closer than `tolerance`\n    to each other (by Euclidian distance) will be removed, leaving only the atom specified by\n    `keep` (defaults to the first atom).\n    If `subset` is specified, only those columns will be included while assessing duplicates.\n    Floating point columns other than 'x', 'y', and 'z' will not by toleranced.\n    \"\"\"\ncols = set((subset,) if isinstance(subset, str) else subset)\nindices = numpy.arange(len(self))\nspatial_cols = cols.intersection(('x', 'y', 'z'))\ncols -= spatial_cols\nif len(spatial_cols) &gt; 0:\ncoords = self.select(list(spatial_cols)).to_numpy()\nprint(coords.shape)\ntree = scipy.spatial.KDTree(coords)\n# TODO This is a bad algorithm\nwhile True:\nchanged = False\nfor (i, j) in tree.query_pairs(tol, 2.):\n# whenever we encounter a pair, ensure their index matches\ni_i, i_j = indices[[i, j]]\nif i_i != i_j:\nindices[i] = indices[j] = min(i_i, i_j)\nchanged = True\nif not changed:\nbreak\nself = self.with_column(polars.Series('_unique_pts', indices))\ncols.add('_unique_pts')\nframe = self._get_frame().unique(subset=list(cols), keep=keep)\nif len(spatial_cols) &gt; 0:\nframe = frame.drop('_unique_pts')\nreturn self.with_atoms(Atoms(frame, _unchecked=True))\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.with_bounds","title":"<code>with_bounds(cell_size=None, cell_origin=None)</code>","text":"<p>Return a periodic cell with the given orthogonal cell dimensions.</p> <p>If cell_size is not specified, it will be assumed (and may be incorrect).</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def with_bounds(self, cell_size: t.Optional[VecLike] = None, cell_origin: t.Optional[VecLike] = None) -&gt; 'AtomCell':\n\"\"\"\n    Return a periodic cell with the given orthogonal cell dimensions.\n    If cell_size is not specified, it will be assumed (and may be incorrect).\n    \"\"\"\n# TODO: test this\nfrom .atomcell import AtomCell\nif cell_size is None:\nwarnings.warn(\"Cell boundary unknown. Defaulting to cell BBox\")\ncell_size = self.bbox().size\ncell_origin = self.bbox().min\n# TODO test this origin code\ncell = Cell.from_unit_cell(cell_size)\nif cell_origin is not None:\ncell = cell.transform_cell(AffineTransform3D.translate(to_vec3(cell_origin)))\nreturn AtomCell(self.get_atoms(), cell, frame='local')\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.types","title":"<code>types()</code>","text":"<p>Returns a <code>Series</code> of atom types (dtype polars.Int32).</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def types(self) -&gt; t.Optional[polars.Series]:\n\"\"\"Returns a `Series` of atom types (dtype polars.Int32).\"\"\"\nreturn self.try_get_column('type')\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.masses","title":"<code>masses()</code>","text":"<p>Returns a <code>Series</code> of atom masses (dtype polars.Float32).</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def masses(self) -&gt; t.Optional[polars.Series]:\n\"\"\"Returns a `Series` of atom masses (dtype polars.Float32).\"\"\"\nreturn self.try_get_column('mass')\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.pos","title":"<code>pos(x=None, y=None, z=None, *, tol=1e-06, **kwargs)</code>","text":"<p>Select all atoms at a given position.</p> <p>Formally, returns all atoms within a cube of radius <code>tol</code> centered at <code>(x,y,z)</code>, exclusive of the cube's surface.</p> <p>Additional parameters given as <code>kwargs</code> will be checked as additional parameters (with strict equality).</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def pos(self,\nx: t.Union[t.Sequence[t.Optional[float]], float, None] = None,\ny: t.Optional[float] = None, z: t.Optional[float] = None, *,\ntol: float = 1e-6, **kwargs: t.Any) -&gt; polars.Expr:\n\"\"\"\n    Select all atoms at a given position.\n    Formally, returns all atoms within a cube of radius ``tol``\n    centered at ``(x,y,z)``, exclusive of the cube's surface.\n    Additional parameters given as ``kwargs`` will be checked\n    as additional parameters (with strict equality).\n    \"\"\"\nif isinstance(x, t.Sequence):\n(x, y, z) = x\ntol = abs(float(tol))\nselection = polars.lit(True)\nif x is not None:\nselection &amp;= (x - tol &lt; polars.col('x')) &amp; (polars.col('x') &lt; x + tol)\nif y is not None:\nselection &amp;= (y - tol &lt; polars.col('y')) &amp; (polars.col('y') &lt; y + tol)\nif z is not None:\nselection &amp;= (z - tol &lt; polars.col('z')) &amp; (polars.col('z') &lt; z + tol)\nfor (col, val) in kwargs.items():\nselection &amp;= (polars.col(col) == val)\nreturn selection\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.apply_occupancy","title":"<code>apply_occupancy(rng=None)</code>","text":"<p>For each atom in <code>self</code>, use its <code>frac_occupancy</code> to randomly decide whether to remove it.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def apply_occupancy(self: HasAtomsT, rng: t.Union[numpy.random.Generator, int, None] = None) -&gt; HasAtomsT:\n\"\"\"\n    For each atom in `self`, use its `frac_occupancy` to randomly decide whether to remove it.\n    \"\"\"\nif 'frac_occupancy' not in self.columns:\nreturn self\nrng = numpy.random.default_rng(seed=rng)\nfrac = self.select('frac_occupancy').to_series().to_numpy()\nchoice = rng.binomial(1, frac).astype(numpy.bool_)\nreturn self.filter(polars.lit(choice))\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.get_frame","title":"<code>get_frame()</code>  <code>abstractmethod</code>","text":"<p>Get the coordinate frame atoms are stored in.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@abc.abstractmethod\ndef get_frame(self) -&gt; CoordinateFrame:\n\"\"\"Get the coordinate frame atoms are stored in.\"\"\"\n...\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.with_atoms","title":"<code>with_atoms(atoms, frame=None)</code>  <code>abstractmethod</code>","text":"<p>Replace the atoms in <code>self</code>. If no coordinate frame is specified, keep the coordinate frame unchanged.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@abc.abstractmethod\ndef with_atoms(self: HasAtomCellT, atoms: HasAtoms, frame: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n\"\"\"\n    Replace the atoms in ``self``. If no coordinate frame is specified, keep the coordinate frame unchanged.\n    \"\"\"\n...\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.with_cell","title":"<code>with_cell(cell)</code>","text":"<p>Replace the cell in <code>self</code>, without touching the atomic coordinates.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def with_cell(self: HasAtomCellT, cell: Cell) -&gt; HasAtomCellT:\n\"\"\"\n    Replace the cell in ``self``, without touching the atomic coordinates.\n    \"\"\"\nreturn self.to_frame('local').with_cell(cell)\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.get_atomcell","title":"<code>get_atomcell()</code>","text":"Source code in <code>atomlib/atomcell.py</code> <pre><code>def get_atomcell(self) -&gt; AtomCell:\nframe = self.get_frame()\nreturn AtomCell(self.get_atoms(frame), self.get_cell(), frame=frame, keep_frame=True)\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.get_atoms","title":"<code>get_atoms(frame=None)</code>  <code>abstractmethod</code>","text":"<p>Get atoms contained in <code>self</code>, in the given coordinate frame.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@abc.abstractmethod\ndef get_atoms(self, frame: t.Optional[CoordinateFrame] = None) -&gt; Atoms:\n\"\"\"Get atoms contained in ``self``, in the given coordinate frame.\"\"\"\n...\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.bbox_atoms","title":"<code>bbox_atoms(frame=None)</code>","text":"<p>Return the bounding box of all the atoms in <code>self</code>, in the given coordinate frame.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def bbox_atoms(self, frame: t.Optional[CoordinateFrame] = None) -&gt; BBox3D:\n\"\"\"Return the bounding box of all the atoms in ``self``, in the given coordinate frame.\"\"\"\nreturn self.get_atoms(frame).bbox()\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.bbox","title":"<code>bbox(frame='local')</code>","text":"<p>Return the combined bounding box of the cell and atoms in the given coordinate system. To get the cell or atoms bounding box only, use :py:meth:<code>bbox_cell</code> or :py:meth:<code>bbox_atoms</code>.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def bbox(self, frame: CoordinateFrame = 'local') -&gt; BBox3D:\n\"\"\"\n    Return the combined bounding box of the cell and atoms in the given coordinate system.\n    To get the cell or atoms bounding box only, use :py:meth:`bbox_cell` or :py:meth:`bbox_atoms`.\n    \"\"\"\nreturn self.bbox_atoms(frame) | self.bbox_cell(frame)\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.to_frame","title":"<code>to_frame(frame)</code>","text":"<p>Convert the stored Atoms to the given coordinate frame.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def to_frame(self: HasAtomCellT, frame: CoordinateFrame) -&gt; HasAtomCellT:\n\"\"\"Convert the stored Atoms to the given coordinate frame.\"\"\"\nreturn self.with_atoms(self.get_atoms(frame), frame)\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.transform_atoms","title":"<code>transform_atoms(transform, selection=None, *, frame='local', transform_velocities=False)</code>","text":"<p>Transform the atoms in <code>self</code> by <code>transform</code>. If <code>selection</code> is given, only transform the atoms in <code>selection</code>.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def transform_atoms(self: HasAtomCellT, transform: IntoTransform3D, selection: t.Optional[AtomSelection] = None, *,\nframe: CoordinateFrame = 'local', transform_velocities: bool = False) -&gt; HasAtomCellT:\n\"\"\"\n    Transform the atoms in `self` by `transform`.\n    If `selection` is given, only transform the atoms in `selection`.\n    \"\"\"\ntransform = self.change_transform(Transform3D.make(transform), self.get_frame(), frame)\nreturn self.with_atoms(self.get_atoms(self.get_frame()).transform(transform, selection, transform_velocities=transform_velocities))\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.transform_cell","title":"<code>transform_cell(transform, frame='local')</code>","text":"<p>Apply the given transform to the unit cell, without changing atom positions. The transform is applied in coordinate frame 'frame'.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def transform_cell(self: HasAtomCellT, transform: AffineTransform3D, frame: CoordinateFrame = 'local') -&gt; HasAtomCellT:\n\"\"\"\n    Apply the given transform to the unit cell, without changing atom positions.\n    The transform is applied in coordinate frame 'frame'.\n    \"\"\"\nreturn self.with_cell(self.get_cell().transform_cell(transform, frame=frame))\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.transform","title":"<code>transform(transform, frame='local')</code>","text":"Source code in <code>atomlib/atomcell.py</code> <pre><code>def transform(self: HasAtomCellT, transform: AffineTransform3D, frame: CoordinateFrame = 'local') -&gt; HasAtomCellT:\nif isinstance(transform, Transform3D) and not isinstance(transform, AffineTransform3D):\nraise ValueError(\"Non-affine transforms cannot change the box dimensions. Use 'transform_atoms' instead.\")\n# TODO: cleanup once tests pass\n# coordinate change the transform into atomic coordinates\nnew_cell = self.get_cell().transform_cell(transform, frame)\ntransform = self.get_cell().change_transform(transform, self.get_frame(), frame)\nreturn self.with_atoms(self.get_atoms().transform(transform), self.get_frame()).with_cell(new_cell)\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.crop","title":"<code>crop(x_min=-numpy.inf, x_max=numpy.inf, y_min=-numpy.inf, y_max=numpy.inf, z_min=-numpy.inf, z_max=numpy.inf, *, frame='local')</code>","text":"<p>Crop atoms and cell to the given extents. For a non-orthogonal cell, this must be specified in cell coordinates. This function implicity <code>explode</code>s the cell as well.</p> <p>To crop atoms only, use :py:meth:<code>crop_atoms</code> instead.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def crop(self: HasAtomCellT, x_min: float = -numpy.inf, x_max: float = numpy.inf,\ny_min: float = -numpy.inf, y_max: float = numpy.inf,\nz_min: float = -numpy.inf, z_max: float = numpy.inf, *,\nframe: CoordinateFrame = 'local') -&gt; HasAtomCellT:\n\"\"\"\n    Crop atoms and cell to the given extents. For a non-orthogonal\n    cell, this must be specified in cell coordinates. This\n    function implicity `explode`s the cell as well.\n    To crop atoms only, use :py:meth:`crop_atoms` instead.\n    \"\"\"\ncell = self.get_cell().crop(x_min, x_max, y_min, y_max, z_min, z_max, frame=frame)\natoms = self._transform_atoms_in_frame(frame, lambda atoms: atoms.crop_atoms(x_min, x_max, y_min, y_max, z_min, z_max))\nreturn self.with_cell(cell).with_atoms(atoms)\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.crop_atoms","title":"<code>crop_atoms(x_min=-numpy.inf, x_max=numpy.inf, y_min=-numpy.inf, y_max=numpy.inf, z_min=-numpy.inf, z_max=numpy.inf, *, frame='local')</code>","text":"Source code in <code>atomlib/atomcell.py</code> <pre><code>def crop_atoms(self: HasAtomCellT, x_min: float = -numpy.inf, x_max: float = numpy.inf,\ny_min: float = -numpy.inf, y_max: float = numpy.inf,\nz_min: float = -numpy.inf, z_max: float = numpy.inf, *,\nframe: CoordinateFrame = 'local') -&gt; HasAtomCellT:\natoms = self._transform_atoms_in_frame(frame, lambda atoms: atoms.crop_atoms(x_min, x_max, y_min, y_max, z_min, z_max))\nreturn self.with_atoms(atoms)\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.crop_to_box","title":"<code>crop_to_box(eps=1e-05)</code>","text":"Source code in <code>atomlib/atomcell.py</code> <pre><code>def crop_to_box(self: HasAtomCellT, eps: float = 1e-5) -&gt; HasAtomCellT:\natoms = self._transform_atoms_in_frame('cell_box', lambda atoms: atoms.crop_atoms(*([-eps, 1-eps]*3)))\nreturn self.with_atoms(atoms)\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.wrap","title":"<code>wrap(eps=1e-05)</code>","text":"<p>Wrap atoms around the cell boundaries.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def wrap(self: HasAtomCellT, eps: float = 1e-5) -&gt; HasAtomCellT:\n\"\"\"Wrap atoms around the cell boundaries.\"\"\"\ndef transform(atoms):\ncoords = atoms.coords()\ncoords = (coords + eps) % 1. - eps\nreturn atoms.with_coords(coords)\nreturn self.with_atoms(self._transform_atoms_in_frame('cell_box', transform))\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.repeat","title":"<code>repeat(n)</code>","text":"<p>Tile the cell</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def repeat(self: HasAtomCellT, n: t.Union[int, VecLike]) -&gt; HasAtomCellT:\n\"\"\"Tile the cell\"\"\"\nns = numpy.broadcast_to(n, 3)\nif not numpy.issubdtype(ns.dtype, numpy.integer):\nraise ValueError(f\"repeat() argument must be an integer or integer array.\")\ncells = numpy.stack(numpy.meshgrid(*map(numpy.arange, ns))) \\\n        .reshape(3, -1).T.astype(float)\ncells = cells * self.box_size\natoms = self.get_atoms('cell')\natoms = Atoms.concat([\natoms.transform(AffineTransform3D.translate(cell))\nfor cell in cells\n]) #.transform(self.cell.get_transform('local', 'cell_frac'))\nreturn self.with_atoms(atoms, 'cell').with_cell(self.get_cell().repeat(ns))\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.repeat_to","title":"<code>repeat_to(size, crop=False)</code>","text":"<p>Repeat the cell so it is at least <code>size</code> along the crystal's axes.</p> <p>If <code>crop</code>, then crop the cell to exactly <code>size</code>. This may break periodicity. <code>crop</code> may be a vector, in which case you can specify cropping only along some axes.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def repeat_to(self: HasAtomCellT, size: VecLike, crop: t.Union[bool, t.Sequence[bool]] = False) -&gt; HasAtomCellT:\n\"\"\"\n    Repeat the cell so it is at least ``size`` along the crystal's axes.\n    If ``crop``, then crop the cell to exactly ``size``. This may break periodicity.\n    ``crop`` may be a vector, in which case you can specify cropping only along some axes.\n    \"\"\"\nsize = to_vec3(size)\ncell_size = self.cell_size * self.n_cells\nrepeat = numpy.maximum(numpy.ceil(size / cell_size).astype(int), 1)\natom_cell = self.repeat(repeat)\ncrop_v = to_vec3(crop, dtype=numpy.bool_)\nif numpy.any(crop_v):\ncrop_x, crop_y, crop_z = crop_v\nreturn atom_cell.crop(\nx_max = size[0] if crop_x else numpy.inf,\ny_max = size[1] if crop_y else numpy.inf,\nz_max = size[2] if crop_z else numpy.inf,\nframe='cell'\n)\nreturn atom_cell\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.repeat_x","title":"<code>repeat_x(n)</code>","text":"<p>Tile the cell in the x axis.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def repeat_x(self: HasAtomCellT, n: int) -&gt; HasAtomCellT:\n\"\"\"Tile the cell in the x axis.\"\"\"\nreturn self.repeat((n, 1, 1))\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.repeat_y","title":"<code>repeat_y(n)</code>","text":"<p>Tile the cell in the y axis.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def repeat_y(self: HasAtomCellT, n: int) -&gt; HasAtomCellT:\n\"\"\"Tile the cell in the y axis.\"\"\"\nreturn self.repeat((1, n, 1))\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.repeat_z","title":"<code>repeat_z(n)</code>","text":"<p>Tile the cell in the z axis.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def repeat_z(self: HasAtomCellT, n: int) -&gt; HasAtomCellT:\n\"\"\"Tile the cell in the z axis.\"\"\"\nreturn self.repeat((1, 1, n))\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.repeat_to_x","title":"<code>repeat_to_x(size, crop=False)</code>","text":"<p>Repeat the cell so it is at least size <code>size</code> along the x axis.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def repeat_to_x(self: HasAtomCellT, size: float, crop: bool = False) -&gt; HasAtomCellT:\n\"\"\"Repeat the cell so it is at least size ``size`` along the x axis.\"\"\"\nreturn self.repeat_to([size, 0., 0.], [crop, False, False])\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.repeat_to_y","title":"<code>repeat_to_y(size, crop=False)</code>","text":"<p>Repeat the cell so it is at least size <code>size</code> along the y axis.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def repeat_to_y(self: HasAtomCellT, size: float, crop: bool = False) -&gt; HasAtomCellT:\n\"\"\"Repeat the cell so it is at least size ``size`` along the y axis.\"\"\"\nreturn self.repeat_to([0., size, 0.], [False, crop, False])\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.repeat_to_z","title":"<code>repeat_to_z(size, crop=False)</code>","text":"<p>Repeat the cell so it is at least size <code>size</code> along the z axis.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def repeat_to_z(self: HasAtomCellT, size: float, crop: bool = False) -&gt; HasAtomCellT:\n\"\"\"Repeat the cell so it is at least size ``size`` along the z axis.\"\"\"\nreturn self.repeat_to([0., 0., size], [False, False, crop])\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.repeat_to_aspect","title":"<code>repeat_to_aspect(plane='xy', *, aspect=1.0, min_size=None, max_size=None)</code>","text":"<p>Repeat to optimize the aspect ratio in <code>plane</code>, while staying above <code>min_size</code> and under <code>max_size</code>.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def repeat_to_aspect(self: HasAtomCellT, plane: t.Literal['xy', 'xz', 'yz'] = 'xy', *,\naspect: float = 1., min_size: t.Optional[VecLike] = None,\nmax_size: t.Optional[VecLike] = None) -&gt; HasAtomCellT:\n\"\"\"\n    Repeat to optimize the aspect ratio in ``plane``,\n    while staying above ``min_size`` and under ``max_size``.\n    \"\"\"\nif min_size is None:\nmin_n = numpy.array([1, 1, 1], numpy.int_)\nelse:\nmin_n = numpy.maximum(numpy.ceil(to_vec3(min_size) / self.box_size), 1).astype(numpy.int_)\nif max_size is None:\nmax_n = 3 * min_n\nelse:\nmax_n = numpy.maximum(numpy.floor(to_vec3(max_size) / self.box_size), 1).astype(numpy.int_)\nif plane == 'xy':\nindices = [0, 1]\nelif plane == 'xz':\nindices = [0, 2]\nelif plane == 'yz':\nindices = [1, 2]\nelse:\nraise ValueError(f\"Invalid plane '{plane}'. Exepcted 'xy', 'xz', 'or 'yz'.\")\nna = numpy.arange(min_n[indices[0]], max_n[indices[0]])\nnb = numpy.arange(min_n[indices[1]], max_n[indices[1]])\n(na, nb) = numpy.meshgrid(na, nb)\naspects = na * self.box_size[indices[0]] / (nb * self.box_size[indices[1]])\n# cost function: log(aspect)^2  (so cost(0.5) == cost(2))\nmin_i = numpy.argmin(numpy.log(aspects / aspect)**2)\nrepeat = numpy.array([1, 1, 1], numpy.int_)\nrepeat[indices] = na.flatten()[min_i], nb.flatten()[min_i]\nreturn self.repeat(repeat)\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.periodic_duplicate","title":"<code>periodic_duplicate(eps=1e-05)</code>","text":"<p>Add duplicate copies of atoms near periodic boundaries.</p> <p>For instance, an atom at a corner will be duplicated into 8 copies. This is mostly only useful for visualization.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def periodic_duplicate(self: HasAtomCellT, eps: float = 1e-5) -&gt; HasAtomCellT:\n\"\"\"\n    Add duplicate copies of atoms near periodic boundaries.\n    For instance, an atom at a corner will be duplicated into 8 copies.\n    This is mostly only useful for visualization.\n    \"\"\"\nframe_save = self.get_frame()\nself = self.to_frame('cell_box').wrap(eps=eps)\nfor i, ax in enumerate(('x', 'y', 'z')):\nself = self.concat((self,\nself.filter(polars.col(ax).abs() &lt;= eps, frame='cell_box')\n.transform_atoms(AffineTransform3D.translate([1. if i == j else 0. for j in range(3)]), frame='cell_box')\n))\nreturn self.to_frame(frame_save)\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.filter","title":"<code>filter(selection=None, *, frame=None)</code>","text":"<p>Filter <code>self</code>, removing rows which evaluate to <code>False</code>.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef filter(self: HasAtomCellT, selection: t.Optional[AtomSelection] = None, *,\nframe: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n\"\"\"Filter ``self``, removing rows which evaluate to ``False``.\"\"\"\n...\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.select","title":"<code>select(exprs, *, frame=None)</code>","text":"<p>Select <code>exprs</code> from <code>self</code>, and return as a :py:class:<code>polars.DataFrame</code>.</p> <p>Expressions may either be columns or expressions of columns.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_get\ndef select(self, exprs: t.Union[str, polars.Expr, polars.Series, t.Sequence[t.Union[str, polars.Expr, polars.Series]]], *,\nframe: t.Optional[CoordinateFrame] = None) -&gt; polars.DataFrame:\n\"\"\"\n    Select ``exprs`` from ``self``, and return as a :py:class:`polars.DataFrame`.\n    Expressions may either be columns or expressions of columns.\n    \"\"\"\n...\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.try_select","title":"<code>try_select(exprs, *, frame=None)</code>","text":"<p>Try to select <code>exprs</code> from <code>self</code>, and return as a :py:class:<code>polars.DataFrame</code>.</p> <p>Expressions may either be columns or expressions of columns. Return <code>None</code> if any columns are missing.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_get\ndef try_select(self, exprs: t.Union[str, polars.Expr, polars.Series, t.Sequence[t.Union[str, polars.Expr, polars.Series]]], *,\nframe: t.Optional[CoordinateFrame] = None) -&gt; t.Optional[polars.DataFrame]:\n\"\"\"\n    Try to select ``exprs`` from ``self``, and return as a :py:class:`polars.DataFrame`.\n    Expressions may either be columns or expressions of columns.\n    Return ``None`` if any columns are missing.\n    \"\"\"\n...\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.sort","title":"<code>sort(by, descending=False, *, frame=None)</code>","text":"Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef sort(self: HasAtomCellT, by: t.Union[str, polars.Expr, t.List[str], t.List[polars.Expr]],\ndescending: t.Union[bool, t.List[bool]] = False, *,\nframe: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n...\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.with_column","title":"<code>with_column(column, *, frame=None)</code>","text":"<p>Return a copy of <code>self</code> with the given column added.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef with_column(self: HasAtomCellT, column: t.Union[polars.Series, polars.Expr], *,\nframe: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n\"\"\"Return a copy of ``self`` with the given column added.\"\"\"\n...\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.with_columns","title":"<code>with_columns(exprs, *, frame=None, **named_exprs)</code>","text":"<p>Return a copy of <code>self</code> with the given columns added.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def with_columns(self: HasAtomCellT,\nexprs: t.Union[t.Literal[None], polars.Series, polars.Expr, t.Sequence[t.Union[polars.Series, polars.Expr]]], *,\nframe: t.Optional[CoordinateFrame] = None,\n**named_exprs: t.Union[polars.Expr, polars.Series]) -&gt; HasAtomCellT:\n\"\"\"Return a copy of ``self`` with the given columns added.\"\"\"\n...\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.round_near_zero","title":"<code>round_near_zero(tol=1e-14, *, frame=None)</code>","text":"<p>Round atom position values near zero to zero.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef round_near_zero(self: HasAtomCellT, tol: float = 1e-14, *,\nframe: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n\"\"\"\n    Round atom position values near zero to zero.\n    \"\"\"\n...\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.coords","title":"<code>coords(selection=None, *, frame=None)</code>","text":"<p>Returns a <code>(N, 3)</code> ndarray of atom coordinates (dtype <code>numpy.float64</code>).</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_get\ndef coords(self, selection: t.Optional[AtomSelection] = None, *, frame: t.Optional[CoordinateFrame] = None) -&gt; NDArray[numpy.float64]:\n\"\"\"Returns a ``(N, 3)`` ndarray of atom coordinates (dtype ``numpy.float64``).\"\"\"\n...\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.velocities","title":"<code>velocities(selection=None, *, frame=None)</code>","text":"<p>Returns a <code>(N, 3)</code> ndarray of atom velocities (dtype <code>numpy.float64</code>).</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_get\ndef velocities(self, selection: t.Optional[AtomSelection] = None, *, frame: t.Optional[CoordinateFrame] = None) -&gt; t.Optional[NDArray[numpy.float64]]:\n\"\"\"Returns a ``(N, 3)`` ndarray of atom velocities (dtype ``numpy.float64``).\"\"\"\n...\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.add_atom","title":"<code>add_atom(elem, /, x, y=None, z=None, *, frame=None, **kwargs)</code>","text":"<p>Return a copy of <code>self</code> with an extra atom.</p> <p>By default, all extra columns present in <code>self</code> must be specified as <code>**kwargs</code>.</p> <p>Try to avoid calling this in a loop (Use :py:meth:<code>concat</code> instead).</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef add_atom(self: HasAtomCellT, elem: t.Union[int, str], /,  # type: ignore (spurious)\nx: t.Union[ArrayLike, float],\ny: t.Optional[float] = None,\nz: t.Optional[float] = None, *,\nframe: t.Optional[CoordinateFrame] = None,\n**kwargs: t.Any) -&gt; HasAtomCellT:\n\"\"\"\n    Return a copy of ``self`` with an extra atom.\n    By default, all extra columns present in ``self`` must be specified as ``**kwargs``.\n    Try to avoid calling this in a loop (Use :py:meth:`concat` instead).\n    \"\"\"\n...\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.with_index","title":"<code>with_index(index=None, *, frame=None)</code>","text":"<p>Returns <code>self</code> with a row index added in column 'i' (dtype polars.Int64). If <code>index</code> is not specified, defaults to an existing index or a new index.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef with_index(self: HasAtomCellT, index: t.Optional[AtomValues] = None, *,\nframe: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n\"\"\"\n    Returns ``self`` with a row index added in column 'i' (dtype polars.Int64).\n    If ``index`` is not specified, defaults to an existing index or a new index.\n    \"\"\"\n...\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.with_wobble","title":"<code>with_wobble(wobble=None, *, frame=None)</code>","text":"<p>Return <code>self</code> with the given displacements in column 'wobble' (dtype polars.Float64). If <code>wobble</code> is not specified, defaults to the already-existing wobbles or 0.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef with_wobble(self: HasAtomCellT, wobble: t.Optional[AtomValues] = None, *,\nframe: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n\"\"\"\n    Return ``self`` with the given displacements in column 'wobble' (dtype polars.Float64).\n    If ``wobble`` is not specified, defaults to the already-existing wobbles or 0.\n    \"\"\"\n...\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.with_occupancy","title":"<code>with_occupancy(frac_occupancy=None, *, frame=None)</code>","text":"<p>Return self with the given fractional occupancies. If <code>frac_occupancy</code> is not specified, defaults to the already-existing occupancies or 1.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef with_occupancy(self: HasAtomCellT, frac_occupancy: t.Optional[AtomValues] = None, *,\nframe: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n\"\"\"\n    Return self with the given fractional occupancies. If ``frac_occupancy`` is not specified,\n    defaults to the already-existing occupancies or 1.\n    \"\"\"\n...\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.apply_wobble","title":"<code>apply_wobble(rng=None, frame=None)</code>","text":"<p>Displace the atoms in <code>self</code> by the amount in the <code>wobble</code> column. <code>wobble</code> is interpretated as a mean-squared displacement, which is distributed equally over each axis.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef apply_wobble(self: HasAtomCellT, rng: t.Union[numpy.random.Generator, int, None] = None,\nframe: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n\"\"\"\n    Displace the atoms in ``self`` by the amount in the `wobble` column.\n    ``wobble`` is interpretated as a mean-squared displacement, which is distributed\n    equally over each axis.\n    \"\"\"\n...\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.with_type","title":"<code>with_type(types=None, *, frame=None)</code>","text":"<p>Return <code>self</code> with the given atom types in column 'type'. If <code>types</code> is not specified, use the already existing types or auto-assign them.</p> <p>When auto-assigning, each symbol is given a unique value, case-sensitive. Values are assigned from lowest atomic number to highest. For instance: <code>[\"Ag+\", \"Na\", \"H\", \"Ag\"]</code> =&gt; <code>[3, 11, 1, 2]</code></p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef with_type(self: HasAtomCellT, types: t.Optional[AtomValues] = None, *,\nframe: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n\"\"\"\n    Return ``self`` with the given atom types in column 'type'.\n    If ``types`` is not specified, use the already existing types or auto-assign them.\n    When auto-assigning, each symbol is given a unique value, case-sensitive.\n    Values are assigned from lowest atomic number to highest.\n    For instance: ``[\"Ag+\", \"Na\", \"H\", \"Ag\"]`` =&gt; ``[3, 11, 1, 2]``\n    \"\"\"\n...\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.with_mass","title":"<code>with_mass(mass=None, *, frame=None)</code>","text":"<p>Return <code>self</code> with the given atom masses in column 'mass'. If <code>mass</code> is not specified, use the already existing masses or auto-assign them.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef with_mass(self: HasAtomCellT, mass: t.Optional[ArrayLike] = None, *,\nframe: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n\"\"\"\n    Return ``self`` with the given atom masses in column 'mass'.\n    If ``mass`` is not specified, use the already existing masses or auto-assign them.\n    \"\"\"\n...\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.with_symbol","title":"<code>with_symbol(symbols, selection=None, *, frame=None)</code>","text":"<p>Return <code>self</code> with the given atomic symbols.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef with_symbol(self: HasAtomCellT, symbols: ArrayLike, selection: t.Optional[AtomSelection] = None, *,\nframe: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n\"\"\"\n    Return ``self`` with the given atomic symbols.\n    \"\"\"\n...\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.with_coords","title":"<code>with_coords(pts, selection=None, *, frame=None)</code>","text":"<p>Return <code>self</code> replaced with the given atomic positions.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef with_coords(self: HasAtomCellT, pts: ArrayLike, selection: t.Optional[AtomSelection] = None, *,\nframe: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n\"\"\"\n    Return ``self`` replaced with the given atomic positions.\n    \"\"\"\n...\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.with_velocity","title":"<code>with_velocity(pts=None, selection=None, *, frame=None)</code>","text":"<p>Return <code>self</code> replaced with the given atomic velocities. If <code>pts</code> is not specified, use the already existing velocities or zero.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef with_velocity(self: HasAtomCellT, pts: t.Optional[ArrayLike] = None,\nselection: t.Optional[AtomSelection] = None, *,\nframe: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n\"\"\"\n    Return ``self`` replaced with the given atomic velocities.\n    If ``pts`` is not specified, use the already existing velocities or zero.\n    \"\"\"\n...\n</code></pre>"},{"location":"api/util/","title":"atomlib.util","text":""},{"location":"api/util/#atomlib.util","title":"<code>atomlib.util</code>","text":""},{"location":"api/util/#atomlib.util.FileOrPath","title":"<code>FileOrPath = t.Union[str, Path, TextIOBase, t.TextIO]</code>  <code>module-attribute</code>","text":"<p>Open text file or path to a file. Use with open_file.</p>"},{"location":"api/util/#atomlib.util.BinaryFileOrPath","title":"<code>BinaryFileOrPath = t.Union[str, Path, t.TextIO, t.BinaryIO, IOBase]</code>  <code>module-attribute</code>","text":"<p>Open binary file or path to a file. Use with open_file_binary.</p>"},{"location":"api/util/#atomlib.util.opt_classmethod","title":"<code>opt_classmethod</code>","text":"<p>             Bases: <code>classmethod</code>, <code>Generic[T, P, U_co]</code></p> <p>Decorates a method that may be called either on an instance or the class. If called on the class, a default instance will be constructed before calling the wrapped function.</p> Source code in <code>atomlib/util.py</code> <pre><code>class opt_classmethod(classmethod, t.Generic[T, P, U_co]):\n\"\"\"\n    Decorates a method that may be called either on an instance or the class.\n    If called on the class, a default instance will be constructed before\n    calling the wrapped function.\n    \"\"\"\n__func__: t.Callable[Concatenate[T, P], U_co]  # type: ignore\ndef __init__(self, f: t.Callable[Concatenate[T, P], U_co]):\nsuper().__init__(f)\ndef __get__(self, obj: t.Optional[T], ty: t.Optional[t.Type[T]] = None) -&gt; t.Callable[P, U_co]:  # type: ignore\nif obj is None:\nif ty is None:\nraise RuntimeError()  # pragma: no cover\nobj = ty()\nreturn t.cast(\nt.Callable[P, U_co],\nsuper().__get__(obj, obj)  # type: ignore\n)\n</code></pre>"},{"location":"api/util/#atomlib.util.map_some","title":"<code>map_some(f, val)</code>","text":"<p>Map <code>f</code> over <code>val</code> if not <code>None</code>.</p> Source code in <code>atomlib/util.py</code> <pre><code>def map_some(f: t.Callable[[T], U], val: t.Optional[T]) -&gt; t.Optional[U]:\n\"\"\"\n    Map `f` over `val` if not `None`.\n    \"\"\"\nreturn None if val is None else f(val)\n</code></pre>"},{"location":"api/util/#atomlib.util.open_file","title":"<code>open_file(f, mode='r', newline=None, encoding='utf-8')</code>","text":"<p>Open the given file for text I/O.</p> <p>If given a path-like, opens it with the specified settings. Otherwise, make an effort to reconfigure the encoding, and check that it is readable/writable as specified.</p> Source code in <code>atomlib/util.py</code> <pre><code>def open_file(f: FileOrPath,\nmode: t.Union[t.Literal['r'], t.Literal['w']] = 'r',\nnewline: t.Optional[str] = None,\nencoding: t.Optional[str] = 'utf-8') -&gt; AbstractContextManager[TextIOBase]:\n\"\"\"\n    Open the given file for text I/O.\n    If given a path-like, opens it with the specified settings.\n    Otherwise, make an effort to reconfigure the encoding, and\n    check that it is readable/writable as specified.\n    \"\"\"\nif not isinstance(f, (IOBase, t.BinaryIO, t.TextIO)):\nreturn open(f, mode, newline=newline, encoding=encoding)\nif isinstance(f, TextIOWrapper):\nf.reconfigure(newline=newline, encoding=encoding)\nelif isinstance(f, t.TextIO):\nf = TextIOWrapper(f.buffer, newline=newline, encoding=encoding)\nelif isinstance(f, (BufferedIOBase, t.BinaryIO)):\nf = TextIOWrapper(t.cast(t.BinaryIO, f), newline=newline, encoding=encoding)\n_validate_file(f, mode)\nreturn nullcontext(f)  # don't close a f we didn't open\n</code></pre>"},{"location":"api/util/#atomlib.util.open_file_binary","title":"<code>open_file_binary(f, mode='r')</code>","text":"<p>Open the given file for binary I/O.</p> <p>If given a path-like, opens it with the specified settings. If given text I/O, reconfigure to binary. Make sure stream is readable/writable, as specified.</p> Source code in <code>atomlib/util.py</code> <pre><code>def open_file_binary(f: BinaryFileOrPath,\nmode: t.Union[t.Literal['r'], t.Literal['w']] = 'r') -&gt; AbstractContextManager[IOBase]:\n\"\"\"\n    Open the given file for binary I/O.\n    If given a path-like, opens it with the specified settings. If given text I/O,\n    reconfigure to binary. Make sure stream is readable/writable, as specified.\n    \"\"\"\nif not isinstance(f, (IOBase, t.BinaryIO, t.TextIO)):\nreturn t.cast(IOBase, open(f, mode + 'b'))\nif isinstance(f, (TextIOWrapper, t.TextIO)):\ntry:\nf = f.buffer\nexcept AttributeError:\nraise ValueError(\"Error: Couldn't get raw buffer from text file.\")\nelif isinstance(f, StringIO):\nif mode == 'w':\nraise ValueError(\"Can't write binary stream to StringIO.\")\nreturn BytesIO(f.getvalue().encode('utf-8'))\nelif isinstance(f, TextIOBase):\nraise ValueError(f\"Error: Couldn't get binary stream from text stream of type '{type(f)}'.\")\n_validate_file(f, mode)\nreturn nullcontext(t.cast(IOBase, f))  # don't close a file we didn't open\n</code></pre>"},{"location":"api/util/#atomlib.util.localtime","title":"<code>localtime()</code>","text":"<p>Return the current time in a timezone-aware datetime object.</p> Source code in <code>atomlib/util.py</code> <pre><code>def localtime() -&gt; datetime.datetime:\n\"\"\"Return the current time in a timezone-aware [datetime][datetime.datetime] object.\"\"\"\nltime = time.localtime()\ntz = datetime.timezone(datetime.timedelta(seconds=ltime.tm_gmtoff), ltime.tm_zone)\nreturn datetime.datetime.now(tz)\n</code></pre>"},{"location":"api/util/#atomlib.util.proc_seed","title":"<code>proc_seed(seed, entropy)</code>","text":"<p>Process a random seed, which can be any object (or <code>None</code> for a random seed). Return it in a form which can be passed to numpy.random.default_rng.</p> <p>Uses a SHA-256 sum under the hood.</p> <p><code>entropy</code> should be a routine-specific object, to ensure that separate random routines called using the same seed return uncorrelated results.</p> Source code in <code>atomlib/util.py</code> <pre><code>def proc_seed(seed: t.Optional[object], entropy: object) -&gt; t.Optional[NDArray[numpy.uint32]]:\n\"\"\"\n    Process a random seed, which can be any object (or `None` for a random seed).\n    Return it in a form which can be passed to [numpy.random.default_rng][].\n    Uses a SHA-256 sum under the hood.\n    `entropy` should be a routine-specific object, to ensure that separate random\n    routines called using the same seed return uncorrelated results.\n    \"\"\"\nif seed is None:\nreturn None\n# hash our seed and our extra entropy\nstate = sha256()\nstate.update(str(seed).encode('utf-8'))\nstate.update(json.dumps(entropy).encode('utf-8'))\nreturn numpy.frombuffer(state.digest(), dtype=numpy.uint32)\n</code></pre>"},{"location":"using/coords/","title":"Coordinate systems","text":"<p>Under construction</p>"},{"location":"using/getting_started/","title":"Getting started","text":"<p><code>atomlib</code> is a package for creating, modifying, and controlling atomic structures. It focuses on flexibilty, correctness, and the preservation of structure metadata, while still managing to support a wide variety of file formats.</p>"}]}