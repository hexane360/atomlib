{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"atomlib: A modern, extensible library for creating atomic structures","text":"<p><code>atomlib</code> is a package for creating, modifying, and controlling atomic structures. It draws heavy inspiration from previous tools like Atomsk and ASE, but attempts to provide a cleaner, more consistent interface that can be used from Python or a command line.</p> <p><code>atomlib</code> has minimal dependencies: <code>numpy</code>, <code>scipy</code>, and <code>polars</code> are required for core atom structure manipulation, and <code>click</code> is required for command line functionality.</p>"},{"location":"#atomic-representation-supported-properties","title":"Atomic representation &amp; supported properties","text":"<p>Atomic structures are stored as <code>polars</code> DataFrames, providing a clean, immutable interface that maximizes expressiveness and minimizes errors. For formats that allow arbitrary properties, these properties can be passed through transparently. <code>atomlib</code> has first-class support for fractional occupancy, Debye-Waller factors, atomic forces, and labels.</p> <p>Translational symmetry is stored in <code>Cell</code> objects, which represent a fully generic cell. Atoms can be modified in any coordinate system that makes sense (global, local real-space, cell fraction, box fraction, etc.). Support for non-translational symmetry operations is limited at this point.</p> <p>For more information, check out the example notebooks and the API documentation.</p>"},{"location":"#currently-supported-file-formats","title":"Currently supported file formats","text":"<p>File format support is still a work in progress. Where possible, parsers are implemented from scratch in-repo. Most formats are implemented in two steps: Parsing to an intermediate representation which preserves all format-specific information, and then conversion to the generic <code>Atoms</code> &amp; <code>AtomCell</code> types for manipulation &amp; display. This means you can write your own code to utilize advanced format features even if they're not supported out of the box.</p> Format Ext. Read Write Notes CIF .cif CIF1 &amp; CIF2. Isotropic B-factor only XCrysDen .xsf AtomEye CFG .cfg Currently basic format only Basic XYZ .xyz Ext. XYZ .exyz Arbitrary properties not implemented Special XYZ .sxyz To be implemented LAMMPS Data .lmp Quantum Espresso .qe pw.x format pyMultislicer .mslice Currently XML format only"},{"location":"api/","title":"Index","text":"<p>Top-level exports:</p>"},{"location":"api/#atomlib.AtomSelection","title":"<code>AtomSelection = t.Union[IntoExprColumn, NDArray[numpy.bool_], ArrayLike, t.Mapping[str, t.Any]]</code>  <code>module-attribute</code>","text":"<p>Polars expression selecting a subset of atoms from an Atoms. Can be used with many Atoms methods.</p>"},{"location":"api/#atomlib.CoordinateFrame","title":"<code>CoordinateFrame = t.Literal['cell', 'cell_frac', 'cell_box', 'ortho', 'ortho_frac', 'ortho_box', 'linear', 'local', 'global']</code>  <code>module-attribute</code>","text":"<p>A coordinate frame to use.</p> <ul> <li><code>cell</code>: Real-space units along crystal axes</li> <li><code>cell_frac</code>: Fraction of unit cells</li> <li><code>cell_box</code>: Fraction of cell box</li> <li><code>ortho</code>: Real-space units along orthogonal cell</li> <li><code>ortho_frac</code>: Fraction of orthogonal cell</li> <li><code>ortho_box</code>: Fraction of orthogonal box</li> <li><code>linear</code>: Angstroms in local coordinate system (without affine transformation)</li> <li><code>local</code>: Angstroms in local coordinate system (with affine transformation)</li> <li><code>global</code>: Angstroms in global coordinate system (with all transformations)</li> </ul> <p>For more information, see the documentation at Coordinate systems, or the example notebook at <code>examples/coords.ipynb</code>.</p>"},{"location":"api/#atomlib.Atoms","title":"<code>Atoms</code>","text":"<p>             Bases: <code>AtomsIOMixin</code>, <code>HasAtoms</code></p> <p>A collection of atoms, absent any implied coordinate system. Implemented as a wrapper around a <code>polars.DataFrame</code>.</p> <p>Must contain the following columns:</p> <ul> <li>coords: array of [x, y, z] positions, float</li> <li>elem: atomic number, int</li> <li>symbol: atomic symbol (may contain charges)</li> </ul> <p>In addition, it commonly contains the following columns:</p> <ul> <li>i: Initial atom number</li> <li>wobble: Isotropic Debye-Waller mean-squared deviation ( = B*3/8pi^2, dimensions of [Length^2]) <li>frac_occupancy: Fractional occupancy, [0., 1.]</li> <li>mass: Atomic mass, in g/mol (approx. Da)</li> <li>velocity: array of [x, y, z] velocities, float, dimensions of length/time</li> <li>type: Numeric atom type, as used by programs like LAMMPS</li> Source code in <code>atomlib/atoms.py</code> <pre><code>class Atoms(AtomsIOMixin, HasAtoms):\n    \"\"\"\n    A collection of atoms, absent any implied coordinate system.\n    Implemented as a wrapper around a [`polars.DataFrame`][polars.DataFrame].\n\n    Must contain the following columns:\n\n    - coords: array of [x, y, z] positions, float\n    - elem: atomic number, int\n    - symbol: atomic symbol (may contain charges)\n\n    In addition, it commonly contains the following columns:\n\n    - i: Initial atom number\n    - wobble: Isotropic Debye-Waller mean-squared deviation (&lt;u^2&gt; = B*3/8pi^2, dimensions of [Length^2])\n    - frac_occupancy: Fractional occupancy, [0., 1.]\n    - mass: Atomic mass, in g/mol (approx. Da)\n    - velocity: array of [x, y, z] velocities, float, dimensions of length/time\n    - type: Numeric atom type, as used by programs like LAMMPS\n\n    [polars.DataFrame]: https://docs.pola.rs/py-polars/html/reference/dataframe/index.html\n    \"\"\"\n\n    def __init__(self, data: t.Optional[IntoAtoms] = None, columns: t.Optional[t.Sequence[str]] = None,\n                 orient: t.Union[t.Literal['row'], t.Literal['col'], None] = None,\n                 _unchecked: bool = False):\n        self._bbox: t.Optional[BBox3D] = None\n        self.inner: polars.DataFrame\n\n        if data is None:\n            assert columns is None\n            self.inner = polars.DataFrame([\n                polars.Series('coords', (), dtype=polars.Array(polars.Float64, 3)),\n                polars.Series('elem', (), dtype=polars.Int8),\n                polars.Series('symbol', (), dtype=polars.Utf8),\n            ])\n        elif isinstance(data, polars.DataFrame):\n            self.inner = data\n        elif isinstance(data, Atoms):\n            self.inner = data.inner\n            _unchecked = True\n        else:\n            self.inner = polars.DataFrame(data, schema=columns, orient=orient)\n\n        if not _unchecked:\n            # stack ('x', 'y', 'z') -&gt; 'coords'\n            self.inner = _with_columns_stacked(self.inner, ('x', 'y', 'z'), 'coords')\n            self.inner = _with_columns_stacked(self.inner, ('v_x', 'v_y', 'v_z'), 'velocity')\n\n            missing: t.Tuple[str, ...] = tuple(set(['symbol', 'elem']) - set(self.columns))\n            if len(missing) &gt; 1:\n                raise ValueError(\"'Atoms' missing columns 'elem' and/or 'symbol'.\")\n            # fill 'symbol' from 'elem' or vice-versa\n            if missing == ('symbol',):\n                self.inner = self.inner.with_columns(get_sym(self.inner['elem']))\n            elif missing == ('elem',):\n                # by convention, add before 'symbol' column\n                self.inner = self.inner.insert_column(\n                    self.inner.get_column_index('symbol'),\n                    get_elem(self.inner['symbol']),\n                )\n\n            # cast to standard dtypes\n            self.inner = self.inner.with_columns([\n                self.inner[col].cast(dtype)\n                for (col, dtype) in _COLUMN_DTYPES.items() if col in self.inner\n            ])\n\n            self._validate_atoms()\n\n    @staticmethod\n    def empty() -&gt; Atoms:\n        \"\"\"\n        Return an empty Atoms with only the mandatory columns.\n        \"\"\"\n        return Atoms()\n\n    def _validate_atoms(self):\n        missing = [col for col in _REQUIRED_COLUMNS if col not in self.columns]\n        if len(missing):\n            raise ValueError(f\"'Atoms' missing column(s) {', '.join(map(repr, missing))}\")\n\n    def get_atoms(self, frame: t.Literal['local'] = 'local') -&gt; Atoms:\n        if frame != 'local':\n            raise ValueError(f\"Atoms without a cell only support the 'local' coordinate frame, not '{frame}'.\")\n        return self\n\n    def with_atoms(self, atoms: HasAtoms, frame: t.Literal['local'] = 'local') -&gt; Atoms:\n        if frame != 'local':\n            raise ValueError(f\"Atoms without a cell only support the 'local' coordinate frame, not '{frame}'.\")\n        return atoms.get_atoms()\n\n    @classmethod\n    def _combine_metadata(cls: t.Type[Atoms], *atoms: HasAtoms) -&gt; Atoms:\n        return cls.empty()\n\n    def bbox(self) -&gt; BBox3D:\n        \"\"\"Return the bounding box of all the points in `self`.\"\"\"\n        if self._bbox is None:\n            self._bbox = BBox3D.from_pts(self.coords())\n\n        return self._bbox\n\n    def __str__(self) -&gt; str:\n        return f\"Atoms, {self.inner!s}\"\n\n    def __repr__(self) -&gt; str:\n        buf = StringIO()\n        buf.write(\"Atoms([\\n\")\n\n        for series in self.inner.to_dict().values():\n            buf.write(f\"    Series({series.name!r}, {series.to_list()!r}, dtype={series.dtype!r}),\\n\")\n\n        buf.write(\"])\\n\")\n        return buf.getvalue()\n\n    def _repr_pretty_(self, p, cycle: bool) -&gt; None:\n        p.text('Atoms(...)') if cycle else p.text(str(self))\n</code></pre>"},{"location":"api/#atomlib.Atoms.columns","title":"<code>columns: t.Sequence[str]</code>  <code>property</code>","text":"<p>Return the columns in <code>self</code>.</p>"},{"location":"api/#atomlib.Atoms.dtypes","title":"<code>dtypes: t.Sequence[polars.DataType]</code>  <code>property</code>","text":"<p>Return the datatypes in <code>self</code>.</p>"},{"location":"api/#atomlib.Atoms.schema","title":"<code>schema: SchemaDict</code>  <code>property</code>","text":"<p>Return the schema of <code>self</code>.</p>"},{"location":"api/#atomlib.Atoms.with_column","title":"<code>with_column = with_columns</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#atomlib.Atoms.transform","title":"<code>transform = transform_atoms</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#atomlib.Atoms.crop_atoms","title":"<code>crop_atoms = crop</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#atomlib.Atoms.unique","title":"<code>unique = deduplicate</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#atomlib.Atoms.inner","title":"<code>inner: polars.DataFrame</code>  <code>instance-attribute</code>","text":""},{"location":"api/#atomlib.Atoms.describe","title":"<code>describe(percentiles=(0.25, 0.5, 0.75), *, interpolation='nearest')</code>","text":"<p>Return summary statistics for <code>self</code>.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>@_fwd_frame(polars.DataFrame.describe)\ndef describe(self, percentiles: t.Union[t.Sequence[float], float, None] = (0.25, 0.5, 0.75), *,\n             interpolation: RollingInterpolationMethod = 'nearest') -&gt; polars.DataFrame:\n    \"\"\"Return summary statistics for `self`.\"\"\"\n    ...\n</code></pre>"},{"location":"api/#atomlib.Atoms.with_columns","title":"<code>with_columns(*exprs, **named_exprs)</code>","text":"<p>Return a copy of <code>self</code> with the given columns added.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>@_fwd_frame_map\ndef with_columns(self,\n                 *exprs: t.Union[IntoExpr, t.Iterable[IntoExpr]],\n                 **named_exprs: IntoExpr) -&gt; polars.DataFrame:\n    \"\"\"Return a copy of `self` with the given columns added.\"\"\"\n    return self._get_frame().with_columns(*exprs, **named_exprs)\n</code></pre>"},{"location":"api/#atomlib.Atoms.insert_column","title":"<code>insert_column(index, column)</code>","text":"Source code in <code>atomlib/atoms.py</code> <pre><code>@_fwd_frame_map\ndef insert_column(self, index: int, column: polars.Series) -&gt; polars.DataFrame:\n    return self._get_frame().insert_column(index, column)\n</code></pre>"},{"location":"api/#atomlib.Atoms.get_column","title":"<code>get_column(name)</code>","text":"<p>Get the specified column from <code>self</code>, raising <code>polars.ColumnNotFoundError</code> if it's not present.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>@_fwd_frame(polars.DataFrame.get_column)\ndef get_column(self, name: str) -&gt; polars.Series:\n    \"\"\"Get the specified column from `self`, raising [`polars.ColumnNotFoundError`][polars.exceptions.ColumnNotFoundError] if it's not present.\"\"\"\n    ...\n</code></pre>"},{"location":"api/#atomlib.Atoms.get_columns","title":"<code>get_columns()</code>","text":"<p>Get the specified columns from <code>self</code>, raising <code>polars.ColumnNotFoundError</code> if it's not present.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>@_fwd_frame(polars.DataFrame.get_columns)\ndef get_columns(self) -&gt; t.List[polars.Series]:\n    \"\"\"Get the specified columns from `self`, raising [`polars.ColumnNotFoundError`][polars.exceptions.ColumnNotFoundError] if it's not present.\"\"\"\n    ...\n</code></pre>"},{"location":"api/#atomlib.Atoms.get_column_index","title":"<code>get_column_index(name)</code>","text":"<p>Get the index of a column by name, raising <code>polars.ColumnNotFoundError</code> if it's not present.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>@_fwd_frame(polars.DataFrame.get_column_index)\ndef get_column_index(self, name: str) -&gt; int:\n    \"\"\"Get the index of a column by name, raising [`polars.ColumnNotFoundError`][polars.exceptions.ColumnNotFoundError] if it's not present.\"\"\"\n    ...\n</code></pre>"},{"location":"api/#atomlib.Atoms.group_by","title":"<code>group_by(*by, maintain_order=False, **named_by)</code>","text":"Source code in <code>atomlib/atoms.py</code> <pre><code>@_fwd_frame(polars.DataFrame.group_by)\ndef group_by(self, *by: t.Union[IntoExpr, t.Iterable[IntoExpr]], maintain_order: bool = False,\n             **named_by: IntoExpr) -&gt; polars.dataframe.group_by.GroupBy:\n    ...\n</code></pre>"},{"location":"api/#atomlib.Atoms.pipe","title":"<code>pipe(function, *args, **kwargs)</code>","text":"<p>Apply <code>function</code> to <code>self</code> (in method-call syntax).</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def pipe(self: HasAtomsT, function: t.Callable[Concatenate[HasAtomsT, P], T], *args: P.args, **kwargs: P.kwargs) -&gt; T:\n    \"\"\"Apply `function` to `self` (in method-call syntax).\"\"\"\n    return function(self, *args, **kwargs)\n</code></pre>"},{"location":"api/#atomlib.Atoms.clone","title":"<code>clone()</code>","text":"<p>Return a copy of <code>self</code>.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>@_fwd_frame_map\ndef clone(self) -&gt; polars.DataFrame:\n    \"\"\"Return a copy of `self`.\"\"\"\n    return self._get_frame().clone()\n</code></pre>"},{"location":"api/#atomlib.Atoms.drop","title":"<code>drop(*columns)</code>","text":"<p>Return <code>self</code> with the specified columns removed.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def drop(self, *columns: t.Union[str, t.Iterable[str]]) -&gt; polars.DataFrame:\n    \"\"\"Return `self` with the specified columns removed.\"\"\"\n    return self._get_frame().drop(*columns)\n</code></pre>"},{"location":"api/#atomlib.Atoms.filter","title":"<code>filter(*predicates, **constraints)</code>","text":"<p>Filter <code>self</code>, removing rows which evaluate to <code>False</code>.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def filter(\n    self: HasAtomsT,\n    *predicates: t.Union[None, IntoExprColumn, t.Iterable[IntoExprColumn], bool, t.List[bool], numpy.ndarray],\n    **constraints: t.Any,\n) -&gt; HasAtomsT:\n    \"\"\"Filter `self`, removing rows which evaluate to `False`.\"\"\"\n    # TODO clean up\n    preds_not_none: t.Tuple[t.Union[IntoExprColumn, t.Iterable[IntoExprColumn], bool, t.List[bool], numpy.ndarray], ...]\n    preds_not_none = tuple(filter(lambda p: p is not None, predicates))  # type: ignore\n    if not len(preds_not_none) and not len(constraints):\n        return self\n    return self.with_atoms(Atoms(self._get_frame().filter(*preds_not_none, **constraints), _unchecked=True))\n</code></pre>"},{"location":"api/#atomlib.Atoms.sort","title":"<code>sort(by, *more_by, descending=False, nulls_last=False)</code>","text":"<p>Sort the atoms in <code>self</code> by the given columns/expressions.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>@_fwd_frame_map\ndef sort(\n    self,\n    by: t.Union[IntoExpr, t.Iterable[IntoExpr]],\n    *more_by: IntoExpr,\n    descending: t.Union[bool, t.Sequence[bool]] = False,\n    nulls_last: bool = False,\n) -&gt; polars.DataFrame:\n    \"\"\"\n    Sort the atoms in `self` by the given columns/expressions.\n    \"\"\"\n    return self._get_frame().sort(\n        by, *more_by, descending=descending, nulls_last=nulls_last\n    )\n</code></pre>"},{"location":"api/#atomlib.Atoms.slice","title":"<code>slice(offset, length=None)</code>","text":"<p>Return a slice of the rows in <code>self</code>.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>@_fwd_frame_map\ndef slice(self, offset: int, length: t.Optional[int] = None) -&gt; polars.DataFrame:\n    \"\"\"Return a slice of the rows in `self`.\"\"\"\n    return self._get_frame().slice(offset, length)\n</code></pre>"},{"location":"api/#atomlib.Atoms.head","title":"<code>head(n=5)</code>","text":"<p>Return the first <code>n</code> rows of <code>self</code>.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>@_fwd_frame_map\ndef head(self, n: int = 5) -&gt; polars.DataFrame:\n    \"\"\"Return the first `n` rows of `self`.\"\"\"\n    return self._get_frame().head(n)\n</code></pre>"},{"location":"api/#atomlib.Atoms.tail","title":"<code>tail(n=5)</code>","text":"<p>Return the last <code>n</code> rows of <code>self</code>.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>@_fwd_frame_map\ndef tail(self, n: int = 5) -&gt; polars.DataFrame:\n    \"\"\"Return the last `n` rows of `self`.\"\"\"\n    return self._get_frame().tail(n)\n</code></pre>"},{"location":"api/#atomlib.Atoms.drop_nulls","title":"<code>drop_nulls(subset=None)</code>","text":"<p>Drop rows that contain nulls in any of columns <code>subset</code>.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>@_fwd_frame_map\ndef drop_nulls(self, subset: t.Union[str, t.Collection[str], None] = None) -&gt; polars.DataFrame:\n    \"\"\"Drop rows that contain nulls in any of columns `subset`.\"\"\"\n    return self._get_frame().drop_nulls(subset)\n</code></pre>"},{"location":"api/#atomlib.Atoms.fill_null","title":"<code>fill_null(value=None, strategy=None, limit=None, matches_supertype=True)</code>","text":"<p>Fill null values in <code>self</code>, using the specified value or strategy.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>@_fwd_frame_map\ndef fill_null(\n    self, value: t.Any = None, strategy: t.Optional[FillNullStrategy] = None,\n    limit: t.Optional[int] = None, matches_supertype: bool = True,\n) -&gt; polars.DataFrame:\n    \"\"\"Fill null values in `self`, using the specified value or strategy.\"\"\"\n    return self._get_frame().fill_null(value, strategy, limit, matches_supertype=matches_supertype)\n</code></pre>"},{"location":"api/#atomlib.Atoms.fill_nan","title":"<code>fill_nan(value)</code>","text":"<p>Fill floating-point NaN values in <code>self</code>.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>@_fwd_frame_map\ndef fill_nan(self, value: t.Union[polars.Expr, int, float, None]) -&gt; polars.DataFrame:\n    \"\"\"Fill floating-point NaN values in `self`.\"\"\"\n    return self._get_frame().fill_nan(value)\n</code></pre>"},{"location":"api/#atomlib.Atoms.concat","title":"<code>concat(atoms, *, rechunk=True, how='vertical')</code>  <code>classmethod</code>","text":"<p>Concatenate multiple <code>Atoms</code> together, handling metadata appropriately.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>@classmethod\ndef concat(cls: t.Type[HasAtomsT],\n           atoms: t.Union[HasAtomsT, IntoAtoms, t.Iterable[t.Union[HasAtomsT, IntoAtoms]]], *,\n           rechunk: bool = True, how: ConcatMethod = 'vertical') -&gt; HasAtomsT:\n    \"\"\"Concatenate multiple `Atoms` together, handling metadata appropriately.\"\"\"\n    # this method is tricky. It needs to accept raw Atoms, as well as HasAtoms of the\n    # same type as ``cls``.\n    if _is_abstract(cls):\n        raise TypeError(f\"concat() must be called on a concrete class.\")\n\n    if isinstance(atoms, HasAtoms):\n        atoms = (atoms,)\n    dfs = [a.get_atoms('local').inner if isinstance(a, HasAtoms) else Atoms(t.cast(IntoAtoms, a)).inner for a in atoms]\n    representative = cls._combine_metadata(*(a for a in atoms if isinstance(a, HasAtoms)))\n\n    if len(dfs) == 0:\n        return representative.with_atoms(Atoms.empty(), 'local')\n\n    if how in ('vertical', 'vertical_relaxed'):\n        # get order from first member\n        cols = dfs[0].columns\n        dfs = [df.select(cols) for df in dfs]\n    elif how == 'inner':\n        cols = reduce(operator.and_, (df.schema.keys() for df in dfs))\n        schema = OrderedDict((col, dfs[0].schema[col]) for col in cols)\n        if len(schema) == 0:\n            raise ValueError(f\"Atoms have no columns in common\")\n\n        dfs = [_select_schema(df, schema) for df in dfs]\n        how = 'vertical'\n\n    return representative.with_atoms(Atoms(polars.concat(dfs, rechunk=rechunk, how=how)), 'local')\n</code></pre>"},{"location":"api/#atomlib.Atoms.partition_by","title":"<code>partition_by(by, *more_by, maintain_order=True, include_key=True, as_dict=False)</code>","text":"<p>Group by the given columns and partition into separate dataframes.</p> <p>Return the partitions as a dictionary by specifying <code>as_dict=True</code>.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def partition_by(\n    self: HasAtomsT, by: t.Union[str, t.Sequence[str]], *more_by: str,\n    maintain_order: bool = True, include_key: bool = True, as_dict: bool = False\n) -&gt; t.Union[t.List[HasAtomsT], t.Dict[t.Any, HasAtomsT]]:\n    \"\"\"\n    Group by the given columns and partition into separate dataframes.\n\n    Return the partitions as a dictionary by specifying `as_dict=True`.\n    \"\"\"\n    if as_dict:\n        d = self._get_frame().partition_by(by, *more_by, maintain_order=maintain_order, include_key=include_key, as_dict=True)\n        return {k: self.with_atoms(Atoms(df, _unchecked=True)) for (k, df) in d.items()}\n\n    return [\n        self.with_atoms(Atoms(df, _unchecked=True))\n        for df in self._get_frame().partition_by(by, *more_by, maintain_order=maintain_order, include_key=include_key, as_dict=False)\n    ]\n</code></pre>"},{"location":"api/#atomlib.Atoms.select","title":"<code>select(*exprs, **named_exprs)</code>","text":"<p>Select <code>exprs</code> from <code>self</code>, and return as a <code>polars.DataFrame</code>.</p> <p>Expressions may either be columns or expressions of columns.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>@_fwd_frame(polars.DataFrame.select)\ndef select(\n    self,\n    *exprs: t.Union[IntoExpr, t.Iterable[IntoExpr]],\n    **named_exprs: IntoExpr,\n):\n    \"\"\"\n    Select `exprs` from `self`, and return as a `polars.DataFrame`.\n\n    Expressions may either be columns or expressions of columns.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/#atomlib.Atoms.select_schema","title":"<code>select_schema(schema)</code>","text":"<p>Select columns from <code>self</code> and cast to the given schema. Raises <code>TypeError</code> if a column is not found or if it can't be cast.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def select_schema(self, schema: SchemaDict) -&gt; polars.DataFrame:\n    \"\"\"\n    Select columns from `self` and cast to the given schema.\n    Raises `TypeError` if a column is not found or if it can't be cast.\n    \"\"\"\n    return _select_schema(self, schema)\n</code></pre>"},{"location":"api/#atomlib.Atoms.select_props","title":"<code>select_props(*exprs, **named_exprs)</code>","text":"<p>Select <code>exprs</code> from <code>self</code>, while keeping required columns.</p> <p>Returns a HasAtoms.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def select_props(\n    self: HasAtomsT,\n    *exprs: t.Union[IntoExpr, t.Iterable[IntoExpr]],\n    **named_exprs: IntoExpr\n) -&gt; HasAtomsT:\n    \"\"\"\n    Select `exprs` from `self`, while keeping required columns.\n\n    Returns a HasAtoms.\n    \"\"\"\n    props = self._get_frame().lazy().select(*exprs, **named_exprs).drop(_REQUIRED_COLUMNS).collect(_eager=True)\n    return self.with_atoms(\n        Atoms(self._get_frame().select(_REQUIRED_COLUMNS).hstack(props), _unchecked=False)\n    )\n</code></pre>"},{"location":"api/#atomlib.Atoms.try_select","title":"<code>try_select(*exprs, **named_exprs)</code>","text":"<p>Try to select <code>exprs</code> from <code>self</code>, and return as a <code>DataFrame</code>.</p> <p>Expressions may either be columns or expressions of columns. Return <code>None</code> if any columns are missing.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def try_select(\n    self,\n    *exprs: t.Union[IntoExpr, t.Iterable[IntoExpr]],\n    **named_exprs: IntoExpr,\n) -&gt; t.Optional[polars.DataFrame]:\n    \"\"\"\n    Try to select `exprs` from `self`, and return as a `DataFrame`.\n\n    Expressions may either be columns or expressions of columns.\n    Return `None` if any columns are missing.\n    \"\"\"\n    try:\n        return self._get_frame().select(*exprs, **named_exprs)\n    except polars.ColumnNotFoundError:\n        return None\n</code></pre>"},{"location":"api/#atomlib.Atoms.try_get_column","title":"<code>try_get_column(name)</code>","text":"<p>Try to get a column from <code>self</code>, returning <code>None</code> if it doesn't exist.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def try_get_column(self, name: str) -&gt; t.Optional[polars.Series]:\n    \"\"\"Try to get a column from `self`, returning `None` if it doesn't exist.\"\"\"\n    try:\n        return self.get_column(name)\n    except polars.ColumnNotFoundError:\n        return None\n</code></pre>"},{"location":"api/#atomlib.Atoms.assert_equal","title":"<code>assert_equal(other)</code>","text":"Source code in <code>atomlib/atoms.py</code> <pre><code>def assert_equal(self, other: t.Any):\n    assert isinstance(other, HasAtoms)\n    assert dict(self.schema) == dict(other.schema)\n    for col in self.schema.keys():\n        polars.testing.assert_series_equal(self[col], other[col], check_names=False, rtol=1e-3, atol=1e-8)\n</code></pre>"},{"location":"api/#atomlib.Atoms.bbox_atoms","title":"<code>bbox_atoms()</code>","text":"<p>Return the bounding box of all the atoms in <code>self</code>.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def bbox_atoms(self) -&gt; BBox3D:\n    \"\"\"Return the bounding box of all the atoms in ``self``.\"\"\"\n    return BBox3D.from_pts(self.coords())\n</code></pre>"},{"location":"api/#atomlib.Atoms.transform_atoms","title":"<code>transform_atoms(transform, selection=None, *, transform_velocities=False)</code>","text":"<p>Transform the atoms in <code>self</code> by <code>transform</code>. If <code>selection</code> is given, only transform the atoms in <code>selection</code>.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def transform_atoms(self: HasAtomsT, transform: IntoTransform3D, selection: t.Optional[AtomSelection] = None, *, transform_velocities: bool = False) -&gt; HasAtomsT:\n    \"\"\"\n    Transform the atoms in `self` by `transform`.\n    If `selection` is given, only transform the atoms in `selection`.\n    \"\"\"\n    transform = Transform3D.make(transform)\n    selection = _selection_to_numpy(self, selection)\n    transformed = self.with_coords(Transform3D.make(transform) @ self.coords(selection), selection)\n    # try to transform velocities as well\n    if transform_velocities and (velocities := self.velocities(selection)) is not None:\n        return transformed.with_velocity(transform.transform_vec(velocities), selection)\n    return transformed\n</code></pre>"},{"location":"api/#atomlib.Atoms.round_near_zero","title":"<code>round_near_zero(tol=1e-14)</code>","text":"<p>Round atom position values near zero to zero.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def round_near_zero(self: HasAtomsT, tol: float = 1e-14) -&gt; HasAtomsT:\n    \"\"\"\n    Round atom position values near zero to zero.\n    \"\"\"\n    return self.with_columns(coords=polars.concat_list(\n        polars.when(_coord_expr(col).abs() &gt;= tol).then(_coord_expr(col)).otherwise(polars.lit(0.))\n        for col in range(3)\n    ).list.to_array(3))\n</code></pre>"},{"location":"api/#atomlib.Atoms.crop","title":"<code>crop(x_min=-numpy.inf, x_max=numpy.inf, y_min=-numpy.inf, y_max=numpy.inf, z_min=-numpy.inf, z_max=numpy.inf)</code>","text":"<p>Crop, removing all atoms outside of the specified region, inclusive.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def crop(self: HasAtomsT, x_min: float = -numpy.inf, x_max: float = numpy.inf,\n         y_min: float = -numpy.inf, y_max: float = numpy.inf,\n         z_min: float = -numpy.inf, z_max: float = numpy.inf) -&gt; HasAtomsT:\n    \"\"\"\n    Crop, removing all atoms outside of the specified region, inclusive.\n    \"\"\"\n\n    return self.filter(\n        self.x().is_between(x_min, x_max, closed='both'),\n        self.y().is_between(y_min, y_max, closed='both'),\n        self.z().is_between(z_min, z_max, closed='both'),\n    )\n</code></pre>"},{"location":"api/#atomlib.Atoms.deduplicate","title":"<code>deduplicate(tol=0.001, subset=('x', 'y', 'z', 'symbol'), keep='first', maintain_order=True)</code>","text":"<p>De-duplicate atoms in <code>self</code>. Atoms of the same <code>symbol</code> that are closer than <code>tolerance</code> to each other (by Euclidian distance) will be removed, leaving only the atom specified by <code>keep</code> (defaults to the first atom).</p> <p>If <code>subset</code> is specified, only those columns will be included while assessing duplicates. Floating point columns other than 'x', 'y', and 'z' will not by toleranced.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def deduplicate(self: HasAtomsT, tol: float = 1e-3, subset: t.Iterable[str] = ('x', 'y', 'z', 'symbol'),\n                keep: UniqueKeepStrategy = 'first', maintain_order: bool = True) -&gt; HasAtomsT:\n    \"\"\"\n    De-duplicate atoms in `self`. Atoms of the same `symbol` that are closer than `tolerance`\n    to each other (by Euclidian distance) will be removed, leaving only the atom specified by\n    `keep` (defaults to the first atom).\n\n    If `subset` is specified, only those columns will be included while assessing duplicates.\n    Floating point columns other than 'x', 'y', and 'z' will not by toleranced.\n    \"\"\"\n    import scipy.spatial\n\n    cols = set((subset,) if isinstance(subset, str) else subset)\n\n    indices = numpy.arange(len(self))\n\n    spatial_cols = cols.intersection(('x', 'y', 'z'))\n    cols -= spatial_cols\n    if len(spatial_cols) &gt; 0:\n        coords = self.select([_coord_expr(col).alias(col) for col in spatial_cols]).to_numpy()\n        tree = scipy.spatial.KDTree(coords)\n\n        # TODO This is a bad algorithm\n        while True:\n            changed = False\n            for (i, j) in tree.query_pairs(tol, 2.):\n                # whenever we encounter a pair, ensure their index matches\n                i_i, i_j = indices[[i, j]]\n                if i_i != i_j:\n                    indices[i] = indices[j] = min(i_i, i_j)\n                    changed = True\n            if not changed:\n                break\n\n        self = self.with_column(polars.Series('_unique_pts', indices))\n        cols.add('_unique_pts')\n\n    frame = self._get_frame().unique(subset=list(cols), keep=keep, maintain_order=maintain_order)\n    if len(spatial_cols) &gt; 0:\n        frame = frame.drop('_unique_pts')\n\n    return self.with_atoms(Atoms(frame, _unchecked=True))\n</code></pre>"},{"location":"api/#atomlib.Atoms.with_bounds","title":"<code>with_bounds(cell_size=None, cell_origin=None)</code>","text":"<p>Return a periodic cell with the given orthogonal cell dimensions.</p> <p>If cell_size is not specified, it will be assumed (and may be incorrect).</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def with_bounds(self, cell_size: t.Optional[VecLike] = None, cell_origin: t.Optional[VecLike] = None) -&gt; 'AtomCell':\n    \"\"\"\n    Return a periodic cell with the given orthogonal cell dimensions.\n\n    If cell_size is not specified, it will be assumed (and may be incorrect).\n    \"\"\"\n    # TODO: test this\n    from .atomcell import AtomCell\n\n    if cell_size is None:\n        warnings.warn(\"Cell boundary unknown. Defaulting to cell BBox\")\n        cell_size = self.bbox().size\n        cell_origin = self.bbox().min\n\n    # TODO test this origin code\n    cell = Cell.from_unit_cell(cell_size)\n    if cell_origin is not None:\n        cell = cell.transform_cell(AffineTransform3D.translate(to_vec3(cell_origin)))\n\n    return AtomCell(self.get_atoms(), cell, frame='local')\n</code></pre>"},{"location":"api/#atomlib.Atoms.coords","title":"<code>coords(selection=None, *, frame='local')</code>","text":"<p>Return a <code>(N, 3)</code> ndarray of atom coordinates (dtype <code>numpy.float64</code>).</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def coords(self, selection: t.Optional[AtomSelection] = None, *, frame: t.Literal['local'] = 'local') -&gt; NDArray[numpy.float64]:\n    \"\"\"Return a `(N, 3)` ndarray of atom coordinates (dtype [`numpy.float64`][numpy.float64]).\"\"\"\n    df = self if selection is None else self.filter(_selection_to_expr(self, selection))\n    return df.get_column('coords').to_numpy().astype(numpy.float64)\n</code></pre>"},{"location":"api/#atomlib.Atoms.x","title":"<code>x()</code>","text":"Source code in <code>atomlib/atoms.py</code> <pre><code>def x(self) -&gt; polars.Expr:\n    return polars.col('coords').arr.get(0).alias('x')\n</code></pre>"},{"location":"api/#atomlib.Atoms.y","title":"<code>y()</code>","text":"Source code in <code>atomlib/atoms.py</code> <pre><code>def y(self) -&gt; polars.Expr:\n    return polars.col('coords').arr.get(1).alias('y')\n</code></pre>"},{"location":"api/#atomlib.Atoms.z","title":"<code>z()</code>","text":"Source code in <code>atomlib/atoms.py</code> <pre><code>def z(self) -&gt; polars.Expr:\n    return polars.col('coords').arr.get(2).alias('z')\n</code></pre>"},{"location":"api/#atomlib.Atoms.velocities","title":"<code>velocities(selection=None)</code>","text":"<p>Return a <code>(N, 3)</code> ndarray of atom velocities (dtype <code>numpy.float64</code>).</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def velocities(self, selection: t.Optional[AtomSelection] = None) -&gt; t.Optional[NDArray[numpy.float64]]:\n    \"\"\"Return a `(N, 3)` ndarray of atom velocities (dtype [`numpy.float64`][numpy.float64]).\"\"\"\n    if 'velocity' not in self:\n        return None\n\n    df = self if selection is None else self.filter(_selection_to_expr(self, selection))\n    return df.get_column('velocity').to_numpy().astype(numpy.float64)\n</code></pre>"},{"location":"api/#atomlib.Atoms.types","title":"<code>types()</code>","text":"<p>Returns a <code>Series</code> of atom types (dtype <code>polars.Int32</code>).</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def types(self) -&gt; t.Optional[polars.Series]:\n    \"\"\"\n    Returns a [`Series`][polars.Series] of atom types (dtype [`polars.Int32`][polars.Int32]).\n\n    [polars.Series]: https://docs.pola.rs/py-polars/html/reference/series/index.html\n    \"\"\"\n    return self.try_get_column('type')\n</code></pre>"},{"location":"api/#atomlib.Atoms.masses","title":"<code>masses()</code>","text":"<p>Returns a <code>Series</code> of atom masses (dtype <code>polars.Float32</code>).</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def masses(self) -&gt; t.Optional[polars.Series]:\n    \"\"\"\n    Returns a [`Series`][polars.Series] of atom masses (dtype [`polars.Float32`][polars.Float32]).\n\n    [polars.Series]: https://docs.pola.rs/py-polars/html/reference/series/index.html\n    \"\"\"\n    return self.try_get_column('mass')\n</code></pre>"},{"location":"api/#atomlib.Atoms.add_atom","title":"<code>add_atom(elem, /, x, y=None, z=None, **kwargs)</code>","text":"<p>Return a copy of <code>self</code> with an extra atom.</p> <p>By default, all extra columns present in <code>self</code> must be specified as <code>**kwargs</code>.</p> <p>Try to avoid calling this in a loop (Use <code>HasAtoms.concat</code> instead).</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def add_atom(self: HasAtomsT, elem: t.Union[int, str], /,\n             x: t.Union[ArrayLike, float],\n             y: t.Optional[float] = None,\n             z: t.Optional[float] = None,\n             **kwargs: t.Any) -&gt; HasAtomsT:\n    \"\"\"\n    Return a copy of `self` with an extra atom.\n\n    By default, all extra columns present in `self` must be specified as `**kwargs`.\n\n    Try to avoid calling this in a loop (Use [`HasAtoms.concat`][atomlib.atoms.HasAtoms.concat] instead).\n    \"\"\"\n    if isinstance(elem, int):\n        kwargs.update(elem=elem)\n    else:\n        kwargs.update(symbol=elem)\n    if hasattr(x, '__len__') and len(x) &gt; 1:  # type: ignore\n        (x, y, z) = to_vec3(x)\n    elif y is None or z is None:\n        raise ValueError(f\"Must specify vector of positions or x, y, &amp; z.\")\n\n    sym = get_sym(elem) if isinstance(elem, int) else elem\n    d: t.Dict[str, t.Any] = {'x': x, 'y': y, 'z': z, 'symbol': sym, **kwargs}\n    return self.concat(\n        (self, Atoms(d).select_schema(self.schema)),\n        how='vertical'\n    )\n</code></pre>"},{"location":"api/#atomlib.Atoms.pos","title":"<code>pos(x=None, y=None, z=None, *, tol=1e-06, **kwargs)</code>","text":"<p>Select all atoms at a given position.</p> <p>Formally, returns all atoms within a cube of radius <code>tol</code> centered at <code>(x,y,z)</code>, exclusive of the cube's surface.</p> <p>Additional parameters given as <code>kwargs</code> will be checked as additional parameters (with strict equality).</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def pos(self,\n        x: t.Union[t.Sequence[t.Optional[float]], float, None] = None,\n        y: t.Optional[float] = None, z: t.Optional[float] = None, *,\n        tol: float = 1e-6, **kwargs: t.Any) -&gt; polars.Expr:\n    \"\"\"\n    Select all atoms at a given position.\n\n    Formally, returns all atoms within a cube of radius ``tol``\n    centered at ``(x,y,z)``, exclusive of the cube's surface.\n\n    Additional parameters given as ``kwargs`` will be checked\n    as additional parameters (with strict equality).\n    \"\"\"\n\n    if isinstance(x, t.Sequence):\n        (x, y, z) = x\n\n    tol = abs(float(tol))\n    selection = polars.lit(True)\n    if x is not None:\n        selection &amp;= self.x().is_between(x - tol, x + tol, closed='none')\n    if y is not None:\n        selection &amp;= self.y().is_between(y - tol, y + tol, closed='none')\n    if z is not None:\n        selection &amp;= self.z().is_between(z - tol, z + tol, closed='none')\n    for (col, val) in kwargs.items():\n        selection &amp;= (polars.col(col) == val)\n\n    return selection\n</code></pre>"},{"location":"api/#atomlib.Atoms.with_index","title":"<code>with_index(index=None)</code>","text":"<p>Returns <code>self</code> with a row index added in column 'i' (dtype <code>polars.Int64</code>). If <code>index</code> is not specified, defaults to an existing index or a new index.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def with_index(self: HasAtomsT, index: t.Optional[AtomValues] = None) -&gt; HasAtomsT:\n    \"\"\"\n    Returns `self` with a row index added in column 'i' (dtype [`polars.Int64`][polars.Int64]).\n    If `index` is not specified, defaults to an existing index or a new index.\n    \"\"\"\n    if index is None and 'i' in self.columns:\n        return self\n    if index is None:\n        index = numpy.arange(len(self), dtype=numpy.int64)\n    return self.with_column(_values_to_expr(self, index, polars.Int64).alias('i'))\n</code></pre>"},{"location":"api/#atomlib.Atoms.with_wobble","title":"<code>with_wobble(wobble=None)</code>","text":"<p>Return <code>self</code> with the given displacements in column 'wobble' (dtype <code>polars.Float64</code>). If <code>wobble</code> is not specified, defaults to the already-existing wobbles or 0.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def with_wobble(self: HasAtomsT, wobble: t.Optional[AtomValues] = None) -&gt; HasAtomsT:\n    \"\"\"\n    Return `self` with the given displacements in column 'wobble' (dtype [`polars.Float64`][polars.Float64]).\n    If `wobble` is not specified, defaults to the already-existing wobbles or 0.\n    \"\"\"\n    if wobble is None and 'wobble' in self.columns:\n        return self\n    wobble = 0. if wobble is None else wobble\n    return self.with_column(_values_to_expr(self, wobble, polars.Float64).alias('wobble'))\n</code></pre>"},{"location":"api/#atomlib.Atoms.with_occupancy","title":"<code>with_occupancy(frac_occupancy=None)</code>","text":"<p>Return self with the given fractional occupancies. If <code>frac_occupancy</code> is not specified, defaults to the already-existing occupancies or 1.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def with_occupancy(self: HasAtomsT, frac_occupancy: t.Optional[AtomValues] = None) -&gt; HasAtomsT:\n    \"\"\"\n    Return self with the given fractional occupancies. If `frac_occupancy` is not specified,\n    defaults to the already-existing occupancies or 1.\n    \"\"\"\n    if frac_occupancy is None and 'frac_occupancy' in self.columns:\n        return self\n    frac_occupancy = 1. if frac_occupancy is None else frac_occupancy\n    return self.with_column(_values_to_expr(self, frac_occupancy, polars.Float64).alias('frac_occupancy'))\n</code></pre>"},{"location":"api/#atomlib.Atoms.apply_wobble","title":"<code>apply_wobble(rng=None)</code>","text":"<p>Displace the atoms in <code>self</code> by the amount in the <code>wobble</code> column. <code>wobble</code> is interpretated as a mean-squared displacement, which is distributed equally over each axis.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def apply_wobble(self: HasAtomsT, rng: t.Union[numpy.random.Generator, int, None] = None) -&gt; HasAtomsT:\n    \"\"\"\n    Displace the atoms in `self` by the amount in the `wobble` column.\n    `wobble` is interpretated as a mean-squared displacement, which is distributed\n    equally over each axis.\n    \"\"\"\n    if 'wobble' not in self.columns:\n        return self\n    rng = numpy.random.default_rng(seed=rng)\n\n    stddev = self.select((polars.col('wobble') / 3.).sqrt()).to_series().to_numpy()\n    coords = self.coords()\n    coords += stddev[:, None] * rng.standard_normal(coords.shape)\n    return self.with_coords(coords)\n</code></pre>"},{"location":"api/#atomlib.Atoms.apply_occupancy","title":"<code>apply_occupancy(rng=None)</code>","text":"<p>For each atom in <code>self</code>, use its <code>frac_occupancy</code> to randomly decide whether to remove it.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def apply_occupancy(self: HasAtomsT, rng: t.Union[numpy.random.Generator, int, None] = None) -&gt; HasAtomsT:\n    \"\"\"\n    For each atom in `self`, use its `frac_occupancy` to randomly decide whether to remove it.\n    \"\"\"\n    if 'frac_occupancy' not in self.columns:\n        return self\n    rng = numpy.random.default_rng(seed=rng)\n\n    frac = self.select('frac_occupancy').to_series().to_numpy()\n    choice = rng.binomial(1, frac).astype(numpy.bool_)\n    return self.filter(polars.lit(choice))\n</code></pre>"},{"location":"api/#atomlib.Atoms.with_type","title":"<code>with_type(types=None)</code>","text":"<p>Return <code>self</code> with the given atom types in column 'type'. If <code>types</code> is not specified, use the already existing types or auto-assign them.</p> <p>When auto-assigning, each symbol is given a unique value, case-sensitive. Values are assigned from lowest atomic number to highest. For instance: <code>[\"Ag+\", \"Na\", \"H\", \"Ag\"]</code> =&gt; <code>[3, 11, 1, 2]</code></p> Source code in <code>atomlib/atoms.py</code> <pre><code>def with_type(self: HasAtomsT, types: t.Optional[AtomValues] = None) -&gt; HasAtomsT:\n    \"\"\"\n    Return `self` with the given atom types in column 'type'.\n    If `types` is not specified, use the already existing types or auto-assign them.\n\n    When auto-assigning, each symbol is given a unique value, case-sensitive.\n    Values are assigned from lowest atomic number to highest.\n    For instance: `[\"Ag+\", \"Na\", \"H\", \"Ag\"]` =&gt; `[3, 11, 1, 2]`\n    \"\"\"\n    if types is not None:\n        return self.with_columns(type=_values_to_expr(self, types, polars.Int32))\n    if 'type' in self.columns:\n        return self\n\n    unique = Atoms(self._get_frame().unique(maintain_order=False, subset=['elem', 'symbol']).sort(['elem', 'symbol']), _unchecked=True)\n    new = self.with_column(polars.Series('type', values=numpy.zeros(len(self)), dtype=polars.Int32))\n\n    logging.warning(\"Auto-assigning element types\")\n    for (i, (elem, sym)) in enumerate(unique.select(('elem', 'symbol')).rows()):\n        print(f\"Assigning type {i+1} to element '{sym}'\")\n        new = new.with_column(polars.when((polars.col('elem') == elem) &amp; (polars.col('symbol') == sym))\n                                    .then(polars.lit(i+1))\n                                    .otherwise(polars.col('type'))\n                                    .alias('type'))\n\n    assert (new.get_column('type') == 0).sum() == 0\n    return new\n</code></pre>"},{"location":"api/#atomlib.Atoms.with_mass","title":"<code>with_mass(mass=None)</code>","text":"<p>Return <code>self</code> with the given atom masses in column 'mass'. If <code>mass</code> is not specified, use the already existing masses or auto-assign them.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def with_mass(self: HasAtomsT, mass: t.Optional[ArrayLike] = None) -&gt; HasAtomsT:\n    \"\"\"\n    Return `self` with the given atom masses in column 'mass'.\n    If `mass` is not specified, use the already existing masses or auto-assign them.\n    \"\"\"\n    if mass is not None:\n        return self.with_column(_values_to_expr(self, mass, polars.Float32).alias('mass'))\n    if 'mass' in self.columns:\n        return self\n\n    unique_elems = self.get_column('elem').unique()\n    new = self.with_column(polars.Series('mass', values=numpy.zeros(len(self)), dtype=polars.Float32))\n\n    logging.warning(\"Auto-assigning element masses\")\n    for elem in unique_elems:\n        new = new.with_column(polars.when(polars.col('elem') == elem)\n                                    .then(polars.lit(get_mass(elem)))\n                                    .otherwise(polars.col('mass'))\n                                    .alias('mass'))\n\n    assert (new.get_column('mass').abs() &lt; 1e-10).sum() == 0\n    return new\n</code></pre>"},{"location":"api/#atomlib.Atoms.with_symbol","title":"<code>with_symbol(symbols, selection=None)</code>","text":"<p>Return <code>self</code> with the given atomic symbols.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def with_symbol(self: HasAtomsT, symbols: ArrayLike, selection: t.Optional[AtomSelection] = None) -&gt; HasAtomsT:\n    \"\"\"\n    Return `self` with the given atomic symbols.\n    \"\"\"\n    if selection is not None:\n        selection = _selection_to_numpy(self, selection)\n        new_symbols = self.get_column('symbol')\n        new_symbols[selection] = polars.Series(list(numpy.broadcast_to(symbols, len(selection))), dtype=polars.Utf8)\n        symbols = new_symbols\n\n    # TODO better cast here\n    symbols = polars.Series('symbol', list(numpy.broadcast_to(symbols, len(self))), dtype=polars.Utf8)\n    return self.with_columns((symbols, get_elem(symbols)))\n</code></pre>"},{"location":"api/#atomlib.Atoms.with_coords","title":"<code>with_coords(pts, selection=None, *, frame='local')</code>","text":"<p>Return <code>self</code> replaced with the given atomic positions.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def with_coords(self: HasAtomsT, pts: ArrayLike, selection: t.Optional[AtomSelection] = None, *, frame: t.Literal['local'] = 'local') -&gt; HasAtomsT:\n    \"\"\"\n    Return `self` replaced with the given atomic positions.\n    \"\"\"\n    if selection is not None:\n        selection = _selection_to_numpy(self, selection)\n        new_pts = self.coords()\n        pts = numpy.atleast_2d(pts)\n        assert pts.shape[-1] == 3\n        new_pts[selection] = pts\n        pts = new_pts\n\n    pts = numpy.broadcast_to(pts, (len(self), 3))\n    return self.with_columns(polars.Series('coords', pts, polars.Array(polars.Float64, 3)))\n</code></pre>"},{"location":"api/#atomlib.Atoms.with_velocity","title":"<code>with_velocity(pts=None, selection=None)</code>","text":"<p>Return <code>self</code> replaced with the given atomic velocities. If <code>pts</code> is not specified, use the already existing velocities or zero.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def with_velocity(self: HasAtomsT, pts: t.Optional[ArrayLike] = None,\n                  selection: t.Optional[AtomSelection] = None) -&gt; HasAtomsT:\n    \"\"\"\n    Return `self` replaced with the given atomic velocities.\n    If `pts` is not specified, use the already existing velocities or zero.\n    \"\"\"\n    if pts is None:\n        if 'velocity' in self:\n            return self\n        all_pts = numpy.zeros((len(self), 3))\n    else:\n        all_pts = self['velocity'].to_numpy()\n\n    if selection is None:\n        all_pts = pts or all_pts\n    elif pts is not None:\n        selection = _selection_to_numpy(self, selection)\n        all_pts = numpy.require(all_pts, requirements=['WRITEABLE'])\n        pts = numpy.atleast_2d(pts)\n        assert pts.shape[-1] == 3\n        all_pts[selection] = pts\n\n    all_pts = numpy.broadcast_to(all_pts, (len(self), 3))\n    return self.with_columns(polars.Series('velocity', all_pts, polars.Array(polars.Float64, 3)))\n</code></pre>"},{"location":"api/#atomlib.Atoms.read","title":"<code>read(path, ty=None)</code>  <code>classmethod</code>","text":"<p>Read a structure from a file.</p> <p>Supported types can be found in the io module. If no <code>ty</code> is specified, it is inferred from the file's extension.</p> Source code in <code>atomlib/mixins.py</code> <pre><code>@classmethod\ndef read(cls: t.Type[HasAtomsT], path: FileOrPath, ty: t.Optional[FileType] = None) -&gt; HasAtomsT:\n    \"\"\"\n    Read a structure from a file.\n\n    Supported types can be found in the [io][atomlib.io] module.\n    If no `ty` is specified, it is inferred from the file's extension.\n    \"\"\"\n    from .io import read\n    return _cast_atoms(read(path, ty), cls)  # type: ignore\n</code></pre>"},{"location":"api/#atomlib.Atoms.read_cif","title":"<code>read_cif(f, block=None)</code>  <code>classmethod</code>","text":"<p>Read a structure from a CIF file.</p> <p>If <code>block</code> is specified, read data from the given block of the CIF file (index or name).</p> Source code in <code>atomlib/mixins.py</code> <pre><code>@classmethod\ndef read_cif(cls: t.Type[HasAtomsT], f: t.Union[FileOrPath, CIF, CIFDataBlock], block: t.Union[int, str, None] = None) -&gt; HasAtomsT:\n    \"\"\"\n    Read a structure from a CIF file.\n\n    If `block` is specified, read data from the given block of the CIF file (index or name).\n    \"\"\"\n    from .io import read_cif\n    return _cast_atoms(read_cif(f, block), cls)\n</code></pre>"},{"location":"api/#atomlib.Atoms.read_xyz","title":"<code>read_xyz(f)</code>  <code>classmethod</code>","text":"<p>Read a structure from an XYZ file.</p> Source code in <code>atomlib/mixins.py</code> <pre><code>@classmethod\ndef read_xyz(cls: t.Type[HasAtomsT], f: t.Union[FileOrPath, XYZ]) -&gt; HasAtomsT:\n    \"\"\"Read a structure from an XYZ file.\"\"\"\n    from .io import read_xyz\n    return _cast_atoms(read_xyz(f), cls)\n</code></pre>"},{"location":"api/#atomlib.Atoms.read_xsf","title":"<code>read_xsf(f)</code>  <code>classmethod</code>","text":"<p>Read a structure from an XSF file.</p> Source code in <code>atomlib/mixins.py</code> <pre><code>@classmethod\ndef read_xsf(cls: t.Type[HasAtomsT], f: t.Union[FileOrPath, XSF]) -&gt; HasAtomsT:\n    \"\"\"Read a structure from an XSF file.\"\"\"\n    from .io import read_xsf\n    return _cast_atoms(read_xsf(f), cls)\n</code></pre>"},{"location":"api/#atomlib.Atoms.read_cfg","title":"<code>read_cfg(f)</code>  <code>classmethod</code>","text":"<p>Read a structure from a CFG file.</p> Source code in <code>atomlib/mixins.py</code> <pre><code>@classmethod\ndef read_cfg(cls: t.Type[HasAtomsT], f: t.Union[FileOrPath, CFG]) -&gt; HasAtomsT:\n    \"\"\"Read a structure from a CFG file.\"\"\"\n    from .io import read_cfg\n    return _cast_atoms(read_cfg(f), cls)\n</code></pre>"},{"location":"api/#atomlib.Atoms.read_lmp","title":"<code>read_lmp(f, type_map=None)</code>  <code>classmethod</code>","text":"<p>Read a structure from a LAAMPS data file.</p> Source code in <code>atomlib/mixins.py</code> <pre><code>@classmethod\ndef read_lmp(cls: t.Type[HasAtomsT], f: t.Union[FileOrPath, LMP], type_map: t.Optional[t.Dict[int, t.Union[str, int]]] = None) -&gt; HasAtomsT:\n    \"\"\"Read a structure from a LAAMPS data file.\"\"\"\n    from .io import read_lmp\n    return _cast_atoms(read_lmp(f, type_map=type_map), cls)\n</code></pre>"},{"location":"api/#atomlib.Atoms.write_cif","title":"<code>write_cif(f)</code>","text":"Source code in <code>atomlib/mixins.py</code> <pre><code>def write_cif(self, f: FileOrPath):\n    from .io import write_cif\n    write_cif(self, f)\n</code></pre>"},{"location":"api/#atomlib.Atoms.write_xyz","title":"<code>write_xyz(f, fmt='exyz')</code>","text":"Source code in <code>atomlib/mixins.py</code> <pre><code>def write_xyz(self, f: FileOrPath, fmt: XYZFormat = 'exyz'):\n    from .io import write_xyz\n    write_xyz(self, f, fmt)\n</code></pre>"},{"location":"api/#atomlib.Atoms.write_xsf","title":"<code>write_xsf(f)</code>","text":"Source code in <code>atomlib/mixins.py</code> <pre><code>def write_xsf(self, f: FileOrPath):\n    from .io import write_xsf\n    write_xsf(self, f)\n</code></pre>"},{"location":"api/#atomlib.Atoms.write_cfg","title":"<code>write_cfg(f)</code>","text":"Source code in <code>atomlib/mixins.py</code> <pre><code>def write_cfg(self, f: FileOrPath):\n    from .io import write_cfg\n    write_cfg(self, f)\n</code></pre>"},{"location":"api/#atomlib.Atoms.write_lmp","title":"<code>write_lmp(f)</code>","text":"Source code in <code>atomlib/mixins.py</code> <pre><code>def write_lmp(self, f: FileOrPath):\n    from .io import write_lmp\n    write_lmp(self, f)\n</code></pre>"},{"location":"api/#atomlib.Atoms.write","title":"<code>write(path, ty=None)</code>","text":"<p>Write this structure to a file.</p> <p>A file type may be specified using <code>ty</code>. If no <code>ty</code> is specified, it is inferred from the path's extension.</p> Source code in <code>atomlib/mixins.py</code> <pre><code>def write(self, path: FileOrPath, ty: t.Optional[FileType] = None):\n    \"\"\"\n    Write this structure to a file.\n\n    A file type may be specified using `ty`.\n    If no `ty` is specified, it is inferred from the path's extension.\n    \"\"\"\n    from .io import write\n    write(self, path, ty)  # type: ignore\n</code></pre>"},{"location":"api/#atomlib.Atoms.empty","title":"<code>empty()</code>  <code>staticmethod</code>","text":"<p>Return an empty Atoms with only the mandatory columns.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>@staticmethod\ndef empty() -&gt; Atoms:\n    \"\"\"\n    Return an empty Atoms with only the mandatory columns.\n    \"\"\"\n    return Atoms()\n</code></pre>"},{"location":"api/#atomlib.Atoms.get_atoms","title":"<code>get_atoms(frame='local')</code>","text":"Source code in <code>atomlib/atoms.py</code> <pre><code>def get_atoms(self, frame: t.Literal['local'] = 'local') -&gt; Atoms:\n    if frame != 'local':\n        raise ValueError(f\"Atoms without a cell only support the 'local' coordinate frame, not '{frame}'.\")\n    return self\n</code></pre>"},{"location":"api/#atomlib.Atoms.with_atoms","title":"<code>with_atoms(atoms, frame='local')</code>","text":"Source code in <code>atomlib/atoms.py</code> <pre><code>def with_atoms(self, atoms: HasAtoms, frame: t.Literal['local'] = 'local') -&gt; Atoms:\n    if frame != 'local':\n        raise ValueError(f\"Atoms without a cell only support the 'local' coordinate frame, not '{frame}'.\")\n    return atoms.get_atoms()\n</code></pre>"},{"location":"api/#atomlib.Atoms.bbox","title":"<code>bbox()</code>","text":"<p>Return the bounding box of all the points in <code>self</code>.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def bbox(self) -&gt; BBox3D:\n    \"\"\"Return the bounding box of all the points in `self`.\"\"\"\n    if self._bbox is None:\n        self._bbox = BBox3D.from_pts(self.coords())\n\n    return self._bbox\n</code></pre>"},{"location":"api/#atomlib.HasAtoms","title":"<code>HasAtoms</code>","text":"<p>             Bases: <code>ABC</code></p> <p>Abstract class representing any (possibly compound) collection of atoms.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>class HasAtoms(abc.ABC):\n    \"\"\"Abstract class representing any (possibly compound) collection of atoms.\"\"\"\n\n    # abstract methods\n\n    @abc.abstractmethod\n    def get_atoms(self, frame: t.Literal['local'] = 'local') -&gt; Atoms:\n        \"\"\"Get atoms contained in `self`. This should be a low cost method.\"\"\"\n        ...\n\n    @abc.abstractmethod\n    def with_atoms(self: HasAtomsT, atoms: HasAtoms, frame: t.Literal['local'] = 'local') -&gt; HasAtomsT:\n        ...\n\n    @classmethod\n    @abc.abstractmethod\n    def _combine_metadata(cls: t.Type[HasAtomsT], *atoms: HasAtoms) -&gt; HasAtomsT:\n        \"\"\"\n        When combining multiple ``HasAtoms``, check that they are compatible with each other,\n        and return a 'representative' which best represents the combined metadata.\n        Implementors should treat `Atoms` as acceptable, but having no metadata.\n        \"\"\"\n        ...\n\n    def _get_frame(self) -&gt; polars.DataFrame:\n        return self.get_atoms().inner\n\n    # dataframe methods\n\n    @property\n    @_fwd_frame(lambda df: df.columns)\n    def columns(self) -&gt; t.Sequence[str]:\n        \"\"\"Return the columns in `self`.\"\"\"\n        ...\n\n    @property\n    @_fwd_frame(lambda df: df.dtypes)\n    def dtypes(self) -&gt; t.Sequence[polars.DataType]:\n        \"\"\"Return the datatypes in `self`.\"\"\"\n        ...\n\n    @property\n    @_fwd_frame(lambda df: df.schema)\n    def schema(self) -&gt; SchemaDict:\n        \"\"\"Return the schema of `self`.\"\"\"\n        ...\n\n    @_fwd_frame(polars.DataFrame.describe)\n    def describe(self, percentiles: t.Union[t.Sequence[float], float, None] = (0.25, 0.5, 0.75), *,\n                 interpolation: RollingInterpolationMethod = 'nearest') -&gt; polars.DataFrame:\n        \"\"\"Return summary statistics for `self`.\"\"\"\n        ...\n\n    @_fwd_frame_map\n    def with_columns(self,\n                     *exprs: t.Union[IntoExpr, t.Iterable[IntoExpr]],\n                     **named_exprs: IntoExpr) -&gt; polars.DataFrame:\n        \"\"\"Return a copy of `self` with the given columns added.\"\"\"\n        return self._get_frame().with_columns(*exprs, **named_exprs)\n\n    with_column = with_columns\n\n    @_fwd_frame_map\n    def insert_column(self, index: int, column: polars.Series) -&gt; polars.DataFrame:\n        return self._get_frame().insert_column(index, column)\n\n    @_fwd_frame(polars.DataFrame.get_column)\n    def get_column(self, name: str) -&gt; polars.Series:\n        \"\"\"Get the specified column from `self`, raising [`polars.ColumnNotFoundError`][polars.exceptions.ColumnNotFoundError] if it's not present.\"\"\"\n        ...\n\n    @_fwd_frame(polars.DataFrame.get_columns)\n    def get_columns(self) -&gt; t.List[polars.Series]:\n        \"\"\"Get the specified columns from `self`, raising [`polars.ColumnNotFoundError`][polars.exceptions.ColumnNotFoundError] if it's not present.\"\"\"\n        ...\n\n    @_fwd_frame(polars.DataFrame.get_column_index)\n    def get_column_index(self, name: str) -&gt; int:\n        \"\"\"Get the index of a column by name, raising [`polars.ColumnNotFoundError`][polars.exceptions.ColumnNotFoundError] if it's not present.\"\"\"\n        ...\n\n    @_fwd_frame(polars.DataFrame.group_by)\n    def group_by(self, *by: t.Union[IntoExpr, t.Iterable[IntoExpr]], maintain_order: bool = False,\n                 **named_by: IntoExpr) -&gt; polars.dataframe.group_by.GroupBy:\n        ...\n\n    def pipe(self: HasAtomsT, function: t.Callable[Concatenate[HasAtomsT, P], T], *args: P.args, **kwargs: P.kwargs) -&gt; T:\n        \"\"\"Apply `function` to `self` (in method-call syntax).\"\"\"\n        return function(self, *args, **kwargs)\n\n    @_fwd_frame_map\n    def clone(self) -&gt; polars.DataFrame:\n        \"\"\"Return a copy of `self`.\"\"\"\n        return self._get_frame().clone()\n\n    def drop(self, *columns: t.Union[str, t.Iterable[str]]) -&gt; polars.DataFrame:\n        \"\"\"Return `self` with the specified columns removed.\"\"\"\n        return self._get_frame().drop(*columns)\n\n    # row-wise operations\n\n    def filter(\n        self: HasAtomsT,\n        *predicates: t.Union[None, IntoExprColumn, t.Iterable[IntoExprColumn], bool, t.List[bool], numpy.ndarray],\n        **constraints: t.Any,\n    ) -&gt; HasAtomsT:\n        \"\"\"Filter `self`, removing rows which evaluate to `False`.\"\"\"\n        # TODO clean up\n        preds_not_none: t.Tuple[t.Union[IntoExprColumn, t.Iterable[IntoExprColumn], bool, t.List[bool], numpy.ndarray], ...]\n        preds_not_none = tuple(filter(lambda p: p is not None, predicates))  # type: ignore\n        if not len(preds_not_none) and not len(constraints):\n            return self\n        return self.with_atoms(Atoms(self._get_frame().filter(*preds_not_none, **constraints), _unchecked=True))\n\n    @_fwd_frame_map\n    def sort(\n        self,\n        by: t.Union[IntoExpr, t.Iterable[IntoExpr]],\n        *more_by: IntoExpr,\n        descending: t.Union[bool, t.Sequence[bool]] = False,\n        nulls_last: bool = False,\n    ) -&gt; polars.DataFrame:\n        \"\"\"\n        Sort the atoms in `self` by the given columns/expressions.\n        \"\"\"\n        return self._get_frame().sort(\n            by, *more_by, descending=descending, nulls_last=nulls_last\n        )\n\n    @_fwd_frame_map\n    def slice(self, offset: int, length: t.Optional[int] = None) -&gt; polars.DataFrame:\n        \"\"\"Return a slice of the rows in `self`.\"\"\"\n        return self._get_frame().slice(offset, length)\n\n    @_fwd_frame_map\n    def head(self, n: int = 5) -&gt; polars.DataFrame:\n        \"\"\"Return the first `n` rows of `self`.\"\"\"\n        return self._get_frame().head(n)\n\n    @_fwd_frame_map\n    def tail(self, n: int = 5) -&gt; polars.DataFrame:\n        \"\"\"Return the last `n` rows of `self`.\"\"\"\n        return self._get_frame().tail(n)\n\n    @_fwd_frame_map\n    def drop_nulls(self, subset: t.Union[str, t.Collection[str], None] = None) -&gt; polars.DataFrame:\n        \"\"\"Drop rows that contain nulls in any of columns `subset`.\"\"\"\n        return self._get_frame().drop_nulls(subset)\n\n    @_fwd_frame_map\n    def fill_null(\n        self, value: t.Any = None, strategy: t.Optional[FillNullStrategy] = None,\n        limit: t.Optional[int] = None, matches_supertype: bool = True,\n    ) -&gt; polars.DataFrame:\n        \"\"\"Fill null values in `self`, using the specified value or strategy.\"\"\"\n        return self._get_frame().fill_null(value, strategy, limit, matches_supertype=matches_supertype)\n\n    @_fwd_frame_map\n    def fill_nan(self, value: t.Union[polars.Expr, int, float, None]) -&gt; polars.DataFrame:\n        \"\"\"Fill floating-point NaN values in `self`.\"\"\"\n        return self._get_frame().fill_nan(value)\n\n    @classmethod\n    def concat(cls: t.Type[HasAtomsT],\n               atoms: t.Union[HasAtomsT, IntoAtoms, t.Iterable[t.Union[HasAtomsT, IntoAtoms]]], *,\n               rechunk: bool = True, how: ConcatMethod = 'vertical') -&gt; HasAtomsT:\n        \"\"\"Concatenate multiple `Atoms` together, handling metadata appropriately.\"\"\"\n        # this method is tricky. It needs to accept raw Atoms, as well as HasAtoms of the\n        # same type as ``cls``.\n        if _is_abstract(cls):\n            raise TypeError(f\"concat() must be called on a concrete class.\")\n\n        if isinstance(atoms, HasAtoms):\n            atoms = (atoms,)\n        dfs = [a.get_atoms('local').inner if isinstance(a, HasAtoms) else Atoms(t.cast(IntoAtoms, a)).inner for a in atoms]\n        representative = cls._combine_metadata(*(a for a in atoms if isinstance(a, HasAtoms)))\n\n        if len(dfs) == 0:\n            return representative.with_atoms(Atoms.empty(), 'local')\n\n        if how in ('vertical', 'vertical_relaxed'):\n            # get order from first member\n            cols = dfs[0].columns\n            dfs = [df.select(cols) for df in dfs]\n        elif how == 'inner':\n            cols = reduce(operator.and_, (df.schema.keys() for df in dfs))\n            schema = OrderedDict((col, dfs[0].schema[col]) for col in cols)\n            if len(schema) == 0:\n                raise ValueError(f\"Atoms have no columns in common\")\n\n            dfs = [_select_schema(df, schema) for df in dfs]\n            how = 'vertical'\n\n        return representative.with_atoms(Atoms(polars.concat(dfs, rechunk=rechunk, how=how)), 'local')\n\n    @t.overload\n    def partition_by(\n        self: HasAtomsT, by: t.Union[str, t.Sequence[str]], *more_by: str,\n        maintain_order: bool = True, include_key: bool = True, as_dict: t.Literal[False] = False\n    ) -&gt; t.List[HasAtomsT]:\n        ...\n\n    @t.overload\n    def partition_by(\n        self: HasAtomsT, by: t.Union[str, t.Sequence[str]], *more_by: str,\n        maintain_order: bool = True, include_key: bool = True, as_dict: t.Literal[True] = ...\n    ) -&gt; t.Dict[t.Any, HasAtomsT]:\n        ...\n\n    def partition_by(\n        self: HasAtomsT, by: t.Union[str, t.Sequence[str]], *more_by: str,\n        maintain_order: bool = True, include_key: bool = True, as_dict: bool = False\n    ) -&gt; t.Union[t.List[HasAtomsT], t.Dict[t.Any, HasAtomsT]]:\n        \"\"\"\n        Group by the given columns and partition into separate dataframes.\n\n        Return the partitions as a dictionary by specifying `as_dict=True`.\n        \"\"\"\n        if as_dict:\n            d = self._get_frame().partition_by(by, *more_by, maintain_order=maintain_order, include_key=include_key, as_dict=True)\n            return {k: self.with_atoms(Atoms(df, _unchecked=True)) for (k, df) in d.items()}\n\n        return [\n            self.with_atoms(Atoms(df, _unchecked=True))\n            for df in self._get_frame().partition_by(by, *more_by, maintain_order=maintain_order, include_key=include_key, as_dict=False)\n        ]\n\n    # column-wise operations\n\n    @_fwd_frame(polars.DataFrame.select)\n    def select(\n        self,\n        *exprs: t.Union[IntoExpr, t.Iterable[IntoExpr]],\n        **named_exprs: IntoExpr,\n    ):\n        \"\"\"\n        Select `exprs` from `self`, and return as a `polars.DataFrame`.\n\n        Expressions may either be columns or expressions of columns.\n        \"\"\"\n        ...\n\n    # some helpers we add\n\n    def select_schema(self, schema: SchemaDict) -&gt; polars.DataFrame:\n        \"\"\"\n        Select columns from `self` and cast to the given schema.\n        Raises `TypeError` if a column is not found or if it can't be cast.\n        \"\"\"\n        return _select_schema(self, schema)\n\n    def select_props(\n        self: HasAtomsT,\n        *exprs: t.Union[IntoExpr, t.Iterable[IntoExpr]],\n        **named_exprs: IntoExpr\n    ) -&gt; HasAtomsT:\n        \"\"\"\n        Select `exprs` from `self`, while keeping required columns.\n\n        Returns a HasAtoms.\n        \"\"\"\n        props = self._get_frame().lazy().select(*exprs, **named_exprs).drop(_REQUIRED_COLUMNS).collect(_eager=True)\n        return self.with_atoms(\n            Atoms(self._get_frame().select(_REQUIRED_COLUMNS).hstack(props), _unchecked=False)\n        )\n\n    def try_select(\n        self,\n        *exprs: t.Union[IntoExpr, t.Iterable[IntoExpr]],\n        **named_exprs: IntoExpr,\n    ) -&gt; t.Optional[polars.DataFrame]:\n        \"\"\"\n        Try to select `exprs` from `self`, and return as a `DataFrame`.\n\n        Expressions may either be columns or expressions of columns.\n        Return `None` if any columns are missing.\n        \"\"\"\n        try:\n            return self._get_frame().select(*exprs, **named_exprs)\n        except polars.ColumnNotFoundError:\n            return None\n\n    def try_get_column(self, name: str) -&gt; t.Optional[polars.Series]:\n        \"\"\"Try to get a column from `self`, returning `None` if it doesn't exist.\"\"\"\n        try:\n            return self.get_column(name)\n        except polars.ColumnNotFoundError:\n            return None\n\n    def assert_equal(self, other: t.Any):\n        assert isinstance(other, HasAtoms)\n        assert dict(self.schema) == dict(other.schema)\n        for col in self.schema.keys():\n            polars.testing.assert_series_equal(self[col], other[col], check_names=False, rtol=1e-3, atol=1e-8)\n\n    # dunders\n\n    @_fwd_frame(polars.DataFrame.__len__)\n    def __len__(self) -&gt; int:\n        \"\"\"Return the number of atoms in `self`.\"\"\"\n        ...\n\n    @_fwd_frame(polars.DataFrame.__contains__)\n    def __contains__(self, key: str) -&gt; bool:\n        \"\"\"Return whether `self` contains the given column.\"\"\"\n        ...\n\n    def __add__(self: HasAtomsT, other: IntoAtoms) -&gt; HasAtomsT:\n        return self.__class__.concat((self, other), how='inner')\n\n    def __radd__(self: HasAtomsT, other: IntoAtoms) -&gt; HasAtomsT:\n        return self.__class__.concat((other, self), how='inner')\n\n    def __getitem__(self, column: str) -&gt; polars.Series:\n        try:\n            return self.get_column(column)\n        except polars.ColumnNotFoundError:\n            if column in ('x', 'y', 'z'):\n                return self.select(_coord_expr(column)).to_series()\n            raise\n\n    @_fwd_frame(polars.DataFrame.__dataframe__)\n    def __dataframe__(self, nan_as_null: bool = False, allow_copy: bool = True) -&gt; polars.interchange.dataframe.PolarsDataFrame:\n        ...\n\n    # atoms-specific methods\n\n    def bbox_atoms(self) -&gt; BBox3D:\n        \"\"\"Return the bounding box of all the atoms in ``self``.\"\"\"\n        return BBox3D.from_pts(self.coords())\n\n    bbox = bbox_atoms\n\n    def transform_atoms(self: HasAtomsT, transform: IntoTransform3D, selection: t.Optional[AtomSelection] = None, *, transform_velocities: bool = False) -&gt; HasAtomsT:\n        \"\"\"\n        Transform the atoms in `self` by `transform`.\n        If `selection` is given, only transform the atoms in `selection`.\n        \"\"\"\n        transform = Transform3D.make(transform)\n        selection = _selection_to_numpy(self, selection)\n        transformed = self.with_coords(Transform3D.make(transform) @ self.coords(selection), selection)\n        # try to transform velocities as well\n        if transform_velocities and (velocities := self.velocities(selection)) is not None:\n            return transformed.with_velocity(transform.transform_vec(velocities), selection)\n        return transformed\n\n    transform = transform_atoms\n\n    def round_near_zero(self: HasAtomsT, tol: float = 1e-14) -&gt; HasAtomsT:\n        \"\"\"\n        Round atom position values near zero to zero.\n        \"\"\"\n        return self.with_columns(coords=polars.concat_list(\n            polars.when(_coord_expr(col).abs() &gt;= tol).then(_coord_expr(col)).otherwise(polars.lit(0.))\n            for col in range(3)\n        ).list.to_array(3))\n\n    def crop(self: HasAtomsT, x_min: float = -numpy.inf, x_max: float = numpy.inf,\n             y_min: float = -numpy.inf, y_max: float = numpy.inf,\n             z_min: float = -numpy.inf, z_max: float = numpy.inf) -&gt; HasAtomsT:\n        \"\"\"\n        Crop, removing all atoms outside of the specified region, inclusive.\n        \"\"\"\n\n        return self.filter(\n            self.x().is_between(x_min, x_max, closed='both'),\n            self.y().is_between(y_min, y_max, closed='both'),\n            self.z().is_between(z_min, z_max, closed='both'),\n        )\n\n    crop_atoms = crop\n\n    def _wrap(self: HasAtomsT, eps: float = 1e-5) -&gt; HasAtomsT:\n        coords = (self.coords() + eps) % 1. - eps\n        return self.with_coords(coords)\n\n    def deduplicate(self: HasAtomsT, tol: float = 1e-3, subset: t.Iterable[str] = ('x', 'y', 'z', 'symbol'),\n                    keep: UniqueKeepStrategy = 'first', maintain_order: bool = True) -&gt; HasAtomsT:\n        \"\"\"\n        De-duplicate atoms in `self`. Atoms of the same `symbol` that are closer than `tolerance`\n        to each other (by Euclidian distance) will be removed, leaving only the atom specified by\n        `keep` (defaults to the first atom).\n\n        If `subset` is specified, only those columns will be included while assessing duplicates.\n        Floating point columns other than 'x', 'y', and 'z' will not by toleranced.\n        \"\"\"\n        import scipy.spatial\n\n        cols = set((subset,) if isinstance(subset, str) else subset)\n\n        indices = numpy.arange(len(self))\n\n        spatial_cols = cols.intersection(('x', 'y', 'z'))\n        cols -= spatial_cols\n        if len(spatial_cols) &gt; 0:\n            coords = self.select([_coord_expr(col).alias(col) for col in spatial_cols]).to_numpy()\n            tree = scipy.spatial.KDTree(coords)\n\n            # TODO This is a bad algorithm\n            while True:\n                changed = False\n                for (i, j) in tree.query_pairs(tol, 2.):\n                    # whenever we encounter a pair, ensure their index matches\n                    i_i, i_j = indices[[i, j]]\n                    if i_i != i_j:\n                        indices[i] = indices[j] = min(i_i, i_j)\n                        changed = True\n                if not changed:\n                    break\n\n            self = self.with_column(polars.Series('_unique_pts', indices))\n            cols.add('_unique_pts')\n\n        frame = self._get_frame().unique(subset=list(cols), keep=keep, maintain_order=maintain_order)\n        if len(spatial_cols) &gt; 0:\n            frame = frame.drop('_unique_pts')\n\n        return self.with_atoms(Atoms(frame, _unchecked=True))\n\n    unique = deduplicate\n\n    def with_bounds(self, cell_size: t.Optional[VecLike] = None, cell_origin: t.Optional[VecLike] = None) -&gt; 'AtomCell':\n        \"\"\"\n        Return a periodic cell with the given orthogonal cell dimensions.\n\n        If cell_size is not specified, it will be assumed (and may be incorrect).\n        \"\"\"\n        # TODO: test this\n        from .atomcell import AtomCell\n\n        if cell_size is None:\n            warnings.warn(\"Cell boundary unknown. Defaulting to cell BBox\")\n            cell_size = self.bbox().size\n            cell_origin = self.bbox().min\n\n        # TODO test this origin code\n        cell = Cell.from_unit_cell(cell_size)\n        if cell_origin is not None:\n            cell = cell.transform_cell(AffineTransform3D.translate(to_vec3(cell_origin)))\n\n        return AtomCell(self.get_atoms(), cell, frame='local')\n\n    # property getters and setters\n\n    def coords(self, selection: t.Optional[AtomSelection] = None, *, frame: t.Literal['local'] = 'local') -&gt; NDArray[numpy.float64]:\n        \"\"\"Return a `(N, 3)` ndarray of atom coordinates (dtype [`numpy.float64`][numpy.float64]).\"\"\"\n        df = self if selection is None else self.filter(_selection_to_expr(self, selection))\n        return df.get_column('coords').to_numpy().astype(numpy.float64)\n\n    def x(self) -&gt; polars.Expr:\n        return polars.col('coords').arr.get(0).alias('x')\n\n    def y(self) -&gt; polars.Expr:\n        return polars.col('coords').arr.get(1).alias('y')\n\n    def z(self) -&gt; polars.Expr:\n        return polars.col('coords').arr.get(2).alias('z')\n\n    def velocities(self, selection: t.Optional[AtomSelection] = None) -&gt; t.Optional[NDArray[numpy.float64]]:\n        \"\"\"Return a `(N, 3)` ndarray of atom velocities (dtype [`numpy.float64`][numpy.float64]).\"\"\"\n        if 'velocity' not in self:\n            return None\n\n        df = self if selection is None else self.filter(_selection_to_expr(self, selection))\n        return df.get_column('velocity').to_numpy().astype(numpy.float64)\n\n    def types(self) -&gt; t.Optional[polars.Series]:\n        \"\"\"\n        Returns a [`Series`][polars.Series] of atom types (dtype [`polars.Int32`][polars.Int32]).\n\n        [polars.Series]: https://docs.pola.rs/py-polars/html/reference/series/index.html\n        \"\"\"\n        return self.try_get_column('type')\n\n    def masses(self) -&gt; t.Optional[polars.Series]:\n        \"\"\"\n        Returns a [`Series`][polars.Series] of atom masses (dtype [`polars.Float32`][polars.Float32]).\n\n        [polars.Series]: https://docs.pola.rs/py-polars/html/reference/series/index.html\n        \"\"\"\n        return self.try_get_column('mass')\n\n    @t.overload\n    def add_atom(self: HasAtomsT, elem: t.Union[int, str], x: ArrayLike, /, *,\n                 y: None = None, z: None = None,\n                 **kwargs: t.Any) -&gt; HasAtomsT:\n        ...\n\n    @t.overload\n    def add_atom(self: HasAtomsT, elem: t.Union[int, str], /,\n                 x: float, y: float, z: float,\n                 **kwargs: t.Any) -&gt; HasAtomsT:\n        ...\n\n    def add_atom(self: HasAtomsT, elem: t.Union[int, str], /,\n                 x: t.Union[ArrayLike, float],\n                 y: t.Optional[float] = None,\n                 z: t.Optional[float] = None,\n                 **kwargs: t.Any) -&gt; HasAtomsT:\n        \"\"\"\n        Return a copy of `self` with an extra atom.\n\n        By default, all extra columns present in `self` must be specified as `**kwargs`.\n\n        Try to avoid calling this in a loop (Use [`HasAtoms.concat`][atomlib.atoms.HasAtoms.concat] instead).\n        \"\"\"\n        if isinstance(elem, int):\n            kwargs.update(elem=elem)\n        else:\n            kwargs.update(symbol=elem)\n        if hasattr(x, '__len__') and len(x) &gt; 1:  # type: ignore\n            (x, y, z) = to_vec3(x)\n        elif y is None or z is None:\n            raise ValueError(f\"Must specify vector of positions or x, y, &amp; z.\")\n\n        sym = get_sym(elem) if isinstance(elem, int) else elem\n        d: t.Dict[str, t.Any] = {'x': x, 'y': y, 'z': z, 'symbol': sym, **kwargs}\n        return self.concat(\n            (self, Atoms(d).select_schema(self.schema)),\n            how='vertical'\n        )\n\n    @t.overload\n    def pos(self, x: t.Sequence[t.Optional[float]], /, *,\n            y: None = None, z: None = None,\n            tol: float = 1e-6, **kwargs: t.Any) -&gt; polars.Expr:\n        ...\n\n    @t.overload\n    def pos(self, x: t.Optional[float] = None, y: t.Optional[float] = None, z: t.Optional[float] = None, *,\n            tol: float = 1e-6, **kwargs: t.Any) -&gt; polars.Expr:\n        ...\n\n    def pos(self,\n            x: t.Union[t.Sequence[t.Optional[float]], float, None] = None,\n            y: t.Optional[float] = None, z: t.Optional[float] = None, *,\n            tol: float = 1e-6, **kwargs: t.Any) -&gt; polars.Expr:\n        \"\"\"\n        Select all atoms at a given position.\n\n        Formally, returns all atoms within a cube of radius ``tol``\n        centered at ``(x,y,z)``, exclusive of the cube's surface.\n\n        Additional parameters given as ``kwargs`` will be checked\n        as additional parameters (with strict equality).\n        \"\"\"\n\n        if isinstance(x, t.Sequence):\n            (x, y, z) = x\n\n        tol = abs(float(tol))\n        selection = polars.lit(True)\n        if x is not None:\n            selection &amp;= self.x().is_between(x - tol, x + tol, closed='none')\n        if y is not None:\n            selection &amp;= self.y().is_between(y - tol, y + tol, closed='none')\n        if z is not None:\n            selection &amp;= self.z().is_between(z - tol, z + tol, closed='none')\n        for (col, val) in kwargs.items():\n            selection &amp;= (polars.col(col) == val)\n\n        return selection\n\n    def with_index(self: HasAtomsT, index: t.Optional[AtomValues] = None) -&gt; HasAtomsT:\n        \"\"\"\n        Returns `self` with a row index added in column 'i' (dtype [`polars.Int64`][polars.Int64]).\n        If `index` is not specified, defaults to an existing index or a new index.\n        \"\"\"\n        if index is None and 'i' in self.columns:\n            return self\n        if index is None:\n            index = numpy.arange(len(self), dtype=numpy.int64)\n        return self.with_column(_values_to_expr(self, index, polars.Int64).alias('i'))\n\n    def with_wobble(self: HasAtomsT, wobble: t.Optional[AtomValues] = None) -&gt; HasAtomsT:\n        \"\"\"\n        Return `self` with the given displacements in column 'wobble' (dtype [`polars.Float64`][polars.Float64]).\n        If `wobble` is not specified, defaults to the already-existing wobbles or 0.\n        \"\"\"\n        if wobble is None and 'wobble' in self.columns:\n            return self\n        wobble = 0. if wobble is None else wobble\n        return self.with_column(_values_to_expr(self, wobble, polars.Float64).alias('wobble'))\n\n    def with_occupancy(self: HasAtomsT, frac_occupancy: t.Optional[AtomValues] = None) -&gt; HasAtomsT:\n        \"\"\"\n        Return self with the given fractional occupancies. If `frac_occupancy` is not specified,\n        defaults to the already-existing occupancies or 1.\n        \"\"\"\n        if frac_occupancy is None and 'frac_occupancy' in self.columns:\n            return self\n        frac_occupancy = 1. if frac_occupancy is None else frac_occupancy\n        return self.with_column(_values_to_expr(self, frac_occupancy, polars.Float64).alias('frac_occupancy'))\n\n    def apply_wobble(self: HasAtomsT, rng: t.Union[numpy.random.Generator, int, None] = None) -&gt; HasAtomsT:\n        \"\"\"\n        Displace the atoms in `self` by the amount in the `wobble` column.\n        `wobble` is interpretated as a mean-squared displacement, which is distributed\n        equally over each axis.\n        \"\"\"\n        if 'wobble' not in self.columns:\n            return self\n        rng = numpy.random.default_rng(seed=rng)\n\n        stddev = self.select((polars.col('wobble') / 3.).sqrt()).to_series().to_numpy()\n        coords = self.coords()\n        coords += stddev[:, None] * rng.standard_normal(coords.shape)\n        return self.with_coords(coords)\n\n    def apply_occupancy(self: HasAtomsT, rng: t.Union[numpy.random.Generator, int, None] = None) -&gt; HasAtomsT:\n        \"\"\"\n        For each atom in `self`, use its `frac_occupancy` to randomly decide whether to remove it.\n        \"\"\"\n        if 'frac_occupancy' not in self.columns:\n            return self\n        rng = numpy.random.default_rng(seed=rng)\n\n        frac = self.select('frac_occupancy').to_series().to_numpy()\n        choice = rng.binomial(1, frac).astype(numpy.bool_)\n        return self.filter(polars.lit(choice))\n\n    def with_type(self: HasAtomsT, types: t.Optional[AtomValues] = None) -&gt; HasAtomsT:\n        \"\"\"\n        Return `self` with the given atom types in column 'type'.\n        If `types` is not specified, use the already existing types or auto-assign them.\n\n        When auto-assigning, each symbol is given a unique value, case-sensitive.\n        Values are assigned from lowest atomic number to highest.\n        For instance: `[\"Ag+\", \"Na\", \"H\", \"Ag\"]` =&gt; `[3, 11, 1, 2]`\n        \"\"\"\n        if types is not None:\n            return self.with_columns(type=_values_to_expr(self, types, polars.Int32))\n        if 'type' in self.columns:\n            return self\n\n        unique = Atoms(self._get_frame().unique(maintain_order=False, subset=['elem', 'symbol']).sort(['elem', 'symbol']), _unchecked=True)\n        new = self.with_column(polars.Series('type', values=numpy.zeros(len(self)), dtype=polars.Int32))\n\n        logging.warning(\"Auto-assigning element types\")\n        for (i, (elem, sym)) in enumerate(unique.select(('elem', 'symbol')).rows()):\n            print(f\"Assigning type {i+1} to element '{sym}'\")\n            new = new.with_column(polars.when((polars.col('elem') == elem) &amp; (polars.col('symbol') == sym))\n                                        .then(polars.lit(i+1))\n                                        .otherwise(polars.col('type'))\n                                        .alias('type'))\n\n        assert (new.get_column('type') == 0).sum() == 0\n        return new\n\n    def with_mass(self: HasAtomsT, mass: t.Optional[ArrayLike] = None) -&gt; HasAtomsT:\n        \"\"\"\n        Return `self` with the given atom masses in column 'mass'.\n        If `mass` is not specified, use the already existing masses or auto-assign them.\n        \"\"\"\n        if mass is not None:\n            return self.with_column(_values_to_expr(self, mass, polars.Float32).alias('mass'))\n        if 'mass' in self.columns:\n            return self\n\n        unique_elems = self.get_column('elem').unique()\n        new = self.with_column(polars.Series('mass', values=numpy.zeros(len(self)), dtype=polars.Float32))\n\n        logging.warning(\"Auto-assigning element masses\")\n        for elem in unique_elems:\n            new = new.with_column(polars.when(polars.col('elem') == elem)\n                                        .then(polars.lit(get_mass(elem)))\n                                        .otherwise(polars.col('mass'))\n                                        .alias('mass'))\n\n        assert (new.get_column('mass').abs() &lt; 1e-10).sum() == 0\n        return new\n\n    def with_symbol(self: HasAtomsT, symbols: ArrayLike, selection: t.Optional[AtomSelection] = None) -&gt; HasAtomsT:\n        \"\"\"\n        Return `self` with the given atomic symbols.\n        \"\"\"\n        if selection is not None:\n            selection = _selection_to_numpy(self, selection)\n            new_symbols = self.get_column('symbol')\n            new_symbols[selection] = polars.Series(list(numpy.broadcast_to(symbols, len(selection))), dtype=polars.Utf8)\n            symbols = new_symbols\n\n        # TODO better cast here\n        symbols = polars.Series('symbol', list(numpy.broadcast_to(symbols, len(self))), dtype=polars.Utf8)\n        return self.with_columns((symbols, get_elem(symbols)))\n\n    def with_coords(self: HasAtomsT, pts: ArrayLike, selection: t.Optional[AtomSelection] = None, *, frame: t.Literal['local'] = 'local') -&gt; HasAtomsT:\n        \"\"\"\n        Return `self` replaced with the given atomic positions.\n        \"\"\"\n        if selection is not None:\n            selection = _selection_to_numpy(self, selection)\n            new_pts = self.coords()\n            pts = numpy.atleast_2d(pts)\n            assert pts.shape[-1] == 3\n            new_pts[selection] = pts\n            pts = new_pts\n\n        pts = numpy.broadcast_to(pts, (len(self), 3))\n        return self.with_columns(polars.Series('coords', pts, polars.Array(polars.Float64, 3)))\n\n    def with_velocity(self: HasAtomsT, pts: t.Optional[ArrayLike] = None,\n                      selection: t.Optional[AtomSelection] = None) -&gt; HasAtomsT:\n        \"\"\"\n        Return `self` replaced with the given atomic velocities.\n        If `pts` is not specified, use the already existing velocities or zero.\n        \"\"\"\n        if pts is None:\n            if 'velocity' in self:\n                return self\n            all_pts = numpy.zeros((len(self), 3))\n        else:\n            all_pts = self['velocity'].to_numpy()\n\n        if selection is None:\n            all_pts = pts or all_pts\n        elif pts is not None:\n            selection = _selection_to_numpy(self, selection)\n            all_pts = numpy.require(all_pts, requirements=['WRITEABLE'])\n            pts = numpy.atleast_2d(pts)\n            assert pts.shape[-1] == 3\n            all_pts[selection] = pts\n\n        all_pts = numpy.broadcast_to(all_pts, (len(self), 3))\n        return self.with_columns(polars.Series('velocity', all_pts, polars.Array(polars.Float64, 3)))\n</code></pre>"},{"location":"api/#atomlib.HasAtoms.columns","title":"<code>columns: t.Sequence[str]</code>  <code>property</code>","text":"<p>Return the columns in <code>self</code>.</p>"},{"location":"api/#atomlib.HasAtoms.dtypes","title":"<code>dtypes: t.Sequence[polars.DataType]</code>  <code>property</code>","text":"<p>Return the datatypes in <code>self</code>.</p>"},{"location":"api/#atomlib.HasAtoms.schema","title":"<code>schema: SchemaDict</code>  <code>property</code>","text":"<p>Return the schema of <code>self</code>.</p>"},{"location":"api/#atomlib.HasAtoms.with_column","title":"<code>with_column = with_columns</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#atomlib.HasAtoms.bbox","title":"<code>bbox = bbox_atoms</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#atomlib.HasAtoms.transform","title":"<code>transform = transform_atoms</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#atomlib.HasAtoms.crop_atoms","title":"<code>crop_atoms = crop</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#atomlib.HasAtoms.unique","title":"<code>unique = deduplicate</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#atomlib.HasAtoms.get_atoms","title":"<code>get_atoms(frame='local')</code>  <code>abstractmethod</code>","text":"<p>Get atoms contained in <code>self</code>. This should be a low cost method.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>@abc.abstractmethod\ndef get_atoms(self, frame: t.Literal['local'] = 'local') -&gt; Atoms:\n    \"\"\"Get atoms contained in `self`. This should be a low cost method.\"\"\"\n    ...\n</code></pre>"},{"location":"api/#atomlib.HasAtoms.with_atoms","title":"<code>with_atoms(atoms, frame='local')</code>  <code>abstractmethod</code>","text":"Source code in <code>atomlib/atoms.py</code> <pre><code>@abc.abstractmethod\ndef with_atoms(self: HasAtomsT, atoms: HasAtoms, frame: t.Literal['local'] = 'local') -&gt; HasAtomsT:\n    ...\n</code></pre>"},{"location":"api/#atomlib.HasAtoms.describe","title":"<code>describe(percentiles=(0.25, 0.5, 0.75), *, interpolation='nearest')</code>","text":"<p>Return summary statistics for <code>self</code>.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>@_fwd_frame(polars.DataFrame.describe)\ndef describe(self, percentiles: t.Union[t.Sequence[float], float, None] = (0.25, 0.5, 0.75), *,\n             interpolation: RollingInterpolationMethod = 'nearest') -&gt; polars.DataFrame:\n    \"\"\"Return summary statistics for `self`.\"\"\"\n    ...\n</code></pre>"},{"location":"api/#atomlib.HasAtoms.with_columns","title":"<code>with_columns(*exprs, **named_exprs)</code>","text":"<p>Return a copy of <code>self</code> with the given columns added.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>@_fwd_frame_map\ndef with_columns(self,\n                 *exprs: t.Union[IntoExpr, t.Iterable[IntoExpr]],\n                 **named_exprs: IntoExpr) -&gt; polars.DataFrame:\n    \"\"\"Return a copy of `self` with the given columns added.\"\"\"\n    return self._get_frame().with_columns(*exprs, **named_exprs)\n</code></pre>"},{"location":"api/#atomlib.HasAtoms.insert_column","title":"<code>insert_column(index, column)</code>","text":"Source code in <code>atomlib/atoms.py</code> <pre><code>@_fwd_frame_map\ndef insert_column(self, index: int, column: polars.Series) -&gt; polars.DataFrame:\n    return self._get_frame().insert_column(index, column)\n</code></pre>"},{"location":"api/#atomlib.HasAtoms.get_column","title":"<code>get_column(name)</code>","text":"<p>Get the specified column from <code>self</code>, raising <code>polars.ColumnNotFoundError</code> if it's not present.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>@_fwd_frame(polars.DataFrame.get_column)\ndef get_column(self, name: str) -&gt; polars.Series:\n    \"\"\"Get the specified column from `self`, raising [`polars.ColumnNotFoundError`][polars.exceptions.ColumnNotFoundError] if it's not present.\"\"\"\n    ...\n</code></pre>"},{"location":"api/#atomlib.HasAtoms.get_columns","title":"<code>get_columns()</code>","text":"<p>Get the specified columns from <code>self</code>, raising <code>polars.ColumnNotFoundError</code> if it's not present.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>@_fwd_frame(polars.DataFrame.get_columns)\ndef get_columns(self) -&gt; t.List[polars.Series]:\n    \"\"\"Get the specified columns from `self`, raising [`polars.ColumnNotFoundError`][polars.exceptions.ColumnNotFoundError] if it's not present.\"\"\"\n    ...\n</code></pre>"},{"location":"api/#atomlib.HasAtoms.get_column_index","title":"<code>get_column_index(name)</code>","text":"<p>Get the index of a column by name, raising <code>polars.ColumnNotFoundError</code> if it's not present.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>@_fwd_frame(polars.DataFrame.get_column_index)\ndef get_column_index(self, name: str) -&gt; int:\n    \"\"\"Get the index of a column by name, raising [`polars.ColumnNotFoundError`][polars.exceptions.ColumnNotFoundError] if it's not present.\"\"\"\n    ...\n</code></pre>"},{"location":"api/#atomlib.HasAtoms.group_by","title":"<code>group_by(*by, maintain_order=False, **named_by)</code>","text":"Source code in <code>atomlib/atoms.py</code> <pre><code>@_fwd_frame(polars.DataFrame.group_by)\ndef group_by(self, *by: t.Union[IntoExpr, t.Iterable[IntoExpr]], maintain_order: bool = False,\n             **named_by: IntoExpr) -&gt; polars.dataframe.group_by.GroupBy:\n    ...\n</code></pre>"},{"location":"api/#atomlib.HasAtoms.pipe","title":"<code>pipe(function, *args, **kwargs)</code>","text":"<p>Apply <code>function</code> to <code>self</code> (in method-call syntax).</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def pipe(self: HasAtomsT, function: t.Callable[Concatenate[HasAtomsT, P], T], *args: P.args, **kwargs: P.kwargs) -&gt; T:\n    \"\"\"Apply `function` to `self` (in method-call syntax).\"\"\"\n    return function(self, *args, **kwargs)\n</code></pre>"},{"location":"api/#atomlib.HasAtoms.clone","title":"<code>clone()</code>","text":"<p>Return a copy of <code>self</code>.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>@_fwd_frame_map\ndef clone(self) -&gt; polars.DataFrame:\n    \"\"\"Return a copy of `self`.\"\"\"\n    return self._get_frame().clone()\n</code></pre>"},{"location":"api/#atomlib.HasAtoms.drop","title":"<code>drop(*columns)</code>","text":"<p>Return <code>self</code> with the specified columns removed.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def drop(self, *columns: t.Union[str, t.Iterable[str]]) -&gt; polars.DataFrame:\n    \"\"\"Return `self` with the specified columns removed.\"\"\"\n    return self._get_frame().drop(*columns)\n</code></pre>"},{"location":"api/#atomlib.HasAtoms.filter","title":"<code>filter(*predicates, **constraints)</code>","text":"<p>Filter <code>self</code>, removing rows which evaluate to <code>False</code>.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def filter(\n    self: HasAtomsT,\n    *predicates: t.Union[None, IntoExprColumn, t.Iterable[IntoExprColumn], bool, t.List[bool], numpy.ndarray],\n    **constraints: t.Any,\n) -&gt; HasAtomsT:\n    \"\"\"Filter `self`, removing rows which evaluate to `False`.\"\"\"\n    # TODO clean up\n    preds_not_none: t.Tuple[t.Union[IntoExprColumn, t.Iterable[IntoExprColumn], bool, t.List[bool], numpy.ndarray], ...]\n    preds_not_none = tuple(filter(lambda p: p is not None, predicates))  # type: ignore\n    if not len(preds_not_none) and not len(constraints):\n        return self\n    return self.with_atoms(Atoms(self._get_frame().filter(*preds_not_none, **constraints), _unchecked=True))\n</code></pre>"},{"location":"api/#atomlib.HasAtoms.sort","title":"<code>sort(by, *more_by, descending=False, nulls_last=False)</code>","text":"<p>Sort the atoms in <code>self</code> by the given columns/expressions.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>@_fwd_frame_map\ndef sort(\n    self,\n    by: t.Union[IntoExpr, t.Iterable[IntoExpr]],\n    *more_by: IntoExpr,\n    descending: t.Union[bool, t.Sequence[bool]] = False,\n    nulls_last: bool = False,\n) -&gt; polars.DataFrame:\n    \"\"\"\n    Sort the atoms in `self` by the given columns/expressions.\n    \"\"\"\n    return self._get_frame().sort(\n        by, *more_by, descending=descending, nulls_last=nulls_last\n    )\n</code></pre>"},{"location":"api/#atomlib.HasAtoms.slice","title":"<code>slice(offset, length=None)</code>","text":"<p>Return a slice of the rows in <code>self</code>.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>@_fwd_frame_map\ndef slice(self, offset: int, length: t.Optional[int] = None) -&gt; polars.DataFrame:\n    \"\"\"Return a slice of the rows in `self`.\"\"\"\n    return self._get_frame().slice(offset, length)\n</code></pre>"},{"location":"api/#atomlib.HasAtoms.head","title":"<code>head(n=5)</code>","text":"<p>Return the first <code>n</code> rows of <code>self</code>.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>@_fwd_frame_map\ndef head(self, n: int = 5) -&gt; polars.DataFrame:\n    \"\"\"Return the first `n` rows of `self`.\"\"\"\n    return self._get_frame().head(n)\n</code></pre>"},{"location":"api/#atomlib.HasAtoms.tail","title":"<code>tail(n=5)</code>","text":"<p>Return the last <code>n</code> rows of <code>self</code>.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>@_fwd_frame_map\ndef tail(self, n: int = 5) -&gt; polars.DataFrame:\n    \"\"\"Return the last `n` rows of `self`.\"\"\"\n    return self._get_frame().tail(n)\n</code></pre>"},{"location":"api/#atomlib.HasAtoms.drop_nulls","title":"<code>drop_nulls(subset=None)</code>","text":"<p>Drop rows that contain nulls in any of columns <code>subset</code>.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>@_fwd_frame_map\ndef drop_nulls(self, subset: t.Union[str, t.Collection[str], None] = None) -&gt; polars.DataFrame:\n    \"\"\"Drop rows that contain nulls in any of columns `subset`.\"\"\"\n    return self._get_frame().drop_nulls(subset)\n</code></pre>"},{"location":"api/#atomlib.HasAtoms.fill_null","title":"<code>fill_null(value=None, strategy=None, limit=None, matches_supertype=True)</code>","text":"<p>Fill null values in <code>self</code>, using the specified value or strategy.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>@_fwd_frame_map\ndef fill_null(\n    self, value: t.Any = None, strategy: t.Optional[FillNullStrategy] = None,\n    limit: t.Optional[int] = None, matches_supertype: bool = True,\n) -&gt; polars.DataFrame:\n    \"\"\"Fill null values in `self`, using the specified value or strategy.\"\"\"\n    return self._get_frame().fill_null(value, strategy, limit, matches_supertype=matches_supertype)\n</code></pre>"},{"location":"api/#atomlib.HasAtoms.fill_nan","title":"<code>fill_nan(value)</code>","text":"<p>Fill floating-point NaN values in <code>self</code>.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>@_fwd_frame_map\ndef fill_nan(self, value: t.Union[polars.Expr, int, float, None]) -&gt; polars.DataFrame:\n    \"\"\"Fill floating-point NaN values in `self`.\"\"\"\n    return self._get_frame().fill_nan(value)\n</code></pre>"},{"location":"api/#atomlib.HasAtoms.concat","title":"<code>concat(atoms, *, rechunk=True, how='vertical')</code>  <code>classmethod</code>","text":"<p>Concatenate multiple <code>Atoms</code> together, handling metadata appropriately.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>@classmethod\ndef concat(cls: t.Type[HasAtomsT],\n           atoms: t.Union[HasAtomsT, IntoAtoms, t.Iterable[t.Union[HasAtomsT, IntoAtoms]]], *,\n           rechunk: bool = True, how: ConcatMethod = 'vertical') -&gt; HasAtomsT:\n    \"\"\"Concatenate multiple `Atoms` together, handling metadata appropriately.\"\"\"\n    # this method is tricky. It needs to accept raw Atoms, as well as HasAtoms of the\n    # same type as ``cls``.\n    if _is_abstract(cls):\n        raise TypeError(f\"concat() must be called on a concrete class.\")\n\n    if isinstance(atoms, HasAtoms):\n        atoms = (atoms,)\n    dfs = [a.get_atoms('local').inner if isinstance(a, HasAtoms) else Atoms(t.cast(IntoAtoms, a)).inner for a in atoms]\n    representative = cls._combine_metadata(*(a for a in atoms if isinstance(a, HasAtoms)))\n\n    if len(dfs) == 0:\n        return representative.with_atoms(Atoms.empty(), 'local')\n\n    if how in ('vertical', 'vertical_relaxed'):\n        # get order from first member\n        cols = dfs[0].columns\n        dfs = [df.select(cols) for df in dfs]\n    elif how == 'inner':\n        cols = reduce(operator.and_, (df.schema.keys() for df in dfs))\n        schema = OrderedDict((col, dfs[0].schema[col]) for col in cols)\n        if len(schema) == 0:\n            raise ValueError(f\"Atoms have no columns in common\")\n\n        dfs = [_select_schema(df, schema) for df in dfs]\n        how = 'vertical'\n\n    return representative.with_atoms(Atoms(polars.concat(dfs, rechunk=rechunk, how=how)), 'local')\n</code></pre>"},{"location":"api/#atomlib.HasAtoms.partition_by","title":"<code>partition_by(by, *more_by, maintain_order=True, include_key=True, as_dict=False)</code>","text":"<p>Group by the given columns and partition into separate dataframes.</p> <p>Return the partitions as a dictionary by specifying <code>as_dict=True</code>.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def partition_by(\n    self: HasAtomsT, by: t.Union[str, t.Sequence[str]], *more_by: str,\n    maintain_order: bool = True, include_key: bool = True, as_dict: bool = False\n) -&gt; t.Union[t.List[HasAtomsT], t.Dict[t.Any, HasAtomsT]]:\n    \"\"\"\n    Group by the given columns and partition into separate dataframes.\n\n    Return the partitions as a dictionary by specifying `as_dict=True`.\n    \"\"\"\n    if as_dict:\n        d = self._get_frame().partition_by(by, *more_by, maintain_order=maintain_order, include_key=include_key, as_dict=True)\n        return {k: self.with_atoms(Atoms(df, _unchecked=True)) for (k, df) in d.items()}\n\n    return [\n        self.with_atoms(Atoms(df, _unchecked=True))\n        for df in self._get_frame().partition_by(by, *more_by, maintain_order=maintain_order, include_key=include_key, as_dict=False)\n    ]\n</code></pre>"},{"location":"api/#atomlib.HasAtoms.select","title":"<code>select(*exprs, **named_exprs)</code>","text":"<p>Select <code>exprs</code> from <code>self</code>, and return as a <code>polars.DataFrame</code>.</p> <p>Expressions may either be columns or expressions of columns.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>@_fwd_frame(polars.DataFrame.select)\ndef select(\n    self,\n    *exprs: t.Union[IntoExpr, t.Iterable[IntoExpr]],\n    **named_exprs: IntoExpr,\n):\n    \"\"\"\n    Select `exprs` from `self`, and return as a `polars.DataFrame`.\n\n    Expressions may either be columns or expressions of columns.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/#atomlib.HasAtoms.select_schema","title":"<code>select_schema(schema)</code>","text":"<p>Select columns from <code>self</code> and cast to the given schema. Raises <code>TypeError</code> if a column is not found or if it can't be cast.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def select_schema(self, schema: SchemaDict) -&gt; polars.DataFrame:\n    \"\"\"\n    Select columns from `self` and cast to the given schema.\n    Raises `TypeError` if a column is not found or if it can't be cast.\n    \"\"\"\n    return _select_schema(self, schema)\n</code></pre>"},{"location":"api/#atomlib.HasAtoms.select_props","title":"<code>select_props(*exprs, **named_exprs)</code>","text":"<p>Select <code>exprs</code> from <code>self</code>, while keeping required columns.</p> <p>Returns a HasAtoms.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def select_props(\n    self: HasAtomsT,\n    *exprs: t.Union[IntoExpr, t.Iterable[IntoExpr]],\n    **named_exprs: IntoExpr\n) -&gt; HasAtomsT:\n    \"\"\"\n    Select `exprs` from `self`, while keeping required columns.\n\n    Returns a HasAtoms.\n    \"\"\"\n    props = self._get_frame().lazy().select(*exprs, **named_exprs).drop(_REQUIRED_COLUMNS).collect(_eager=True)\n    return self.with_atoms(\n        Atoms(self._get_frame().select(_REQUIRED_COLUMNS).hstack(props), _unchecked=False)\n    )\n</code></pre>"},{"location":"api/#atomlib.HasAtoms.try_select","title":"<code>try_select(*exprs, **named_exprs)</code>","text":"<p>Try to select <code>exprs</code> from <code>self</code>, and return as a <code>DataFrame</code>.</p> <p>Expressions may either be columns or expressions of columns. Return <code>None</code> if any columns are missing.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def try_select(\n    self,\n    *exprs: t.Union[IntoExpr, t.Iterable[IntoExpr]],\n    **named_exprs: IntoExpr,\n) -&gt; t.Optional[polars.DataFrame]:\n    \"\"\"\n    Try to select `exprs` from `self`, and return as a `DataFrame`.\n\n    Expressions may either be columns or expressions of columns.\n    Return `None` if any columns are missing.\n    \"\"\"\n    try:\n        return self._get_frame().select(*exprs, **named_exprs)\n    except polars.ColumnNotFoundError:\n        return None\n</code></pre>"},{"location":"api/#atomlib.HasAtoms.try_get_column","title":"<code>try_get_column(name)</code>","text":"<p>Try to get a column from <code>self</code>, returning <code>None</code> if it doesn't exist.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def try_get_column(self, name: str) -&gt; t.Optional[polars.Series]:\n    \"\"\"Try to get a column from `self`, returning `None` if it doesn't exist.\"\"\"\n    try:\n        return self.get_column(name)\n    except polars.ColumnNotFoundError:\n        return None\n</code></pre>"},{"location":"api/#atomlib.HasAtoms.assert_equal","title":"<code>assert_equal(other)</code>","text":"Source code in <code>atomlib/atoms.py</code> <pre><code>def assert_equal(self, other: t.Any):\n    assert isinstance(other, HasAtoms)\n    assert dict(self.schema) == dict(other.schema)\n    for col in self.schema.keys():\n        polars.testing.assert_series_equal(self[col], other[col], check_names=False, rtol=1e-3, atol=1e-8)\n</code></pre>"},{"location":"api/#atomlib.HasAtoms.bbox_atoms","title":"<code>bbox_atoms()</code>","text":"<p>Return the bounding box of all the atoms in <code>self</code>.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def bbox_atoms(self) -&gt; BBox3D:\n    \"\"\"Return the bounding box of all the atoms in ``self``.\"\"\"\n    return BBox3D.from_pts(self.coords())\n</code></pre>"},{"location":"api/#atomlib.HasAtoms.transform_atoms","title":"<code>transform_atoms(transform, selection=None, *, transform_velocities=False)</code>","text":"<p>Transform the atoms in <code>self</code> by <code>transform</code>. If <code>selection</code> is given, only transform the atoms in <code>selection</code>.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def transform_atoms(self: HasAtomsT, transform: IntoTransform3D, selection: t.Optional[AtomSelection] = None, *, transform_velocities: bool = False) -&gt; HasAtomsT:\n    \"\"\"\n    Transform the atoms in `self` by `transform`.\n    If `selection` is given, only transform the atoms in `selection`.\n    \"\"\"\n    transform = Transform3D.make(transform)\n    selection = _selection_to_numpy(self, selection)\n    transformed = self.with_coords(Transform3D.make(transform) @ self.coords(selection), selection)\n    # try to transform velocities as well\n    if transform_velocities and (velocities := self.velocities(selection)) is not None:\n        return transformed.with_velocity(transform.transform_vec(velocities), selection)\n    return transformed\n</code></pre>"},{"location":"api/#atomlib.HasAtoms.round_near_zero","title":"<code>round_near_zero(tol=1e-14)</code>","text":"<p>Round atom position values near zero to zero.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def round_near_zero(self: HasAtomsT, tol: float = 1e-14) -&gt; HasAtomsT:\n    \"\"\"\n    Round atom position values near zero to zero.\n    \"\"\"\n    return self.with_columns(coords=polars.concat_list(\n        polars.when(_coord_expr(col).abs() &gt;= tol).then(_coord_expr(col)).otherwise(polars.lit(0.))\n        for col in range(3)\n    ).list.to_array(3))\n</code></pre>"},{"location":"api/#atomlib.HasAtoms.crop","title":"<code>crop(x_min=-numpy.inf, x_max=numpy.inf, y_min=-numpy.inf, y_max=numpy.inf, z_min=-numpy.inf, z_max=numpy.inf)</code>","text":"<p>Crop, removing all atoms outside of the specified region, inclusive.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def crop(self: HasAtomsT, x_min: float = -numpy.inf, x_max: float = numpy.inf,\n         y_min: float = -numpy.inf, y_max: float = numpy.inf,\n         z_min: float = -numpy.inf, z_max: float = numpy.inf) -&gt; HasAtomsT:\n    \"\"\"\n    Crop, removing all atoms outside of the specified region, inclusive.\n    \"\"\"\n\n    return self.filter(\n        self.x().is_between(x_min, x_max, closed='both'),\n        self.y().is_between(y_min, y_max, closed='both'),\n        self.z().is_between(z_min, z_max, closed='both'),\n    )\n</code></pre>"},{"location":"api/#atomlib.HasAtoms.deduplicate","title":"<code>deduplicate(tol=0.001, subset=('x', 'y', 'z', 'symbol'), keep='first', maintain_order=True)</code>","text":"<p>De-duplicate atoms in <code>self</code>. Atoms of the same <code>symbol</code> that are closer than <code>tolerance</code> to each other (by Euclidian distance) will be removed, leaving only the atom specified by <code>keep</code> (defaults to the first atom).</p> <p>If <code>subset</code> is specified, only those columns will be included while assessing duplicates. Floating point columns other than 'x', 'y', and 'z' will not by toleranced.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def deduplicate(self: HasAtomsT, tol: float = 1e-3, subset: t.Iterable[str] = ('x', 'y', 'z', 'symbol'),\n                keep: UniqueKeepStrategy = 'first', maintain_order: bool = True) -&gt; HasAtomsT:\n    \"\"\"\n    De-duplicate atoms in `self`. Atoms of the same `symbol` that are closer than `tolerance`\n    to each other (by Euclidian distance) will be removed, leaving only the atom specified by\n    `keep` (defaults to the first atom).\n\n    If `subset` is specified, only those columns will be included while assessing duplicates.\n    Floating point columns other than 'x', 'y', and 'z' will not by toleranced.\n    \"\"\"\n    import scipy.spatial\n\n    cols = set((subset,) if isinstance(subset, str) else subset)\n\n    indices = numpy.arange(len(self))\n\n    spatial_cols = cols.intersection(('x', 'y', 'z'))\n    cols -= spatial_cols\n    if len(spatial_cols) &gt; 0:\n        coords = self.select([_coord_expr(col).alias(col) for col in spatial_cols]).to_numpy()\n        tree = scipy.spatial.KDTree(coords)\n\n        # TODO This is a bad algorithm\n        while True:\n            changed = False\n            for (i, j) in tree.query_pairs(tol, 2.):\n                # whenever we encounter a pair, ensure their index matches\n                i_i, i_j = indices[[i, j]]\n                if i_i != i_j:\n                    indices[i] = indices[j] = min(i_i, i_j)\n                    changed = True\n            if not changed:\n                break\n\n        self = self.with_column(polars.Series('_unique_pts', indices))\n        cols.add('_unique_pts')\n\n    frame = self._get_frame().unique(subset=list(cols), keep=keep, maintain_order=maintain_order)\n    if len(spatial_cols) &gt; 0:\n        frame = frame.drop('_unique_pts')\n\n    return self.with_atoms(Atoms(frame, _unchecked=True))\n</code></pre>"},{"location":"api/#atomlib.HasAtoms.with_bounds","title":"<code>with_bounds(cell_size=None, cell_origin=None)</code>","text":"<p>Return a periodic cell with the given orthogonal cell dimensions.</p> <p>If cell_size is not specified, it will be assumed (and may be incorrect).</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def with_bounds(self, cell_size: t.Optional[VecLike] = None, cell_origin: t.Optional[VecLike] = None) -&gt; 'AtomCell':\n    \"\"\"\n    Return a periodic cell with the given orthogonal cell dimensions.\n\n    If cell_size is not specified, it will be assumed (and may be incorrect).\n    \"\"\"\n    # TODO: test this\n    from .atomcell import AtomCell\n\n    if cell_size is None:\n        warnings.warn(\"Cell boundary unknown. Defaulting to cell BBox\")\n        cell_size = self.bbox().size\n        cell_origin = self.bbox().min\n\n    # TODO test this origin code\n    cell = Cell.from_unit_cell(cell_size)\n    if cell_origin is not None:\n        cell = cell.transform_cell(AffineTransform3D.translate(to_vec3(cell_origin)))\n\n    return AtomCell(self.get_atoms(), cell, frame='local')\n</code></pre>"},{"location":"api/#atomlib.HasAtoms.coords","title":"<code>coords(selection=None, *, frame='local')</code>","text":"<p>Return a <code>(N, 3)</code> ndarray of atom coordinates (dtype <code>numpy.float64</code>).</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def coords(self, selection: t.Optional[AtomSelection] = None, *, frame: t.Literal['local'] = 'local') -&gt; NDArray[numpy.float64]:\n    \"\"\"Return a `(N, 3)` ndarray of atom coordinates (dtype [`numpy.float64`][numpy.float64]).\"\"\"\n    df = self if selection is None else self.filter(_selection_to_expr(self, selection))\n    return df.get_column('coords').to_numpy().astype(numpy.float64)\n</code></pre>"},{"location":"api/#atomlib.HasAtoms.x","title":"<code>x()</code>","text":"Source code in <code>atomlib/atoms.py</code> <pre><code>def x(self) -&gt; polars.Expr:\n    return polars.col('coords').arr.get(0).alias('x')\n</code></pre>"},{"location":"api/#atomlib.HasAtoms.y","title":"<code>y()</code>","text":"Source code in <code>atomlib/atoms.py</code> <pre><code>def y(self) -&gt; polars.Expr:\n    return polars.col('coords').arr.get(1).alias('y')\n</code></pre>"},{"location":"api/#atomlib.HasAtoms.z","title":"<code>z()</code>","text":"Source code in <code>atomlib/atoms.py</code> <pre><code>def z(self) -&gt; polars.Expr:\n    return polars.col('coords').arr.get(2).alias('z')\n</code></pre>"},{"location":"api/#atomlib.HasAtoms.velocities","title":"<code>velocities(selection=None)</code>","text":"<p>Return a <code>(N, 3)</code> ndarray of atom velocities (dtype <code>numpy.float64</code>).</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def velocities(self, selection: t.Optional[AtomSelection] = None) -&gt; t.Optional[NDArray[numpy.float64]]:\n    \"\"\"Return a `(N, 3)` ndarray of atom velocities (dtype [`numpy.float64`][numpy.float64]).\"\"\"\n    if 'velocity' not in self:\n        return None\n\n    df = self if selection is None else self.filter(_selection_to_expr(self, selection))\n    return df.get_column('velocity').to_numpy().astype(numpy.float64)\n</code></pre>"},{"location":"api/#atomlib.HasAtoms.types","title":"<code>types()</code>","text":"<p>Returns a <code>Series</code> of atom types (dtype <code>polars.Int32</code>).</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def types(self) -&gt; t.Optional[polars.Series]:\n    \"\"\"\n    Returns a [`Series`][polars.Series] of atom types (dtype [`polars.Int32`][polars.Int32]).\n\n    [polars.Series]: https://docs.pola.rs/py-polars/html/reference/series/index.html\n    \"\"\"\n    return self.try_get_column('type')\n</code></pre>"},{"location":"api/#atomlib.HasAtoms.masses","title":"<code>masses()</code>","text":"<p>Returns a <code>Series</code> of atom masses (dtype <code>polars.Float32</code>).</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def masses(self) -&gt; t.Optional[polars.Series]:\n    \"\"\"\n    Returns a [`Series`][polars.Series] of atom masses (dtype [`polars.Float32`][polars.Float32]).\n\n    [polars.Series]: https://docs.pola.rs/py-polars/html/reference/series/index.html\n    \"\"\"\n    return self.try_get_column('mass')\n</code></pre>"},{"location":"api/#atomlib.HasAtoms.add_atom","title":"<code>add_atom(elem, /, x, y=None, z=None, **kwargs)</code>","text":"<p>Return a copy of <code>self</code> with an extra atom.</p> <p>By default, all extra columns present in <code>self</code> must be specified as <code>**kwargs</code>.</p> <p>Try to avoid calling this in a loop (Use <code>HasAtoms.concat</code> instead).</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def add_atom(self: HasAtomsT, elem: t.Union[int, str], /,\n             x: t.Union[ArrayLike, float],\n             y: t.Optional[float] = None,\n             z: t.Optional[float] = None,\n             **kwargs: t.Any) -&gt; HasAtomsT:\n    \"\"\"\n    Return a copy of `self` with an extra atom.\n\n    By default, all extra columns present in `self` must be specified as `**kwargs`.\n\n    Try to avoid calling this in a loop (Use [`HasAtoms.concat`][atomlib.atoms.HasAtoms.concat] instead).\n    \"\"\"\n    if isinstance(elem, int):\n        kwargs.update(elem=elem)\n    else:\n        kwargs.update(symbol=elem)\n    if hasattr(x, '__len__') and len(x) &gt; 1:  # type: ignore\n        (x, y, z) = to_vec3(x)\n    elif y is None or z is None:\n        raise ValueError(f\"Must specify vector of positions or x, y, &amp; z.\")\n\n    sym = get_sym(elem) if isinstance(elem, int) else elem\n    d: t.Dict[str, t.Any] = {'x': x, 'y': y, 'z': z, 'symbol': sym, **kwargs}\n    return self.concat(\n        (self, Atoms(d).select_schema(self.schema)),\n        how='vertical'\n    )\n</code></pre>"},{"location":"api/#atomlib.HasAtoms.pos","title":"<code>pos(x=None, y=None, z=None, *, tol=1e-06, **kwargs)</code>","text":"<p>Select all atoms at a given position.</p> <p>Formally, returns all atoms within a cube of radius <code>tol</code> centered at <code>(x,y,z)</code>, exclusive of the cube's surface.</p> <p>Additional parameters given as <code>kwargs</code> will be checked as additional parameters (with strict equality).</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def pos(self,\n        x: t.Union[t.Sequence[t.Optional[float]], float, None] = None,\n        y: t.Optional[float] = None, z: t.Optional[float] = None, *,\n        tol: float = 1e-6, **kwargs: t.Any) -&gt; polars.Expr:\n    \"\"\"\n    Select all atoms at a given position.\n\n    Formally, returns all atoms within a cube of radius ``tol``\n    centered at ``(x,y,z)``, exclusive of the cube's surface.\n\n    Additional parameters given as ``kwargs`` will be checked\n    as additional parameters (with strict equality).\n    \"\"\"\n\n    if isinstance(x, t.Sequence):\n        (x, y, z) = x\n\n    tol = abs(float(tol))\n    selection = polars.lit(True)\n    if x is not None:\n        selection &amp;= self.x().is_between(x - tol, x + tol, closed='none')\n    if y is not None:\n        selection &amp;= self.y().is_between(y - tol, y + tol, closed='none')\n    if z is not None:\n        selection &amp;= self.z().is_between(z - tol, z + tol, closed='none')\n    for (col, val) in kwargs.items():\n        selection &amp;= (polars.col(col) == val)\n\n    return selection\n</code></pre>"},{"location":"api/#atomlib.HasAtoms.with_index","title":"<code>with_index(index=None)</code>","text":"<p>Returns <code>self</code> with a row index added in column 'i' (dtype <code>polars.Int64</code>). If <code>index</code> is not specified, defaults to an existing index or a new index.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def with_index(self: HasAtomsT, index: t.Optional[AtomValues] = None) -&gt; HasAtomsT:\n    \"\"\"\n    Returns `self` with a row index added in column 'i' (dtype [`polars.Int64`][polars.Int64]).\n    If `index` is not specified, defaults to an existing index or a new index.\n    \"\"\"\n    if index is None and 'i' in self.columns:\n        return self\n    if index is None:\n        index = numpy.arange(len(self), dtype=numpy.int64)\n    return self.with_column(_values_to_expr(self, index, polars.Int64).alias('i'))\n</code></pre>"},{"location":"api/#atomlib.HasAtoms.with_wobble","title":"<code>with_wobble(wobble=None)</code>","text":"<p>Return <code>self</code> with the given displacements in column 'wobble' (dtype <code>polars.Float64</code>). If <code>wobble</code> is not specified, defaults to the already-existing wobbles or 0.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def with_wobble(self: HasAtomsT, wobble: t.Optional[AtomValues] = None) -&gt; HasAtomsT:\n    \"\"\"\n    Return `self` with the given displacements in column 'wobble' (dtype [`polars.Float64`][polars.Float64]).\n    If `wobble` is not specified, defaults to the already-existing wobbles or 0.\n    \"\"\"\n    if wobble is None and 'wobble' in self.columns:\n        return self\n    wobble = 0. if wobble is None else wobble\n    return self.with_column(_values_to_expr(self, wobble, polars.Float64).alias('wobble'))\n</code></pre>"},{"location":"api/#atomlib.HasAtoms.with_occupancy","title":"<code>with_occupancy(frac_occupancy=None)</code>","text":"<p>Return self with the given fractional occupancies. If <code>frac_occupancy</code> is not specified, defaults to the already-existing occupancies or 1.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def with_occupancy(self: HasAtomsT, frac_occupancy: t.Optional[AtomValues] = None) -&gt; HasAtomsT:\n    \"\"\"\n    Return self with the given fractional occupancies. If `frac_occupancy` is not specified,\n    defaults to the already-existing occupancies or 1.\n    \"\"\"\n    if frac_occupancy is None and 'frac_occupancy' in self.columns:\n        return self\n    frac_occupancy = 1. if frac_occupancy is None else frac_occupancy\n    return self.with_column(_values_to_expr(self, frac_occupancy, polars.Float64).alias('frac_occupancy'))\n</code></pre>"},{"location":"api/#atomlib.HasAtoms.apply_wobble","title":"<code>apply_wobble(rng=None)</code>","text":"<p>Displace the atoms in <code>self</code> by the amount in the <code>wobble</code> column. <code>wobble</code> is interpretated as a mean-squared displacement, which is distributed equally over each axis.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def apply_wobble(self: HasAtomsT, rng: t.Union[numpy.random.Generator, int, None] = None) -&gt; HasAtomsT:\n    \"\"\"\n    Displace the atoms in `self` by the amount in the `wobble` column.\n    `wobble` is interpretated as a mean-squared displacement, which is distributed\n    equally over each axis.\n    \"\"\"\n    if 'wobble' not in self.columns:\n        return self\n    rng = numpy.random.default_rng(seed=rng)\n\n    stddev = self.select((polars.col('wobble') / 3.).sqrt()).to_series().to_numpy()\n    coords = self.coords()\n    coords += stddev[:, None] * rng.standard_normal(coords.shape)\n    return self.with_coords(coords)\n</code></pre>"},{"location":"api/#atomlib.HasAtoms.apply_occupancy","title":"<code>apply_occupancy(rng=None)</code>","text":"<p>For each atom in <code>self</code>, use its <code>frac_occupancy</code> to randomly decide whether to remove it.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def apply_occupancy(self: HasAtomsT, rng: t.Union[numpy.random.Generator, int, None] = None) -&gt; HasAtomsT:\n    \"\"\"\n    For each atom in `self`, use its `frac_occupancy` to randomly decide whether to remove it.\n    \"\"\"\n    if 'frac_occupancy' not in self.columns:\n        return self\n    rng = numpy.random.default_rng(seed=rng)\n\n    frac = self.select('frac_occupancy').to_series().to_numpy()\n    choice = rng.binomial(1, frac).astype(numpy.bool_)\n    return self.filter(polars.lit(choice))\n</code></pre>"},{"location":"api/#atomlib.HasAtoms.with_type","title":"<code>with_type(types=None)</code>","text":"<p>Return <code>self</code> with the given atom types in column 'type'. If <code>types</code> is not specified, use the already existing types or auto-assign them.</p> <p>When auto-assigning, each symbol is given a unique value, case-sensitive. Values are assigned from lowest atomic number to highest. For instance: <code>[\"Ag+\", \"Na\", \"H\", \"Ag\"]</code> =&gt; <code>[3, 11, 1, 2]</code></p> Source code in <code>atomlib/atoms.py</code> <pre><code>def with_type(self: HasAtomsT, types: t.Optional[AtomValues] = None) -&gt; HasAtomsT:\n    \"\"\"\n    Return `self` with the given atom types in column 'type'.\n    If `types` is not specified, use the already existing types or auto-assign them.\n\n    When auto-assigning, each symbol is given a unique value, case-sensitive.\n    Values are assigned from lowest atomic number to highest.\n    For instance: `[\"Ag+\", \"Na\", \"H\", \"Ag\"]` =&gt; `[3, 11, 1, 2]`\n    \"\"\"\n    if types is not None:\n        return self.with_columns(type=_values_to_expr(self, types, polars.Int32))\n    if 'type' in self.columns:\n        return self\n\n    unique = Atoms(self._get_frame().unique(maintain_order=False, subset=['elem', 'symbol']).sort(['elem', 'symbol']), _unchecked=True)\n    new = self.with_column(polars.Series('type', values=numpy.zeros(len(self)), dtype=polars.Int32))\n\n    logging.warning(\"Auto-assigning element types\")\n    for (i, (elem, sym)) in enumerate(unique.select(('elem', 'symbol')).rows()):\n        print(f\"Assigning type {i+1} to element '{sym}'\")\n        new = new.with_column(polars.when((polars.col('elem') == elem) &amp; (polars.col('symbol') == sym))\n                                    .then(polars.lit(i+1))\n                                    .otherwise(polars.col('type'))\n                                    .alias('type'))\n\n    assert (new.get_column('type') == 0).sum() == 0\n    return new\n</code></pre>"},{"location":"api/#atomlib.HasAtoms.with_mass","title":"<code>with_mass(mass=None)</code>","text":"<p>Return <code>self</code> with the given atom masses in column 'mass'. If <code>mass</code> is not specified, use the already existing masses or auto-assign them.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def with_mass(self: HasAtomsT, mass: t.Optional[ArrayLike] = None) -&gt; HasAtomsT:\n    \"\"\"\n    Return `self` with the given atom masses in column 'mass'.\n    If `mass` is not specified, use the already existing masses or auto-assign them.\n    \"\"\"\n    if mass is not None:\n        return self.with_column(_values_to_expr(self, mass, polars.Float32).alias('mass'))\n    if 'mass' in self.columns:\n        return self\n\n    unique_elems = self.get_column('elem').unique()\n    new = self.with_column(polars.Series('mass', values=numpy.zeros(len(self)), dtype=polars.Float32))\n\n    logging.warning(\"Auto-assigning element masses\")\n    for elem in unique_elems:\n        new = new.with_column(polars.when(polars.col('elem') == elem)\n                                    .then(polars.lit(get_mass(elem)))\n                                    .otherwise(polars.col('mass'))\n                                    .alias('mass'))\n\n    assert (new.get_column('mass').abs() &lt; 1e-10).sum() == 0\n    return new\n</code></pre>"},{"location":"api/#atomlib.HasAtoms.with_symbol","title":"<code>with_symbol(symbols, selection=None)</code>","text":"<p>Return <code>self</code> with the given atomic symbols.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def with_symbol(self: HasAtomsT, symbols: ArrayLike, selection: t.Optional[AtomSelection] = None) -&gt; HasAtomsT:\n    \"\"\"\n    Return `self` with the given atomic symbols.\n    \"\"\"\n    if selection is not None:\n        selection = _selection_to_numpy(self, selection)\n        new_symbols = self.get_column('symbol')\n        new_symbols[selection] = polars.Series(list(numpy.broadcast_to(symbols, len(selection))), dtype=polars.Utf8)\n        symbols = new_symbols\n\n    # TODO better cast here\n    symbols = polars.Series('symbol', list(numpy.broadcast_to(symbols, len(self))), dtype=polars.Utf8)\n    return self.with_columns((symbols, get_elem(symbols)))\n</code></pre>"},{"location":"api/#atomlib.HasAtoms.with_coords","title":"<code>with_coords(pts, selection=None, *, frame='local')</code>","text":"<p>Return <code>self</code> replaced with the given atomic positions.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def with_coords(self: HasAtomsT, pts: ArrayLike, selection: t.Optional[AtomSelection] = None, *, frame: t.Literal['local'] = 'local') -&gt; HasAtomsT:\n    \"\"\"\n    Return `self` replaced with the given atomic positions.\n    \"\"\"\n    if selection is not None:\n        selection = _selection_to_numpy(self, selection)\n        new_pts = self.coords()\n        pts = numpy.atleast_2d(pts)\n        assert pts.shape[-1] == 3\n        new_pts[selection] = pts\n        pts = new_pts\n\n    pts = numpy.broadcast_to(pts, (len(self), 3))\n    return self.with_columns(polars.Series('coords', pts, polars.Array(polars.Float64, 3)))\n</code></pre>"},{"location":"api/#atomlib.HasAtoms.with_velocity","title":"<code>with_velocity(pts=None, selection=None)</code>","text":"<p>Return <code>self</code> replaced with the given atomic velocities. If <code>pts</code> is not specified, use the already existing velocities or zero.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def with_velocity(self: HasAtomsT, pts: t.Optional[ArrayLike] = None,\n                  selection: t.Optional[AtomSelection] = None) -&gt; HasAtomsT:\n    \"\"\"\n    Return `self` replaced with the given atomic velocities.\n    If `pts` is not specified, use the already existing velocities or zero.\n    \"\"\"\n    if pts is None:\n        if 'velocity' in self:\n            return self\n        all_pts = numpy.zeros((len(self), 3))\n    else:\n        all_pts = self['velocity'].to_numpy()\n\n    if selection is None:\n        all_pts = pts or all_pts\n    elif pts is not None:\n        selection = _selection_to_numpy(self, selection)\n        all_pts = numpy.require(all_pts, requirements=['WRITEABLE'])\n        pts = numpy.atleast_2d(pts)\n        assert pts.shape[-1] == 3\n        all_pts[selection] = pts\n\n    all_pts = numpy.broadcast_to(all_pts, (len(self), 3))\n    return self.with_columns(polars.Series('velocity', all_pts, polars.Array(polars.Float64, 3)))\n</code></pre>"},{"location":"api/#atomlib.Cell","title":"<code>Cell</code>  <code>dataclass</code>","text":"<p>             Bases: <code>HasCell</code></p> <p>Internal class for representing the coordinate systems of a crystal.</p> <p>The overall transformation from crystal coordinates to real-space coordinates is is split into four transformations, applied from bottom to top. First is <code>n_cells</code>, which scales from fractions of a unit cell to fractions of a supercell. Next is <code>cell_size</code>, which scales to real-space units. <code>ortho</code> is an orthogonalization matrix, a det = 1 upper-triangular matrix which transforms crystal axes to an orthogonal coordinate system. Finally, <code>affine</code> contains any remaining transformations to the local coordinate system, which atoms are stored in.</p> Source code in <code>atomlib/cell.py</code> <pre><code>@dataclass(frozen=True, init=False)\nclass Cell(HasCell):\n    \"\"\"\n    Internal class for representing the coordinate systems of a crystal.\n\n    The overall transformation from crystal coordinates to real-space coordinates is\n    is split into four transformations, applied from bottom to top. First is ``n_cells``,\n    which scales from fractions of a unit cell to fractions of a supercell. Next is\n    ``cell_size``, which scales to real-space units. ``ortho`` is an orthogonalization\n    matrix, a det = 1 upper-triangular matrix which transforms crystal axes to\n    an orthogonal coordinate system. Finally, ``affine`` contains any remaining\n    transformations to the local coordinate system, which atoms are stored in.\n    \"\"\"\n\n    def get_cell(self) -&gt; Cell:\n        return self\n\n    def with_cell(self: Cell, cell: Cell) -&gt; Cell:\n        return cell\n\n    _affine: AffineTransform3D = AffineTransform3D()\n    \"\"\"\n    Affine transformation. Holds transformation from 'ortho' to 'local' coordinates,\n    including rotation away from the standard crystal orientation.\n    \"\"\"\n\n    _ortho: LinearTransform3D = LinearTransform3D()\n    \"\"\"\n    Orthogonalization transformation. Skews but does not scale the crystal axes to cartesian axes.\n    \"\"\"\n\n    _cell_size: NDArray[numpy.float_]\n    \"\"\"Unit cell size.\"\"\"\n    _cell_angle: NDArray[numpy.float_] = field(default_factory=lambda: numpy.full(3, numpy.pi/2.))\n    \"\"\"Unit cell angles, in radians.\"\"\"\n    _n_cells: NDArray[numpy.int_] = field(default_factory=lambda: numpy.ones(3, numpy.int_))\n    \"\"\"Number of unit cells.\"\"\"\n    _pbc: NDArray[numpy.bool_] = field(default_factory=lambda: numpy.ones(3, numpy.bool_))\n    \"\"\"Flags indicating the presence of periodic boundary conditions along each axis.\"\"\"\n\n    def __init__(self, *,\n        affine: t.Optional[AffineTransform3D] = None, ortho: t.Optional[LinearTransform3D] = None,\n        cell_size: VecLike, cell_angle: t.Optional[VecLike] = None,\n        n_cells: t.Optional[VecLike] = None, pbc: t.Optional[VecLike] = None):\n\n        object.__setattr__(self, '_affine', AffineTransform3D() if affine is None else affine)\n        object.__setattr__(self, '_ortho', LinearTransform3D() if ortho is None else ortho)\n        object.__setattr__(self, '_cell_size', to_vec3(cell_size))\n        object.__setattr__(self, '_cell_angle', numpy.full(3, numpy.pi/2.) if cell_angle is None else to_vec3(cell_angle))\n        object.__setattr__(self, '_n_cells', numpy.ones(3, numpy.int_) if n_cells is None else to_vec3(n_cells, numpy.int_))\n        object.__setattr__(self, '_pbc', numpy.ones(3, numpy.bool_) if pbc is None else to_vec3(pbc, numpy.bool_))\n\n    @staticmethod\n    def from_unit_cell(cell_size: VecLike, cell_angle: t.Optional[VecLike] = None, n_cells: t.Optional[VecLike] = None,\n                       pbc: t.Optional[VecLike] = None):\n        return Cell(\n            ortho=cell_to_ortho([1.]*3, cell_angle),\n            n_cells=to_vec3([1]*3 if n_cells is None else n_cells, numpy.int_),\n            cell_size=to_vec3(cell_size),\n            cell_angle=to_vec3([numpy.pi/2.]*3 if cell_angle is None else cell_angle),\n            pbc=pbc\n        )\n\n    @staticmethod\n    def from_ortho(ortho: AffineTransform3D, n_cells: t.Optional[VecLike] = None, pbc: t.Optional[VecLike] = None):\n        lin = ortho.to_linear()\n        # decompose into orthogonal and upper triangular\n        q, r = numpy.linalg.qr(lin.inner)\n\n        # flip QR decomposition so R has positive diagonals\n        signs = numpy.sign(numpy.diagonal(r))\n        # multiply flips to columns of Q, rows of R\n        q = q * signs; r = r * signs[:, None]\n        #numpy.testing.assert_allclose(q @ r, lin.inner)\n        if numpy.linalg.det(q) &lt; 0:\n            warn(\"Crystal is left-handed. This is currently unsupported, and may cause errors.\")\n            # currently, behavior is to leave `ortho` proper, and move the inversion into the affine transform\n\n        cell_size, cell_angle = ortho_to_cell(lin)\n        return Cell(\n            affine=LinearTransform3D(q).translate(ortho.translation()),\n            ortho=LinearTransform3D(r / cell_size).round_near_zero(),\n            cell_size=cell_size, cell_angle=cell_angle,\n            n_cells=to_vec3([1]*3 if n_cells is None else n_cells, numpy.int_),\n            pbc=pbc,\n        )\n\n    def __str__(self) -&gt; str:\n        return \"\\n\".join((\n            self.__class__.__name__,\n            f\"Cell size: {self.cell_size!r}\",\n            f\"Cell angle: {self.cell_angle!r}\",\n            f\"# cells: {self.n_cells!r}\",\n            f\"pbc: {self.pbc!r}\",\n        ))\n\n    def __repr__(self) -&gt; str:\n        return (\n            f\"{self.__class__.__name__}(\"\n            f\"ortho={self.ortho}, affine={self.affine}, cell_size={self.cell_size}, \"\n            f\"cell_angle={self.cell_angle}, n_cells={self.n_cells}, pbc={self.pbc})\"\n        )\n\n    def _repr_pretty_(self, p, cycle: bool) -&gt; None:\n        p.text(f\"{self.__class__.__name__}(...)\") if cycle else p.text(str(self))\n</code></pre>"},{"location":"api/#atomlib.Cell.affine","title":"<code>affine: AffineTransform3D</code>  <code>property</code>","text":"<p>Affine transformation. Holds transformation from 'ortho' to 'local' coordinates, including rotation away from the standard crystal orientation.</p>"},{"location":"api/#atomlib.Cell.ortho","title":"<code>ortho: LinearTransform3D</code>  <code>property</code>","text":"<p>Orthogonalization transformation. Skews but does not scale the crystal axes to cartesian axes.</p>"},{"location":"api/#atomlib.Cell.metric","title":"<code>metric: LinearTransform3D</code>  <code>property</code>","text":"<p>Cell metric tensor</p> <p>Returns the dot product between every combination of basis vectors. :math:<code>\\mathbf{a} \\cdot \\mathbf{b} = a_i M_ij b_j</code></p>"},{"location":"api/#atomlib.Cell.cell_size","title":"<code>cell_size: NDArray[numpy.float_]</code>  <code>property</code>","text":"<p>Unit cell size.</p>"},{"location":"api/#atomlib.Cell.cell_angle","title":"<code>cell_angle: NDArray[numpy.float_]</code>  <code>property</code>","text":"<p>Unit cell angles, in radians.</p>"},{"location":"api/#atomlib.Cell.n_cells","title":"<code>n_cells: NDArray[numpy.int_]</code>  <code>property</code>","text":"<p>Number of unit cells.</p>"},{"location":"api/#atomlib.Cell.pbc","title":"<code>pbc: NDArray[numpy.bool_]</code>  <code>property</code>","text":"<p>Flags indicating the presence of periodic boundary conditions along each axis.</p>"},{"location":"api/#atomlib.Cell.ortho_size","title":"<code>ortho_size: NDArray[numpy.float_]</code>  <code>property</code>","text":"<p>Return size of orthogonal unit cell.</p> <p>Equivalent to the diagonal of the orthogonalization matrix.</p>"},{"location":"api/#atomlib.Cell.box_size","title":"<code>box_size: NDArray[numpy.float_]</code>  <code>property</code>","text":"<p>Return size of the cell box.</p> <p>Equivalent to <code>self.n_cells * self.cell_size</code>.</p>"},{"location":"api/#atomlib.Cell.bbox","title":"<code>bbox = bbox_cell</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#atomlib.Cell.get_transform","title":"<code>get_transform(frame_to=None, frame_from=None)</code>","text":"<p>In the two-argument form, get the transform to 'frame_to' from 'frame_from'. In the one-argument form, get the transform from local coordinates to 'frame'.</p> Source code in <code>atomlib/cell.py</code> <pre><code>def get_transform(self, frame_to: t.Optional[CoordinateFrame] = None, frame_from: t.Optional[CoordinateFrame] = None) -&gt; AffineTransform3D:\n    \"\"\"\n    In the two-argument form, get the transform to 'frame_to' from 'frame_from'.\n    In the one-argument form, get the transform from local coordinates to 'frame'.\n    \"\"\"\n    transform_from = self._get_transform_to_local(frame_from) if frame_from is not None else AffineTransform3D()\n    transform_to = self._get_transform_to_local(frame_to) if frame_to is not None else AffineTransform3D()\n    if frame_from is not None and frame_to is not None and frame_from.lower() == frame_to.lower():\n        return AffineTransform3D()\n    return transform_to.inverse() @ transform_from\n</code></pre>"},{"location":"api/#atomlib.Cell.corners","title":"<code>corners(frame='local')</code>","text":"Source code in <code>atomlib/cell.py</code> <pre><code>def corners(self, frame: CoordinateFrame = 'local') -&gt; numpy.ndarray:\n    corners = numpy.array(list(itertools.product((0., 1.), repeat=3)))\n    return self.get_transform(frame, 'cell_box') @ corners\n</code></pre>"},{"location":"api/#atomlib.Cell.bbox_cell","title":"<code>bbox_cell(frame='local')</code>","text":"<p>Return the bounding box of the cell box in the given coordinate system.</p> Source code in <code>atomlib/cell.py</code> <pre><code>def bbox_cell(self, frame: CoordinateFrame = 'local') -&gt; BBox3D:\n    \"\"\"Return the bounding box of the cell box in the given coordinate system.\"\"\"\n    return BBox3D.from_pts(self.corners(frame))\n</code></pre>"},{"location":"api/#atomlib.Cell.is_orthogonal","title":"<code>is_orthogonal(tol=1e-08)</code>","text":"<p>Returns whether this cell is orthogonal (axes are at right angles.)</p> Source code in <code>atomlib/cell.py</code> <pre><code>def is_orthogonal(self, tol: float = 1e-8) -&gt; bool:\n    \"\"\"Returns whether this cell is orthogonal (axes are at right angles.)\"\"\"\n    return self.ortho.is_diagonal(tol=tol)\n</code></pre>"},{"location":"api/#atomlib.Cell.is_orthogonal_in_local","title":"<code>is_orthogonal_in_local(tol=1e-08)</code>","text":"<p>Returns whether this cell is orthogonal and aligned with the local coordinate system.</p> Source code in <code>atomlib/cell.py</code> <pre><code>def is_orthogonal_in_local(self, tol: float = 1e-8) -&gt; bool:\n    \"\"\"Returns whether this cell is orthogonal and aligned with the local coordinate system.\"\"\"\n    transform = (self.affine @ self.ortho).to_linear()\n    if not transform.is_scaled_orthogonal(tol):\n        return False\n    normed = transform.inner / numpy.linalg.norm(transform.inner, axis=-2, keepdims=True)\n    # every row of transform must be a +/- 1 times a basis vector (i, j, or k)\n    return all(\n        any(numpy.isclose(numpy.abs(numpy.dot(row, v)), 1., atol=tol) for v in numpy.eye(3))\n        for row in normed\n    )\n</code></pre>"},{"location":"api/#atomlib.Cell.to_ortho","title":"<code>to_ortho()</code>","text":"Source code in <code>atomlib/cell.py</code> <pre><code>def to_ortho(self) -&gt; AffineTransform3D:\n    return self.get_transform('local', 'cell_box')\n</code></pre>"},{"location":"api/#atomlib.Cell.transform_cell","title":"<code>transform_cell(transform, frame='local')</code>","text":"<p>Apply the given transform to the unit cell, and return a new <code>Cell</code>. The transform is applied in coordinate frame 'frame'. Orthogonal and affine transformations are applied to the affine matrix component, while skew and scaling is applied to the orthogonalization matrix/cell_size.</p> Source code in <code>atomlib/cell.py</code> <pre><code>def transform_cell(self: HasCellT, transform: AffineTransform3D, frame: CoordinateFrame = 'local') -&gt; HasCellT:\n    \"\"\"\n    Apply the given transform to the unit cell, and return a new `Cell`.\n    The transform is applied in coordinate frame 'frame'.\n    Orthogonal and affine transformations are applied to the affine matrix component,\n    while skew and scaling is applied to the orthogonalization matrix/cell_size.\n    \"\"\"\n    transform = t.cast(AffineTransform3D, self.change_transform(transform, 'local', frame))\n    if not transform.to_linear().is_orthogonal():\n        raise NotImplementedError()\n    return self.with_cell(Cell(\n        affine=transform @ self.affine,\n        ortho=self.ortho,\n        cell_size=self.cell_size,\n        cell_angle=self.cell_angle,\n        n_cells=self.n_cells,\n        pbc=self.pbc,\n    ))\n</code></pre>"},{"location":"api/#atomlib.Cell.strain_orthogonal","title":"<code>strain_orthogonal()</code>","text":"<p>Orthogonalize using strain.</p> <p>Strain is applied such that the x-axis remains fixed, and the y-axis remains in the xy plane. For small displacements, no hydrostatic strain is applied (volume is conserved).</p> Source code in <code>atomlib/cell.py</code> <pre><code>def strain_orthogonal(self: HasCellT) -&gt; HasCellT:\n    \"\"\"\n    Orthogonalize using strain.\n\n    Strain is applied such that the x-axis remains fixed, and the y-axis remains in the xy plane.\n    For small displacements, no hydrostatic strain is applied (volume is conserved).\n    \"\"\"\n    return self.with_cell(Cell(\n        affine=self.affine,\n        ortho=LinearTransform3D(),\n        cell_size=self.cell_size,\n        n_cells=self.n_cells,\n        pbc=self.pbc,\n    ))\n</code></pre>"},{"location":"api/#atomlib.Cell.repeat","title":"<code>repeat(n)</code>","text":"<p>Tile the cell by <code>n</code> in each dimension.</p> Source code in <code>atomlib/cell.py</code> <pre><code>def repeat(self: HasCellT, n: t.Union[int, VecLike]) -&gt; HasCellT:\n    \"\"\"Tile the cell by `n` in each dimension.\"\"\"\n    ns = numpy.broadcast_to(n, 3)\n    if not numpy.issubdtype(ns.dtype, numpy.integer):\n        raise ValueError(f\"repeat() argument must be an integer or integer array.\")\n    return self.with_cell(Cell(\n        affine=self.affine,\n        ortho=self.ortho,\n        cell_size=self.cell_size,\n        cell_angle=self.cell_angle,\n        n_cells=self.n_cells * numpy.broadcast_to(n, 3),\n        pbc = self.pbc | (ns &gt; 1)  # assume periodic along repeated directions\n    ))\n</code></pre>"},{"location":"api/#atomlib.Cell.explode","title":"<code>explode()</code>","text":"<p>Materialize repeated cells as one supercell.</p> Source code in <code>atomlib/cell.py</code> <pre><code>def explode(self: HasCellT) -&gt; HasCellT:\n    \"\"\"Materialize repeated cells as one supercell.\"\"\"\n    return self.with_cell(Cell(\n        affine=self.affine,\n        ortho=self.ortho,\n        cell_size=self.cell_size*self.n_cells,\n        cell_angle=self.cell_angle,\n        pbc=self.pbc,\n    ))\n</code></pre>"},{"location":"api/#atomlib.Cell.explode_z","title":"<code>explode_z()</code>","text":"<p>Materialize repeated cells as one supercell in z.</p> Source code in <code>atomlib/cell.py</code> <pre><code>def explode_z(self: HasCellT) -&gt; HasCellT:\n    \"\"\"Materialize repeated cells as one supercell in z.\"\"\"\n    return self.with_cell(Cell(\n        affine=self.affine,\n        ortho=self.ortho,\n        cell_size=self.cell_size*[1, 1, self.n_cells[2]],\n        n_cells=[*self.n_cells[:2], 1],\n        cell_angle=self.cell_angle,\n        pbc=self.pbc,\n    ))\n</code></pre>"},{"location":"api/#atomlib.Cell.crop","title":"<code>crop(x_min=-numpy.inf, x_max=numpy.inf, y_min=-numpy.inf, y_max=numpy.inf, z_min=-numpy.inf, z_max=numpy.inf, *, frame='local')</code>","text":"<p>Crop 'cell' to the given extents. For a non-orthogonal cell, this must be specified in cell coordinates. This function implicity <code>explode</code>s the cell as well.</p> Source code in <code>atomlib/cell.py</code> <pre><code>def crop(self: HasCellT, x_min: float = -numpy.inf, x_max: float = numpy.inf,\n         y_min: float = -numpy.inf, y_max: float = numpy.inf,\n         z_min: float = -numpy.inf, z_max: float = numpy.inf, *,\n         frame: CoordinateFrame = 'local') -&gt; HasCellT:\n    \"\"\"\n    Crop 'cell' to the given extents. For a non-orthogonal\n    cell, this must be specified in cell coordinates. This\n    function implicity `explode`s the cell as well.\n    \"\"\"\n\n    if not frame.lower().startswith('cell'):\n        if not self.is_orthogonal():\n            raise ValueError(\"Cannot crop a non-orthogonal cell in orthogonal coordinates. Use crop_atoms instead.\")\n\n    min = to_vec3([x_min, y_min, z_min])\n    max = to_vec3([x_max, y_max, z_max])\n    (min, max) = self.get_transform('cell_box', frame).transform([min, max])\n    new_box = BBox3D(min, max) &amp; BBox3D.unit()\n    cropped = (new_box.min &gt; 0.) | (new_box.max &lt; 1.)\n\n    return self.with_cell(Cell(\n        affine=self.affine @ AffineTransform3D.translate(-new_box.min),\n        ortho=self.ortho,\n        cell_size=new_box.size * self.cell_size * numpy.where(cropped, self.n_cells, 1),\n        n_cells=numpy.where(cropped, 1, self.n_cells),\n        cell_angle=self.cell_angle,\n        pbc=self.pbc &amp; ~cropped  # remove periodicity along cropped directions\n    ))\n</code></pre>"},{"location":"api/#atomlib.Cell.change_transform","title":"<code>change_transform(transform, frame_to=None, frame_from=None)</code>","text":"<p>Coordinate-change a transformation to 'frame_to' from 'frame_from'.</p> Source code in <code>atomlib/cell.py</code> <pre><code>def change_transform(self, transform: Transform3D,\n                     frame_to: t.Optional[CoordinateFrame] = None,\n                     frame_from: t.Optional[CoordinateFrame] = None) -&gt; Transform3D:\n    \"\"\"Coordinate-change a transformation to 'frame_to' from 'frame_from'.\"\"\"\n    if frame_to == frame_from and frame_to is not None:\n        return transform\n    coord_change = self.get_transform(frame_to, frame_from)\n    return coord_change @ transform @ coord_change.inverse()\n</code></pre>"},{"location":"api/#atomlib.Cell.assert_equal","title":"<code>assert_equal(other)</code>","text":"Source code in <code>atomlib/cell.py</code> <pre><code>def assert_equal(self, other: t.Any):\n    assert isinstance(other, HasCell) and type(self) == type(other)\n    numpy.testing.assert_array_almost_equal(self.affine.inner, other.affine.inner, 6)\n    numpy.testing.assert_array_almost_equal(self.ortho.inner, other.ortho.inner, 6)\n    numpy.testing.assert_array_almost_equal(self.cell_size, other.cell_size, 6)\n    numpy.testing.assert_array_equal(self.n_cells, other.n_cells)\n    numpy.testing.assert_array_equal(self.pbc, other.pbc)\n</code></pre>"},{"location":"api/#atomlib.Cell.get_cell","title":"<code>get_cell()</code>","text":"Source code in <code>atomlib/cell.py</code> <pre><code>def get_cell(self) -&gt; Cell:\n    return self\n</code></pre>"},{"location":"api/#atomlib.Cell.with_cell","title":"<code>with_cell(cell)</code>","text":"Source code in <code>atomlib/cell.py</code> <pre><code>def with_cell(self: Cell, cell: Cell) -&gt; Cell:\n    return cell\n</code></pre>"},{"location":"api/#atomlib.Cell.from_unit_cell","title":"<code>from_unit_cell(cell_size, cell_angle=None, n_cells=None, pbc=None)</code>  <code>staticmethod</code>","text":"Source code in <code>atomlib/cell.py</code> <pre><code>@staticmethod\ndef from_unit_cell(cell_size: VecLike, cell_angle: t.Optional[VecLike] = None, n_cells: t.Optional[VecLike] = None,\n                   pbc: t.Optional[VecLike] = None):\n    return Cell(\n        ortho=cell_to_ortho([1.]*3, cell_angle),\n        n_cells=to_vec3([1]*3 if n_cells is None else n_cells, numpy.int_),\n        cell_size=to_vec3(cell_size),\n        cell_angle=to_vec3([numpy.pi/2.]*3 if cell_angle is None else cell_angle),\n        pbc=pbc\n    )\n</code></pre>"},{"location":"api/#atomlib.Cell.from_ortho","title":"<code>from_ortho(ortho, n_cells=None, pbc=None)</code>  <code>staticmethod</code>","text":"Source code in <code>atomlib/cell.py</code> <pre><code>@staticmethod\ndef from_ortho(ortho: AffineTransform3D, n_cells: t.Optional[VecLike] = None, pbc: t.Optional[VecLike] = None):\n    lin = ortho.to_linear()\n    # decompose into orthogonal and upper triangular\n    q, r = numpy.linalg.qr(lin.inner)\n\n    # flip QR decomposition so R has positive diagonals\n    signs = numpy.sign(numpy.diagonal(r))\n    # multiply flips to columns of Q, rows of R\n    q = q * signs; r = r * signs[:, None]\n    #numpy.testing.assert_allclose(q @ r, lin.inner)\n    if numpy.linalg.det(q) &lt; 0:\n        warn(\"Crystal is left-handed. This is currently unsupported, and may cause errors.\")\n        # currently, behavior is to leave `ortho` proper, and move the inversion into the affine transform\n\n    cell_size, cell_angle = ortho_to_cell(lin)\n    return Cell(\n        affine=LinearTransform3D(q).translate(ortho.translation()),\n        ortho=LinearTransform3D(r / cell_size).round_near_zero(),\n        cell_size=cell_size, cell_angle=cell_angle,\n        n_cells=to_vec3([1]*3 if n_cells is None else n_cells, numpy.int_),\n        pbc=pbc,\n    )\n</code></pre>"},{"location":"api/#atomlib.HasCell","title":"<code>HasCell</code>","text":"Source code in <code>atomlib/cell.py</code> <pre><code>class HasCell:\n    # abstract methods\n\n    @abc.abstractmethod\n    def get_cell(self) -&gt; Cell:\n        \"\"\"Get the cell contained in ``self``. This should be a low cost method.\"\"\"\n        ...\n\n    @abc.abstractmethod\n    def with_cell(self: HasCellT, cell: Cell) -&gt; HasCellT:\n        \"\"\"Replace the cell in ``self`` with ``cell``.\"\"\"\n        ...\n\n    # getters\n\n    @property\n    def affine(self) -&gt; AffineTransform3D:\n        \"\"\"\n        Affine transformation. Holds transformation from 'ortho' to 'local' coordinates,\n        including rotation away from the standard crystal orientation.\n        \"\"\"\n        return self.get_cell()._affine\n\n    @property\n    def ortho(self) -&gt; LinearTransform3D:\n        \"\"\"\n        Orthogonalization transformation. Skews but does not scale the crystal axes to cartesian axes.\n        \"\"\"\n        return self.get_cell()._ortho\n\n    @property\n    def metric(self) -&gt; LinearTransform3D:\n        r\"\"\"\n        Cell metric tensor\n\n        Returns the dot product between every combination of basis vectors.\n        :math:`\\mathbf{a} \\cdot \\mathbf{b} = a_i M_ij b_j`\n        \"\"\"\n        ortho = self.get_cell()._ortho.scale(self.cell_size)\n        return ortho.T @ ortho\n\n    @property\n    def cell_size(self) -&gt; NDArray[numpy.float_]:\n        \"\"\"Unit cell size.\"\"\"\n        return self.get_cell()._cell_size\n\n    @property\n    def cell_angle(self) -&gt; NDArray[numpy.float_]:\n        \"\"\"Unit cell angles, in radians.\"\"\"\n        return self.get_cell()._cell_angle\n\n    @property\n    def n_cells(self) -&gt; NDArray[numpy.int_]:\n        \"\"\"Number of unit cells.\"\"\"\n        return self.get_cell()._n_cells\n\n    @property\n    def pbc(self) -&gt; NDArray[numpy.bool_]:\n        \"\"\"Flags indicating the presence of periodic boundary conditions along each axis.\"\"\"\n        return self.get_cell()._pbc\n\n    @property\n    def ortho_size(self) -&gt; NDArray[numpy.float_]:\n        \"\"\"\n        Return size of orthogonal unit cell.\n\n        Equivalent to the diagonal of the orthogonalization matrix.\n        \"\"\"\n        return self.cell_size * numpy.diag(self.ortho.inner)\n\n    @property\n    def box_size(self) -&gt; NDArray[numpy.float_]:\n        \"\"\"\n        Return size of the cell box.\n\n        Equivalent to ``self.n_cells * self.cell_size``.\n        \"\"\"\n        return self.n_cells * self.cell_size\n\n    # get transforms\n\n    def _get_transform_to_local(self, frame: CoordinateFrame) -&gt; AffineTransform3D:\n        \"\"\"Get the transform from 'frame' to local coordinates.\"\"\"\n        frame = t.cast(CoordinateFrame, frame.lower())\n\n        if frame == 'local' or frame == 'global':\n            return LinearTransform3D()\n\n        if frame == 'linear':\n            return self.affine.to_translation()\n\n        if frame.startswith('cell'):\n            transform = self.affine @ self.ortho\n            cell_size = self.cell_size\n        elif frame.startswith('ortho'):\n            transform = self.affine\n            cell_size = self.ortho_size\n        else:\n            raise ValueError(f\"Unknown coordinate frame '{frame}'\")\n\n        if '_' not in frame:\n            return transform\n        end = frame.split('_', 2)[1]\n        if end == 'frac':\n            return transform @ LinearTransform3D.scale(cell_size)\n        if end == 'box':\n            return transform @ LinearTransform3D.scale(cell_size * self.n_cells)\n        raise ValueError(f\"Unknown coordinate frame '{frame}'\")\n\n    def get_transform(self, frame_to: t.Optional[CoordinateFrame] = None, frame_from: t.Optional[CoordinateFrame] = None) -&gt; AffineTransform3D:\n        \"\"\"\n        In the two-argument form, get the transform to 'frame_to' from 'frame_from'.\n        In the one-argument form, get the transform from local coordinates to 'frame'.\n        \"\"\"\n        transform_from = self._get_transform_to_local(frame_from) if frame_from is not None else AffineTransform3D()\n        transform_to = self._get_transform_to_local(frame_to) if frame_to is not None else AffineTransform3D()\n        if frame_from is not None and frame_to is not None and frame_from.lower() == frame_to.lower():\n            return AffineTransform3D()\n        return transform_to.inverse() @ transform_from\n\n    def corners(self, frame: CoordinateFrame = 'local') -&gt; numpy.ndarray:\n        corners = numpy.array(list(itertools.product((0., 1.), repeat=3)))\n        return self.get_transform(frame, 'cell_box') @ corners\n\n    def bbox_cell(self, frame: CoordinateFrame = 'local') -&gt; BBox3D:\n        \"\"\"Return the bounding box of the cell box in the given coordinate system.\"\"\"\n        return BBox3D.from_pts(self.corners(frame))\n\n    bbox = bbox_cell\n\n    def is_orthogonal(self, tol: float = 1e-8) -&gt; bool:\n        \"\"\"Returns whether this cell is orthogonal (axes are at right angles.)\"\"\"\n        return self.ortho.is_diagonal(tol=tol)\n\n    def is_orthogonal_in_local(self, tol: float = 1e-8) -&gt; bool:\n        \"\"\"Returns whether this cell is orthogonal and aligned with the local coordinate system.\"\"\"\n        transform = (self.affine @ self.ortho).to_linear()\n        if not transform.is_scaled_orthogonal(tol):\n            return False\n        normed = transform.inner / numpy.linalg.norm(transform.inner, axis=-2, keepdims=True)\n        # every row of transform must be a +/- 1 times a basis vector (i, j, or k)\n        return all(\n            any(numpy.isclose(numpy.abs(numpy.dot(row, v)), 1., atol=tol) for v in numpy.eye(3))\n            for row in normed\n        )\n\n    def _cell_size_in_local(self) -&gt; Vec3:\n        \"\"\"Calculate cell_size in the local coordinate system. Assumes ``self.is_orthogonal_in_local()``.\"\"\"\n        return numpy.abs(self.get_transform('local', 'ortho').transform_vec(self.cell_size))\n\n    def _box_size_in_local(self) -&gt; Vec3:\n        \"\"\"Calculate box_size in the local coordinate system. Assumes ``self.is_orthogonal_in_local()``.\"\"\"\n        return numpy.abs(self.get_transform('local', 'ortho').transform_vec(self.box_size))\n\n    def _n_cells_in_local(self) -&gt; NDArray[numpy.int_]:\n        \"\"\"Calculate n_cells after any local rotation. Assumes ``self.is_orthogonal_in_local()``.\"\"\"\n        return numpy.abs(numpy.round(self.get_transform('local', 'ortho').transform_vec(self.n_cells)).astype(int))\n\n    def to_ortho(self) -&gt; AffineTransform3D:\n        return self.get_transform('local', 'cell_box')\n\n    def transform_cell(self: HasCellT, transform: AffineTransform3D, frame: CoordinateFrame = 'local') -&gt; HasCellT:\n        \"\"\"\n        Apply the given transform to the unit cell, and return a new `Cell`.\n        The transform is applied in coordinate frame 'frame'.\n        Orthogonal and affine transformations are applied to the affine matrix component,\n        while skew and scaling is applied to the orthogonalization matrix/cell_size.\n        \"\"\"\n        transform = t.cast(AffineTransform3D, self.change_transform(transform, 'local', frame))\n        if not transform.to_linear().is_orthogonal():\n            raise NotImplementedError()\n        return self.with_cell(Cell(\n            affine=transform @ self.affine,\n            ortho=self.ortho,\n            cell_size=self.cell_size,\n            cell_angle=self.cell_angle,\n            n_cells=self.n_cells,\n            pbc=self.pbc,\n        ))\n\n    def strain_orthogonal(self: HasCellT) -&gt; HasCellT:\n        \"\"\"\n        Orthogonalize using strain.\n\n        Strain is applied such that the x-axis remains fixed, and the y-axis remains in the xy plane.\n        For small displacements, no hydrostatic strain is applied (volume is conserved).\n        \"\"\"\n        return self.with_cell(Cell(\n            affine=self.affine,\n            ortho=LinearTransform3D(),\n            cell_size=self.cell_size,\n            n_cells=self.n_cells,\n            pbc=self.pbc,\n        ))\n\n    def repeat(self: HasCellT, n: t.Union[int, VecLike]) -&gt; HasCellT:\n        \"\"\"Tile the cell by `n` in each dimension.\"\"\"\n        ns = numpy.broadcast_to(n, 3)\n        if not numpy.issubdtype(ns.dtype, numpy.integer):\n            raise ValueError(f\"repeat() argument must be an integer or integer array.\")\n        return self.with_cell(Cell(\n            affine=self.affine,\n            ortho=self.ortho,\n            cell_size=self.cell_size,\n            cell_angle=self.cell_angle,\n            n_cells=self.n_cells * numpy.broadcast_to(n, 3),\n            pbc = self.pbc | (ns &gt; 1)  # assume periodic along repeated directions\n        ))\n\n    def explode(self: HasCellT) -&gt; HasCellT:\n        \"\"\"Materialize repeated cells as one supercell.\"\"\"\n        return self.with_cell(Cell(\n            affine=self.affine,\n            ortho=self.ortho,\n            cell_size=self.cell_size*self.n_cells,\n            cell_angle=self.cell_angle,\n            pbc=self.pbc,\n        ))\n\n    def explode_z(self: HasCellT) -&gt; HasCellT:\n        \"\"\"Materialize repeated cells as one supercell in z.\"\"\"\n        return self.with_cell(Cell(\n            affine=self.affine,\n            ortho=self.ortho,\n            cell_size=self.cell_size*[1, 1, self.n_cells[2]],\n            n_cells=[*self.n_cells[:2], 1],\n            cell_angle=self.cell_angle,\n            pbc=self.pbc,\n        ))\n\n    def crop(self: HasCellT, x_min: float = -numpy.inf, x_max: float = numpy.inf,\n             y_min: float = -numpy.inf, y_max: float = numpy.inf,\n             z_min: float = -numpy.inf, z_max: float = numpy.inf, *,\n             frame: CoordinateFrame = 'local') -&gt; HasCellT:\n        \"\"\"\n        Crop 'cell' to the given extents. For a non-orthogonal\n        cell, this must be specified in cell coordinates. This\n        function implicity `explode`s the cell as well.\n        \"\"\"\n\n        if not frame.lower().startswith('cell'):\n            if not self.is_orthogonal():\n                raise ValueError(\"Cannot crop a non-orthogonal cell in orthogonal coordinates. Use crop_atoms instead.\")\n\n        min = to_vec3([x_min, y_min, z_min])\n        max = to_vec3([x_max, y_max, z_max])\n        (min, max) = self.get_transform('cell_box', frame).transform([min, max])\n        new_box = BBox3D(min, max) &amp; BBox3D.unit()\n        cropped = (new_box.min &gt; 0.) | (new_box.max &lt; 1.)\n\n        return self.with_cell(Cell(\n            affine=self.affine @ AffineTransform3D.translate(-new_box.min),\n            ortho=self.ortho,\n            cell_size=new_box.size * self.cell_size * numpy.where(cropped, self.n_cells, 1),\n            n_cells=numpy.where(cropped, 1, self.n_cells),\n            cell_angle=self.cell_angle,\n            pbc=self.pbc &amp; ~cropped  # remove periodicity along cropped directions\n        ))\n\n    @t.overload\n    def change_transform(self, transform: AffineTransform3D,\n                         frame_to: t.Optional[CoordinateFrame] = None,\n                         frame_from: t.Optional[CoordinateFrame] = None) -&gt; AffineTransform3D:\n        ...\n\n    @t.overload\n    def change_transform(self, transform: Transform3D,\n                         frame_to: t.Optional[CoordinateFrame] = None,\n                         frame_from: t.Optional[CoordinateFrame] = None) -&gt; Transform3D:\n        ...\n\n    def change_transform(self, transform: Transform3D,\n                         frame_to: t.Optional[CoordinateFrame] = None,\n                         frame_from: t.Optional[CoordinateFrame] = None) -&gt; Transform3D:\n        \"\"\"Coordinate-change a transformation to 'frame_to' from 'frame_from'.\"\"\"\n        if frame_to == frame_from and frame_to is not None:\n            return transform\n        coord_change = self.get_transform(frame_to, frame_from)\n        return coord_change @ transform @ coord_change.inverse()\n\n    def assert_equal(self, other: t.Any):\n        assert isinstance(other, HasCell) and type(self) == type(other)\n        numpy.testing.assert_array_almost_equal(self.affine.inner, other.affine.inner, 6)\n        numpy.testing.assert_array_almost_equal(self.ortho.inner, other.ortho.inner, 6)\n        numpy.testing.assert_array_almost_equal(self.cell_size, other.cell_size, 6)\n        numpy.testing.assert_array_equal(self.n_cells, other.n_cells)\n        numpy.testing.assert_array_equal(self.pbc, other.pbc)\n</code></pre>"},{"location":"api/#atomlib.HasCell.affine","title":"<code>affine: AffineTransform3D</code>  <code>property</code>","text":"<p>Affine transformation. Holds transformation from 'ortho' to 'local' coordinates, including rotation away from the standard crystal orientation.</p>"},{"location":"api/#atomlib.HasCell.ortho","title":"<code>ortho: LinearTransform3D</code>  <code>property</code>","text":"<p>Orthogonalization transformation. Skews but does not scale the crystal axes to cartesian axes.</p>"},{"location":"api/#atomlib.HasCell.metric","title":"<code>metric: LinearTransform3D</code>  <code>property</code>","text":"<p>Cell metric tensor</p> <p>Returns the dot product between every combination of basis vectors. :math:<code>\\mathbf{a} \\cdot \\mathbf{b} = a_i M_ij b_j</code></p>"},{"location":"api/#atomlib.HasCell.cell_size","title":"<code>cell_size: NDArray[numpy.float_]</code>  <code>property</code>","text":"<p>Unit cell size.</p>"},{"location":"api/#atomlib.HasCell.cell_angle","title":"<code>cell_angle: NDArray[numpy.float_]</code>  <code>property</code>","text":"<p>Unit cell angles, in radians.</p>"},{"location":"api/#atomlib.HasCell.n_cells","title":"<code>n_cells: NDArray[numpy.int_]</code>  <code>property</code>","text":"<p>Number of unit cells.</p>"},{"location":"api/#atomlib.HasCell.pbc","title":"<code>pbc: NDArray[numpy.bool_]</code>  <code>property</code>","text":"<p>Flags indicating the presence of periodic boundary conditions along each axis.</p>"},{"location":"api/#atomlib.HasCell.ortho_size","title":"<code>ortho_size: NDArray[numpy.float_]</code>  <code>property</code>","text":"<p>Return size of orthogonal unit cell.</p> <p>Equivalent to the diagonal of the orthogonalization matrix.</p>"},{"location":"api/#atomlib.HasCell.box_size","title":"<code>box_size: NDArray[numpy.float_]</code>  <code>property</code>","text":"<p>Return size of the cell box.</p> <p>Equivalent to <code>self.n_cells * self.cell_size</code>.</p>"},{"location":"api/#atomlib.HasCell.bbox","title":"<code>bbox = bbox_cell</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#atomlib.HasCell.get_cell","title":"<code>get_cell()</code>  <code>abstractmethod</code>","text":"<p>Get the cell contained in <code>self</code>. This should be a low cost method.</p> Source code in <code>atomlib/cell.py</code> <pre><code>@abc.abstractmethod\ndef get_cell(self) -&gt; Cell:\n    \"\"\"Get the cell contained in ``self``. This should be a low cost method.\"\"\"\n    ...\n</code></pre>"},{"location":"api/#atomlib.HasCell.with_cell","title":"<code>with_cell(cell)</code>  <code>abstractmethod</code>","text":"<p>Replace the cell in <code>self</code> with <code>cell</code>.</p> Source code in <code>atomlib/cell.py</code> <pre><code>@abc.abstractmethod\ndef with_cell(self: HasCellT, cell: Cell) -&gt; HasCellT:\n    \"\"\"Replace the cell in ``self`` with ``cell``.\"\"\"\n    ...\n</code></pre>"},{"location":"api/#atomlib.HasCell.get_transform","title":"<code>get_transform(frame_to=None, frame_from=None)</code>","text":"<p>In the two-argument form, get the transform to 'frame_to' from 'frame_from'. In the one-argument form, get the transform from local coordinates to 'frame'.</p> Source code in <code>atomlib/cell.py</code> <pre><code>def get_transform(self, frame_to: t.Optional[CoordinateFrame] = None, frame_from: t.Optional[CoordinateFrame] = None) -&gt; AffineTransform3D:\n    \"\"\"\n    In the two-argument form, get the transform to 'frame_to' from 'frame_from'.\n    In the one-argument form, get the transform from local coordinates to 'frame'.\n    \"\"\"\n    transform_from = self._get_transform_to_local(frame_from) if frame_from is not None else AffineTransform3D()\n    transform_to = self._get_transform_to_local(frame_to) if frame_to is not None else AffineTransform3D()\n    if frame_from is not None and frame_to is not None and frame_from.lower() == frame_to.lower():\n        return AffineTransform3D()\n    return transform_to.inverse() @ transform_from\n</code></pre>"},{"location":"api/#atomlib.HasCell.corners","title":"<code>corners(frame='local')</code>","text":"Source code in <code>atomlib/cell.py</code> <pre><code>def corners(self, frame: CoordinateFrame = 'local') -&gt; numpy.ndarray:\n    corners = numpy.array(list(itertools.product((0., 1.), repeat=3)))\n    return self.get_transform(frame, 'cell_box') @ corners\n</code></pre>"},{"location":"api/#atomlib.HasCell.bbox_cell","title":"<code>bbox_cell(frame='local')</code>","text":"<p>Return the bounding box of the cell box in the given coordinate system.</p> Source code in <code>atomlib/cell.py</code> <pre><code>def bbox_cell(self, frame: CoordinateFrame = 'local') -&gt; BBox3D:\n    \"\"\"Return the bounding box of the cell box in the given coordinate system.\"\"\"\n    return BBox3D.from_pts(self.corners(frame))\n</code></pre>"},{"location":"api/#atomlib.HasCell.is_orthogonal","title":"<code>is_orthogonal(tol=1e-08)</code>","text":"<p>Returns whether this cell is orthogonal (axes are at right angles.)</p> Source code in <code>atomlib/cell.py</code> <pre><code>def is_orthogonal(self, tol: float = 1e-8) -&gt; bool:\n    \"\"\"Returns whether this cell is orthogonal (axes are at right angles.)\"\"\"\n    return self.ortho.is_diagonal(tol=tol)\n</code></pre>"},{"location":"api/#atomlib.HasCell.is_orthogonal_in_local","title":"<code>is_orthogonal_in_local(tol=1e-08)</code>","text":"<p>Returns whether this cell is orthogonal and aligned with the local coordinate system.</p> Source code in <code>atomlib/cell.py</code> <pre><code>def is_orthogonal_in_local(self, tol: float = 1e-8) -&gt; bool:\n    \"\"\"Returns whether this cell is orthogonal and aligned with the local coordinate system.\"\"\"\n    transform = (self.affine @ self.ortho).to_linear()\n    if not transform.is_scaled_orthogonal(tol):\n        return False\n    normed = transform.inner / numpy.linalg.norm(transform.inner, axis=-2, keepdims=True)\n    # every row of transform must be a +/- 1 times a basis vector (i, j, or k)\n    return all(\n        any(numpy.isclose(numpy.abs(numpy.dot(row, v)), 1., atol=tol) for v in numpy.eye(3))\n        for row in normed\n    )\n</code></pre>"},{"location":"api/#atomlib.HasCell.to_ortho","title":"<code>to_ortho()</code>","text":"Source code in <code>atomlib/cell.py</code> <pre><code>def to_ortho(self) -&gt; AffineTransform3D:\n    return self.get_transform('local', 'cell_box')\n</code></pre>"},{"location":"api/#atomlib.HasCell.transform_cell","title":"<code>transform_cell(transform, frame='local')</code>","text":"<p>Apply the given transform to the unit cell, and return a new <code>Cell</code>. The transform is applied in coordinate frame 'frame'. Orthogonal and affine transformations are applied to the affine matrix component, while skew and scaling is applied to the orthogonalization matrix/cell_size.</p> Source code in <code>atomlib/cell.py</code> <pre><code>def transform_cell(self: HasCellT, transform: AffineTransform3D, frame: CoordinateFrame = 'local') -&gt; HasCellT:\n    \"\"\"\n    Apply the given transform to the unit cell, and return a new `Cell`.\n    The transform is applied in coordinate frame 'frame'.\n    Orthogonal and affine transformations are applied to the affine matrix component,\n    while skew and scaling is applied to the orthogonalization matrix/cell_size.\n    \"\"\"\n    transform = t.cast(AffineTransform3D, self.change_transform(transform, 'local', frame))\n    if not transform.to_linear().is_orthogonal():\n        raise NotImplementedError()\n    return self.with_cell(Cell(\n        affine=transform @ self.affine,\n        ortho=self.ortho,\n        cell_size=self.cell_size,\n        cell_angle=self.cell_angle,\n        n_cells=self.n_cells,\n        pbc=self.pbc,\n    ))\n</code></pre>"},{"location":"api/#atomlib.HasCell.strain_orthogonal","title":"<code>strain_orthogonal()</code>","text":"<p>Orthogonalize using strain.</p> <p>Strain is applied such that the x-axis remains fixed, and the y-axis remains in the xy plane. For small displacements, no hydrostatic strain is applied (volume is conserved).</p> Source code in <code>atomlib/cell.py</code> <pre><code>def strain_orthogonal(self: HasCellT) -&gt; HasCellT:\n    \"\"\"\n    Orthogonalize using strain.\n\n    Strain is applied such that the x-axis remains fixed, and the y-axis remains in the xy plane.\n    For small displacements, no hydrostatic strain is applied (volume is conserved).\n    \"\"\"\n    return self.with_cell(Cell(\n        affine=self.affine,\n        ortho=LinearTransform3D(),\n        cell_size=self.cell_size,\n        n_cells=self.n_cells,\n        pbc=self.pbc,\n    ))\n</code></pre>"},{"location":"api/#atomlib.HasCell.repeat","title":"<code>repeat(n)</code>","text":"<p>Tile the cell by <code>n</code> in each dimension.</p> Source code in <code>atomlib/cell.py</code> <pre><code>def repeat(self: HasCellT, n: t.Union[int, VecLike]) -&gt; HasCellT:\n    \"\"\"Tile the cell by `n` in each dimension.\"\"\"\n    ns = numpy.broadcast_to(n, 3)\n    if not numpy.issubdtype(ns.dtype, numpy.integer):\n        raise ValueError(f\"repeat() argument must be an integer or integer array.\")\n    return self.with_cell(Cell(\n        affine=self.affine,\n        ortho=self.ortho,\n        cell_size=self.cell_size,\n        cell_angle=self.cell_angle,\n        n_cells=self.n_cells * numpy.broadcast_to(n, 3),\n        pbc = self.pbc | (ns &gt; 1)  # assume periodic along repeated directions\n    ))\n</code></pre>"},{"location":"api/#atomlib.HasCell.explode","title":"<code>explode()</code>","text":"<p>Materialize repeated cells as one supercell.</p> Source code in <code>atomlib/cell.py</code> <pre><code>def explode(self: HasCellT) -&gt; HasCellT:\n    \"\"\"Materialize repeated cells as one supercell.\"\"\"\n    return self.with_cell(Cell(\n        affine=self.affine,\n        ortho=self.ortho,\n        cell_size=self.cell_size*self.n_cells,\n        cell_angle=self.cell_angle,\n        pbc=self.pbc,\n    ))\n</code></pre>"},{"location":"api/#atomlib.HasCell.explode_z","title":"<code>explode_z()</code>","text":"<p>Materialize repeated cells as one supercell in z.</p> Source code in <code>atomlib/cell.py</code> <pre><code>def explode_z(self: HasCellT) -&gt; HasCellT:\n    \"\"\"Materialize repeated cells as one supercell in z.\"\"\"\n    return self.with_cell(Cell(\n        affine=self.affine,\n        ortho=self.ortho,\n        cell_size=self.cell_size*[1, 1, self.n_cells[2]],\n        n_cells=[*self.n_cells[:2], 1],\n        cell_angle=self.cell_angle,\n        pbc=self.pbc,\n    ))\n</code></pre>"},{"location":"api/#atomlib.HasCell.crop","title":"<code>crop(x_min=-numpy.inf, x_max=numpy.inf, y_min=-numpy.inf, y_max=numpy.inf, z_min=-numpy.inf, z_max=numpy.inf, *, frame='local')</code>","text":"<p>Crop 'cell' to the given extents. For a non-orthogonal cell, this must be specified in cell coordinates. This function implicity <code>explode</code>s the cell as well.</p> Source code in <code>atomlib/cell.py</code> <pre><code>def crop(self: HasCellT, x_min: float = -numpy.inf, x_max: float = numpy.inf,\n         y_min: float = -numpy.inf, y_max: float = numpy.inf,\n         z_min: float = -numpy.inf, z_max: float = numpy.inf, *,\n         frame: CoordinateFrame = 'local') -&gt; HasCellT:\n    \"\"\"\n    Crop 'cell' to the given extents. For a non-orthogonal\n    cell, this must be specified in cell coordinates. This\n    function implicity `explode`s the cell as well.\n    \"\"\"\n\n    if not frame.lower().startswith('cell'):\n        if not self.is_orthogonal():\n            raise ValueError(\"Cannot crop a non-orthogonal cell in orthogonal coordinates. Use crop_atoms instead.\")\n\n    min = to_vec3([x_min, y_min, z_min])\n    max = to_vec3([x_max, y_max, z_max])\n    (min, max) = self.get_transform('cell_box', frame).transform([min, max])\n    new_box = BBox3D(min, max) &amp; BBox3D.unit()\n    cropped = (new_box.min &gt; 0.) | (new_box.max &lt; 1.)\n\n    return self.with_cell(Cell(\n        affine=self.affine @ AffineTransform3D.translate(-new_box.min),\n        ortho=self.ortho,\n        cell_size=new_box.size * self.cell_size * numpy.where(cropped, self.n_cells, 1),\n        n_cells=numpy.where(cropped, 1, self.n_cells),\n        cell_angle=self.cell_angle,\n        pbc=self.pbc &amp; ~cropped  # remove periodicity along cropped directions\n    ))\n</code></pre>"},{"location":"api/#atomlib.HasCell.change_transform","title":"<code>change_transform(transform, frame_to=None, frame_from=None)</code>","text":"<p>Coordinate-change a transformation to 'frame_to' from 'frame_from'.</p> Source code in <code>atomlib/cell.py</code> <pre><code>def change_transform(self, transform: Transform3D,\n                     frame_to: t.Optional[CoordinateFrame] = None,\n                     frame_from: t.Optional[CoordinateFrame] = None) -&gt; Transform3D:\n    \"\"\"Coordinate-change a transformation to 'frame_to' from 'frame_from'.\"\"\"\n    if frame_to == frame_from and frame_to is not None:\n        return transform\n    coord_change = self.get_transform(frame_to, frame_from)\n    return coord_change @ transform @ coord_change.inverse()\n</code></pre>"},{"location":"api/#atomlib.HasCell.assert_equal","title":"<code>assert_equal(other)</code>","text":"Source code in <code>atomlib/cell.py</code> <pre><code>def assert_equal(self, other: t.Any):\n    assert isinstance(other, HasCell) and type(self) == type(other)\n    numpy.testing.assert_array_almost_equal(self.affine.inner, other.affine.inner, 6)\n    numpy.testing.assert_array_almost_equal(self.ortho.inner, other.ortho.inner, 6)\n    numpy.testing.assert_array_almost_equal(self.cell_size, other.cell_size, 6)\n    numpy.testing.assert_array_equal(self.n_cells, other.n_cells)\n    numpy.testing.assert_array_equal(self.pbc, other.pbc)\n</code></pre>"},{"location":"api/#atomlib.AtomCell","title":"<code>AtomCell</code>  <code>dataclass</code>","text":"<p>             Bases: <code>AtomCellIOMixin</code>, <code>HasAtomCell</code></p> <p>Cell of atoms with known size and periodic boundary conditions.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@dataclass(init=False, repr=False, frozen=True)\nclass AtomCell(AtomCellIOMixin, HasAtomCell):\n    \"\"\"\n    Cell of atoms with known size and periodic boundary conditions.\n    \"\"\"\n\n    atoms: Atoms\n    \"\"\"Atoms in the cell. Stored in 'local' coordinates (i.e. relative to the enclosing group but not relative to box dimensions).\"\"\"\n\n    cell: Cell\n    \"\"\"Cell coordinate system.\"\"\"\n\n    frame: CoordinateFrame = 'local'\n    \"\"\"Coordinate frame 'atoms' are stored in.\"\"\"\n\n    def get_cell(self) -&gt; Cell:\n        return self.cell\n\n    def with_cell(self: AtomCellT, cell: Cell) -&gt; AtomCellT:\n        return self.__class__(self.atoms, cell, frame=self.frame, keep_frame=True)\n\n    def get_atoms(self, frame: t.Optional[CoordinateFrame] = None) -&gt; Atoms:\n        \"\"\"Get atoms contained in ``self``, in the given coordinate frame.\"\"\"\n\n        if frame is None or frame == self.get_frame():\n            return self.atoms\n        return self.atoms.transform(self.get_transform(frame, self.get_frame()))\n\n    def with_atoms(self: AtomCellT, atoms: HasAtoms, frame: t.Optional[CoordinateFrame] = None) -&gt; AtomCellT:\n        frame = frame if frame is not None else self.frame\n        return self.__class__(atoms.get_atoms(), cell=self.cell, frame=frame, keep_frame=True)\n        #return replace(self, atoms=atoms, frame = frame if frame is not None else self.frame, keep_frame=True)\n\n    def get_frame(self) -&gt; CoordinateFrame:\n        \"\"\"Get the coordinate frame atoms are stored in.\"\"\"\n        return self.frame\n\n    @classmethod\n    def _combine_metadata(cls: t.Type[AtomCellT], *atoms: HasAtoms, n: t.Optional[int] = None) -&gt; AtomCellT:\n        \"\"\"\n        When combining multiple :py:`HasAtoms`, check that they are compatible with each other,\n        and return a 'representative' which best represents the combined metadata.\n        Implementors should treat :py:`Atoms` as acceptable, but having no metadata.\n        \"\"\"\n        if n is not None:\n            rep = atoms[n]\n            if not isinstance(rep, AtomCell):\n                raise ValueError(f\"Atoms #{n} has no cell\")\n        else:\n            atom_cells = [a for a in atoms if isinstance(a, AtomCell)]\n            if len(atom_cells) == 0:\n                raise TypeError(f\"No AtomCells to combine\")\n            rep = atom_cells[0]\n            if not all(a.cell == rep.cell for a in atom_cells[1:]):\n                raise TypeError(f\"Can't combine AtomCells with different cells\")\n\n        return cls(Atoms.empty(), frame=rep.frame, cell=rep.cell)\n\n    @classmethod\n    def from_ortho(cls, atoms: IntoAtoms, ortho: LinearTransform3D, *,\n                   n_cells: t.Optional[VecLike] = None,\n                   frame: CoordinateFrame = 'local',\n                   keep_frame: bool = False):\n        \"\"\"\n        Make an atom cell given a list of atoms and an orthogonalization matrix.\n        Atoms are assumed to be in the coordinate system ``frame``.\n        \"\"\"\n        cell = Cell.from_ortho(ortho, n_cells)\n        return cls(atoms, cell, frame=frame, keep_frame=keep_frame)\n\n    @classmethod\n    def from_unit_cell(cls, atoms: IntoAtoms, cell_size: VecLike,\n                       cell_angle: t.Optional[VecLike] = None, *,\n                       n_cells: t.Optional[VecLike] = None,\n                       frame: CoordinateFrame = 'local',\n                       keep_frame: bool = False):\n        \"\"\"\n        Make a cell given a list of atoms and unit cell parameters.\n        Atoms are assumed to be in the coordinate system ``frame``.\n        \"\"\"\n        cell = Cell.from_unit_cell(cell_size, cell_angle, n_cells=n_cells)\n        return cls(atoms, cell, frame=frame, keep_frame=keep_frame)\n\n    def __init__(self, atoms: IntoAtoms, cell: Cell, *,\n                 frame: CoordinateFrame = 'local',\n                 keep_frame: bool = False):\n        atoms = Atoms(atoms)\n        # by default, store in local coordinates\n        if not keep_frame and frame != 'local':\n            atoms = atoms.transform(cell.get_transform('local', frame))\n            frame = 'local'\n\n        object.__setattr__(self, 'atoms', atoms)\n        object.__setattr__(self, 'cell', cell)\n        object.__setattr__(self, 'frame', frame)\n\n        self.__post_init__()\n\n    def __post_init__(self):\n        pass\n\n    def orthogonalize(self) -&gt; OrthoCell:\n        if self.is_orthogonal():\n            return OrthoCell(self.atoms, self.cell, frame=self.frame)\n        raise NotImplementedError()\n\n    def clone(self: AtomCellT) -&gt; AtomCellT:\n        \"\"\"Make a deep copy of `self`.\"\"\"\n        return self.__class__(**{field.name: copy.deepcopy(getattr(self, field.name)) for field in fields(self)})\n\n    def assert_equal(self, other: t.Any):\n        \"\"\"Assert this structure is equal to \"\"\"\n        assert isinstance(other, AtomCell)\n        self.cell.assert_equal(other.cell)\n        self.get_atoms('local').assert_equal(other.get_atoms('local'))\n\n    def _str_parts(self) -&gt; t.Iterable[t.Any]:\n        return (\n            f\"Cell size:  {self.cell.cell_size!s}\",\n            f\"Cell angle: {self.cell.cell_angle!s}\",\n            f\"# Cells: {self.cell.n_cells!s}\",\n            f\"Frame: {self.frame}\",\n            self.atoms,\n        )\n\n    def __str__(self) -&gt; str:\n        return \"\\n\".join(map(str, self._str_parts()))\n\n    def __repr__(self) -&gt; str:\n        return f\"{self.__class__.__name__}({self.atoms!r}, cell={self.cell!r}, frame={self.frame})\"\n\n    def _repr_pretty_(self, p, cycle: bool) -&gt; None:\n        p.text(f'{self.__class__.__name__}(...)') if cycle else p.text(str(self))\n</code></pre>"},{"location":"api/#atomlib.AtomCell.affine","title":"<code>affine: AffineTransform3D</code>  <code>property</code>","text":"<p>Affine transformation. Holds transformation from 'ortho' to 'local' coordinates, including rotation away from the standard crystal orientation.</p>"},{"location":"api/#atomlib.AtomCell.ortho","title":"<code>ortho: LinearTransform3D</code>  <code>property</code>","text":"<p>Orthogonalization transformation. Skews but does not scale the crystal axes to cartesian axes.</p>"},{"location":"api/#atomlib.AtomCell.metric","title":"<code>metric: LinearTransform3D</code>  <code>property</code>","text":"<p>Cell metric tensor</p> <p>Returns the dot product between every combination of basis vectors. :math:<code>\\mathbf{a} \\cdot \\mathbf{b} = a_i M_ij b_j</code></p>"},{"location":"api/#atomlib.AtomCell.cell_size","title":"<code>cell_size: NDArray[numpy.float_]</code>  <code>property</code>","text":"<p>Unit cell size.</p>"},{"location":"api/#atomlib.AtomCell.cell_angle","title":"<code>cell_angle: NDArray[numpy.float_]</code>  <code>property</code>","text":"<p>Unit cell angles, in radians.</p>"},{"location":"api/#atomlib.AtomCell.n_cells","title":"<code>n_cells: NDArray[numpy.int_]</code>  <code>property</code>","text":"<p>Number of unit cells.</p>"},{"location":"api/#atomlib.AtomCell.pbc","title":"<code>pbc: NDArray[numpy.bool_]</code>  <code>property</code>","text":"<p>Flags indicating the presence of periodic boundary conditions along each axis.</p>"},{"location":"api/#atomlib.AtomCell.ortho_size","title":"<code>ortho_size: NDArray[numpy.float_]</code>  <code>property</code>","text":"<p>Return size of orthogonal unit cell.</p> <p>Equivalent to the diagonal of the orthogonalization matrix.</p>"},{"location":"api/#atomlib.AtomCell.box_size","title":"<code>box_size: NDArray[numpy.float_]</code>  <code>property</code>","text":"<p>Return size of the cell box.</p> <p>Equivalent to <code>self.n_cells * self.cell_size</code>.</p>"},{"location":"api/#atomlib.AtomCell.columns","title":"<code>columns: t.Sequence[str]</code>  <code>property</code>","text":"<p>Return the columns in <code>self</code>.</p>"},{"location":"api/#atomlib.AtomCell.dtypes","title":"<code>dtypes: t.Sequence[polars.DataType]</code>  <code>property</code>","text":"<p>Return the datatypes in <code>self</code>.</p>"},{"location":"api/#atomlib.AtomCell.schema","title":"<code>schema: SchemaDict</code>  <code>property</code>","text":"<p>Return the schema of <code>self</code>.</p>"},{"location":"api/#atomlib.AtomCell.with_column","title":"<code>with_column = with_columns</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#atomlib.AtomCell.unique","title":"<code>unique = deduplicate</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#atomlib.AtomCell.atoms","title":"<code>atoms: Atoms</code>  <code>instance-attribute</code>","text":"<p>Atoms in the cell. Stored in 'local' coordinates (i.e. relative to the enclosing group but not relative to box dimensions).</p>"},{"location":"api/#atomlib.AtomCell.cell","title":"<code>cell: Cell</code>  <code>instance-attribute</code>","text":"<p>Cell coordinate system.</p>"},{"location":"api/#atomlib.AtomCell.frame","title":"<code>frame: CoordinateFrame = 'local'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Coordinate frame 'atoms' are stored in.</p>"},{"location":"api/#atomlib.AtomCell.get_transform","title":"<code>get_transform(frame_to=None, frame_from=None)</code>","text":"<p>In the two-argument form, get the transform to 'frame_to' from 'frame_from'. In the one-argument form, get the transform from local coordinates to 'frame'.</p> Source code in <code>atomlib/cell.py</code> <pre><code>def get_transform(self, frame_to: t.Optional[CoordinateFrame] = None, frame_from: t.Optional[CoordinateFrame] = None) -&gt; AffineTransform3D:\n    \"\"\"\n    In the two-argument form, get the transform to 'frame_to' from 'frame_from'.\n    In the one-argument form, get the transform from local coordinates to 'frame'.\n    \"\"\"\n    transform_from = self._get_transform_to_local(frame_from) if frame_from is not None else AffineTransform3D()\n    transform_to = self._get_transform_to_local(frame_to) if frame_to is not None else AffineTransform3D()\n    if frame_from is not None and frame_to is not None and frame_from.lower() == frame_to.lower():\n        return AffineTransform3D()\n    return transform_to.inverse() @ transform_from\n</code></pre>"},{"location":"api/#atomlib.AtomCell.corners","title":"<code>corners(frame='local')</code>","text":"Source code in <code>atomlib/cell.py</code> <pre><code>def corners(self, frame: CoordinateFrame = 'local') -&gt; numpy.ndarray:\n    corners = numpy.array(list(itertools.product((0., 1.), repeat=3)))\n    return self.get_transform(frame, 'cell_box') @ corners\n</code></pre>"},{"location":"api/#atomlib.AtomCell.bbox_cell","title":"<code>bbox_cell(frame='local')</code>","text":"<p>Return the bounding box of the cell box in the given coordinate system.</p> Source code in <code>atomlib/cell.py</code> <pre><code>def bbox_cell(self, frame: CoordinateFrame = 'local') -&gt; BBox3D:\n    \"\"\"Return the bounding box of the cell box in the given coordinate system.\"\"\"\n    return BBox3D.from_pts(self.corners(frame))\n</code></pre>"},{"location":"api/#atomlib.AtomCell.bbox","title":"<code>bbox(frame='local')</code>","text":"<p>Return the combined bounding box of the cell and atoms in the given coordinate system. To get the cell or atoms bounding box only, use meth:<code>bbox_cell</code> or meth:<code>bbox_atoms</code>.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def bbox(self, frame: CoordinateFrame = 'local') -&gt; BBox3D:\n    \"\"\"\n    Return the combined bounding box of the cell and atoms in the given coordinate system.\n    To get the cell or atoms bounding box only, use :py:meth:`bbox_cell` or :py:meth:`bbox_atoms`.\n    \"\"\"\n    return self.bbox_atoms(frame) | self.bbox_cell(frame)\n</code></pre>"},{"location":"api/#atomlib.AtomCell.is_orthogonal","title":"<code>is_orthogonal(tol=1e-08)</code>","text":"<p>Returns whether this cell is orthogonal (axes are at right angles.)</p> Source code in <code>atomlib/cell.py</code> <pre><code>def is_orthogonal(self, tol: float = 1e-8) -&gt; bool:\n    \"\"\"Returns whether this cell is orthogonal (axes are at right angles.)\"\"\"\n    return self.ortho.is_diagonal(tol=tol)\n</code></pre>"},{"location":"api/#atomlib.AtomCell.is_orthogonal_in_local","title":"<code>is_orthogonal_in_local(tol=1e-08)</code>","text":"<p>Returns whether this cell is orthogonal and aligned with the local coordinate system.</p> Source code in <code>atomlib/cell.py</code> <pre><code>def is_orthogonal_in_local(self, tol: float = 1e-8) -&gt; bool:\n    \"\"\"Returns whether this cell is orthogonal and aligned with the local coordinate system.\"\"\"\n    transform = (self.affine @ self.ortho).to_linear()\n    if not transform.is_scaled_orthogonal(tol):\n        return False\n    normed = transform.inner / numpy.linalg.norm(transform.inner, axis=-2, keepdims=True)\n    # every row of transform must be a +/- 1 times a basis vector (i, j, or k)\n    return all(\n        any(numpy.isclose(numpy.abs(numpy.dot(row, v)), 1., atol=tol) for v in numpy.eye(3))\n        for row in normed\n    )\n</code></pre>"},{"location":"api/#atomlib.AtomCell.to_ortho","title":"<code>to_ortho()</code>","text":"Source code in <code>atomlib/cell.py</code> <pre><code>def to_ortho(self) -&gt; AffineTransform3D:\n    return self.get_transform('local', 'cell_box')\n</code></pre>"},{"location":"api/#atomlib.AtomCell.transform_cell","title":"<code>transform_cell(transform, frame='local')</code>","text":"<p>Apply the given transform to the unit cell, without changing atom positions. The transform is applied in coordinate frame 'frame'.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def transform_cell(self: HasAtomCellT, transform: AffineTransform3D, frame: CoordinateFrame = 'local') -&gt; HasAtomCellT:\n    \"\"\"\n    Apply the given transform to the unit cell, without changing atom positions.\n    The transform is applied in coordinate frame 'frame'.\n    \"\"\"\n    return self.with_cell(self.get_cell().transform_cell(transform, frame=frame))\n</code></pre>"},{"location":"api/#atomlib.AtomCell.strain_orthogonal","title":"<code>strain_orthogonal()</code>","text":"<p>Orthogonalize using strain.</p> <p>Strain is applied such that the x-axis remains fixed, and the y-axis remains in the xy plane. For small displacements, no hydrostatic strain is applied (volume is conserved).</p> Source code in <code>atomlib/cell.py</code> <pre><code>def strain_orthogonal(self: HasCellT) -&gt; HasCellT:\n    \"\"\"\n    Orthogonalize using strain.\n\n    Strain is applied such that the x-axis remains fixed, and the y-axis remains in the xy plane.\n    For small displacements, no hydrostatic strain is applied (volume is conserved).\n    \"\"\"\n    return self.with_cell(Cell(\n        affine=self.affine,\n        ortho=LinearTransform3D(),\n        cell_size=self.cell_size,\n        n_cells=self.n_cells,\n        pbc=self.pbc,\n    ))\n</code></pre>"},{"location":"api/#atomlib.AtomCell.repeat","title":"<code>repeat(n)</code>","text":"<p>Tile the cell</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def repeat(self: HasAtomCellT, n: t.Union[int, VecLike]) -&gt; HasAtomCellT:\n    \"\"\"Tile the cell\"\"\"\n    ns = numpy.broadcast_to(n, 3)\n    if not numpy.issubdtype(ns.dtype, numpy.integer):\n        raise ValueError(f\"repeat() argument must be an integer or integer array.\")\n\n    cells = numpy.stack(numpy.meshgrid(*map(numpy.arange, ns))) \\\n        .reshape(3, -1).T.astype(float)\n    cells = cells * self.box_size\n\n    atoms = self.get_atoms('cell')\n    atoms = Atoms.concat([\n        atoms.transform(AffineTransform3D.translate(cell))\n        for cell in cells\n    ]) #.transform(self.cell.get_transform('local', 'cell_frac'))\n    return self.with_atoms(atoms, 'cell').with_cell(self.get_cell().repeat(ns))\n</code></pre>"},{"location":"api/#atomlib.AtomCell.explode","title":"<code>explode()</code>","text":"<p>Materialize repeated cells as one supercell.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def explode(self: HasAtomCellT) -&gt; HasAtomCellT:\n    \"\"\"Materialize repeated cells as one supercell.\"\"\"\n    frame = self.get_frame()\n\n    return self.with_atoms(self.get_atoms('local'), 'local') \\\n        .with_cell(self.get_cell().explode()) \\\n        .to_frame(frame)\n</code></pre>"},{"location":"api/#atomlib.AtomCell.explode_z","title":"<code>explode_z()</code>","text":"<p>Materialize repeated cells as one supercell in z.</p> Source code in <code>atomlib/cell.py</code> <pre><code>def explode_z(self: HasCellT) -&gt; HasCellT:\n    \"\"\"Materialize repeated cells as one supercell in z.\"\"\"\n    return self.with_cell(Cell(\n        affine=self.affine,\n        ortho=self.ortho,\n        cell_size=self.cell_size*[1, 1, self.n_cells[2]],\n        n_cells=[*self.n_cells[:2], 1],\n        cell_angle=self.cell_angle,\n        pbc=self.pbc,\n    ))\n</code></pre>"},{"location":"api/#atomlib.AtomCell.crop","title":"<code>crop(x_min=-numpy.inf, x_max=numpy.inf, y_min=-numpy.inf, y_max=numpy.inf, z_min=-numpy.inf, z_max=numpy.inf, *, frame='local')</code>","text":"<p>Crop atoms and cell to the given extents. For a non-orthogonal cell, this must be specified in cell coordinates. This function implicity <code>explode</code>s the cell as well.</p> <p>To crop atoms only, use <code>crop_atoms</code> instead.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def crop(self: HasAtomCellT, x_min: float = -numpy.inf, x_max: float = numpy.inf,\n         y_min: float = -numpy.inf, y_max: float = numpy.inf,\n         z_min: float = -numpy.inf, z_max: float = numpy.inf, *,\n         frame: CoordinateFrame = 'local') -&gt; HasAtomCellT:\n    \"\"\"\n    Crop atoms and cell to the given extents. For a non-orthogonal\n    cell, this must be specified in cell coordinates. This\n    function implicity `explode`s the cell as well.\n\n    To crop atoms only, use `crop_atoms` instead.\n    \"\"\"\n\n    cell = self.get_cell().crop(x_min, x_max, y_min, y_max, z_min, z_max, frame=frame)\n    atoms = self._transform_atoms_in_frame(frame, lambda atoms: atoms.crop_atoms(x_min, x_max, y_min, y_max, z_min, z_max))\n    return self.with_cell(cell).with_atoms(atoms)\n</code></pre>"},{"location":"api/#atomlib.AtomCell.change_transform","title":"<code>change_transform(transform, frame_to=None, frame_from=None)</code>","text":"<p>Coordinate-change a transformation to 'frame_to' from 'frame_from'.</p> Source code in <code>atomlib/cell.py</code> <pre><code>def change_transform(self, transform: Transform3D,\n                     frame_to: t.Optional[CoordinateFrame] = None,\n                     frame_from: t.Optional[CoordinateFrame] = None) -&gt; Transform3D:\n    \"\"\"Coordinate-change a transformation to 'frame_to' from 'frame_from'.\"\"\"\n    if frame_to == frame_from and frame_to is not None:\n        return transform\n    coord_change = self.get_transform(frame_to, frame_from)\n    return coord_change @ transform @ coord_change.inverse()\n</code></pre>"},{"location":"api/#atomlib.AtomCell.describe","title":"<code>describe(percentiles=(0.25, 0.5, 0.75), *, interpolation='nearest', frame=None)</code>","text":"<p>Return summary statistics for <code>self</code>.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_get\ndef describe(self, percentiles: t.Union[t.Sequence[float], float, None] = (0.25, 0.5, 0.75), *,\n             interpolation: RollingInterpolationMethod = 'nearest',\n             frame: t.Optional[CoordinateFrame] = None) -&gt; polars.DataFrame:\n    \"\"\"Return summary statistics for `self`.\"\"\"\n    ...\n</code></pre>"},{"location":"api/#atomlib.AtomCell.with_columns","title":"<code>with_columns(*exprs, frame=None, **named_exprs)</code>","text":"<p>Return a copy of <code>self</code> with the given columns added.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef with_columns(self: HasAtomCellT,\n                 *exprs: t.Union[IntoExpr, t.Iterable[IntoExpr]],\n                 frame: t.Optional[CoordinateFrame] = None,\n                 **named_exprs: IntoExpr) -&gt; HasAtomCellT:\n    \"\"\"Return a copy of ``self`` with the given columns added.\"\"\"\n    ...\n</code></pre>"},{"location":"api/#atomlib.AtomCell.insert_column","title":"<code>insert_column(index, column)</code>","text":"Source code in <code>atomlib/atoms.py</code> <pre><code>@_fwd_frame_map\ndef insert_column(self, index: int, column: polars.Series) -&gt; polars.DataFrame:\n    return self._get_frame().insert_column(index, column)\n</code></pre>"},{"location":"api/#atomlib.AtomCell.get_column","title":"<code>get_column(name, *, frame=None)</code>","text":"<p>Get the specified column from <code>self</code>, raising <code>polars.ColumnNotFoundError</code> if it's not present.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_get\ndef get_column(self, name: str, *, frame: t.Optional[CoordinateFrame] = None) -&gt; polars.Series:\n    \"\"\"Get the specified column from `self`, raising [`polars.ColumnNotFoundError`][polars.exceptions.ColumnNotFoundError] if it's not present.\"\"\"\n    ...\n</code></pre>"},{"location":"api/#atomlib.AtomCell.get_columns","title":"<code>get_columns(*, frame=None)</code>","text":"<p>Get the specified columns from <code>self</code>, raising <code>polars.ColumnNotFoundError</code> if it's not present.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_get\ndef get_columns(self, *, frame: t.Optional[CoordinateFrame] = None) -&gt; t.List[polars.Series]:\n    \"\"\"Get the specified columns from `self`, raising [`polars.ColumnNotFoundError`][polars.exceptions.ColumnNotFoundError] if it's not present.\"\"\"\n    ...\n</code></pre>"},{"location":"api/#atomlib.AtomCell.get_column_index","title":"<code>get_column_index(name)</code>","text":"<p>Get the index of a column by name, raising <code>polars.ColumnNotFoundError</code> if it's not present.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>@_fwd_frame(polars.DataFrame.get_column_index)\ndef get_column_index(self, name: str) -&gt; int:\n    \"\"\"Get the index of a column by name, raising [`polars.ColumnNotFoundError`][polars.exceptions.ColumnNotFoundError] if it's not present.\"\"\"\n    ...\n</code></pre>"},{"location":"api/#atomlib.AtomCell.group_by","title":"<code>group_by(*by, maintain_order=False, frame=None, **named_by)</code>","text":"Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_get\ndef group_by(self, *by: t.Union[IntoExpr, t.Iterable[IntoExpr]],\n             maintain_order: bool = False, frame: t.Optional[CoordinateFrame] = None,\n             **named_by: IntoExpr) -&gt; polars.dataframe.group_by.GroupBy:\n    ...\n</code></pre>"},{"location":"api/#atomlib.AtomCell.pipe","title":"<code>pipe(function, *args, **kwargs)</code>","text":"<p>Apply <code>function</code> to <code>self</code> (in method-call syntax).</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def pipe(self: HasAtomCellT, function: t.Callable[Concatenate[HasAtomCellT, P], T], *args: P.args, **kwargs: P.kwargs) -&gt; T:\n    \"\"\"Apply `function` to `self` (in method-call syntax).\"\"\"\n    return function(self, *args, **kwargs)\n</code></pre>"},{"location":"api/#atomlib.AtomCell.drop","title":"<code>drop(*columns)</code>","text":"<p>Return <code>self</code> with the specified columns removed.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def drop(self, *columns: t.Union[str, t.Iterable[str]]) -&gt; polars.DataFrame:\n    \"\"\"Return `self` with the specified columns removed.\"\"\"\n    return self._get_frame().drop(*columns)\n</code></pre>"},{"location":"api/#atomlib.AtomCell.filter","title":"<code>filter(*predicates, frame=None, **constraints)</code>","text":"<p>Filter <code>self</code>, removing rows which evaluate to <code>False</code>.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef filter(\n    self: HasAtomCellT,\n    *predicates: t.Union[None, IntoExprColumn, t.Iterable[IntoExprColumn], bool, t.List[bool], numpy.ndarray],\n    frame: t.Optional[CoordinateFrame] = None,\n    **constraints: t.Any,\n) -&gt; HasAtomCellT:\n    \"\"\"Filter `self`, removing rows which evaluate to `False`.\"\"\"\n    ...\n</code></pre>"},{"location":"api/#atomlib.AtomCell.sort","title":"<code>sort(by, *more_by, descending=False, nulls_last=False)</code>","text":"<p>Sort the atoms in <code>self</code> by the given columns/expressions.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef sort(\n    self: HasAtomCellT,\n    by: t.Union[IntoExpr, t.Iterable[IntoExpr]],\n    *more_by: IntoExpr,\n    descending: t.Union[bool, t.Sequence[bool]] = False,\n    nulls_last: bool = False,\n) -&gt; HasAtomCellT:\n    \"\"\"\n    Sort the atoms in `self` by the given columns/expressions.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/#atomlib.AtomCell.slice","title":"<code>slice(offset, length=None, *, frame=None)</code>","text":"<p>Return a slice of the rows in <code>self</code>.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef slice(self: HasAtomCellT, offset: int, length: t.Optional[int] = None, *,\n          frame: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n    \"\"\"Return a slice of the rows in `self`.\"\"\"\n    ...\n</code></pre>"},{"location":"api/#atomlib.AtomCell.head","title":"<code>head(n=5, *, frame=None)</code>","text":"<p>Return the first <code>n</code> rows of <code>self</code>.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef head(self: HasAtomCellT, n: int = 5, *, frame: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n    \"\"\"Return the first `n` rows of `self`.\"\"\"\n    ...\n</code></pre>"},{"location":"api/#atomlib.AtomCell.tail","title":"<code>tail(n=5, *, frame=None)</code>","text":"<p>Return the last <code>n</code> rows of <code>self</code>.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef tail(self: HasAtomCellT, n: int = 5, *, frame: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n    \"\"\"Return the last `n` rows of `self`.\"\"\"\n    ...\n</code></pre>"},{"location":"api/#atomlib.AtomCell.drop_nulls","title":"<code>drop_nulls(subset=None)</code>","text":"<p>Drop rows that contain nulls in any of columns <code>subset</code>.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>@_fwd_frame_map\ndef drop_nulls(self, subset: t.Union[str, t.Collection[str], None] = None) -&gt; polars.DataFrame:\n    \"\"\"Drop rows that contain nulls in any of columns `subset`.\"\"\"\n    return self._get_frame().drop_nulls(subset)\n</code></pre>"},{"location":"api/#atomlib.AtomCell.fill_null","title":"<code>fill_null(value=None, strategy=None, limit=None, matches_supertype=True)</code>","text":"Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef fill_null(\n    self: HasAtomCellT, value: t.Any = None, strategy: t.Optional[FillNullStrategy] = None,\n    limit: t.Optional[int] = None, matches_supertype: bool = True,\n) -&gt; HasAtomCellT:\n    ...\n</code></pre>"},{"location":"api/#atomlib.AtomCell.fill_nan","title":"<code>fill_nan(value, *, frame=None)</code>","text":"Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef fill_nan(self: HasAtomCellT, value: t.Union[polars.Expr, int, float, None], *,\n             frame: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n    ...\n</code></pre>"},{"location":"api/#atomlib.AtomCell.concat","title":"<code>concat(atoms, *, rechunk=True, how='vertical')</code>  <code>classmethod</code>","text":"<p>Concatenate multiple <code>Atoms</code> together, handling metadata appropriately.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>@classmethod\ndef concat(cls: t.Type[HasAtomsT],\n           atoms: t.Union[HasAtomsT, IntoAtoms, t.Iterable[t.Union[HasAtomsT, IntoAtoms]]], *,\n           rechunk: bool = True, how: ConcatMethod = 'vertical') -&gt; HasAtomsT:\n    \"\"\"Concatenate multiple `Atoms` together, handling metadata appropriately.\"\"\"\n    # this method is tricky. It needs to accept raw Atoms, as well as HasAtoms of the\n    # same type as ``cls``.\n    if _is_abstract(cls):\n        raise TypeError(f\"concat() must be called on a concrete class.\")\n\n    if isinstance(atoms, HasAtoms):\n        atoms = (atoms,)\n    dfs = [a.get_atoms('local').inner if isinstance(a, HasAtoms) else Atoms(t.cast(IntoAtoms, a)).inner for a in atoms]\n    representative = cls._combine_metadata(*(a for a in atoms if isinstance(a, HasAtoms)))\n\n    if len(dfs) == 0:\n        return representative.with_atoms(Atoms.empty(), 'local')\n\n    if how in ('vertical', 'vertical_relaxed'):\n        # get order from first member\n        cols = dfs[0].columns\n        dfs = [df.select(cols) for df in dfs]\n    elif how == 'inner':\n        cols = reduce(operator.and_, (df.schema.keys() for df in dfs))\n        schema = OrderedDict((col, dfs[0].schema[col]) for col in cols)\n        if len(schema) == 0:\n            raise ValueError(f\"Atoms have no columns in common\")\n\n        dfs = [_select_schema(df, schema) for df in dfs]\n        how = 'vertical'\n\n    return representative.with_atoms(Atoms(polars.concat(dfs, rechunk=rechunk, how=how)), 'local')\n</code></pre>"},{"location":"api/#atomlib.AtomCell.partition_by","title":"<code>partition_by(by, *more_by, maintain_order=True, include_key=True, as_dict=False)</code>","text":"<p>Group by the given columns and partition into separate dataframes.</p> <p>Return the partitions as a dictionary by specifying <code>as_dict=True</code>.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def partition_by(\n    self: HasAtomsT, by: t.Union[str, t.Sequence[str]], *more_by: str,\n    maintain_order: bool = True, include_key: bool = True, as_dict: bool = False\n) -&gt; t.Union[t.List[HasAtomsT], t.Dict[t.Any, HasAtomsT]]:\n    \"\"\"\n    Group by the given columns and partition into separate dataframes.\n\n    Return the partitions as a dictionary by specifying `as_dict=True`.\n    \"\"\"\n    if as_dict:\n        d = self._get_frame().partition_by(by, *more_by, maintain_order=maintain_order, include_key=include_key, as_dict=True)\n        return {k: self.with_atoms(Atoms(df, _unchecked=True)) for (k, df) in d.items()}\n\n    return [\n        self.with_atoms(Atoms(df, _unchecked=True))\n        for df in self._get_frame().partition_by(by, *more_by, maintain_order=maintain_order, include_key=include_key, as_dict=False)\n    ]\n</code></pre>"},{"location":"api/#atomlib.AtomCell.select","title":"<code>select(*exprs, frame=None, **named_exprs)</code>","text":"<p>Select <code>exprs`` from ``self</code>, and return as a <code>polars.DataFrame</code>.</p> <p>Expressions may either be columns or expressions of columns.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_get\ndef select(\n    self, *exprs: t.Union[IntoExpr, t.Iterable[IntoExpr]],\n    frame: t.Optional[CoordinateFrame] = None,\n    **named_exprs: IntoExpr\n) -&gt; polars.DataFrame:\n    \"\"\"\n    Select `exprs`` from ``self`, and return as a `polars.DataFrame`.\n\n    Expressions may either be columns or expressions of columns.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/#atomlib.AtomCell.select_schema","title":"<code>select_schema(schema)</code>","text":"<p>Select columns from <code>self</code> and cast to the given schema. Raises <code>TypeError</code> if a column is not found or if it can't be cast.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def select_schema(self, schema: SchemaDict) -&gt; polars.DataFrame:\n    \"\"\"\n    Select columns from `self` and cast to the given schema.\n    Raises `TypeError` if a column is not found or if it can't be cast.\n    \"\"\"\n    return _select_schema(self, schema)\n</code></pre>"},{"location":"api/#atomlib.AtomCell.select_props","title":"<code>select_props(*exprs, frame=None, **named_exprs)</code>","text":"<p>Select <code>exprs</code> from <code>self</code>, while keeping required columns.</p> <p>Returns a HasAtoms.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef select_props(\n    self: HasAtomCellT,\n    *exprs: t.Union[IntoExpr, t.Iterable[IntoExpr]],\n    frame: t.Optional[CoordinateFrame] = None,\n    **named_exprs: IntoExpr\n) -&gt; HasAtomCellT:\n    \"\"\"\n    Select `exprs` from `self`, while keeping required columns.\n\n    Returns a HasAtoms.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/#atomlib.AtomCell.try_select","title":"<code>try_select(*exprs, frame=None, **named_exprs)</code>","text":"<p>Try to select <code>exprs</code> from <code>self</code>, and return as a <code>polars.DataFrame</code>.</p> <p>Expressions may either be columns or expressions of columns. Return <code>None</code> if any columns are missing.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_get\ndef try_select(\n    self, *exprs: t.Union[IntoExpr, t.Iterable[IntoExpr]],\n    frame: t.Optional[CoordinateFrame] = None,\n    **named_exprs: IntoExpr\n) -&gt; t.Optional[polars.DataFrame]:\n    \"\"\"\n    Try to select `exprs` from `self`, and return as a `polars.DataFrame`.\n\n    Expressions may either be columns or expressions of columns.\n    Return `None` if any columns are missing.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/#atomlib.AtomCell.try_get_column","title":"<code>try_get_column(name)</code>","text":"<p>Try to get a column from <code>self</code>, returning <code>None</code> if it doesn't exist.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def try_get_column(self, name: str) -&gt; t.Optional[polars.Series]:\n    \"\"\"Try to get a column from `self`, returning `None` if it doesn't exist.\"\"\"\n    try:\n        return self.get_column(name)\n    except polars.ColumnNotFoundError:\n        return None\n</code></pre>"},{"location":"api/#atomlib.AtomCell.bbox_atoms","title":"<code>bbox_atoms(frame=None)</code>","text":"<p>Return the bounding box of all the atoms in <code>self</code>, in the given coordinate frame.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def bbox_atoms(self, frame: t.Optional[CoordinateFrame] = None) -&gt; BBox3D:\n    \"\"\"Return the bounding box of all the atoms in ``self``, in the given coordinate frame.\"\"\"\n    return self.get_atoms(frame).bbox()\n</code></pre>"},{"location":"api/#atomlib.AtomCell.transform_atoms","title":"<code>transform_atoms(transform, selection=None, *, frame='local', transform_velocities=False)</code>","text":"<p>Transform the atoms in <code>self</code> by <code>transform</code>. If <code>selection</code> is given, only transform the atoms in <code>selection</code>.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def transform_atoms(self: HasAtomCellT, transform: IntoTransform3D, selection: t.Optional[AtomSelection] = None, *,\n                    frame: CoordinateFrame = 'local', transform_velocities: bool = False) -&gt; HasAtomCellT:\n    \"\"\"\n    Transform the atoms in `self` by `transform`.\n    If `selection` is given, only transform the atoms in `selection`.\n    \"\"\"\n    transform = self.change_transform(Transform3D.make(transform), self.get_frame(), frame)\n    return self.with_atoms(self.get_atoms(self.get_frame()).transform(transform, selection, transform_velocities=transform_velocities))\n</code></pre>"},{"location":"api/#atomlib.AtomCell.transform","title":"<code>transform(transform, frame='local')</code>","text":"Source code in <code>atomlib/atomcell.py</code> <pre><code>def transform(self: HasAtomCellT, transform: AffineTransform3D, frame: CoordinateFrame = 'local') -&gt; HasAtomCellT:\n    if isinstance(transform, Transform3D) and not isinstance(transform, AffineTransform3D):\n        raise ValueError(\"Non-affine transforms cannot change the box dimensions. Use 'transform_atoms' instead.\")\n    # TODO: cleanup once tests pass\n    # coordinate change the transform into atomic coordinates\n    new_cell = self.get_cell().transform_cell(transform, frame)\n    transform = self.get_cell().change_transform(transform, self.get_frame(), frame)\n    return self.with_atoms(self.get_atoms().transform(transform), self.get_frame()).with_cell(new_cell)\n</code></pre>"},{"location":"api/#atomlib.AtomCell.round_near_zero","title":"<code>round_near_zero(tol=1e-14, *, frame=None)</code>","text":"<p>Round atom position values near zero to zero.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef round_near_zero(self: HasAtomCellT, tol: float = 1e-14, *,\n                    frame: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n    \"\"\"\n    Round atom position values near zero to zero.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/#atomlib.AtomCell.crop_atoms","title":"<code>crop_atoms(x_min=-numpy.inf, x_max=numpy.inf, y_min=-numpy.inf, y_max=numpy.inf, z_min=-numpy.inf, z_max=numpy.inf, *, frame='local')</code>","text":"Source code in <code>atomlib/atomcell.py</code> <pre><code>def crop_atoms(self: HasAtomCellT, x_min: float = -numpy.inf, x_max: float = numpy.inf,\n               y_min: float = -numpy.inf, y_max: float = numpy.inf,\n               z_min: float = -numpy.inf, z_max: float = numpy.inf, *,\n               frame: CoordinateFrame = 'local') -&gt; HasAtomCellT:\n    atoms = self._transform_atoms_in_frame(frame, lambda atoms: atoms.crop_atoms(x_min, x_max, y_min, y_max, z_min, z_max))\n    return self.with_atoms(atoms)\n</code></pre>"},{"location":"api/#atomlib.AtomCell.deduplicate","title":"<code>deduplicate(tol=0.001, subset=('x', 'y', 'z', 'symbol'), keep='first', maintain_order=True)</code>","text":"<p>De-duplicate atoms in <code>self</code>. Atoms of the same <code>symbol</code> that are closer than <code>tolerance</code> to each other (by Euclidian distance) will be removed, leaving only the atom specified by <code>keep</code> (defaults to the first atom).</p> <p>If <code>subset</code> is specified, only those columns will be included while assessing duplicates. Floating point columns other than 'x', 'y', and 'z' will not by toleranced.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def deduplicate(self: HasAtomsT, tol: float = 1e-3, subset: t.Iterable[str] = ('x', 'y', 'z', 'symbol'),\n                keep: UniqueKeepStrategy = 'first', maintain_order: bool = True) -&gt; HasAtomsT:\n    \"\"\"\n    De-duplicate atoms in `self`. Atoms of the same `symbol` that are closer than `tolerance`\n    to each other (by Euclidian distance) will be removed, leaving only the atom specified by\n    `keep` (defaults to the first atom).\n\n    If `subset` is specified, only those columns will be included while assessing duplicates.\n    Floating point columns other than 'x', 'y', and 'z' will not by toleranced.\n    \"\"\"\n    import scipy.spatial\n\n    cols = set((subset,) if isinstance(subset, str) else subset)\n\n    indices = numpy.arange(len(self))\n\n    spatial_cols = cols.intersection(('x', 'y', 'z'))\n    cols -= spatial_cols\n    if len(spatial_cols) &gt; 0:\n        coords = self.select([_coord_expr(col).alias(col) for col in spatial_cols]).to_numpy()\n        tree = scipy.spatial.KDTree(coords)\n\n        # TODO This is a bad algorithm\n        while True:\n            changed = False\n            for (i, j) in tree.query_pairs(tol, 2.):\n                # whenever we encounter a pair, ensure their index matches\n                i_i, i_j = indices[[i, j]]\n                if i_i != i_j:\n                    indices[i] = indices[j] = min(i_i, i_j)\n                    changed = True\n            if not changed:\n                break\n\n        self = self.with_column(polars.Series('_unique_pts', indices))\n        cols.add('_unique_pts')\n\n    frame = self._get_frame().unique(subset=list(cols), keep=keep, maintain_order=maintain_order)\n    if len(spatial_cols) &gt; 0:\n        frame = frame.drop('_unique_pts')\n\n    return self.with_atoms(Atoms(frame, _unchecked=True))\n</code></pre>"},{"location":"api/#atomlib.AtomCell.with_bounds","title":"<code>with_bounds(cell_size=None, cell_origin=None)</code>","text":"<p>Return a periodic cell with the given orthogonal cell dimensions.</p> <p>If cell_size is not specified, it will be assumed (and may be incorrect).</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def with_bounds(self, cell_size: t.Optional[VecLike] = None, cell_origin: t.Optional[VecLike] = None) -&gt; 'AtomCell':\n    \"\"\"\n    Return a periodic cell with the given orthogonal cell dimensions.\n\n    If cell_size is not specified, it will be assumed (and may be incorrect).\n    \"\"\"\n    # TODO: test this\n    from .atomcell import AtomCell\n\n    if cell_size is None:\n        warnings.warn(\"Cell boundary unknown. Defaulting to cell BBox\")\n        cell_size = self.bbox().size\n        cell_origin = self.bbox().min\n\n    # TODO test this origin code\n    cell = Cell.from_unit_cell(cell_size)\n    if cell_origin is not None:\n        cell = cell.transform_cell(AffineTransform3D.translate(to_vec3(cell_origin)))\n\n    return AtomCell(self.get_atoms(), cell, frame='local')\n</code></pre>"},{"location":"api/#atomlib.AtomCell.coords","title":"<code>coords(selection=None, *, frame=None)</code>","text":"<p>Returns a <code>(N, 3)</code> ndarray of atom coordinates (dtype <code>numpy.float64</code>).</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_get\ndef coords(self, selection: t.Optional[AtomSelection] = None, *, frame: t.Optional[CoordinateFrame] = None) -&gt; NDArray[numpy.float64]:\n    \"\"\"Returns a `(N, 3)` ndarray of atom coordinates (dtype ``numpy.float64``).\"\"\"\n    ...\n</code></pre>"},{"location":"api/#atomlib.AtomCell.x","title":"<code>x()</code>","text":"Source code in <code>atomlib/atoms.py</code> <pre><code>def x(self) -&gt; polars.Expr:\n    return polars.col('coords').arr.get(0).alias('x')\n</code></pre>"},{"location":"api/#atomlib.AtomCell.y","title":"<code>y()</code>","text":"Source code in <code>atomlib/atoms.py</code> <pre><code>def y(self) -&gt; polars.Expr:\n    return polars.col('coords').arr.get(1).alias('y')\n</code></pre>"},{"location":"api/#atomlib.AtomCell.z","title":"<code>z()</code>","text":"Source code in <code>atomlib/atoms.py</code> <pre><code>def z(self) -&gt; polars.Expr:\n    return polars.col('coords').arr.get(2).alias('z')\n</code></pre>"},{"location":"api/#atomlib.AtomCell.velocities","title":"<code>velocities(selection=None, *, frame=None)</code>","text":"<p>Returns a <code>(N, 3)</code> ndarray of atom velocities (dtype <code>numpy.float64</code>).</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_get\ndef velocities(self, selection: t.Optional[AtomSelection] = None, *, frame: t.Optional[CoordinateFrame] = None) -&gt; t.Optional[NDArray[numpy.float64]]:\n    \"\"\"Returns a `(N, 3)` ndarray of atom velocities (dtype ``numpy.float64``).\"\"\"\n    ...\n</code></pre>"},{"location":"api/#atomlib.AtomCell.types","title":"<code>types()</code>","text":"<p>Returns a <code>Series</code> of atom types (dtype <code>polars.Int32</code>).</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def types(self) -&gt; t.Optional[polars.Series]:\n    \"\"\"\n    Returns a [`Series`][polars.Series] of atom types (dtype [`polars.Int32`][polars.Int32]).\n\n    [polars.Series]: https://docs.pola.rs/py-polars/html/reference/series/index.html\n    \"\"\"\n    return self.try_get_column('type')\n</code></pre>"},{"location":"api/#atomlib.AtomCell.masses","title":"<code>masses()</code>","text":"<p>Returns a <code>Series</code> of atom masses (dtype <code>polars.Float32</code>).</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def masses(self) -&gt; t.Optional[polars.Series]:\n    \"\"\"\n    Returns a [`Series`][polars.Series] of atom masses (dtype [`polars.Float32`][polars.Float32]).\n\n    [polars.Series]: https://docs.pola.rs/py-polars/html/reference/series/index.html\n    \"\"\"\n    return self.try_get_column('mass')\n</code></pre>"},{"location":"api/#atomlib.AtomCell.add_atom","title":"<code>add_atom(elem, /, x, y=None, z=None, *, frame=None, **kwargs)</code>","text":"<p>Return a copy of <code>self</code> with an extra atom.</p> <p>By default, all extra columns present in <code>self</code> must be specified as <code>**kwargs</code>.</p> <p>Try to avoid calling this in a loop (Use meth:<code>concat</code> instead).</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef add_atom(self: HasAtomCellT, elem: t.Union[int, str], /,  # type: ignore (spurious)\n             x: t.Union[ArrayLike, float],\n             y: t.Optional[float] = None,\n             z: t.Optional[float] = None, *,\n             frame: t.Optional[CoordinateFrame] = None,\n             **kwargs: t.Any) -&gt; HasAtomCellT:\n    \"\"\"\n    Return a copy of ``self`` with an extra atom.\n\n    By default, all extra columns present in ``self`` must be specified as ``**kwargs``.\n\n    Try to avoid calling this in a loop (Use :py:meth:`concat` instead).\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/#atomlib.AtomCell.pos","title":"<code>pos(x=None, y=None, z=None, *, tol=1e-06, **kwargs)</code>","text":"<p>Select all atoms at a given position.</p> <p>Formally, returns all atoms within a cube of radius <code>tol</code> centered at <code>(x,y,z)</code>, exclusive of the cube's surface.</p> <p>Additional parameters given as <code>kwargs</code> will be checked as additional parameters (with strict equality).</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def pos(self,\n        x: t.Union[t.Sequence[t.Optional[float]], float, None] = None,\n        y: t.Optional[float] = None, z: t.Optional[float] = None, *,\n        tol: float = 1e-6, **kwargs: t.Any) -&gt; polars.Expr:\n    \"\"\"\n    Select all atoms at a given position.\n\n    Formally, returns all atoms within a cube of radius ``tol``\n    centered at ``(x,y,z)``, exclusive of the cube's surface.\n\n    Additional parameters given as ``kwargs`` will be checked\n    as additional parameters (with strict equality).\n    \"\"\"\n\n    if isinstance(x, t.Sequence):\n        (x, y, z) = x\n\n    tol = abs(float(tol))\n    selection = polars.lit(True)\n    if x is not None:\n        selection &amp;= self.x().is_between(x - tol, x + tol, closed='none')\n    if y is not None:\n        selection &amp;= self.y().is_between(y - tol, y + tol, closed='none')\n    if z is not None:\n        selection &amp;= self.z().is_between(z - tol, z + tol, closed='none')\n    for (col, val) in kwargs.items():\n        selection &amp;= (polars.col(col) == val)\n\n    return selection\n</code></pre>"},{"location":"api/#atomlib.AtomCell.with_index","title":"<code>with_index(index=None, *, frame=None)</code>","text":"<p>Returns <code>self</code> with a row index added in column 'i' (dtype polars.Int64). If <code>index</code> is not specified, defaults to an existing index or a new index.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef with_index(self: HasAtomCellT, index: t.Optional[AtomValues] = None, *,\n               frame: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n    \"\"\"\n    Returns ``self`` with a row index added in column 'i' (dtype polars.Int64).\n    If ``index`` is not specified, defaults to an existing index or a new index.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/#atomlib.AtomCell.with_wobble","title":"<code>with_wobble(wobble=None, *, frame=None)</code>","text":"<p>Return <code>self</code> with the given displacements in column 'wobble' (dtype polars.Float64). If <code>wobble</code> is not specified, defaults to the already-existing wobbles or 0.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef with_wobble(self: HasAtomCellT, wobble: t.Optional[AtomValues] = None, *,\n                frame: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n    \"\"\"\n    Return ``self`` with the given displacements in column 'wobble' (dtype polars.Float64).\n    If ``wobble`` is not specified, defaults to the already-existing wobbles or 0.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/#atomlib.AtomCell.with_occupancy","title":"<code>with_occupancy(frac_occupancy=None, *, frame=None)</code>","text":"<p>Return self with the given fractional occupancies. If <code>frac_occupancy</code> is not specified, defaults to the already-existing occupancies or 1.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef with_occupancy(self: HasAtomCellT, frac_occupancy: t.Optional[AtomValues] = None, *,\n                   frame: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n    \"\"\"\n    Return self with the given fractional occupancies. If ``frac_occupancy`` is not specified,\n    defaults to the already-existing occupancies or 1.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/#atomlib.AtomCell.apply_wobble","title":"<code>apply_wobble(rng=None, frame=None)</code>","text":"<p>Displace the atoms in <code>self</code> by the amount in the <code>wobble</code> column. <code>wobble</code> is interpretated as a mean-squared displacement, which is distributed equally over each axis.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef apply_wobble(self: HasAtomCellT, rng: t.Union[numpy.random.Generator, int, None] = None,\n                 frame: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n    \"\"\"\n    Displace the atoms in ``self`` by the amount in the `wobble` column.\n    ``wobble`` is interpretated as a mean-squared displacement, which is distributed\n    equally over each axis.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/#atomlib.AtomCell.apply_occupancy","title":"<code>apply_occupancy(rng=None)</code>","text":"<p>For each atom in <code>self</code>, use its <code>frac_occupancy</code> to randomly decide whether to remove it.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def apply_occupancy(self: HasAtomsT, rng: t.Union[numpy.random.Generator, int, None] = None) -&gt; HasAtomsT:\n    \"\"\"\n    For each atom in `self`, use its `frac_occupancy` to randomly decide whether to remove it.\n    \"\"\"\n    if 'frac_occupancy' not in self.columns:\n        return self\n    rng = numpy.random.default_rng(seed=rng)\n\n    frac = self.select('frac_occupancy').to_series().to_numpy()\n    choice = rng.binomial(1, frac).astype(numpy.bool_)\n    return self.filter(polars.lit(choice))\n</code></pre>"},{"location":"api/#atomlib.AtomCell.with_type","title":"<code>with_type(types=None, *, frame=None)</code>","text":"<p>Return <code>self</code> with the given atom types in column 'type'. If <code>types</code> is not specified, use the already existing types or auto-assign them.</p> <p>When auto-assigning, each symbol is given a unique value, case-sensitive. Values are assigned from lowest atomic number to highest. For instance: <code>[\"Ag+\", \"Na\", \"H\", \"Ag\"]</code> =&gt; <code>[3, 11, 1, 2]</code></p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef with_type(self: HasAtomCellT, types: t.Optional[AtomValues] = None, *,\n              frame: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n    \"\"\"\n    Return ``self`` with the given atom types in column 'type'.\n    If ``types`` is not specified, use the already existing types or auto-assign them.\n\n    When auto-assigning, each symbol is given a unique value, case-sensitive.\n    Values are assigned from lowest atomic number to highest.\n    For instance: ``[\"Ag+\", \"Na\", \"H\", \"Ag\"]`` =&gt; ``[3, 11, 1, 2]``\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/#atomlib.AtomCell.with_mass","title":"<code>with_mass(mass=None, *, frame=None)</code>","text":"<p>Return <code>self</code> with the given atom masses in column 'mass'. If <code>mass</code> is not specified, use the already existing masses or auto-assign them.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef with_mass(self: HasAtomCellT, mass: t.Optional[ArrayLike] = None, *,\n              frame: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n    \"\"\"\n    Return ``self`` with the given atom masses in column 'mass'.\n    If ``mass`` is not specified, use the already existing masses or auto-assign them.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/#atomlib.AtomCell.with_symbol","title":"<code>with_symbol(symbols, selection=None, *, frame=None)</code>","text":"<p>Return <code>self</code> with the given atomic symbols.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef with_symbol(self: HasAtomCellT, symbols: ArrayLike, selection: t.Optional[AtomSelection] = None, *,\n                frame: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n    \"\"\"\n    Return ``self`` with the given atomic symbols.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/#atomlib.AtomCell.with_coords","title":"<code>with_coords(pts, selection=None, *, frame=None)</code>","text":"<p>Return <code>self</code> replaced with the given atomic positions.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef with_coords(self: HasAtomCellT, pts: ArrayLike, selection: t.Optional[AtomSelection] = None, *,\n                frame: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n    \"\"\"\n    Return ``self`` replaced with the given atomic positions.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/#atomlib.AtomCell.with_velocity","title":"<code>with_velocity(pts=None, selection=None, *, frame=None)</code>","text":"<p>Return <code>self</code> replaced with the given atomic velocities. If <code>pts</code> is not specified, use the already existing velocities or zero.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef with_velocity(self: HasAtomCellT, pts: t.Optional[ArrayLike] = None,\n                  selection: t.Optional[AtomSelection] = None, *,\n                  frame: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n    \"\"\"\n    Return ``self`` replaced with the given atomic velocities.\n    If ``pts`` is not specified, use the already existing velocities or zero.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/#atomlib.AtomCell.get_atomcell","title":"<code>get_atomcell()</code>","text":"Source code in <code>atomlib/atomcell.py</code> <pre><code>def get_atomcell(self) -&gt; AtomCell:\n    frame = self.get_frame()\n    return AtomCell(self.get_atoms(frame), self.get_cell(), frame=frame, keep_frame=True)\n</code></pre>"},{"location":"api/#atomlib.AtomCell.to_frame","title":"<code>to_frame(frame)</code>","text":"<p>Convert the stored Atoms to the given coordinate frame.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def to_frame(self: HasAtomCellT, frame: CoordinateFrame) -&gt; HasAtomCellT:\n    \"\"\"Convert the stored Atoms to the given coordinate frame.\"\"\"\n    return self.with_atoms(self.get_atoms(frame), frame)\n</code></pre>"},{"location":"api/#atomlib.AtomCell.crop_to_box","title":"<code>crop_to_box(eps=1e-05)</code>","text":"Source code in <code>atomlib/atomcell.py</code> <pre><code>def crop_to_box(self: HasAtomCellT, eps: float = 1e-5) -&gt; HasAtomCellT:\n    atoms = self._transform_atoms_in_frame('cell_box', lambda atoms: atoms.crop_atoms(*([-eps, 1-eps]*3)))\n    return self.with_atoms(atoms)\n</code></pre>"},{"location":"api/#atomlib.AtomCell.wrap","title":"<code>wrap(eps=1e-05)</code>","text":"<p>Wrap atoms around the cell boundaries.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def wrap(self: HasAtomCellT, eps: float = 1e-5) -&gt; HasAtomCellT:\n    \"\"\"Wrap atoms around the cell boundaries.\"\"\"\n    return self.with_atoms(self._transform_atoms_in_frame('cell_box', lambda a: a._wrap(eps)))\n</code></pre>"},{"location":"api/#atomlib.AtomCell.repeat_to","title":"<code>repeat_to(size, crop=False)</code>","text":"<p>Repeat the cell so it is at least <code>size</code> along the crystal's axes.</p> <p>If <code>crop</code>, then crop the cell to exactly <code>size</code>. This may break periodicity. <code>crop</code> may be a vector, in which case you can specify cropping only along some axes.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def repeat_to(self: HasAtomCellT, size: VecLike, crop: t.Union[bool, t.Sequence[bool]] = False) -&gt; HasAtomCellT:\n    \"\"\"\n    Repeat the cell so it is at least ``size`` along the crystal's axes.\n\n    If ``crop``, then crop the cell to exactly ``size``. This may break periodicity.\n    ``crop`` may be a vector, in which case you can specify cropping only along some axes.\n    \"\"\"\n    size = to_vec3(size)\n    cell_size = self.cell_size * self.n_cells\n    repeat = numpy.maximum(numpy.ceil(size / cell_size).astype(int), 1)\n    atom_cell = self.repeat(repeat)\n\n    crop_v = to_vec3(crop, dtype=numpy.bool_)\n    if numpy.any(crop_v):\n        crop_x, crop_y, crop_z = crop_v\n        return atom_cell.crop(\n            x_max = size[0] if crop_x else numpy.inf,\n            y_max = size[1] if crop_y else numpy.inf,\n            z_max = size[2] if crop_z else numpy.inf,\n            frame='cell'\n        )\n\n    return atom_cell\n</code></pre>"},{"location":"api/#atomlib.AtomCell.repeat_x","title":"<code>repeat_x(n)</code>","text":"<p>Tile the cell in the x axis.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def repeat_x(self: HasAtomCellT, n: int) -&gt; HasAtomCellT:\n    \"\"\"Tile the cell in the x axis.\"\"\"\n    return self.repeat((n, 1, 1))\n</code></pre>"},{"location":"api/#atomlib.AtomCell.repeat_y","title":"<code>repeat_y(n)</code>","text":"<p>Tile the cell in the y axis.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def repeat_y(self: HasAtomCellT, n: int) -&gt; HasAtomCellT:\n    \"\"\"Tile the cell in the y axis.\"\"\"\n    return self.repeat((1, n, 1))\n</code></pre>"},{"location":"api/#atomlib.AtomCell.repeat_z","title":"<code>repeat_z(n)</code>","text":"<p>Tile the cell in the z axis.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def repeat_z(self: HasAtomCellT, n: int) -&gt; HasAtomCellT:\n    \"\"\"Tile the cell in the z axis.\"\"\"\n    return self.repeat((1, 1, n))\n</code></pre>"},{"location":"api/#atomlib.AtomCell.repeat_to_x","title":"<code>repeat_to_x(size, crop=False)</code>","text":"<p>Repeat the cell so it is at least size <code>size</code> along the x axis.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def repeat_to_x(self: HasAtomCellT, size: float, crop: bool = False) -&gt; HasAtomCellT:\n    \"\"\"Repeat the cell so it is at least size ``size`` along the x axis.\"\"\"\n    return self.repeat_to([size, 0., 0.], [crop, False, False])\n</code></pre>"},{"location":"api/#atomlib.AtomCell.repeat_to_y","title":"<code>repeat_to_y(size, crop=False)</code>","text":"<p>Repeat the cell so it is at least size <code>size</code> along the y axis.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def repeat_to_y(self: HasAtomCellT, size: float, crop: bool = False) -&gt; HasAtomCellT:\n    \"\"\"Repeat the cell so it is at least size ``size`` along the y axis.\"\"\"\n    return self.repeat_to([0., size, 0.], [False, crop, False])\n</code></pre>"},{"location":"api/#atomlib.AtomCell.repeat_to_z","title":"<code>repeat_to_z(size, crop=False)</code>","text":"<p>Repeat the cell so it is at least size <code>size</code> along the z axis.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def repeat_to_z(self: HasAtomCellT, size: float, crop: bool = False) -&gt; HasAtomCellT:\n    \"\"\"Repeat the cell so it is at least size ``size`` along the z axis.\"\"\"\n    return self.repeat_to([0., 0., size], [False, False, crop])\n</code></pre>"},{"location":"api/#atomlib.AtomCell.repeat_to_aspect","title":"<code>repeat_to_aspect(plane='xy', *, aspect=1.0, min_size=None, max_size=None)</code>","text":"<p>Repeat to optimize the aspect ratio in <code>plane</code>, while staying above <code>min_size</code> and under <code>max_size</code>.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def repeat_to_aspect(self: HasAtomCellT, plane: t.Literal['xy', 'xz', 'yz'] = 'xy', *,\n                     aspect: float = 1., min_size: t.Optional[VecLike] = None,\n                     max_size: t.Optional[VecLike] = None) -&gt; HasAtomCellT:\n    \"\"\"\n    Repeat to optimize the aspect ratio in ``plane``,\n    while staying above ``min_size`` and under ``max_size``.\n    \"\"\"\n    if min_size is None:\n        min_n = numpy.array([1, 1, 1], numpy.int_)\n    else:\n        min_n = numpy.maximum(numpy.ceil(to_vec3(min_size) / self.box_size), 1).astype(numpy.int_)\n\n    if max_size is None:\n        max_n = 3 * min_n\n    else:\n        max_n = numpy.maximum(numpy.floor(to_vec3(max_size) / self.box_size), 1).astype(numpy.int_)\n\n    if plane == 'xy':\n        indices = [0, 1]\n    elif plane == 'xz':\n        indices = [0, 2]\n    elif plane == 'yz':\n        indices = [1, 2]\n    else:\n        raise ValueError(f\"Invalid plane '{plane}'. Exepcted 'xy', 'xz', 'or 'yz'.\")\n\n    na = numpy.arange(min_n[indices[0]], max_n[indices[0]])\n    nb = numpy.arange(min_n[indices[1]], max_n[indices[1]])\n    (na, nb) = numpy.meshgrid(na, nb)\n\n    aspects = na * self.box_size[indices[0]] / (nb * self.box_size[indices[1]])\n    # cost function: log(aspect)^2  (so cost(0.5) == cost(2))\n    min_i = numpy.argmin(numpy.log(aspects / aspect)**2)\n    repeat = numpy.array([1, 1, 1], numpy.int_)\n    repeat[indices] = na.flatten()[min_i], nb.flatten()[min_i]\n    return self.repeat(repeat)\n</code></pre>"},{"location":"api/#atomlib.AtomCell.periodic_duplicate","title":"<code>periodic_duplicate(eps=1e-05)</code>","text":"<p>Add duplicate copies of atoms near periodic boundaries.</p> <p>For instance, an atom at a corner will be duplicated into 8 copies. This is mostly only useful for visualization.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def periodic_duplicate(self: HasAtomCellT, eps: float = 1e-5) -&gt; HasAtomCellT:\n    \"\"\"\n    Add duplicate copies of atoms near periodic boundaries.\n\n    For instance, an atom at a corner will be duplicated into 8 copies.\n    This is mostly only useful for visualization.\n    \"\"\"\n    frame_save = self.get_frame()\n    self = self.to_frame('cell_box').wrap(eps=eps)\n\n    for i in range(3):\n        self = self.concat((self,\n            self.filter(polars.col('coords').arr.get(i).abs() &lt;= eps, frame='cell_box')\n                .transform_atoms(AffineTransform3D.translate([1. if i == j else 0. for j in range(3)]), frame='cell_box')\n        ))\n\n    return self.to_frame(frame_save)\n</code></pre>"},{"location":"api/#atomlib.AtomCell.read","title":"<code>read(path, ty=None)</code>  <code>classmethod</code>","text":"<p>Read a structure from a file.</p> <p>Supported types can be found in the io module. If no <code>ty</code> is specified, it is inferred from the file's extension.</p> Source code in <code>atomlib/mixins.py</code> <pre><code>@classmethod\ndef read(cls: t.Type[HasAtomsT], path: FileOrPath, ty: t.Optional[FileType] = None) -&gt; HasAtomsT:\n    \"\"\"\n    Read a structure from a file.\n\n    Supported types can be found in the [io][atomlib.io] module.\n    If no `ty` is specified, it is inferred from the file's extension.\n    \"\"\"\n    from .io import read\n    return _cast_atoms(read(path, ty), cls)  # type: ignore\n</code></pre>"},{"location":"api/#atomlib.AtomCell.read_cif","title":"<code>read_cif(f, block=None)</code>  <code>classmethod</code>","text":"<p>Read a structure from a CIF file.</p> <p>If <code>block</code> is specified, read data from the given block of the CIF file (index or name).</p> Source code in <code>atomlib/mixins.py</code> <pre><code>@classmethod\ndef read_cif(cls: t.Type[HasAtomsT], f: t.Union[FileOrPath, CIF, CIFDataBlock], block: t.Union[int, str, None] = None) -&gt; HasAtomsT:\n    \"\"\"\n    Read a structure from a CIF file.\n\n    If `block` is specified, read data from the given block of the CIF file (index or name).\n    \"\"\"\n    from .io import read_cif\n    return _cast_atoms(read_cif(f, block), cls)\n</code></pre>"},{"location":"api/#atomlib.AtomCell.read_xyz","title":"<code>read_xyz(f)</code>  <code>classmethod</code>","text":"<p>Read a structure from an XYZ file.</p> Source code in <code>atomlib/mixins.py</code> <pre><code>@classmethod\ndef read_xyz(cls: t.Type[HasAtomsT], f: t.Union[FileOrPath, XYZ]) -&gt; HasAtomsT:\n    \"\"\"Read a structure from an XYZ file.\"\"\"\n    from .io import read_xyz\n    return _cast_atoms(read_xyz(f), cls)\n</code></pre>"},{"location":"api/#atomlib.AtomCell.read_xsf","title":"<code>read_xsf(f)</code>  <code>classmethod</code>","text":"<p>Read a structure from an XSF file.</p> Source code in <code>atomlib/mixins.py</code> <pre><code>@classmethod\ndef read_xsf(cls: t.Type[HasAtomsT], f: t.Union[FileOrPath, XSF]) -&gt; HasAtomsT:\n    \"\"\"Read a structure from an XSF file.\"\"\"\n    from .io import read_xsf\n    return _cast_atoms(read_xsf(f), cls)\n</code></pre>"},{"location":"api/#atomlib.AtomCell.read_cfg","title":"<code>read_cfg(f)</code>  <code>classmethod</code>","text":"<p>Read a structure from a CFG file.</p> Source code in <code>atomlib/mixins.py</code> <pre><code>@classmethod\ndef read_cfg(cls: t.Type[HasAtomsT], f: t.Union[FileOrPath, CFG]) -&gt; HasAtomsT:\n    \"\"\"Read a structure from a CFG file.\"\"\"\n    from .io import read_cfg\n    return _cast_atoms(read_cfg(f), cls)\n</code></pre>"},{"location":"api/#atomlib.AtomCell.read_lmp","title":"<code>read_lmp(f, type_map=None)</code>  <code>classmethod</code>","text":"<p>Read a structure from a LAAMPS data file.</p> Source code in <code>atomlib/mixins.py</code> <pre><code>@classmethod\ndef read_lmp(cls: t.Type[HasAtomsT], f: t.Union[FileOrPath, LMP], type_map: t.Optional[t.Dict[int, t.Union[str, int]]] = None) -&gt; HasAtomsT:\n    \"\"\"Read a structure from a LAAMPS data file.\"\"\"\n    from .io import read_lmp\n    return _cast_atoms(read_lmp(f, type_map=type_map), cls)\n</code></pre>"},{"location":"api/#atomlib.AtomCell.write_cif","title":"<code>write_cif(f)</code>","text":"Source code in <code>atomlib/mixins.py</code> <pre><code>def write_cif(self, f: FileOrPath):\n    from .io import write_cif\n    write_cif(self, f)\n</code></pre>"},{"location":"api/#atomlib.AtomCell.write_xyz","title":"<code>write_xyz(f, fmt='exyz')</code>","text":"Source code in <code>atomlib/mixins.py</code> <pre><code>def write_xyz(self, f: FileOrPath, fmt: XYZFormat = 'exyz'):\n    from .io import write_xyz\n    write_xyz(self, f, fmt)\n</code></pre>"},{"location":"api/#atomlib.AtomCell.write_xsf","title":"<code>write_xsf(f)</code>","text":"Source code in <code>atomlib/mixins.py</code> <pre><code>def write_xsf(self, f: FileOrPath):\n    from .io import write_xsf\n    write_xsf(self, f)\n</code></pre>"},{"location":"api/#atomlib.AtomCell.write_cfg","title":"<code>write_cfg(f)</code>","text":"Source code in <code>atomlib/mixins.py</code> <pre><code>def write_cfg(self, f: FileOrPath):\n    from .io import write_cfg\n    write_cfg(self, f)\n</code></pre>"},{"location":"api/#atomlib.AtomCell.write_lmp","title":"<code>write_lmp(f)</code>","text":"Source code in <code>atomlib/mixins.py</code> <pre><code>def write_lmp(self, f: FileOrPath):\n    from .io import write_lmp\n    write_lmp(self, f)\n</code></pre>"},{"location":"api/#atomlib.AtomCell.write","title":"<code>write(path, ty=None)</code>","text":"<p>Write this structure to a file.</p> <p>A file type may be specified using <code>ty</code>. If no <code>ty</code> is specified, it is inferred from the path's extension.</p> Source code in <code>atomlib/mixins.py</code> <pre><code>def write(self, path: FileOrPath, ty: t.Optional[FileType] = None):\n    \"\"\"\n    Write this structure to a file.\n\n    A file type may be specified using `ty`.\n    If no `ty` is specified, it is inferred from the path's extension.\n    \"\"\"\n    from .io import write\n    write(self, path, ty)  # type: ignore\n</code></pre>"},{"location":"api/#atomlib.AtomCell.write_mslice","title":"<code>write_mslice(f, template=None, *, slice_thickness=None, scan_points=None, scan_extent=None, noise_sigma=None, conv_angle=None, energy=None, defocus=None, tilt=None, tds=None, n_cells=None)</code>","text":"<p>Write a structure to an mslice file.</p> <p><code>template</code> may be a file, path, or ElementTree containing an existing mslice file. Its structure will be modified to make the final output. If not specified, a default template will be used.</p> <p>Additional options modify simulation properties. If an option is not specified, the template's properties are used.</p> Source code in <code>atomlib/mixins.py</code> <pre><code>def write_mslice(self, f: BinaryFileOrPath, template: t.Optional[MSliceFile] = None, *,\n             slice_thickness: t.Optional[float] = None,  # angstrom\n             scan_points: t.Optional[ArrayLike] = None,\n             scan_extent: t.Optional[ArrayLike] = None,\n             noise_sigma: t.Optional[float] = None,  # angstrom\n             conv_angle: t.Optional[float] = None,  # mrad\n             energy: t.Optional[float] = None,  # keV\n             defocus: t.Optional[float] = None,  # angstrom\n             tilt: t.Optional[t.Tuple[float, float]] = None,  # (mrad, mrad)\n             tds: t.Optional[bool] = None,\n             n_cells: t.Optional[ArrayLike] = None):\n    \"\"\"\n    Write a structure to an mslice file.\n\n    `template` may be a file, path, or ElementTree containing an existing mslice file.\n    Its structure will be modified to make the final output. If not specified, a default\n    template will be used.\n\n    Additional options modify simulation properties. If an option is not specified, the\n    template's properties are used.\n    \"\"\"\n    from .io import write_mslice\n    return write_mslice(self, f, template, slice_thickness=slice_thickness,\n                        scan_points=scan_points, scan_extent=scan_extent,\n                        conv_angle=conv_angle, energy=energy, defocus=defocus,\n                        noise_sigma=noise_sigma, tilt=tilt, tds=tds, n_cells=n_cells)\n</code></pre>"},{"location":"api/#atomlib.AtomCell.write_qe","title":"<code>write_qe(f, pseudo=None)</code>","text":"Source code in <code>atomlib/mixins.py</code> <pre><code>def write_qe(self, f: FileOrPath, pseudo: t.Optional[t.Mapping[str, str]] = None):\n    from .io import write_qe\n    write_qe(self, f, pseudo)\n</code></pre>"},{"location":"api/#atomlib.AtomCell.get_cell","title":"<code>get_cell()</code>","text":"Source code in <code>atomlib/atomcell.py</code> <pre><code>def get_cell(self) -&gt; Cell:\n    return self.cell\n</code></pre>"},{"location":"api/#atomlib.AtomCell.with_cell","title":"<code>with_cell(cell)</code>","text":"Source code in <code>atomlib/atomcell.py</code> <pre><code>def with_cell(self: AtomCellT, cell: Cell) -&gt; AtomCellT:\n    return self.__class__(self.atoms, cell, frame=self.frame, keep_frame=True)\n</code></pre>"},{"location":"api/#atomlib.AtomCell.get_atoms","title":"<code>get_atoms(frame=None)</code>","text":"<p>Get atoms contained in <code>self</code>, in the given coordinate frame.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def get_atoms(self, frame: t.Optional[CoordinateFrame] = None) -&gt; Atoms:\n    \"\"\"Get atoms contained in ``self``, in the given coordinate frame.\"\"\"\n\n    if frame is None or frame == self.get_frame():\n        return self.atoms\n    return self.atoms.transform(self.get_transform(frame, self.get_frame()))\n</code></pre>"},{"location":"api/#atomlib.AtomCell.with_atoms","title":"<code>with_atoms(atoms, frame=None)</code>","text":"Source code in <code>atomlib/atomcell.py</code> <pre><code>def with_atoms(self: AtomCellT, atoms: HasAtoms, frame: t.Optional[CoordinateFrame] = None) -&gt; AtomCellT:\n    frame = frame if frame is not None else self.frame\n    return self.__class__(atoms.get_atoms(), cell=self.cell, frame=frame, keep_frame=True)\n</code></pre>"},{"location":"api/#atomlib.AtomCell.get_frame","title":"<code>get_frame()</code>","text":"<p>Get the coordinate frame atoms are stored in.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def get_frame(self) -&gt; CoordinateFrame:\n    \"\"\"Get the coordinate frame atoms are stored in.\"\"\"\n    return self.frame\n</code></pre>"},{"location":"api/#atomlib.AtomCell.from_ortho","title":"<code>from_ortho(atoms, ortho, *, n_cells=None, frame='local', keep_frame=False)</code>  <code>classmethod</code>","text":"<p>Make an atom cell given a list of atoms and an orthogonalization matrix. Atoms are assumed to be in the coordinate system <code>frame</code>.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@classmethod\ndef from_ortho(cls, atoms: IntoAtoms, ortho: LinearTransform3D, *,\n               n_cells: t.Optional[VecLike] = None,\n               frame: CoordinateFrame = 'local',\n               keep_frame: bool = False):\n    \"\"\"\n    Make an atom cell given a list of atoms and an orthogonalization matrix.\n    Atoms are assumed to be in the coordinate system ``frame``.\n    \"\"\"\n    cell = Cell.from_ortho(ortho, n_cells)\n    return cls(atoms, cell, frame=frame, keep_frame=keep_frame)\n</code></pre>"},{"location":"api/#atomlib.AtomCell.from_unit_cell","title":"<code>from_unit_cell(atoms, cell_size, cell_angle=None, *, n_cells=None, frame='local', keep_frame=False)</code>  <code>classmethod</code>","text":"<p>Make a cell given a list of atoms and unit cell parameters. Atoms are assumed to be in the coordinate system <code>frame</code>.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@classmethod\ndef from_unit_cell(cls, atoms: IntoAtoms, cell_size: VecLike,\n                   cell_angle: t.Optional[VecLike] = None, *,\n                   n_cells: t.Optional[VecLike] = None,\n                   frame: CoordinateFrame = 'local',\n                   keep_frame: bool = False):\n    \"\"\"\n    Make a cell given a list of atoms and unit cell parameters.\n    Atoms are assumed to be in the coordinate system ``frame``.\n    \"\"\"\n    cell = Cell.from_unit_cell(cell_size, cell_angle, n_cells=n_cells)\n    return cls(atoms, cell, frame=frame, keep_frame=keep_frame)\n</code></pre>"},{"location":"api/#atomlib.AtomCell.orthogonalize","title":"<code>orthogonalize()</code>","text":"Source code in <code>atomlib/atomcell.py</code> <pre><code>def orthogonalize(self) -&gt; OrthoCell:\n    if self.is_orthogonal():\n        return OrthoCell(self.atoms, self.cell, frame=self.frame)\n    raise NotImplementedError()\n</code></pre>"},{"location":"api/#atomlib.AtomCell.clone","title":"<code>clone()</code>","text":"<p>Make a deep copy of <code>self</code>.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def clone(self: AtomCellT) -&gt; AtomCellT:\n    \"\"\"Make a deep copy of `self`.\"\"\"\n    return self.__class__(**{field.name: copy.deepcopy(getattr(self, field.name)) for field in fields(self)})\n</code></pre>"},{"location":"api/#atomlib.AtomCell.assert_equal","title":"<code>assert_equal(other)</code>","text":"<p>Assert this structure is equal to</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def assert_equal(self, other: t.Any):\n    \"\"\"Assert this structure is equal to \"\"\"\n    assert isinstance(other, AtomCell)\n    self.cell.assert_equal(other.cell)\n    self.get_atoms('local').assert_equal(other.get_atoms('local'))\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell","title":"<code>HasAtomCell</code>","text":"<p>             Bases: <code>HasAtoms</code>, <code>HasCell</code>, <code>ABC</code></p> Source code in <code>atomlib/atomcell.py</code> <pre><code>class HasAtomCell(HasAtoms, HasCell, abc.ABC):\n    @abc.abstractmethod\n    def get_frame(self) -&gt; CoordinateFrame:\n        \"\"\"Get the coordinate frame atoms are stored in.\"\"\"\n        ...\n\n    @abc.abstractmethod\n    def with_atoms(self: HasAtomCellT, atoms: HasAtoms, frame: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n        \"\"\"\n        Replace the atoms in ``self``. If no coordinate frame is specified, keep the coordinate frame unchanged.\n        \"\"\"\n        ...\n\n    def with_cell(self: HasAtomCellT, cell: Cell) -&gt; HasAtomCellT:\n        \"\"\"\n        Replace the cell in ``self``, without touching the atomic coordinates.\n        \"\"\"\n        return self.to_frame('local').with_cell(cell)\n\n    def get_atomcell(self) -&gt; AtomCell:\n        frame = self.get_frame()\n        return AtomCell(self.get_atoms(frame), self.get_cell(), frame=frame, keep_frame=True)\n\n    @abc.abstractmethod\n    def get_atoms(self, frame: t.Optional[CoordinateFrame] = None) -&gt; Atoms:\n        \"\"\"Get atoms contained in ``self``, in the given coordinate frame.\"\"\"\n        ...\n\n    def bbox_atoms(self, frame: t.Optional[CoordinateFrame] = None) -&gt; BBox3D:\n        \"\"\"Return the bounding box of all the atoms in ``self``, in the given coordinate frame.\"\"\"\n        return self.get_atoms(frame).bbox()\n\n    def bbox(self, frame: CoordinateFrame = 'local') -&gt; BBox3D:\n        \"\"\"\n        Return the combined bounding box of the cell and atoms in the given coordinate system.\n        To get the cell or atoms bounding box only, use :py:meth:`bbox_cell` or :py:meth:`bbox_atoms`.\n        \"\"\"\n        return self.bbox_atoms(frame) | self.bbox_cell(frame)\n\n    # transformation\n\n    def _transform_atoms_in_frame(self, frame: t.Optional[CoordinateFrame], f: t.Callable[[Atoms], Atoms]) -&gt; Atoms:\n        # ugly code\n        if frame is None or frame == self.get_frame():\n            return f(self.get_atoms())\n        return f(self.get_atoms(frame)).transform(self.get_transform(self.get_frame(), frame))\n\n    def to_frame(self: HasAtomCellT, frame: CoordinateFrame) -&gt; HasAtomCellT:\n        \"\"\"Convert the stored Atoms to the given coordinate frame.\"\"\"\n        return self.with_atoms(self.get_atoms(frame), frame)\n\n    def transform_atoms(self: HasAtomCellT, transform: IntoTransform3D, selection: t.Optional[AtomSelection] = None, *,\n                        frame: CoordinateFrame = 'local', transform_velocities: bool = False) -&gt; HasAtomCellT:\n        \"\"\"\n        Transform the atoms in `self` by `transform`.\n        If `selection` is given, only transform the atoms in `selection`.\n        \"\"\"\n        transform = self.change_transform(Transform3D.make(transform), self.get_frame(), frame)\n        return self.with_atoms(self.get_atoms(self.get_frame()).transform(transform, selection, transform_velocities=transform_velocities))\n\n    def transform_cell(self: HasAtomCellT, transform: AffineTransform3D, frame: CoordinateFrame = 'local') -&gt; HasAtomCellT:\n        \"\"\"\n        Apply the given transform to the unit cell, without changing atom positions.\n        The transform is applied in coordinate frame 'frame'.\n        \"\"\"\n        return self.with_cell(self.get_cell().transform_cell(transform, frame=frame))\n\n    def transform(self: HasAtomCellT, transform: AffineTransform3D, frame: CoordinateFrame = 'local') -&gt; HasAtomCellT:\n        if isinstance(transform, Transform3D) and not isinstance(transform, AffineTransform3D):\n            raise ValueError(\"Non-affine transforms cannot change the box dimensions. Use 'transform_atoms' instead.\")\n        # TODO: cleanup once tests pass\n        # coordinate change the transform into atomic coordinates\n        new_cell = self.get_cell().transform_cell(transform, frame)\n        transform = self.get_cell().change_transform(transform, self.get_frame(), frame)\n        return self.with_atoms(self.get_atoms().transform(transform), self.get_frame()).with_cell(new_cell)\n\n    # crop methods\n\n    def crop(self: HasAtomCellT, x_min: float = -numpy.inf, x_max: float = numpy.inf,\n             y_min: float = -numpy.inf, y_max: float = numpy.inf,\n             z_min: float = -numpy.inf, z_max: float = numpy.inf, *,\n             frame: CoordinateFrame = 'local') -&gt; HasAtomCellT:\n        \"\"\"\n        Crop atoms and cell to the given extents. For a non-orthogonal\n        cell, this must be specified in cell coordinates. This\n        function implicity `explode`s the cell as well.\n\n        To crop atoms only, use `crop_atoms` instead.\n        \"\"\"\n\n        cell = self.get_cell().crop(x_min, x_max, y_min, y_max, z_min, z_max, frame=frame)\n        atoms = self._transform_atoms_in_frame(frame, lambda atoms: atoms.crop_atoms(x_min, x_max, y_min, y_max, z_min, z_max))\n        return self.with_cell(cell).with_atoms(atoms)\n\n    def crop_atoms(self: HasAtomCellT, x_min: float = -numpy.inf, x_max: float = numpy.inf,\n                   y_min: float = -numpy.inf, y_max: float = numpy.inf,\n                   z_min: float = -numpy.inf, z_max: float = numpy.inf, *,\n                   frame: CoordinateFrame = 'local') -&gt; HasAtomCellT:\n        atoms = self._transform_atoms_in_frame(frame, lambda atoms: atoms.crop_atoms(x_min, x_max, y_min, y_max, z_min, z_max))\n        return self.with_atoms(atoms)\n\n    def crop_to_box(self: HasAtomCellT, eps: float = 1e-5) -&gt; HasAtomCellT:\n        atoms = self._transform_atoms_in_frame('cell_box', lambda atoms: atoms.crop_atoms(*([-eps, 1-eps]*3)))\n        return self.with_atoms(atoms)\n\n    def wrap(self: HasAtomCellT, eps: float = 1e-5) -&gt; HasAtomCellT:\n        \"\"\"Wrap atoms around the cell boundaries.\"\"\"\n        return self.with_atoms(self._transform_atoms_in_frame('cell_box', lambda a: a._wrap(eps)))\n\n    def _repeat_to_contain(self: HasAtomCellT, pts: numpy.ndarray, pad: int = 0, frame: CoordinateFrame = 'cell_frac') -&gt; HasAtomCellT:\n        #print(f\"pts: {pts} in frame {frame}\")\n        pts = self.get_transform('cell_frac', frame) @ pts\n\n        bbox = BBox3D.unit() | BBox3D.from_pts(pts)\n        min_bounds = numpy.floor(bbox.min).astype(int) - pad\n        max_bounds = numpy.ceil(bbox.max).astype(int) + pad\n        #print(f\"tiling to {min_bounds}, {max_bounds}\")\n        repeat = max_bounds - min_bounds\n        cells = numpy.stack(numpy.meshgrid(*map(numpy.arange, repeat))).reshape(3, -1).T.astype(float)\n\n        atoms = self.get_atoms('cell_frac')\n        atoms = Atoms.concat([\n            atoms.transform(AffineTransform3D.translate(cell))\n            for cell in cells\n        ])\n        #print(f\"atoms:\\n{atoms}\")\n        cell = self.get_cell().repeat(repeat) \\\n            .transform_cell(AffineTransform3D.translate(min_bounds), 'cell_frac')\n        return self.with_cell(cell).with_atoms(atoms, 'cell_frac')\n\n    def repeat(self: HasAtomCellT, n: t.Union[int, VecLike]) -&gt; HasAtomCellT:\n        \"\"\"Tile the cell\"\"\"\n        ns = numpy.broadcast_to(n, 3)\n        if not numpy.issubdtype(ns.dtype, numpy.integer):\n            raise ValueError(f\"repeat() argument must be an integer or integer array.\")\n\n        cells = numpy.stack(numpy.meshgrid(*map(numpy.arange, ns))) \\\n            .reshape(3, -1).T.astype(float)\n        cells = cells * self.box_size\n\n        atoms = self.get_atoms('cell')\n        atoms = Atoms.concat([\n            atoms.transform(AffineTransform3D.translate(cell))\n            for cell in cells\n        ]) #.transform(self.cell.get_transform('local', 'cell_frac'))\n        return self.with_atoms(atoms, 'cell').with_cell(self.get_cell().repeat(ns))\n\n    def repeat_to(self: HasAtomCellT, size: VecLike, crop: t.Union[bool, t.Sequence[bool]] = False) -&gt; HasAtomCellT:\n        \"\"\"\n        Repeat the cell so it is at least ``size`` along the crystal's axes.\n\n        If ``crop``, then crop the cell to exactly ``size``. This may break periodicity.\n        ``crop`` may be a vector, in which case you can specify cropping only along some axes.\n        \"\"\"\n        size = to_vec3(size)\n        cell_size = self.cell_size * self.n_cells\n        repeat = numpy.maximum(numpy.ceil(size / cell_size).astype(int), 1)\n        atom_cell = self.repeat(repeat)\n\n        crop_v = to_vec3(crop, dtype=numpy.bool_)\n        if numpy.any(crop_v):\n            crop_x, crop_y, crop_z = crop_v\n            return atom_cell.crop(\n                x_max = size[0] if crop_x else numpy.inf,\n                y_max = size[1] if crop_y else numpy.inf,\n                z_max = size[2] if crop_z else numpy.inf,\n                frame='cell'\n            )\n\n        return atom_cell\n\n    def repeat_x(self: HasAtomCellT, n: int) -&gt; HasAtomCellT:\n        \"\"\"Tile the cell in the x axis.\"\"\"\n        return self.repeat((n, 1, 1))\n\n    def repeat_y(self: HasAtomCellT, n: int) -&gt; HasAtomCellT:\n        \"\"\"Tile the cell in the y axis.\"\"\"\n        return self.repeat((1, n, 1))\n\n    def repeat_z(self: HasAtomCellT, n: int) -&gt; HasAtomCellT:\n        \"\"\"Tile the cell in the z axis.\"\"\"\n        return self.repeat((1, 1, n))\n\n    def repeat_to_x(self: HasAtomCellT, size: float, crop: bool = False) -&gt; HasAtomCellT:\n        \"\"\"Repeat the cell so it is at least size ``size`` along the x axis.\"\"\"\n        return self.repeat_to([size, 0., 0.], [crop, False, False])\n\n    def repeat_to_y(self: HasAtomCellT, size: float, crop: bool = False) -&gt; HasAtomCellT:\n        \"\"\"Repeat the cell so it is at least size ``size`` along the y axis.\"\"\"\n        return self.repeat_to([0., size, 0.], [False, crop, False])\n\n    def repeat_to_z(self: HasAtomCellT, size: float, crop: bool = False) -&gt; HasAtomCellT:\n        \"\"\"Repeat the cell so it is at least size ``size`` along the z axis.\"\"\"\n        return self.repeat_to([0., 0., size], [False, False, crop])\n\n    def repeat_to_aspect(self: HasAtomCellT, plane: t.Literal['xy', 'xz', 'yz'] = 'xy', *,\n                         aspect: float = 1., min_size: t.Optional[VecLike] = None,\n                         max_size: t.Optional[VecLike] = None) -&gt; HasAtomCellT:\n        \"\"\"\n        Repeat to optimize the aspect ratio in ``plane``,\n        while staying above ``min_size`` and under ``max_size``.\n        \"\"\"\n        if min_size is None:\n            min_n = numpy.array([1, 1, 1], numpy.int_)\n        else:\n            min_n = numpy.maximum(numpy.ceil(to_vec3(min_size) / self.box_size), 1).astype(numpy.int_)\n\n        if max_size is None:\n            max_n = 3 * min_n\n        else:\n            max_n = numpy.maximum(numpy.floor(to_vec3(max_size) / self.box_size), 1).astype(numpy.int_)\n\n        if plane == 'xy':\n            indices = [0, 1]\n        elif plane == 'xz':\n            indices = [0, 2]\n        elif plane == 'yz':\n            indices = [1, 2]\n        else:\n            raise ValueError(f\"Invalid plane '{plane}'. Exepcted 'xy', 'xz', 'or 'yz'.\")\n\n        na = numpy.arange(min_n[indices[0]], max_n[indices[0]])\n        nb = numpy.arange(min_n[indices[1]], max_n[indices[1]])\n        (na, nb) = numpy.meshgrid(na, nb)\n\n        aspects = na * self.box_size[indices[0]] / (nb * self.box_size[indices[1]])\n        # cost function: log(aspect)^2  (so cost(0.5) == cost(2))\n        min_i = numpy.argmin(numpy.log(aspects / aspect)**2)\n        repeat = numpy.array([1, 1, 1], numpy.int_)\n        repeat[indices] = na.flatten()[min_i], nb.flatten()[min_i]\n        return self.repeat(repeat)\n\n    def explode(self: HasAtomCellT) -&gt; HasAtomCellT:\n        \"\"\"Materialize repeated cells as one supercell.\"\"\"\n        frame = self.get_frame()\n\n        return self.with_atoms(self.get_atoms('local'), 'local') \\\n            .with_cell(self.get_cell().explode()) \\\n            .to_frame(frame)\n\n    def periodic_duplicate(self: HasAtomCellT, eps: float = 1e-5) -&gt; HasAtomCellT:\n        \"\"\"\n        Add duplicate copies of atoms near periodic boundaries.\n\n        For instance, an atom at a corner will be duplicated into 8 copies.\n        This is mostly only useful for visualization.\n        \"\"\"\n        frame_save = self.get_frame()\n        self = self.to_frame('cell_box').wrap(eps=eps)\n\n        for i in range(3):\n            self = self.concat((self,\n                self.filter(polars.col('coords').arr.get(i).abs() &lt;= eps, frame='cell_box')\n                    .transform_atoms(AffineTransform3D.translate([1. if i == j else 0. for j in range(3)]), frame='cell_box')\n            ))\n\n        return self.to_frame(frame_save)\n\n    # add frame to some HasAtoms methods\n\n    @_fwd_atoms_get\n    def describe(self, percentiles: t.Union[t.Sequence[float], float, None] = (0.25, 0.5, 0.75), *,\n                 interpolation: RollingInterpolationMethod = 'nearest',\n                 frame: t.Optional[CoordinateFrame] = None) -&gt; polars.DataFrame:\n        \"\"\"Return summary statistics for `self`.\"\"\"\n        ...\n\n    @_fwd_atoms_transform\n    def with_columns(self: HasAtomCellT,\n                     *exprs: t.Union[IntoExpr, t.Iterable[IntoExpr]],\n                     frame: t.Optional[CoordinateFrame] = None,\n                     **named_exprs: IntoExpr) -&gt; HasAtomCellT:\n        \"\"\"Return a copy of ``self`` with the given columns added.\"\"\"\n        ...\n\n    with_column = with_columns\n\n    @_fwd_atoms_get\n    def get_column(self, name: str, *, frame: t.Optional[CoordinateFrame] = None) -&gt; polars.Series:\n        \"\"\"Get the specified column from `self`, raising [`polars.ColumnNotFoundError`][polars.exceptions.ColumnNotFoundError] if it's not present.\"\"\"\n        ...\n\n    @_fwd_atoms_get\n    def get_columns(self, *, frame: t.Optional[CoordinateFrame] = None) -&gt; t.List[polars.Series]:\n        \"\"\"Get the specified columns from `self`, raising [`polars.ColumnNotFoundError`][polars.exceptions.ColumnNotFoundError] if it's not present.\"\"\"\n        ...\n\n    @_fwd_atoms_get\n    def group_by(self, *by: t.Union[IntoExpr, t.Iterable[IntoExpr]],\n                 maintain_order: bool = False, frame: t.Optional[CoordinateFrame] = None,\n                 **named_by: IntoExpr) -&gt; polars.dataframe.group_by.GroupBy:\n        ...\n\n    def pipe(self: HasAtomCellT, function: t.Callable[Concatenate[HasAtomCellT, P], T], *args: P.args, **kwargs: P.kwargs) -&gt; T:\n        \"\"\"Apply `function` to `self` (in method-call syntax).\"\"\"\n        return function(self, *args, **kwargs)\n\n    @_fwd_atoms_transform\n    def filter(\n        self: HasAtomCellT,\n        *predicates: t.Union[None, IntoExprColumn, t.Iterable[IntoExprColumn], bool, t.List[bool], numpy.ndarray],\n        frame: t.Optional[CoordinateFrame] = None,\n        **constraints: t.Any,\n    ) -&gt; HasAtomCellT:\n        \"\"\"Filter `self`, removing rows which evaluate to `False`.\"\"\"\n        ...\n\n    @_fwd_atoms_transform\n    def sort(\n        self: HasAtomCellT,\n        by: t.Union[IntoExpr, t.Iterable[IntoExpr]],\n        *more_by: IntoExpr,\n        descending: t.Union[bool, t.Sequence[bool]] = False,\n        nulls_last: bool = False,\n    ) -&gt; HasAtomCellT:\n        \"\"\"\n        Sort the atoms in `self` by the given columns/expressions.\n        \"\"\"\n        ...\n\n    @_fwd_atoms_transform\n    def slice(self: HasAtomCellT, offset: int, length: t.Optional[int] = None, *,\n              frame: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n        \"\"\"Return a slice of the rows in `self`.\"\"\"\n        ...\n\n    @_fwd_atoms_transform\n    def head(self: HasAtomCellT, n: int = 5, *, frame: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n        \"\"\"Return the first `n` rows of `self`.\"\"\"\n        ...\n\n    @_fwd_atoms_transform\n    def tail(self: HasAtomCellT, n: int = 5, *, frame: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n        \"\"\"Return the last `n` rows of `self`.\"\"\"\n        ...\n\n    @_fwd_atoms_transform\n    def fill_null(\n        self: HasAtomCellT, value: t.Any = None, strategy: t.Optional[FillNullStrategy] = None,\n        limit: t.Optional[int] = None, matches_supertype: bool = True,\n    ) -&gt; HasAtomCellT:\n        ...\n\n    @_fwd_atoms_transform\n    def fill_nan(self: HasAtomCellT, value: t.Union[polars.Expr, int, float, None], *,\n                 frame: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n        ...\n\n    # TODO: partition_by\n\n    @_fwd_atoms_get\n    def select(\n        self, *exprs: t.Union[IntoExpr, t.Iterable[IntoExpr]],\n        frame: t.Optional[CoordinateFrame] = None,\n        **named_exprs: IntoExpr\n    ) -&gt; polars.DataFrame:\n        \"\"\"\n        Select `exprs`` from ``self`, and return as a `polars.DataFrame`.\n\n        Expressions may either be columns or expressions of columns.\n        \"\"\"\n        ...\n\n    @_fwd_atoms_transform\n    def select_props(\n        self: HasAtomCellT,\n        *exprs: t.Union[IntoExpr, t.Iterable[IntoExpr]],\n        frame: t.Optional[CoordinateFrame] = None,\n        **named_exprs: IntoExpr\n    ) -&gt; HasAtomCellT:\n        \"\"\"\n        Select `exprs` from `self`, while keeping required columns.\n\n        Returns a HasAtoms.\n        \"\"\"\n        ...\n\n    @_fwd_atoms_get\n    def try_select(\n        self, *exprs: t.Union[IntoExpr, t.Iterable[IntoExpr]],\n        frame: t.Optional[CoordinateFrame] = None,\n        **named_exprs: IntoExpr\n    ) -&gt; t.Optional[polars.DataFrame]:\n        \"\"\"\n        Try to select `exprs` from `self`, and return as a `polars.DataFrame`.\n\n        Expressions may either be columns or expressions of columns.\n        Return `None` if any columns are missing.\n        \"\"\"\n        ...\n\n    @_fwd_atoms_transform\n    def round_near_zero(self: HasAtomCellT, tol: float = 1e-14, *,\n                        frame: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n        \"\"\"\n        Round atom position values near zero to zero.\n        \"\"\"\n        ...\n\n    @_fwd_atoms_get\n    def coords(self, selection: t.Optional[AtomSelection] = None, *, frame: t.Optional[CoordinateFrame] = None) -&gt; NDArray[numpy.float64]:\n        \"\"\"Returns a `(N, 3)` ndarray of atom coordinates (dtype ``numpy.float64``).\"\"\"\n        ...\n\n    @_fwd_atoms_get\n    def velocities(self, selection: t.Optional[AtomSelection] = None, *, frame: t.Optional[CoordinateFrame] = None) -&gt; t.Optional[NDArray[numpy.float64]]:\n        \"\"\"Returns a `(N, 3)` ndarray of atom velocities (dtype ``numpy.float64``).\"\"\"\n        ...\n\n    @t.overload\n    def add_atom(self: HasAtomCellT, elem: t.Union[int, str], x: ArrayLike, /, *,\n                 y: None = None, z: None = None, frame: t.Optional[CoordinateFrame] = None,\n                 **kwargs: t.Any) -&gt; HasAtomCellT:\n        ...\n\n    @t.overload\n    def add_atom(self: HasAtomCellT, elem: t.Union[int, str], /,\n                 x: float, y: float, z: float, *,\n                 frame: t.Optional[CoordinateFrame] = None,\n                 **kwargs: t.Any) -&gt; HasAtomCellT:\n        ...\n\n    @_fwd_atoms_transform\n    def add_atom(self: HasAtomCellT, elem: t.Union[int, str], /,  # type: ignore (spurious)\n                 x: t.Union[ArrayLike, float],\n                 y: t.Optional[float] = None,\n                 z: t.Optional[float] = None, *,\n                 frame: t.Optional[CoordinateFrame] = None,\n                 **kwargs: t.Any) -&gt; HasAtomCellT:\n        \"\"\"\n        Return a copy of ``self`` with an extra atom.\n\n        By default, all extra columns present in ``self`` must be specified as ``**kwargs``.\n\n        Try to avoid calling this in a loop (Use :py:meth:`concat` instead).\n        \"\"\"\n        ...\n\n    @_fwd_atoms_transform\n    def with_index(self: HasAtomCellT, index: t.Optional[AtomValues] = None, *,\n                   frame: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n        \"\"\"\n        Returns ``self`` with a row index added in column 'i' (dtype polars.Int64).\n        If ``index`` is not specified, defaults to an existing index or a new index.\n        \"\"\"\n        ...\n\n    @_fwd_atoms_transform\n    def with_wobble(self: HasAtomCellT, wobble: t.Optional[AtomValues] = None, *,\n                    frame: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n        \"\"\"\n        Return ``self`` with the given displacements in column 'wobble' (dtype polars.Float64).\n        If ``wobble`` is not specified, defaults to the already-existing wobbles or 0.\n        \"\"\"\n        ...\n\n    @_fwd_atoms_transform\n    def with_occupancy(self: HasAtomCellT, frac_occupancy: t.Optional[AtomValues] = None, *,\n                       frame: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n        \"\"\"\n        Return self with the given fractional occupancies. If ``frac_occupancy`` is not specified,\n        defaults to the already-existing occupancies or 1.\n        \"\"\"\n        ...\n\n    @_fwd_atoms_transform\n    def apply_wobble(self: HasAtomCellT, rng: t.Union[numpy.random.Generator, int, None] = None,\n                     frame: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n        \"\"\"\n        Displace the atoms in ``self`` by the amount in the `wobble` column.\n        ``wobble`` is interpretated as a mean-squared displacement, which is distributed\n        equally over each axis.\n        \"\"\"\n        ...\n\n    @_fwd_atoms_transform\n    def with_type(self: HasAtomCellT, types: t.Optional[AtomValues] = None, *,\n                  frame: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n        \"\"\"\n        Return ``self`` with the given atom types in column 'type'.\n        If ``types`` is not specified, use the already existing types or auto-assign them.\n\n        When auto-assigning, each symbol is given a unique value, case-sensitive.\n        Values are assigned from lowest atomic number to highest.\n        For instance: ``[\"Ag+\", \"Na\", \"H\", \"Ag\"]`` =&gt; ``[3, 11, 1, 2]``\n        \"\"\"\n        ...\n\n    @_fwd_atoms_transform\n    def with_mass(self: HasAtomCellT, mass: t.Optional[ArrayLike] = None, *,\n                  frame: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n        \"\"\"\n        Return ``self`` with the given atom masses in column 'mass'.\n        If ``mass`` is not specified, use the already existing masses or auto-assign them.\n        \"\"\"\n        ...\n\n    @_fwd_atoms_transform\n    def with_symbol(self: HasAtomCellT, symbols: ArrayLike, selection: t.Optional[AtomSelection] = None, *,\n                    frame: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n        \"\"\"\n        Return ``self`` with the given atomic symbols.\n        \"\"\"\n        ...\n\n    @_fwd_atoms_transform\n    def with_coords(self: HasAtomCellT, pts: ArrayLike, selection: t.Optional[AtomSelection] = None, *,\n                    frame: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n        \"\"\"\n        Return ``self`` replaced with the given atomic positions.\n        \"\"\"\n        ...\n\n    @_fwd_atoms_transform\n    def with_velocity(self: HasAtomCellT, pts: t.Optional[ArrayLike] = None,\n                      selection: t.Optional[AtomSelection] = None, *,\n                      frame: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n        \"\"\"\n        Return ``self`` replaced with the given atomic velocities.\n        If ``pts`` is not specified, use the already existing velocities or zero.\n        \"\"\"\n        ...\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.affine","title":"<code>affine: AffineTransform3D</code>  <code>property</code>","text":"<p>Affine transformation. Holds transformation from 'ortho' to 'local' coordinates, including rotation away from the standard crystal orientation.</p>"},{"location":"api/#atomlib.HasAtomCell.ortho","title":"<code>ortho: LinearTransform3D</code>  <code>property</code>","text":"<p>Orthogonalization transformation. Skews but does not scale the crystal axes to cartesian axes.</p>"},{"location":"api/#atomlib.HasAtomCell.metric","title":"<code>metric: LinearTransform3D</code>  <code>property</code>","text":"<p>Cell metric tensor</p> <p>Returns the dot product between every combination of basis vectors. :math:<code>\\mathbf{a} \\cdot \\mathbf{b} = a_i M_ij b_j</code></p>"},{"location":"api/#atomlib.HasAtomCell.cell_size","title":"<code>cell_size: NDArray[numpy.float_]</code>  <code>property</code>","text":"<p>Unit cell size.</p>"},{"location":"api/#atomlib.HasAtomCell.cell_angle","title":"<code>cell_angle: NDArray[numpy.float_]</code>  <code>property</code>","text":"<p>Unit cell angles, in radians.</p>"},{"location":"api/#atomlib.HasAtomCell.n_cells","title":"<code>n_cells: NDArray[numpy.int_]</code>  <code>property</code>","text":"<p>Number of unit cells.</p>"},{"location":"api/#atomlib.HasAtomCell.pbc","title":"<code>pbc: NDArray[numpy.bool_]</code>  <code>property</code>","text":"<p>Flags indicating the presence of periodic boundary conditions along each axis.</p>"},{"location":"api/#atomlib.HasAtomCell.ortho_size","title":"<code>ortho_size: NDArray[numpy.float_]</code>  <code>property</code>","text":"<p>Return size of orthogonal unit cell.</p> <p>Equivalent to the diagonal of the orthogonalization matrix.</p>"},{"location":"api/#atomlib.HasAtomCell.box_size","title":"<code>box_size: NDArray[numpy.float_]</code>  <code>property</code>","text":"<p>Return size of the cell box.</p> <p>Equivalent to <code>self.n_cells * self.cell_size</code>.</p>"},{"location":"api/#atomlib.HasAtomCell.columns","title":"<code>columns: t.Sequence[str]</code>  <code>property</code>","text":"<p>Return the columns in <code>self</code>.</p>"},{"location":"api/#atomlib.HasAtomCell.dtypes","title":"<code>dtypes: t.Sequence[polars.DataType]</code>  <code>property</code>","text":"<p>Return the datatypes in <code>self</code>.</p>"},{"location":"api/#atomlib.HasAtomCell.schema","title":"<code>schema: SchemaDict</code>  <code>property</code>","text":"<p>Return the schema of <code>self</code>.</p>"},{"location":"api/#atomlib.HasAtomCell.unique","title":"<code>unique = deduplicate</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#atomlib.HasAtomCell.with_column","title":"<code>with_column = with_columns</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#atomlib.HasAtomCell.get_cell","title":"<code>get_cell()</code>  <code>abstractmethod</code>","text":"<p>Get the cell contained in <code>self</code>. This should be a low cost method.</p> Source code in <code>atomlib/cell.py</code> <pre><code>@abc.abstractmethod\ndef get_cell(self) -&gt; Cell:\n    \"\"\"Get the cell contained in ``self``. This should be a low cost method.\"\"\"\n    ...\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.get_transform","title":"<code>get_transform(frame_to=None, frame_from=None)</code>","text":"<p>In the two-argument form, get the transform to 'frame_to' from 'frame_from'. In the one-argument form, get the transform from local coordinates to 'frame'.</p> Source code in <code>atomlib/cell.py</code> <pre><code>def get_transform(self, frame_to: t.Optional[CoordinateFrame] = None, frame_from: t.Optional[CoordinateFrame] = None) -&gt; AffineTransform3D:\n    \"\"\"\n    In the two-argument form, get the transform to 'frame_to' from 'frame_from'.\n    In the one-argument form, get the transform from local coordinates to 'frame'.\n    \"\"\"\n    transform_from = self._get_transform_to_local(frame_from) if frame_from is not None else AffineTransform3D()\n    transform_to = self._get_transform_to_local(frame_to) if frame_to is not None else AffineTransform3D()\n    if frame_from is not None and frame_to is not None and frame_from.lower() == frame_to.lower():\n        return AffineTransform3D()\n    return transform_to.inverse() @ transform_from\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.corners","title":"<code>corners(frame='local')</code>","text":"Source code in <code>atomlib/cell.py</code> <pre><code>def corners(self, frame: CoordinateFrame = 'local') -&gt; numpy.ndarray:\n    corners = numpy.array(list(itertools.product((0., 1.), repeat=3)))\n    return self.get_transform(frame, 'cell_box') @ corners\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.bbox_cell","title":"<code>bbox_cell(frame='local')</code>","text":"<p>Return the bounding box of the cell box in the given coordinate system.</p> Source code in <code>atomlib/cell.py</code> <pre><code>def bbox_cell(self, frame: CoordinateFrame = 'local') -&gt; BBox3D:\n    \"\"\"Return the bounding box of the cell box in the given coordinate system.\"\"\"\n    return BBox3D.from_pts(self.corners(frame))\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.is_orthogonal","title":"<code>is_orthogonal(tol=1e-08)</code>","text":"<p>Returns whether this cell is orthogonal (axes are at right angles.)</p> Source code in <code>atomlib/cell.py</code> <pre><code>def is_orthogonal(self, tol: float = 1e-8) -&gt; bool:\n    \"\"\"Returns whether this cell is orthogonal (axes are at right angles.)\"\"\"\n    return self.ortho.is_diagonal(tol=tol)\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.is_orthogonal_in_local","title":"<code>is_orthogonal_in_local(tol=1e-08)</code>","text":"<p>Returns whether this cell is orthogonal and aligned with the local coordinate system.</p> Source code in <code>atomlib/cell.py</code> <pre><code>def is_orthogonal_in_local(self, tol: float = 1e-8) -&gt; bool:\n    \"\"\"Returns whether this cell is orthogonal and aligned with the local coordinate system.\"\"\"\n    transform = (self.affine @ self.ortho).to_linear()\n    if not transform.is_scaled_orthogonal(tol):\n        return False\n    normed = transform.inner / numpy.linalg.norm(transform.inner, axis=-2, keepdims=True)\n    # every row of transform must be a +/- 1 times a basis vector (i, j, or k)\n    return all(\n        any(numpy.isclose(numpy.abs(numpy.dot(row, v)), 1., atol=tol) for v in numpy.eye(3))\n        for row in normed\n    )\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.to_ortho","title":"<code>to_ortho()</code>","text":"Source code in <code>atomlib/cell.py</code> <pre><code>def to_ortho(self) -&gt; AffineTransform3D:\n    return self.get_transform('local', 'cell_box')\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.strain_orthogonal","title":"<code>strain_orthogonal()</code>","text":"<p>Orthogonalize using strain.</p> <p>Strain is applied such that the x-axis remains fixed, and the y-axis remains in the xy plane. For small displacements, no hydrostatic strain is applied (volume is conserved).</p> Source code in <code>atomlib/cell.py</code> <pre><code>def strain_orthogonal(self: HasCellT) -&gt; HasCellT:\n    \"\"\"\n    Orthogonalize using strain.\n\n    Strain is applied such that the x-axis remains fixed, and the y-axis remains in the xy plane.\n    For small displacements, no hydrostatic strain is applied (volume is conserved).\n    \"\"\"\n    return self.with_cell(Cell(\n        affine=self.affine,\n        ortho=LinearTransform3D(),\n        cell_size=self.cell_size,\n        n_cells=self.n_cells,\n        pbc=self.pbc,\n    ))\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.explode_z","title":"<code>explode_z()</code>","text":"<p>Materialize repeated cells as one supercell in z.</p> Source code in <code>atomlib/cell.py</code> <pre><code>def explode_z(self: HasCellT) -&gt; HasCellT:\n    \"\"\"Materialize repeated cells as one supercell in z.\"\"\"\n    return self.with_cell(Cell(\n        affine=self.affine,\n        ortho=self.ortho,\n        cell_size=self.cell_size*[1, 1, self.n_cells[2]],\n        n_cells=[*self.n_cells[:2], 1],\n        cell_angle=self.cell_angle,\n        pbc=self.pbc,\n    ))\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.change_transform","title":"<code>change_transform(transform, frame_to=None, frame_from=None)</code>","text":"<p>Coordinate-change a transformation to 'frame_to' from 'frame_from'.</p> Source code in <code>atomlib/cell.py</code> <pre><code>def change_transform(self, transform: Transform3D,\n                     frame_to: t.Optional[CoordinateFrame] = None,\n                     frame_from: t.Optional[CoordinateFrame] = None) -&gt; Transform3D:\n    \"\"\"Coordinate-change a transformation to 'frame_to' from 'frame_from'.\"\"\"\n    if frame_to == frame_from and frame_to is not None:\n        return transform\n    coord_change = self.get_transform(frame_to, frame_from)\n    return coord_change @ transform @ coord_change.inverse()\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.assert_equal","title":"<code>assert_equal(other)</code>","text":"Source code in <code>atomlib/atoms.py</code> <pre><code>def assert_equal(self, other: t.Any):\n    assert isinstance(other, HasAtoms)\n    assert dict(self.schema) == dict(other.schema)\n    for col in self.schema.keys():\n        polars.testing.assert_series_equal(self[col], other[col], check_names=False, rtol=1e-3, atol=1e-8)\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.insert_column","title":"<code>insert_column(index, column)</code>","text":"Source code in <code>atomlib/atoms.py</code> <pre><code>@_fwd_frame_map\ndef insert_column(self, index: int, column: polars.Series) -&gt; polars.DataFrame:\n    return self._get_frame().insert_column(index, column)\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.get_column_index","title":"<code>get_column_index(name)</code>","text":"<p>Get the index of a column by name, raising <code>polars.ColumnNotFoundError</code> if it's not present.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>@_fwd_frame(polars.DataFrame.get_column_index)\ndef get_column_index(self, name: str) -&gt; int:\n    \"\"\"Get the index of a column by name, raising [`polars.ColumnNotFoundError`][polars.exceptions.ColumnNotFoundError] if it's not present.\"\"\"\n    ...\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.clone","title":"<code>clone()</code>","text":"<p>Return a copy of <code>self</code>.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>@_fwd_frame_map\ndef clone(self) -&gt; polars.DataFrame:\n    \"\"\"Return a copy of `self`.\"\"\"\n    return self._get_frame().clone()\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.drop","title":"<code>drop(*columns)</code>","text":"<p>Return <code>self</code> with the specified columns removed.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def drop(self, *columns: t.Union[str, t.Iterable[str]]) -&gt; polars.DataFrame:\n    \"\"\"Return `self` with the specified columns removed.\"\"\"\n    return self._get_frame().drop(*columns)\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.drop_nulls","title":"<code>drop_nulls(subset=None)</code>","text":"<p>Drop rows that contain nulls in any of columns <code>subset</code>.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>@_fwd_frame_map\ndef drop_nulls(self, subset: t.Union[str, t.Collection[str], None] = None) -&gt; polars.DataFrame:\n    \"\"\"Drop rows that contain nulls in any of columns `subset`.\"\"\"\n    return self._get_frame().drop_nulls(subset)\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.concat","title":"<code>concat(atoms, *, rechunk=True, how='vertical')</code>  <code>classmethod</code>","text":"<p>Concatenate multiple <code>Atoms</code> together, handling metadata appropriately.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>@classmethod\ndef concat(cls: t.Type[HasAtomsT],\n           atoms: t.Union[HasAtomsT, IntoAtoms, t.Iterable[t.Union[HasAtomsT, IntoAtoms]]], *,\n           rechunk: bool = True, how: ConcatMethod = 'vertical') -&gt; HasAtomsT:\n    \"\"\"Concatenate multiple `Atoms` together, handling metadata appropriately.\"\"\"\n    # this method is tricky. It needs to accept raw Atoms, as well as HasAtoms of the\n    # same type as ``cls``.\n    if _is_abstract(cls):\n        raise TypeError(f\"concat() must be called on a concrete class.\")\n\n    if isinstance(atoms, HasAtoms):\n        atoms = (atoms,)\n    dfs = [a.get_atoms('local').inner if isinstance(a, HasAtoms) else Atoms(t.cast(IntoAtoms, a)).inner for a in atoms]\n    representative = cls._combine_metadata(*(a for a in atoms if isinstance(a, HasAtoms)))\n\n    if len(dfs) == 0:\n        return representative.with_atoms(Atoms.empty(), 'local')\n\n    if how in ('vertical', 'vertical_relaxed'):\n        # get order from first member\n        cols = dfs[0].columns\n        dfs = [df.select(cols) for df in dfs]\n    elif how == 'inner':\n        cols = reduce(operator.and_, (df.schema.keys() for df in dfs))\n        schema = OrderedDict((col, dfs[0].schema[col]) for col in cols)\n        if len(schema) == 0:\n            raise ValueError(f\"Atoms have no columns in common\")\n\n        dfs = [_select_schema(df, schema) for df in dfs]\n        how = 'vertical'\n\n    return representative.with_atoms(Atoms(polars.concat(dfs, rechunk=rechunk, how=how)), 'local')\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.partition_by","title":"<code>partition_by(by, *more_by, maintain_order=True, include_key=True, as_dict=False)</code>","text":"<p>Group by the given columns and partition into separate dataframes.</p> <p>Return the partitions as a dictionary by specifying <code>as_dict=True</code>.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def partition_by(\n    self: HasAtomsT, by: t.Union[str, t.Sequence[str]], *more_by: str,\n    maintain_order: bool = True, include_key: bool = True, as_dict: bool = False\n) -&gt; t.Union[t.List[HasAtomsT], t.Dict[t.Any, HasAtomsT]]:\n    \"\"\"\n    Group by the given columns and partition into separate dataframes.\n\n    Return the partitions as a dictionary by specifying `as_dict=True`.\n    \"\"\"\n    if as_dict:\n        d = self._get_frame().partition_by(by, *more_by, maintain_order=maintain_order, include_key=include_key, as_dict=True)\n        return {k: self.with_atoms(Atoms(df, _unchecked=True)) for (k, df) in d.items()}\n\n    return [\n        self.with_atoms(Atoms(df, _unchecked=True))\n        for df in self._get_frame().partition_by(by, *more_by, maintain_order=maintain_order, include_key=include_key, as_dict=False)\n    ]\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.select_schema","title":"<code>select_schema(schema)</code>","text":"<p>Select columns from <code>self</code> and cast to the given schema. Raises <code>TypeError</code> if a column is not found or if it can't be cast.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def select_schema(self, schema: SchemaDict) -&gt; polars.DataFrame:\n    \"\"\"\n    Select columns from `self` and cast to the given schema.\n    Raises `TypeError` if a column is not found or if it can't be cast.\n    \"\"\"\n    return _select_schema(self, schema)\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.try_get_column","title":"<code>try_get_column(name)</code>","text":"<p>Try to get a column from <code>self</code>, returning <code>None</code> if it doesn't exist.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def try_get_column(self, name: str) -&gt; t.Optional[polars.Series]:\n    \"\"\"Try to get a column from `self`, returning `None` if it doesn't exist.\"\"\"\n    try:\n        return self.get_column(name)\n    except polars.ColumnNotFoundError:\n        return None\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.deduplicate","title":"<code>deduplicate(tol=0.001, subset=('x', 'y', 'z', 'symbol'), keep='first', maintain_order=True)</code>","text":"<p>De-duplicate atoms in <code>self</code>. Atoms of the same <code>symbol</code> that are closer than <code>tolerance</code> to each other (by Euclidian distance) will be removed, leaving only the atom specified by <code>keep</code> (defaults to the first atom).</p> <p>If <code>subset</code> is specified, only those columns will be included while assessing duplicates. Floating point columns other than 'x', 'y', and 'z' will not by toleranced.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def deduplicate(self: HasAtomsT, tol: float = 1e-3, subset: t.Iterable[str] = ('x', 'y', 'z', 'symbol'),\n                keep: UniqueKeepStrategy = 'first', maintain_order: bool = True) -&gt; HasAtomsT:\n    \"\"\"\n    De-duplicate atoms in `self`. Atoms of the same `symbol` that are closer than `tolerance`\n    to each other (by Euclidian distance) will be removed, leaving only the atom specified by\n    `keep` (defaults to the first atom).\n\n    If `subset` is specified, only those columns will be included while assessing duplicates.\n    Floating point columns other than 'x', 'y', and 'z' will not by toleranced.\n    \"\"\"\n    import scipy.spatial\n\n    cols = set((subset,) if isinstance(subset, str) else subset)\n\n    indices = numpy.arange(len(self))\n\n    spatial_cols = cols.intersection(('x', 'y', 'z'))\n    cols -= spatial_cols\n    if len(spatial_cols) &gt; 0:\n        coords = self.select([_coord_expr(col).alias(col) for col in spatial_cols]).to_numpy()\n        tree = scipy.spatial.KDTree(coords)\n\n        # TODO This is a bad algorithm\n        while True:\n            changed = False\n            for (i, j) in tree.query_pairs(tol, 2.):\n                # whenever we encounter a pair, ensure their index matches\n                i_i, i_j = indices[[i, j]]\n                if i_i != i_j:\n                    indices[i] = indices[j] = min(i_i, i_j)\n                    changed = True\n            if not changed:\n                break\n\n        self = self.with_column(polars.Series('_unique_pts', indices))\n        cols.add('_unique_pts')\n\n    frame = self._get_frame().unique(subset=list(cols), keep=keep, maintain_order=maintain_order)\n    if len(spatial_cols) &gt; 0:\n        frame = frame.drop('_unique_pts')\n\n    return self.with_atoms(Atoms(frame, _unchecked=True))\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.with_bounds","title":"<code>with_bounds(cell_size=None, cell_origin=None)</code>","text":"<p>Return a periodic cell with the given orthogonal cell dimensions.</p> <p>If cell_size is not specified, it will be assumed (and may be incorrect).</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def with_bounds(self, cell_size: t.Optional[VecLike] = None, cell_origin: t.Optional[VecLike] = None) -&gt; 'AtomCell':\n    \"\"\"\n    Return a periodic cell with the given orthogonal cell dimensions.\n\n    If cell_size is not specified, it will be assumed (and may be incorrect).\n    \"\"\"\n    # TODO: test this\n    from .atomcell import AtomCell\n\n    if cell_size is None:\n        warnings.warn(\"Cell boundary unknown. Defaulting to cell BBox\")\n        cell_size = self.bbox().size\n        cell_origin = self.bbox().min\n\n    # TODO test this origin code\n    cell = Cell.from_unit_cell(cell_size)\n    if cell_origin is not None:\n        cell = cell.transform_cell(AffineTransform3D.translate(to_vec3(cell_origin)))\n\n    return AtomCell(self.get_atoms(), cell, frame='local')\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.x","title":"<code>x()</code>","text":"Source code in <code>atomlib/atoms.py</code> <pre><code>def x(self) -&gt; polars.Expr:\n    return polars.col('coords').arr.get(0).alias('x')\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.y","title":"<code>y()</code>","text":"Source code in <code>atomlib/atoms.py</code> <pre><code>def y(self) -&gt; polars.Expr:\n    return polars.col('coords').arr.get(1).alias('y')\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.z","title":"<code>z()</code>","text":"Source code in <code>atomlib/atoms.py</code> <pre><code>def z(self) -&gt; polars.Expr:\n    return polars.col('coords').arr.get(2).alias('z')\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.types","title":"<code>types()</code>","text":"<p>Returns a <code>Series</code> of atom types (dtype <code>polars.Int32</code>).</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def types(self) -&gt; t.Optional[polars.Series]:\n    \"\"\"\n    Returns a [`Series`][polars.Series] of atom types (dtype [`polars.Int32`][polars.Int32]).\n\n    [polars.Series]: https://docs.pola.rs/py-polars/html/reference/series/index.html\n    \"\"\"\n    return self.try_get_column('type')\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.masses","title":"<code>masses()</code>","text":"<p>Returns a <code>Series</code> of atom masses (dtype <code>polars.Float32</code>).</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def masses(self) -&gt; t.Optional[polars.Series]:\n    \"\"\"\n    Returns a [`Series`][polars.Series] of atom masses (dtype [`polars.Float32`][polars.Float32]).\n\n    [polars.Series]: https://docs.pola.rs/py-polars/html/reference/series/index.html\n    \"\"\"\n    return self.try_get_column('mass')\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.pos","title":"<code>pos(x=None, y=None, z=None, *, tol=1e-06, **kwargs)</code>","text":"<p>Select all atoms at a given position.</p> <p>Formally, returns all atoms within a cube of radius <code>tol</code> centered at <code>(x,y,z)</code>, exclusive of the cube's surface.</p> <p>Additional parameters given as <code>kwargs</code> will be checked as additional parameters (with strict equality).</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def pos(self,\n        x: t.Union[t.Sequence[t.Optional[float]], float, None] = None,\n        y: t.Optional[float] = None, z: t.Optional[float] = None, *,\n        tol: float = 1e-6, **kwargs: t.Any) -&gt; polars.Expr:\n    \"\"\"\n    Select all atoms at a given position.\n\n    Formally, returns all atoms within a cube of radius ``tol``\n    centered at ``(x,y,z)``, exclusive of the cube's surface.\n\n    Additional parameters given as ``kwargs`` will be checked\n    as additional parameters (with strict equality).\n    \"\"\"\n\n    if isinstance(x, t.Sequence):\n        (x, y, z) = x\n\n    tol = abs(float(tol))\n    selection = polars.lit(True)\n    if x is not None:\n        selection &amp;= self.x().is_between(x - tol, x + tol, closed='none')\n    if y is not None:\n        selection &amp;= self.y().is_between(y - tol, y + tol, closed='none')\n    if z is not None:\n        selection &amp;= self.z().is_between(z - tol, z + tol, closed='none')\n    for (col, val) in kwargs.items():\n        selection &amp;= (polars.col(col) == val)\n\n    return selection\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.apply_occupancy","title":"<code>apply_occupancy(rng=None)</code>","text":"<p>For each atom in <code>self</code>, use its <code>frac_occupancy</code> to randomly decide whether to remove it.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def apply_occupancy(self: HasAtomsT, rng: t.Union[numpy.random.Generator, int, None] = None) -&gt; HasAtomsT:\n    \"\"\"\n    For each atom in `self`, use its `frac_occupancy` to randomly decide whether to remove it.\n    \"\"\"\n    if 'frac_occupancy' not in self.columns:\n        return self\n    rng = numpy.random.default_rng(seed=rng)\n\n    frac = self.select('frac_occupancy').to_series().to_numpy()\n    choice = rng.binomial(1, frac).astype(numpy.bool_)\n    return self.filter(polars.lit(choice))\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.get_frame","title":"<code>get_frame()</code>  <code>abstractmethod</code>","text":"<p>Get the coordinate frame atoms are stored in.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@abc.abstractmethod\ndef get_frame(self) -&gt; CoordinateFrame:\n    \"\"\"Get the coordinate frame atoms are stored in.\"\"\"\n    ...\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.with_atoms","title":"<code>with_atoms(atoms, frame=None)</code>  <code>abstractmethod</code>","text":"<p>Replace the atoms in <code>self</code>. If no coordinate frame is specified, keep the coordinate frame unchanged.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@abc.abstractmethod\ndef with_atoms(self: HasAtomCellT, atoms: HasAtoms, frame: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n    \"\"\"\n    Replace the atoms in ``self``. If no coordinate frame is specified, keep the coordinate frame unchanged.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.with_cell","title":"<code>with_cell(cell)</code>","text":"<p>Replace the cell in <code>self</code>, without touching the atomic coordinates.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def with_cell(self: HasAtomCellT, cell: Cell) -&gt; HasAtomCellT:\n    \"\"\"\n    Replace the cell in ``self``, without touching the atomic coordinates.\n    \"\"\"\n    return self.to_frame('local').with_cell(cell)\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.get_atomcell","title":"<code>get_atomcell()</code>","text":"Source code in <code>atomlib/atomcell.py</code> <pre><code>def get_atomcell(self) -&gt; AtomCell:\n    frame = self.get_frame()\n    return AtomCell(self.get_atoms(frame), self.get_cell(), frame=frame, keep_frame=True)\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.get_atoms","title":"<code>get_atoms(frame=None)</code>  <code>abstractmethod</code>","text":"<p>Get atoms contained in <code>self</code>, in the given coordinate frame.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@abc.abstractmethod\ndef get_atoms(self, frame: t.Optional[CoordinateFrame] = None) -&gt; Atoms:\n    \"\"\"Get atoms contained in ``self``, in the given coordinate frame.\"\"\"\n    ...\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.bbox_atoms","title":"<code>bbox_atoms(frame=None)</code>","text":"<p>Return the bounding box of all the atoms in <code>self</code>, in the given coordinate frame.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def bbox_atoms(self, frame: t.Optional[CoordinateFrame] = None) -&gt; BBox3D:\n    \"\"\"Return the bounding box of all the atoms in ``self``, in the given coordinate frame.\"\"\"\n    return self.get_atoms(frame).bbox()\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.bbox","title":"<code>bbox(frame='local')</code>","text":"<p>Return the combined bounding box of the cell and atoms in the given coordinate system. To get the cell or atoms bounding box only, use meth:<code>bbox_cell</code> or meth:<code>bbox_atoms</code>.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def bbox(self, frame: CoordinateFrame = 'local') -&gt; BBox3D:\n    \"\"\"\n    Return the combined bounding box of the cell and atoms in the given coordinate system.\n    To get the cell or atoms bounding box only, use :py:meth:`bbox_cell` or :py:meth:`bbox_atoms`.\n    \"\"\"\n    return self.bbox_atoms(frame) | self.bbox_cell(frame)\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.to_frame","title":"<code>to_frame(frame)</code>","text":"<p>Convert the stored Atoms to the given coordinate frame.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def to_frame(self: HasAtomCellT, frame: CoordinateFrame) -&gt; HasAtomCellT:\n    \"\"\"Convert the stored Atoms to the given coordinate frame.\"\"\"\n    return self.with_atoms(self.get_atoms(frame), frame)\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.transform_atoms","title":"<code>transform_atoms(transform, selection=None, *, frame='local', transform_velocities=False)</code>","text":"<p>Transform the atoms in <code>self</code> by <code>transform</code>. If <code>selection</code> is given, only transform the atoms in <code>selection</code>.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def transform_atoms(self: HasAtomCellT, transform: IntoTransform3D, selection: t.Optional[AtomSelection] = None, *,\n                    frame: CoordinateFrame = 'local', transform_velocities: bool = False) -&gt; HasAtomCellT:\n    \"\"\"\n    Transform the atoms in `self` by `transform`.\n    If `selection` is given, only transform the atoms in `selection`.\n    \"\"\"\n    transform = self.change_transform(Transform3D.make(transform), self.get_frame(), frame)\n    return self.with_atoms(self.get_atoms(self.get_frame()).transform(transform, selection, transform_velocities=transform_velocities))\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.transform_cell","title":"<code>transform_cell(transform, frame='local')</code>","text":"<p>Apply the given transform to the unit cell, without changing atom positions. The transform is applied in coordinate frame 'frame'.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def transform_cell(self: HasAtomCellT, transform: AffineTransform3D, frame: CoordinateFrame = 'local') -&gt; HasAtomCellT:\n    \"\"\"\n    Apply the given transform to the unit cell, without changing atom positions.\n    The transform is applied in coordinate frame 'frame'.\n    \"\"\"\n    return self.with_cell(self.get_cell().transform_cell(transform, frame=frame))\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.transform","title":"<code>transform(transform, frame='local')</code>","text":"Source code in <code>atomlib/atomcell.py</code> <pre><code>def transform(self: HasAtomCellT, transform: AffineTransform3D, frame: CoordinateFrame = 'local') -&gt; HasAtomCellT:\n    if isinstance(transform, Transform3D) and not isinstance(transform, AffineTransform3D):\n        raise ValueError(\"Non-affine transforms cannot change the box dimensions. Use 'transform_atoms' instead.\")\n    # TODO: cleanup once tests pass\n    # coordinate change the transform into atomic coordinates\n    new_cell = self.get_cell().transform_cell(transform, frame)\n    transform = self.get_cell().change_transform(transform, self.get_frame(), frame)\n    return self.with_atoms(self.get_atoms().transform(transform), self.get_frame()).with_cell(new_cell)\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.crop","title":"<code>crop(x_min=-numpy.inf, x_max=numpy.inf, y_min=-numpy.inf, y_max=numpy.inf, z_min=-numpy.inf, z_max=numpy.inf, *, frame='local')</code>","text":"<p>Crop atoms and cell to the given extents. For a non-orthogonal cell, this must be specified in cell coordinates. This function implicity <code>explode</code>s the cell as well.</p> <p>To crop atoms only, use <code>crop_atoms</code> instead.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def crop(self: HasAtomCellT, x_min: float = -numpy.inf, x_max: float = numpy.inf,\n         y_min: float = -numpy.inf, y_max: float = numpy.inf,\n         z_min: float = -numpy.inf, z_max: float = numpy.inf, *,\n         frame: CoordinateFrame = 'local') -&gt; HasAtomCellT:\n    \"\"\"\n    Crop atoms and cell to the given extents. For a non-orthogonal\n    cell, this must be specified in cell coordinates. This\n    function implicity `explode`s the cell as well.\n\n    To crop atoms only, use `crop_atoms` instead.\n    \"\"\"\n\n    cell = self.get_cell().crop(x_min, x_max, y_min, y_max, z_min, z_max, frame=frame)\n    atoms = self._transform_atoms_in_frame(frame, lambda atoms: atoms.crop_atoms(x_min, x_max, y_min, y_max, z_min, z_max))\n    return self.with_cell(cell).with_atoms(atoms)\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.crop_atoms","title":"<code>crop_atoms(x_min=-numpy.inf, x_max=numpy.inf, y_min=-numpy.inf, y_max=numpy.inf, z_min=-numpy.inf, z_max=numpy.inf, *, frame='local')</code>","text":"Source code in <code>atomlib/atomcell.py</code> <pre><code>def crop_atoms(self: HasAtomCellT, x_min: float = -numpy.inf, x_max: float = numpy.inf,\n               y_min: float = -numpy.inf, y_max: float = numpy.inf,\n               z_min: float = -numpy.inf, z_max: float = numpy.inf, *,\n               frame: CoordinateFrame = 'local') -&gt; HasAtomCellT:\n    atoms = self._transform_atoms_in_frame(frame, lambda atoms: atoms.crop_atoms(x_min, x_max, y_min, y_max, z_min, z_max))\n    return self.with_atoms(atoms)\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.crop_to_box","title":"<code>crop_to_box(eps=1e-05)</code>","text":"Source code in <code>atomlib/atomcell.py</code> <pre><code>def crop_to_box(self: HasAtomCellT, eps: float = 1e-5) -&gt; HasAtomCellT:\n    atoms = self._transform_atoms_in_frame('cell_box', lambda atoms: atoms.crop_atoms(*([-eps, 1-eps]*3)))\n    return self.with_atoms(atoms)\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.wrap","title":"<code>wrap(eps=1e-05)</code>","text":"<p>Wrap atoms around the cell boundaries.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def wrap(self: HasAtomCellT, eps: float = 1e-5) -&gt; HasAtomCellT:\n    \"\"\"Wrap atoms around the cell boundaries.\"\"\"\n    return self.with_atoms(self._transform_atoms_in_frame('cell_box', lambda a: a._wrap(eps)))\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.repeat","title":"<code>repeat(n)</code>","text":"<p>Tile the cell</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def repeat(self: HasAtomCellT, n: t.Union[int, VecLike]) -&gt; HasAtomCellT:\n    \"\"\"Tile the cell\"\"\"\n    ns = numpy.broadcast_to(n, 3)\n    if not numpy.issubdtype(ns.dtype, numpy.integer):\n        raise ValueError(f\"repeat() argument must be an integer or integer array.\")\n\n    cells = numpy.stack(numpy.meshgrid(*map(numpy.arange, ns))) \\\n        .reshape(3, -1).T.astype(float)\n    cells = cells * self.box_size\n\n    atoms = self.get_atoms('cell')\n    atoms = Atoms.concat([\n        atoms.transform(AffineTransform3D.translate(cell))\n        for cell in cells\n    ]) #.transform(self.cell.get_transform('local', 'cell_frac'))\n    return self.with_atoms(atoms, 'cell').with_cell(self.get_cell().repeat(ns))\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.repeat_to","title":"<code>repeat_to(size, crop=False)</code>","text":"<p>Repeat the cell so it is at least <code>size</code> along the crystal's axes.</p> <p>If <code>crop</code>, then crop the cell to exactly <code>size</code>. This may break periodicity. <code>crop</code> may be a vector, in which case you can specify cropping only along some axes.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def repeat_to(self: HasAtomCellT, size: VecLike, crop: t.Union[bool, t.Sequence[bool]] = False) -&gt; HasAtomCellT:\n    \"\"\"\n    Repeat the cell so it is at least ``size`` along the crystal's axes.\n\n    If ``crop``, then crop the cell to exactly ``size``. This may break periodicity.\n    ``crop`` may be a vector, in which case you can specify cropping only along some axes.\n    \"\"\"\n    size = to_vec3(size)\n    cell_size = self.cell_size * self.n_cells\n    repeat = numpy.maximum(numpy.ceil(size / cell_size).astype(int), 1)\n    atom_cell = self.repeat(repeat)\n\n    crop_v = to_vec3(crop, dtype=numpy.bool_)\n    if numpy.any(crop_v):\n        crop_x, crop_y, crop_z = crop_v\n        return atom_cell.crop(\n            x_max = size[0] if crop_x else numpy.inf,\n            y_max = size[1] if crop_y else numpy.inf,\n            z_max = size[2] if crop_z else numpy.inf,\n            frame='cell'\n        )\n\n    return atom_cell\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.repeat_x","title":"<code>repeat_x(n)</code>","text":"<p>Tile the cell in the x axis.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def repeat_x(self: HasAtomCellT, n: int) -&gt; HasAtomCellT:\n    \"\"\"Tile the cell in the x axis.\"\"\"\n    return self.repeat((n, 1, 1))\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.repeat_y","title":"<code>repeat_y(n)</code>","text":"<p>Tile the cell in the y axis.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def repeat_y(self: HasAtomCellT, n: int) -&gt; HasAtomCellT:\n    \"\"\"Tile the cell in the y axis.\"\"\"\n    return self.repeat((1, n, 1))\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.repeat_z","title":"<code>repeat_z(n)</code>","text":"<p>Tile the cell in the z axis.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def repeat_z(self: HasAtomCellT, n: int) -&gt; HasAtomCellT:\n    \"\"\"Tile the cell in the z axis.\"\"\"\n    return self.repeat((1, 1, n))\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.repeat_to_x","title":"<code>repeat_to_x(size, crop=False)</code>","text":"<p>Repeat the cell so it is at least size <code>size</code> along the x axis.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def repeat_to_x(self: HasAtomCellT, size: float, crop: bool = False) -&gt; HasAtomCellT:\n    \"\"\"Repeat the cell so it is at least size ``size`` along the x axis.\"\"\"\n    return self.repeat_to([size, 0., 0.], [crop, False, False])\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.repeat_to_y","title":"<code>repeat_to_y(size, crop=False)</code>","text":"<p>Repeat the cell so it is at least size <code>size</code> along the y axis.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def repeat_to_y(self: HasAtomCellT, size: float, crop: bool = False) -&gt; HasAtomCellT:\n    \"\"\"Repeat the cell so it is at least size ``size`` along the y axis.\"\"\"\n    return self.repeat_to([0., size, 0.], [False, crop, False])\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.repeat_to_z","title":"<code>repeat_to_z(size, crop=False)</code>","text":"<p>Repeat the cell so it is at least size <code>size</code> along the z axis.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def repeat_to_z(self: HasAtomCellT, size: float, crop: bool = False) -&gt; HasAtomCellT:\n    \"\"\"Repeat the cell so it is at least size ``size`` along the z axis.\"\"\"\n    return self.repeat_to([0., 0., size], [False, False, crop])\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.repeat_to_aspect","title":"<code>repeat_to_aspect(plane='xy', *, aspect=1.0, min_size=None, max_size=None)</code>","text":"<p>Repeat to optimize the aspect ratio in <code>plane</code>, while staying above <code>min_size</code> and under <code>max_size</code>.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def repeat_to_aspect(self: HasAtomCellT, plane: t.Literal['xy', 'xz', 'yz'] = 'xy', *,\n                     aspect: float = 1., min_size: t.Optional[VecLike] = None,\n                     max_size: t.Optional[VecLike] = None) -&gt; HasAtomCellT:\n    \"\"\"\n    Repeat to optimize the aspect ratio in ``plane``,\n    while staying above ``min_size`` and under ``max_size``.\n    \"\"\"\n    if min_size is None:\n        min_n = numpy.array([1, 1, 1], numpy.int_)\n    else:\n        min_n = numpy.maximum(numpy.ceil(to_vec3(min_size) / self.box_size), 1).astype(numpy.int_)\n\n    if max_size is None:\n        max_n = 3 * min_n\n    else:\n        max_n = numpy.maximum(numpy.floor(to_vec3(max_size) / self.box_size), 1).astype(numpy.int_)\n\n    if plane == 'xy':\n        indices = [0, 1]\n    elif plane == 'xz':\n        indices = [0, 2]\n    elif plane == 'yz':\n        indices = [1, 2]\n    else:\n        raise ValueError(f\"Invalid plane '{plane}'. Exepcted 'xy', 'xz', 'or 'yz'.\")\n\n    na = numpy.arange(min_n[indices[0]], max_n[indices[0]])\n    nb = numpy.arange(min_n[indices[1]], max_n[indices[1]])\n    (na, nb) = numpy.meshgrid(na, nb)\n\n    aspects = na * self.box_size[indices[0]] / (nb * self.box_size[indices[1]])\n    # cost function: log(aspect)^2  (so cost(0.5) == cost(2))\n    min_i = numpy.argmin(numpy.log(aspects / aspect)**2)\n    repeat = numpy.array([1, 1, 1], numpy.int_)\n    repeat[indices] = na.flatten()[min_i], nb.flatten()[min_i]\n    return self.repeat(repeat)\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.explode","title":"<code>explode()</code>","text":"<p>Materialize repeated cells as one supercell.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def explode(self: HasAtomCellT) -&gt; HasAtomCellT:\n    \"\"\"Materialize repeated cells as one supercell.\"\"\"\n    frame = self.get_frame()\n\n    return self.with_atoms(self.get_atoms('local'), 'local') \\\n        .with_cell(self.get_cell().explode()) \\\n        .to_frame(frame)\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.periodic_duplicate","title":"<code>periodic_duplicate(eps=1e-05)</code>","text":"<p>Add duplicate copies of atoms near periodic boundaries.</p> <p>For instance, an atom at a corner will be duplicated into 8 copies. This is mostly only useful for visualization.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def periodic_duplicate(self: HasAtomCellT, eps: float = 1e-5) -&gt; HasAtomCellT:\n    \"\"\"\n    Add duplicate copies of atoms near periodic boundaries.\n\n    For instance, an atom at a corner will be duplicated into 8 copies.\n    This is mostly only useful for visualization.\n    \"\"\"\n    frame_save = self.get_frame()\n    self = self.to_frame('cell_box').wrap(eps=eps)\n\n    for i in range(3):\n        self = self.concat((self,\n            self.filter(polars.col('coords').arr.get(i).abs() &lt;= eps, frame='cell_box')\n                .transform_atoms(AffineTransform3D.translate([1. if i == j else 0. for j in range(3)]), frame='cell_box')\n        ))\n\n    return self.to_frame(frame_save)\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.describe","title":"<code>describe(percentiles=(0.25, 0.5, 0.75), *, interpolation='nearest', frame=None)</code>","text":"<p>Return summary statistics for <code>self</code>.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_get\ndef describe(self, percentiles: t.Union[t.Sequence[float], float, None] = (0.25, 0.5, 0.75), *,\n             interpolation: RollingInterpolationMethod = 'nearest',\n             frame: t.Optional[CoordinateFrame] = None) -&gt; polars.DataFrame:\n    \"\"\"Return summary statistics for `self`.\"\"\"\n    ...\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.with_columns","title":"<code>with_columns(*exprs, frame=None, **named_exprs)</code>","text":"<p>Return a copy of <code>self</code> with the given columns added.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef with_columns(self: HasAtomCellT,\n                 *exprs: t.Union[IntoExpr, t.Iterable[IntoExpr]],\n                 frame: t.Optional[CoordinateFrame] = None,\n                 **named_exprs: IntoExpr) -&gt; HasAtomCellT:\n    \"\"\"Return a copy of ``self`` with the given columns added.\"\"\"\n    ...\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.get_column","title":"<code>get_column(name, *, frame=None)</code>","text":"<p>Get the specified column from <code>self</code>, raising <code>polars.ColumnNotFoundError</code> if it's not present.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_get\ndef get_column(self, name: str, *, frame: t.Optional[CoordinateFrame] = None) -&gt; polars.Series:\n    \"\"\"Get the specified column from `self`, raising [`polars.ColumnNotFoundError`][polars.exceptions.ColumnNotFoundError] if it's not present.\"\"\"\n    ...\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.get_columns","title":"<code>get_columns(*, frame=None)</code>","text":"<p>Get the specified columns from <code>self</code>, raising <code>polars.ColumnNotFoundError</code> if it's not present.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_get\ndef get_columns(self, *, frame: t.Optional[CoordinateFrame] = None) -&gt; t.List[polars.Series]:\n    \"\"\"Get the specified columns from `self`, raising [`polars.ColumnNotFoundError`][polars.exceptions.ColumnNotFoundError] if it's not present.\"\"\"\n    ...\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.group_by","title":"<code>group_by(*by, maintain_order=False, frame=None, **named_by)</code>","text":"Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_get\ndef group_by(self, *by: t.Union[IntoExpr, t.Iterable[IntoExpr]],\n             maintain_order: bool = False, frame: t.Optional[CoordinateFrame] = None,\n             **named_by: IntoExpr) -&gt; polars.dataframe.group_by.GroupBy:\n    ...\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.pipe","title":"<code>pipe(function, *args, **kwargs)</code>","text":"<p>Apply <code>function</code> to <code>self</code> (in method-call syntax).</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def pipe(self: HasAtomCellT, function: t.Callable[Concatenate[HasAtomCellT, P], T], *args: P.args, **kwargs: P.kwargs) -&gt; T:\n    \"\"\"Apply `function` to `self` (in method-call syntax).\"\"\"\n    return function(self, *args, **kwargs)\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.filter","title":"<code>filter(*predicates, frame=None, **constraints)</code>","text":"<p>Filter <code>self</code>, removing rows which evaluate to <code>False</code>.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef filter(\n    self: HasAtomCellT,\n    *predicates: t.Union[None, IntoExprColumn, t.Iterable[IntoExprColumn], bool, t.List[bool], numpy.ndarray],\n    frame: t.Optional[CoordinateFrame] = None,\n    **constraints: t.Any,\n) -&gt; HasAtomCellT:\n    \"\"\"Filter `self`, removing rows which evaluate to `False`.\"\"\"\n    ...\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.sort","title":"<code>sort(by, *more_by, descending=False, nulls_last=False)</code>","text":"<p>Sort the atoms in <code>self</code> by the given columns/expressions.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef sort(\n    self: HasAtomCellT,\n    by: t.Union[IntoExpr, t.Iterable[IntoExpr]],\n    *more_by: IntoExpr,\n    descending: t.Union[bool, t.Sequence[bool]] = False,\n    nulls_last: bool = False,\n) -&gt; HasAtomCellT:\n    \"\"\"\n    Sort the atoms in `self` by the given columns/expressions.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.slice","title":"<code>slice(offset, length=None, *, frame=None)</code>","text":"<p>Return a slice of the rows in <code>self</code>.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef slice(self: HasAtomCellT, offset: int, length: t.Optional[int] = None, *,\n          frame: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n    \"\"\"Return a slice of the rows in `self`.\"\"\"\n    ...\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.head","title":"<code>head(n=5, *, frame=None)</code>","text":"<p>Return the first <code>n</code> rows of <code>self</code>.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef head(self: HasAtomCellT, n: int = 5, *, frame: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n    \"\"\"Return the first `n` rows of `self`.\"\"\"\n    ...\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.tail","title":"<code>tail(n=5, *, frame=None)</code>","text":"<p>Return the last <code>n</code> rows of <code>self</code>.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef tail(self: HasAtomCellT, n: int = 5, *, frame: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n    \"\"\"Return the last `n` rows of `self`.\"\"\"\n    ...\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.fill_null","title":"<code>fill_null(value=None, strategy=None, limit=None, matches_supertype=True)</code>","text":"Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef fill_null(\n    self: HasAtomCellT, value: t.Any = None, strategy: t.Optional[FillNullStrategy] = None,\n    limit: t.Optional[int] = None, matches_supertype: bool = True,\n) -&gt; HasAtomCellT:\n    ...\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.fill_nan","title":"<code>fill_nan(value, *, frame=None)</code>","text":"Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef fill_nan(self: HasAtomCellT, value: t.Union[polars.Expr, int, float, None], *,\n             frame: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n    ...\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.select","title":"<code>select(*exprs, frame=None, **named_exprs)</code>","text":"<p>Select <code>exprs`` from ``self</code>, and return as a <code>polars.DataFrame</code>.</p> <p>Expressions may either be columns or expressions of columns.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_get\ndef select(\n    self, *exprs: t.Union[IntoExpr, t.Iterable[IntoExpr]],\n    frame: t.Optional[CoordinateFrame] = None,\n    **named_exprs: IntoExpr\n) -&gt; polars.DataFrame:\n    \"\"\"\n    Select `exprs`` from ``self`, and return as a `polars.DataFrame`.\n\n    Expressions may either be columns or expressions of columns.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.select_props","title":"<code>select_props(*exprs, frame=None, **named_exprs)</code>","text":"<p>Select <code>exprs</code> from <code>self</code>, while keeping required columns.</p> <p>Returns a HasAtoms.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef select_props(\n    self: HasAtomCellT,\n    *exprs: t.Union[IntoExpr, t.Iterable[IntoExpr]],\n    frame: t.Optional[CoordinateFrame] = None,\n    **named_exprs: IntoExpr\n) -&gt; HasAtomCellT:\n    \"\"\"\n    Select `exprs` from `self`, while keeping required columns.\n\n    Returns a HasAtoms.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.try_select","title":"<code>try_select(*exprs, frame=None, **named_exprs)</code>","text":"<p>Try to select <code>exprs</code> from <code>self</code>, and return as a <code>polars.DataFrame</code>.</p> <p>Expressions may either be columns or expressions of columns. Return <code>None</code> if any columns are missing.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_get\ndef try_select(\n    self, *exprs: t.Union[IntoExpr, t.Iterable[IntoExpr]],\n    frame: t.Optional[CoordinateFrame] = None,\n    **named_exprs: IntoExpr\n) -&gt; t.Optional[polars.DataFrame]:\n    \"\"\"\n    Try to select `exprs` from `self`, and return as a `polars.DataFrame`.\n\n    Expressions may either be columns or expressions of columns.\n    Return `None` if any columns are missing.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.round_near_zero","title":"<code>round_near_zero(tol=1e-14, *, frame=None)</code>","text":"<p>Round atom position values near zero to zero.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef round_near_zero(self: HasAtomCellT, tol: float = 1e-14, *,\n                    frame: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n    \"\"\"\n    Round atom position values near zero to zero.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.coords","title":"<code>coords(selection=None, *, frame=None)</code>","text":"<p>Returns a <code>(N, 3)</code> ndarray of atom coordinates (dtype <code>numpy.float64</code>).</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_get\ndef coords(self, selection: t.Optional[AtomSelection] = None, *, frame: t.Optional[CoordinateFrame] = None) -&gt; NDArray[numpy.float64]:\n    \"\"\"Returns a `(N, 3)` ndarray of atom coordinates (dtype ``numpy.float64``).\"\"\"\n    ...\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.velocities","title":"<code>velocities(selection=None, *, frame=None)</code>","text":"<p>Returns a <code>(N, 3)</code> ndarray of atom velocities (dtype <code>numpy.float64</code>).</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_get\ndef velocities(self, selection: t.Optional[AtomSelection] = None, *, frame: t.Optional[CoordinateFrame] = None) -&gt; t.Optional[NDArray[numpy.float64]]:\n    \"\"\"Returns a `(N, 3)` ndarray of atom velocities (dtype ``numpy.float64``).\"\"\"\n    ...\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.add_atom","title":"<code>add_atom(elem, /, x, y=None, z=None, *, frame=None, **kwargs)</code>","text":"<p>Return a copy of <code>self</code> with an extra atom.</p> <p>By default, all extra columns present in <code>self</code> must be specified as <code>**kwargs</code>.</p> <p>Try to avoid calling this in a loop (Use meth:<code>concat</code> instead).</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef add_atom(self: HasAtomCellT, elem: t.Union[int, str], /,  # type: ignore (spurious)\n             x: t.Union[ArrayLike, float],\n             y: t.Optional[float] = None,\n             z: t.Optional[float] = None, *,\n             frame: t.Optional[CoordinateFrame] = None,\n             **kwargs: t.Any) -&gt; HasAtomCellT:\n    \"\"\"\n    Return a copy of ``self`` with an extra atom.\n\n    By default, all extra columns present in ``self`` must be specified as ``**kwargs``.\n\n    Try to avoid calling this in a loop (Use :py:meth:`concat` instead).\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.with_index","title":"<code>with_index(index=None, *, frame=None)</code>","text":"<p>Returns <code>self</code> with a row index added in column 'i' (dtype polars.Int64). If <code>index</code> is not specified, defaults to an existing index or a new index.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef with_index(self: HasAtomCellT, index: t.Optional[AtomValues] = None, *,\n               frame: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n    \"\"\"\n    Returns ``self`` with a row index added in column 'i' (dtype polars.Int64).\n    If ``index`` is not specified, defaults to an existing index or a new index.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.with_wobble","title":"<code>with_wobble(wobble=None, *, frame=None)</code>","text":"<p>Return <code>self</code> with the given displacements in column 'wobble' (dtype polars.Float64). If <code>wobble</code> is not specified, defaults to the already-existing wobbles or 0.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef with_wobble(self: HasAtomCellT, wobble: t.Optional[AtomValues] = None, *,\n                frame: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n    \"\"\"\n    Return ``self`` with the given displacements in column 'wobble' (dtype polars.Float64).\n    If ``wobble`` is not specified, defaults to the already-existing wobbles or 0.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.with_occupancy","title":"<code>with_occupancy(frac_occupancy=None, *, frame=None)</code>","text":"<p>Return self with the given fractional occupancies. If <code>frac_occupancy</code> is not specified, defaults to the already-existing occupancies or 1.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef with_occupancy(self: HasAtomCellT, frac_occupancy: t.Optional[AtomValues] = None, *,\n                   frame: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n    \"\"\"\n    Return self with the given fractional occupancies. If ``frac_occupancy`` is not specified,\n    defaults to the already-existing occupancies or 1.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.apply_wobble","title":"<code>apply_wobble(rng=None, frame=None)</code>","text":"<p>Displace the atoms in <code>self</code> by the amount in the <code>wobble</code> column. <code>wobble</code> is interpretated as a mean-squared displacement, which is distributed equally over each axis.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef apply_wobble(self: HasAtomCellT, rng: t.Union[numpy.random.Generator, int, None] = None,\n                 frame: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n    \"\"\"\n    Displace the atoms in ``self`` by the amount in the `wobble` column.\n    ``wobble`` is interpretated as a mean-squared displacement, which is distributed\n    equally over each axis.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.with_type","title":"<code>with_type(types=None, *, frame=None)</code>","text":"<p>Return <code>self</code> with the given atom types in column 'type'. If <code>types</code> is not specified, use the already existing types or auto-assign them.</p> <p>When auto-assigning, each symbol is given a unique value, case-sensitive. Values are assigned from lowest atomic number to highest. For instance: <code>[\"Ag+\", \"Na\", \"H\", \"Ag\"]</code> =&gt; <code>[3, 11, 1, 2]</code></p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef with_type(self: HasAtomCellT, types: t.Optional[AtomValues] = None, *,\n              frame: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n    \"\"\"\n    Return ``self`` with the given atom types in column 'type'.\n    If ``types`` is not specified, use the already existing types or auto-assign them.\n\n    When auto-assigning, each symbol is given a unique value, case-sensitive.\n    Values are assigned from lowest atomic number to highest.\n    For instance: ``[\"Ag+\", \"Na\", \"H\", \"Ag\"]`` =&gt; ``[3, 11, 1, 2]``\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.with_mass","title":"<code>with_mass(mass=None, *, frame=None)</code>","text":"<p>Return <code>self</code> with the given atom masses in column 'mass'. If <code>mass</code> is not specified, use the already existing masses or auto-assign them.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef with_mass(self: HasAtomCellT, mass: t.Optional[ArrayLike] = None, *,\n              frame: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n    \"\"\"\n    Return ``self`` with the given atom masses in column 'mass'.\n    If ``mass`` is not specified, use the already existing masses or auto-assign them.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.with_symbol","title":"<code>with_symbol(symbols, selection=None, *, frame=None)</code>","text":"<p>Return <code>self</code> with the given atomic symbols.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef with_symbol(self: HasAtomCellT, symbols: ArrayLike, selection: t.Optional[AtomSelection] = None, *,\n                frame: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n    \"\"\"\n    Return ``self`` with the given atomic symbols.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.with_coords","title":"<code>with_coords(pts, selection=None, *, frame=None)</code>","text":"<p>Return <code>self</code> replaced with the given atomic positions.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef with_coords(self: HasAtomCellT, pts: ArrayLike, selection: t.Optional[AtomSelection] = None, *,\n                frame: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n    \"\"\"\n    Return ``self`` replaced with the given atomic positions.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/#atomlib.HasAtomCell.with_velocity","title":"<code>with_velocity(pts=None, selection=None, *, frame=None)</code>","text":"<p>Return <code>self</code> replaced with the given atomic velocities. If <code>pts</code> is not specified, use the already existing velocities or zero.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef with_velocity(self: HasAtomCellT, pts: t.Optional[ArrayLike] = None,\n                  selection: t.Optional[AtomSelection] = None, *,\n                  frame: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n    \"\"\"\n    Return ``self`` replaced with the given atomic velocities.\n    If ``pts`` is not specified, use the already existing velocities or zero.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/atomcell/","title":"<code>atomlib.atomcell</code>","text":"<p>class:<code>Atoms</code> with an associated class:<code>Cell</code>.</p> <p>This module defines class:<code>HasAtomCell</code> and the concrete class:<code>AtomCell</code>, which combines the functionality of class:<code>HasAtoms</code> and class:<code>HasCell</code>.</p>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCellT","title":"<code>AtomCellT = t.TypeVar('AtomCellT', bound='AtomCell')</code>  <code>module-attribute</code>","text":""},{"location":"api/atomcell/#atomlib.atomcell.HasAtomCellT","title":"<code>HasAtomCellT = t.TypeVar('HasAtomCellT', bound='HasAtomCell')</code>  <code>module-attribute</code>","text":""},{"location":"api/atomcell/#atomlib.atomcell.HasAtomCell","title":"<code>HasAtomCell</code>","text":"<p>             Bases: <code>HasAtoms</code>, <code>HasCell</code>, <code>ABC</code></p> Source code in <code>atomlib/atomcell.py</code> <pre><code>class HasAtomCell(HasAtoms, HasCell, abc.ABC):\n    @abc.abstractmethod\n    def get_frame(self) -&gt; CoordinateFrame:\n        \"\"\"Get the coordinate frame atoms are stored in.\"\"\"\n        ...\n\n    @abc.abstractmethod\n    def with_atoms(self: HasAtomCellT, atoms: HasAtoms, frame: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n        \"\"\"\n        Replace the atoms in ``self``. If no coordinate frame is specified, keep the coordinate frame unchanged.\n        \"\"\"\n        ...\n\n    def with_cell(self: HasAtomCellT, cell: Cell) -&gt; HasAtomCellT:\n        \"\"\"\n        Replace the cell in ``self``, without touching the atomic coordinates.\n        \"\"\"\n        return self.to_frame('local').with_cell(cell)\n\n    def get_atomcell(self) -&gt; AtomCell:\n        frame = self.get_frame()\n        return AtomCell(self.get_atoms(frame), self.get_cell(), frame=frame, keep_frame=True)\n\n    @abc.abstractmethod\n    def get_atoms(self, frame: t.Optional[CoordinateFrame] = None) -&gt; Atoms:\n        \"\"\"Get atoms contained in ``self``, in the given coordinate frame.\"\"\"\n        ...\n\n    def bbox_atoms(self, frame: t.Optional[CoordinateFrame] = None) -&gt; BBox3D:\n        \"\"\"Return the bounding box of all the atoms in ``self``, in the given coordinate frame.\"\"\"\n        return self.get_atoms(frame).bbox()\n\n    def bbox(self, frame: CoordinateFrame = 'local') -&gt; BBox3D:\n        \"\"\"\n        Return the combined bounding box of the cell and atoms in the given coordinate system.\n        To get the cell or atoms bounding box only, use :py:meth:`bbox_cell` or :py:meth:`bbox_atoms`.\n        \"\"\"\n        return self.bbox_atoms(frame) | self.bbox_cell(frame)\n\n    # transformation\n\n    def _transform_atoms_in_frame(self, frame: t.Optional[CoordinateFrame], f: t.Callable[[Atoms], Atoms]) -&gt; Atoms:\n        # ugly code\n        if frame is None or frame == self.get_frame():\n            return f(self.get_atoms())\n        return f(self.get_atoms(frame)).transform(self.get_transform(self.get_frame(), frame))\n\n    def to_frame(self: HasAtomCellT, frame: CoordinateFrame) -&gt; HasAtomCellT:\n        \"\"\"Convert the stored Atoms to the given coordinate frame.\"\"\"\n        return self.with_atoms(self.get_atoms(frame), frame)\n\n    def transform_atoms(self: HasAtomCellT, transform: IntoTransform3D, selection: t.Optional[AtomSelection] = None, *,\n                        frame: CoordinateFrame = 'local', transform_velocities: bool = False) -&gt; HasAtomCellT:\n        \"\"\"\n        Transform the atoms in `self` by `transform`.\n        If `selection` is given, only transform the atoms in `selection`.\n        \"\"\"\n        transform = self.change_transform(Transform3D.make(transform), self.get_frame(), frame)\n        return self.with_atoms(self.get_atoms(self.get_frame()).transform(transform, selection, transform_velocities=transform_velocities))\n\n    def transform_cell(self: HasAtomCellT, transform: AffineTransform3D, frame: CoordinateFrame = 'local') -&gt; HasAtomCellT:\n        \"\"\"\n        Apply the given transform to the unit cell, without changing atom positions.\n        The transform is applied in coordinate frame 'frame'.\n        \"\"\"\n        return self.with_cell(self.get_cell().transform_cell(transform, frame=frame))\n\n    def transform(self: HasAtomCellT, transform: AffineTransform3D, frame: CoordinateFrame = 'local') -&gt; HasAtomCellT:\n        if isinstance(transform, Transform3D) and not isinstance(transform, AffineTransform3D):\n            raise ValueError(\"Non-affine transforms cannot change the box dimensions. Use 'transform_atoms' instead.\")\n        # TODO: cleanup once tests pass\n        # coordinate change the transform into atomic coordinates\n        new_cell = self.get_cell().transform_cell(transform, frame)\n        transform = self.get_cell().change_transform(transform, self.get_frame(), frame)\n        return self.with_atoms(self.get_atoms().transform(transform), self.get_frame()).with_cell(new_cell)\n\n    # crop methods\n\n    def crop(self: HasAtomCellT, x_min: float = -numpy.inf, x_max: float = numpy.inf,\n             y_min: float = -numpy.inf, y_max: float = numpy.inf,\n             z_min: float = -numpy.inf, z_max: float = numpy.inf, *,\n             frame: CoordinateFrame = 'local') -&gt; HasAtomCellT:\n        \"\"\"\n        Crop atoms and cell to the given extents. For a non-orthogonal\n        cell, this must be specified in cell coordinates. This\n        function implicity `explode`s the cell as well.\n\n        To crop atoms only, use `crop_atoms` instead.\n        \"\"\"\n\n        cell = self.get_cell().crop(x_min, x_max, y_min, y_max, z_min, z_max, frame=frame)\n        atoms = self._transform_atoms_in_frame(frame, lambda atoms: atoms.crop_atoms(x_min, x_max, y_min, y_max, z_min, z_max))\n        return self.with_cell(cell).with_atoms(atoms)\n\n    def crop_atoms(self: HasAtomCellT, x_min: float = -numpy.inf, x_max: float = numpy.inf,\n                   y_min: float = -numpy.inf, y_max: float = numpy.inf,\n                   z_min: float = -numpy.inf, z_max: float = numpy.inf, *,\n                   frame: CoordinateFrame = 'local') -&gt; HasAtomCellT:\n        atoms = self._transform_atoms_in_frame(frame, lambda atoms: atoms.crop_atoms(x_min, x_max, y_min, y_max, z_min, z_max))\n        return self.with_atoms(atoms)\n\n    def crop_to_box(self: HasAtomCellT, eps: float = 1e-5) -&gt; HasAtomCellT:\n        atoms = self._transform_atoms_in_frame('cell_box', lambda atoms: atoms.crop_atoms(*([-eps, 1-eps]*3)))\n        return self.with_atoms(atoms)\n\n    def wrap(self: HasAtomCellT, eps: float = 1e-5) -&gt; HasAtomCellT:\n        \"\"\"Wrap atoms around the cell boundaries.\"\"\"\n        return self.with_atoms(self._transform_atoms_in_frame('cell_box', lambda a: a._wrap(eps)))\n\n    def _repeat_to_contain(self: HasAtomCellT, pts: numpy.ndarray, pad: int = 0, frame: CoordinateFrame = 'cell_frac') -&gt; HasAtomCellT:\n        #print(f\"pts: {pts} in frame {frame}\")\n        pts = self.get_transform('cell_frac', frame) @ pts\n\n        bbox = BBox3D.unit() | BBox3D.from_pts(pts)\n        min_bounds = numpy.floor(bbox.min).astype(int) - pad\n        max_bounds = numpy.ceil(bbox.max).astype(int) + pad\n        #print(f\"tiling to {min_bounds}, {max_bounds}\")\n        repeat = max_bounds - min_bounds\n        cells = numpy.stack(numpy.meshgrid(*map(numpy.arange, repeat))).reshape(3, -1).T.astype(float)\n\n        atoms = self.get_atoms('cell_frac')\n        atoms = Atoms.concat([\n            atoms.transform(AffineTransform3D.translate(cell))\n            for cell in cells\n        ])\n        #print(f\"atoms:\\n{atoms}\")\n        cell = self.get_cell().repeat(repeat) \\\n            .transform_cell(AffineTransform3D.translate(min_bounds), 'cell_frac')\n        return self.with_cell(cell).with_atoms(atoms, 'cell_frac')\n\n    def repeat(self: HasAtomCellT, n: t.Union[int, VecLike]) -&gt; HasAtomCellT:\n        \"\"\"Tile the cell\"\"\"\n        ns = numpy.broadcast_to(n, 3)\n        if not numpy.issubdtype(ns.dtype, numpy.integer):\n            raise ValueError(f\"repeat() argument must be an integer or integer array.\")\n\n        cells = numpy.stack(numpy.meshgrid(*map(numpy.arange, ns))) \\\n            .reshape(3, -1).T.astype(float)\n        cells = cells * self.box_size\n\n        atoms = self.get_atoms('cell')\n        atoms = Atoms.concat([\n            atoms.transform(AffineTransform3D.translate(cell))\n            for cell in cells\n        ]) #.transform(self.cell.get_transform('local', 'cell_frac'))\n        return self.with_atoms(atoms, 'cell').with_cell(self.get_cell().repeat(ns))\n\n    def repeat_to(self: HasAtomCellT, size: VecLike, crop: t.Union[bool, t.Sequence[bool]] = False) -&gt; HasAtomCellT:\n        \"\"\"\n        Repeat the cell so it is at least ``size`` along the crystal's axes.\n\n        If ``crop``, then crop the cell to exactly ``size``. This may break periodicity.\n        ``crop`` may be a vector, in which case you can specify cropping only along some axes.\n        \"\"\"\n        size = to_vec3(size)\n        cell_size = self.cell_size * self.n_cells\n        repeat = numpy.maximum(numpy.ceil(size / cell_size).astype(int), 1)\n        atom_cell = self.repeat(repeat)\n\n        crop_v = to_vec3(crop, dtype=numpy.bool_)\n        if numpy.any(crop_v):\n            crop_x, crop_y, crop_z = crop_v\n            return atom_cell.crop(\n                x_max = size[0] if crop_x else numpy.inf,\n                y_max = size[1] if crop_y else numpy.inf,\n                z_max = size[2] if crop_z else numpy.inf,\n                frame='cell'\n            )\n\n        return atom_cell\n\n    def repeat_x(self: HasAtomCellT, n: int) -&gt; HasAtomCellT:\n        \"\"\"Tile the cell in the x axis.\"\"\"\n        return self.repeat((n, 1, 1))\n\n    def repeat_y(self: HasAtomCellT, n: int) -&gt; HasAtomCellT:\n        \"\"\"Tile the cell in the y axis.\"\"\"\n        return self.repeat((1, n, 1))\n\n    def repeat_z(self: HasAtomCellT, n: int) -&gt; HasAtomCellT:\n        \"\"\"Tile the cell in the z axis.\"\"\"\n        return self.repeat((1, 1, n))\n\n    def repeat_to_x(self: HasAtomCellT, size: float, crop: bool = False) -&gt; HasAtomCellT:\n        \"\"\"Repeat the cell so it is at least size ``size`` along the x axis.\"\"\"\n        return self.repeat_to([size, 0., 0.], [crop, False, False])\n\n    def repeat_to_y(self: HasAtomCellT, size: float, crop: bool = False) -&gt; HasAtomCellT:\n        \"\"\"Repeat the cell so it is at least size ``size`` along the y axis.\"\"\"\n        return self.repeat_to([0., size, 0.], [False, crop, False])\n\n    def repeat_to_z(self: HasAtomCellT, size: float, crop: bool = False) -&gt; HasAtomCellT:\n        \"\"\"Repeat the cell so it is at least size ``size`` along the z axis.\"\"\"\n        return self.repeat_to([0., 0., size], [False, False, crop])\n\n    def repeat_to_aspect(self: HasAtomCellT, plane: t.Literal['xy', 'xz', 'yz'] = 'xy', *,\n                         aspect: float = 1., min_size: t.Optional[VecLike] = None,\n                         max_size: t.Optional[VecLike] = None) -&gt; HasAtomCellT:\n        \"\"\"\n        Repeat to optimize the aspect ratio in ``plane``,\n        while staying above ``min_size`` and under ``max_size``.\n        \"\"\"\n        if min_size is None:\n            min_n = numpy.array([1, 1, 1], numpy.int_)\n        else:\n            min_n = numpy.maximum(numpy.ceil(to_vec3(min_size) / self.box_size), 1).astype(numpy.int_)\n\n        if max_size is None:\n            max_n = 3 * min_n\n        else:\n            max_n = numpy.maximum(numpy.floor(to_vec3(max_size) / self.box_size), 1).astype(numpy.int_)\n\n        if plane == 'xy':\n            indices = [0, 1]\n        elif plane == 'xz':\n            indices = [0, 2]\n        elif plane == 'yz':\n            indices = [1, 2]\n        else:\n            raise ValueError(f\"Invalid plane '{plane}'. Exepcted 'xy', 'xz', 'or 'yz'.\")\n\n        na = numpy.arange(min_n[indices[0]], max_n[indices[0]])\n        nb = numpy.arange(min_n[indices[1]], max_n[indices[1]])\n        (na, nb) = numpy.meshgrid(na, nb)\n\n        aspects = na * self.box_size[indices[0]] / (nb * self.box_size[indices[1]])\n        # cost function: log(aspect)^2  (so cost(0.5) == cost(2))\n        min_i = numpy.argmin(numpy.log(aspects / aspect)**2)\n        repeat = numpy.array([1, 1, 1], numpy.int_)\n        repeat[indices] = na.flatten()[min_i], nb.flatten()[min_i]\n        return self.repeat(repeat)\n\n    def explode(self: HasAtomCellT) -&gt; HasAtomCellT:\n        \"\"\"Materialize repeated cells as one supercell.\"\"\"\n        frame = self.get_frame()\n\n        return self.with_atoms(self.get_atoms('local'), 'local') \\\n            .with_cell(self.get_cell().explode()) \\\n            .to_frame(frame)\n\n    def periodic_duplicate(self: HasAtomCellT, eps: float = 1e-5) -&gt; HasAtomCellT:\n        \"\"\"\n        Add duplicate copies of atoms near periodic boundaries.\n\n        For instance, an atom at a corner will be duplicated into 8 copies.\n        This is mostly only useful for visualization.\n        \"\"\"\n        frame_save = self.get_frame()\n        self = self.to_frame('cell_box').wrap(eps=eps)\n\n        for i in range(3):\n            self = self.concat((self,\n                self.filter(polars.col('coords').arr.get(i).abs() &lt;= eps, frame='cell_box')\n                    .transform_atoms(AffineTransform3D.translate([1. if i == j else 0. for j in range(3)]), frame='cell_box')\n            ))\n\n        return self.to_frame(frame_save)\n\n    # add frame to some HasAtoms methods\n\n    @_fwd_atoms_get\n    def describe(self, percentiles: t.Union[t.Sequence[float], float, None] = (0.25, 0.5, 0.75), *,\n                 interpolation: RollingInterpolationMethod = 'nearest',\n                 frame: t.Optional[CoordinateFrame] = None) -&gt; polars.DataFrame:\n        \"\"\"Return summary statistics for `self`.\"\"\"\n        ...\n\n    @_fwd_atoms_transform\n    def with_columns(self: HasAtomCellT,\n                     *exprs: t.Union[IntoExpr, t.Iterable[IntoExpr]],\n                     frame: t.Optional[CoordinateFrame] = None,\n                     **named_exprs: IntoExpr) -&gt; HasAtomCellT:\n        \"\"\"Return a copy of ``self`` with the given columns added.\"\"\"\n        ...\n\n    with_column = with_columns\n\n    @_fwd_atoms_get\n    def get_column(self, name: str, *, frame: t.Optional[CoordinateFrame] = None) -&gt; polars.Series:\n        \"\"\"Get the specified column from `self`, raising [`polars.ColumnNotFoundError`][polars.exceptions.ColumnNotFoundError] if it's not present.\"\"\"\n        ...\n\n    @_fwd_atoms_get\n    def get_columns(self, *, frame: t.Optional[CoordinateFrame] = None) -&gt; t.List[polars.Series]:\n        \"\"\"Get the specified columns from `self`, raising [`polars.ColumnNotFoundError`][polars.exceptions.ColumnNotFoundError] if it's not present.\"\"\"\n        ...\n\n    @_fwd_atoms_get\n    def group_by(self, *by: t.Union[IntoExpr, t.Iterable[IntoExpr]],\n                 maintain_order: bool = False, frame: t.Optional[CoordinateFrame] = None,\n                 **named_by: IntoExpr) -&gt; polars.dataframe.group_by.GroupBy:\n        ...\n\n    def pipe(self: HasAtomCellT, function: t.Callable[Concatenate[HasAtomCellT, P], T], *args: P.args, **kwargs: P.kwargs) -&gt; T:\n        \"\"\"Apply `function` to `self` (in method-call syntax).\"\"\"\n        return function(self, *args, **kwargs)\n\n    @_fwd_atoms_transform\n    def filter(\n        self: HasAtomCellT,\n        *predicates: t.Union[None, IntoExprColumn, t.Iterable[IntoExprColumn], bool, t.List[bool], numpy.ndarray],\n        frame: t.Optional[CoordinateFrame] = None,\n        **constraints: t.Any,\n    ) -&gt; HasAtomCellT:\n        \"\"\"Filter `self`, removing rows which evaluate to `False`.\"\"\"\n        ...\n\n    @_fwd_atoms_transform\n    def sort(\n        self: HasAtomCellT,\n        by: t.Union[IntoExpr, t.Iterable[IntoExpr]],\n        *more_by: IntoExpr,\n        descending: t.Union[bool, t.Sequence[bool]] = False,\n        nulls_last: bool = False,\n    ) -&gt; HasAtomCellT:\n        \"\"\"\n        Sort the atoms in `self` by the given columns/expressions.\n        \"\"\"\n        ...\n\n    @_fwd_atoms_transform\n    def slice(self: HasAtomCellT, offset: int, length: t.Optional[int] = None, *,\n              frame: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n        \"\"\"Return a slice of the rows in `self`.\"\"\"\n        ...\n\n    @_fwd_atoms_transform\n    def head(self: HasAtomCellT, n: int = 5, *, frame: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n        \"\"\"Return the first `n` rows of `self`.\"\"\"\n        ...\n\n    @_fwd_atoms_transform\n    def tail(self: HasAtomCellT, n: int = 5, *, frame: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n        \"\"\"Return the last `n` rows of `self`.\"\"\"\n        ...\n\n    @_fwd_atoms_transform\n    def fill_null(\n        self: HasAtomCellT, value: t.Any = None, strategy: t.Optional[FillNullStrategy] = None,\n        limit: t.Optional[int] = None, matches_supertype: bool = True,\n    ) -&gt; HasAtomCellT:\n        ...\n\n    @_fwd_atoms_transform\n    def fill_nan(self: HasAtomCellT, value: t.Union[polars.Expr, int, float, None], *,\n                 frame: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n        ...\n\n    # TODO: partition_by\n\n    @_fwd_atoms_get\n    def select(\n        self, *exprs: t.Union[IntoExpr, t.Iterable[IntoExpr]],\n        frame: t.Optional[CoordinateFrame] = None,\n        **named_exprs: IntoExpr\n    ) -&gt; polars.DataFrame:\n        \"\"\"\n        Select `exprs`` from ``self`, and return as a `polars.DataFrame`.\n\n        Expressions may either be columns or expressions of columns.\n        \"\"\"\n        ...\n\n    @_fwd_atoms_transform\n    def select_props(\n        self: HasAtomCellT,\n        *exprs: t.Union[IntoExpr, t.Iterable[IntoExpr]],\n        frame: t.Optional[CoordinateFrame] = None,\n        **named_exprs: IntoExpr\n    ) -&gt; HasAtomCellT:\n        \"\"\"\n        Select `exprs` from `self`, while keeping required columns.\n\n        Returns a HasAtoms.\n        \"\"\"\n        ...\n\n    @_fwd_atoms_get\n    def try_select(\n        self, *exprs: t.Union[IntoExpr, t.Iterable[IntoExpr]],\n        frame: t.Optional[CoordinateFrame] = None,\n        **named_exprs: IntoExpr\n    ) -&gt; t.Optional[polars.DataFrame]:\n        \"\"\"\n        Try to select `exprs` from `self`, and return as a `polars.DataFrame`.\n\n        Expressions may either be columns or expressions of columns.\n        Return `None` if any columns are missing.\n        \"\"\"\n        ...\n\n    @_fwd_atoms_transform\n    def round_near_zero(self: HasAtomCellT, tol: float = 1e-14, *,\n                        frame: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n        \"\"\"\n        Round atom position values near zero to zero.\n        \"\"\"\n        ...\n\n    @_fwd_atoms_get\n    def coords(self, selection: t.Optional[AtomSelection] = None, *, frame: t.Optional[CoordinateFrame] = None) -&gt; NDArray[numpy.float64]:\n        \"\"\"Returns a `(N, 3)` ndarray of atom coordinates (dtype ``numpy.float64``).\"\"\"\n        ...\n\n    @_fwd_atoms_get\n    def velocities(self, selection: t.Optional[AtomSelection] = None, *, frame: t.Optional[CoordinateFrame] = None) -&gt; t.Optional[NDArray[numpy.float64]]:\n        \"\"\"Returns a `(N, 3)` ndarray of atom velocities (dtype ``numpy.float64``).\"\"\"\n        ...\n\n    @t.overload\n    def add_atom(self: HasAtomCellT, elem: t.Union[int, str], x: ArrayLike, /, *,\n                 y: None = None, z: None = None, frame: t.Optional[CoordinateFrame] = None,\n                 **kwargs: t.Any) -&gt; HasAtomCellT:\n        ...\n\n    @t.overload\n    def add_atom(self: HasAtomCellT, elem: t.Union[int, str], /,\n                 x: float, y: float, z: float, *,\n                 frame: t.Optional[CoordinateFrame] = None,\n                 **kwargs: t.Any) -&gt; HasAtomCellT:\n        ...\n\n    @_fwd_atoms_transform\n    def add_atom(self: HasAtomCellT, elem: t.Union[int, str], /,  # type: ignore (spurious)\n                 x: t.Union[ArrayLike, float],\n                 y: t.Optional[float] = None,\n                 z: t.Optional[float] = None, *,\n                 frame: t.Optional[CoordinateFrame] = None,\n                 **kwargs: t.Any) -&gt; HasAtomCellT:\n        \"\"\"\n        Return a copy of ``self`` with an extra atom.\n\n        By default, all extra columns present in ``self`` must be specified as ``**kwargs``.\n\n        Try to avoid calling this in a loop (Use :py:meth:`concat` instead).\n        \"\"\"\n        ...\n\n    @_fwd_atoms_transform\n    def with_index(self: HasAtomCellT, index: t.Optional[AtomValues] = None, *,\n                   frame: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n        \"\"\"\n        Returns ``self`` with a row index added in column 'i' (dtype polars.Int64).\n        If ``index`` is not specified, defaults to an existing index or a new index.\n        \"\"\"\n        ...\n\n    @_fwd_atoms_transform\n    def with_wobble(self: HasAtomCellT, wobble: t.Optional[AtomValues] = None, *,\n                    frame: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n        \"\"\"\n        Return ``self`` with the given displacements in column 'wobble' (dtype polars.Float64).\n        If ``wobble`` is not specified, defaults to the already-existing wobbles or 0.\n        \"\"\"\n        ...\n\n    @_fwd_atoms_transform\n    def with_occupancy(self: HasAtomCellT, frac_occupancy: t.Optional[AtomValues] = None, *,\n                       frame: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n        \"\"\"\n        Return self with the given fractional occupancies. If ``frac_occupancy`` is not specified,\n        defaults to the already-existing occupancies or 1.\n        \"\"\"\n        ...\n\n    @_fwd_atoms_transform\n    def apply_wobble(self: HasAtomCellT, rng: t.Union[numpy.random.Generator, int, None] = None,\n                     frame: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n        \"\"\"\n        Displace the atoms in ``self`` by the amount in the `wobble` column.\n        ``wobble`` is interpretated as a mean-squared displacement, which is distributed\n        equally over each axis.\n        \"\"\"\n        ...\n\n    @_fwd_atoms_transform\n    def with_type(self: HasAtomCellT, types: t.Optional[AtomValues] = None, *,\n                  frame: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n        \"\"\"\n        Return ``self`` with the given atom types in column 'type'.\n        If ``types`` is not specified, use the already existing types or auto-assign them.\n\n        When auto-assigning, each symbol is given a unique value, case-sensitive.\n        Values are assigned from lowest atomic number to highest.\n        For instance: ``[\"Ag+\", \"Na\", \"H\", \"Ag\"]`` =&gt; ``[3, 11, 1, 2]``\n        \"\"\"\n        ...\n\n    @_fwd_atoms_transform\n    def with_mass(self: HasAtomCellT, mass: t.Optional[ArrayLike] = None, *,\n                  frame: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n        \"\"\"\n        Return ``self`` with the given atom masses in column 'mass'.\n        If ``mass`` is not specified, use the already existing masses or auto-assign them.\n        \"\"\"\n        ...\n\n    @_fwd_atoms_transform\n    def with_symbol(self: HasAtomCellT, symbols: ArrayLike, selection: t.Optional[AtomSelection] = None, *,\n                    frame: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n        \"\"\"\n        Return ``self`` with the given atomic symbols.\n        \"\"\"\n        ...\n\n    @_fwd_atoms_transform\n    def with_coords(self: HasAtomCellT, pts: ArrayLike, selection: t.Optional[AtomSelection] = None, *,\n                    frame: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n        \"\"\"\n        Return ``self`` replaced with the given atomic positions.\n        \"\"\"\n        ...\n\n    @_fwd_atoms_transform\n    def with_velocity(self: HasAtomCellT, pts: t.Optional[ArrayLike] = None,\n                      selection: t.Optional[AtomSelection] = None, *,\n                      frame: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n        \"\"\"\n        Return ``self`` replaced with the given atomic velocities.\n        If ``pts`` is not specified, use the already existing velocities or zero.\n        \"\"\"\n        ...\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.HasAtomCell.affine","title":"<code>affine: AffineTransform3D</code>  <code>property</code>","text":"<p>Affine transformation. Holds transformation from 'ortho' to 'local' coordinates, including rotation away from the standard crystal orientation.</p>"},{"location":"api/atomcell/#atomlib.atomcell.HasAtomCell.ortho","title":"<code>ortho: LinearTransform3D</code>  <code>property</code>","text":"<p>Orthogonalization transformation. Skews but does not scale the crystal axes to cartesian axes.</p>"},{"location":"api/atomcell/#atomlib.atomcell.HasAtomCell.metric","title":"<code>metric: LinearTransform3D</code>  <code>property</code>","text":"<p>Cell metric tensor</p> <p>Returns the dot product between every combination of basis vectors. :math:<code>\\mathbf{a} \\cdot \\mathbf{b} = a_i M_ij b_j</code></p>"},{"location":"api/atomcell/#atomlib.atomcell.HasAtomCell.cell_size","title":"<code>cell_size: NDArray[numpy.float_]</code>  <code>property</code>","text":"<p>Unit cell size.</p>"},{"location":"api/atomcell/#atomlib.atomcell.HasAtomCell.cell_angle","title":"<code>cell_angle: NDArray[numpy.float_]</code>  <code>property</code>","text":"<p>Unit cell angles, in radians.</p>"},{"location":"api/atomcell/#atomlib.atomcell.HasAtomCell.n_cells","title":"<code>n_cells: NDArray[numpy.int_]</code>  <code>property</code>","text":"<p>Number of unit cells.</p>"},{"location":"api/atomcell/#atomlib.atomcell.HasAtomCell.pbc","title":"<code>pbc: NDArray[numpy.bool_]</code>  <code>property</code>","text":"<p>Flags indicating the presence of periodic boundary conditions along each axis.</p>"},{"location":"api/atomcell/#atomlib.atomcell.HasAtomCell.ortho_size","title":"<code>ortho_size: NDArray[numpy.float_]</code>  <code>property</code>","text":"<p>Return size of orthogonal unit cell.</p> <p>Equivalent to the diagonal of the orthogonalization matrix.</p>"},{"location":"api/atomcell/#atomlib.atomcell.HasAtomCell.box_size","title":"<code>box_size: NDArray[numpy.float_]</code>  <code>property</code>","text":"<p>Return size of the cell box.</p> <p>Equivalent to <code>self.n_cells * self.cell_size</code>.</p>"},{"location":"api/atomcell/#atomlib.atomcell.HasAtomCell.columns","title":"<code>columns: t.Sequence[str]</code>  <code>property</code>","text":"<p>Return the columns in <code>self</code>.</p>"},{"location":"api/atomcell/#atomlib.atomcell.HasAtomCell.dtypes","title":"<code>dtypes: t.Sequence[polars.DataType]</code>  <code>property</code>","text":"<p>Return the datatypes in <code>self</code>.</p>"},{"location":"api/atomcell/#atomlib.atomcell.HasAtomCell.schema","title":"<code>schema: SchemaDict</code>  <code>property</code>","text":"<p>Return the schema of <code>self</code>.</p>"},{"location":"api/atomcell/#atomlib.atomcell.HasAtomCell.unique","title":"<code>unique = deduplicate</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/atomcell/#atomlib.atomcell.HasAtomCell.with_column","title":"<code>with_column = with_columns</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/atomcell/#atomlib.atomcell.HasAtomCell.get_cell","title":"<code>get_cell()</code>  <code>abstractmethod</code>","text":"<p>Get the cell contained in <code>self</code>. This should be a low cost method.</p> Source code in <code>atomlib/cell.py</code> <pre><code>@abc.abstractmethod\ndef get_cell(self) -&gt; Cell:\n    \"\"\"Get the cell contained in ``self``. This should be a low cost method.\"\"\"\n    ...\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.HasAtomCell.get_transform","title":"<code>get_transform(frame_to=None, frame_from=None)</code>","text":"<p>In the two-argument form, get the transform to 'frame_to' from 'frame_from'. In the one-argument form, get the transform from local coordinates to 'frame'.</p> Source code in <code>atomlib/cell.py</code> <pre><code>def get_transform(self, frame_to: t.Optional[CoordinateFrame] = None, frame_from: t.Optional[CoordinateFrame] = None) -&gt; AffineTransform3D:\n    \"\"\"\n    In the two-argument form, get the transform to 'frame_to' from 'frame_from'.\n    In the one-argument form, get the transform from local coordinates to 'frame'.\n    \"\"\"\n    transform_from = self._get_transform_to_local(frame_from) if frame_from is not None else AffineTransform3D()\n    transform_to = self._get_transform_to_local(frame_to) if frame_to is not None else AffineTransform3D()\n    if frame_from is not None and frame_to is not None and frame_from.lower() == frame_to.lower():\n        return AffineTransform3D()\n    return transform_to.inverse() @ transform_from\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.HasAtomCell.corners","title":"<code>corners(frame='local')</code>","text":"Source code in <code>atomlib/cell.py</code> <pre><code>def corners(self, frame: CoordinateFrame = 'local') -&gt; numpy.ndarray:\n    corners = numpy.array(list(itertools.product((0., 1.), repeat=3)))\n    return self.get_transform(frame, 'cell_box') @ corners\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.HasAtomCell.bbox_cell","title":"<code>bbox_cell(frame='local')</code>","text":"<p>Return the bounding box of the cell box in the given coordinate system.</p> Source code in <code>atomlib/cell.py</code> <pre><code>def bbox_cell(self, frame: CoordinateFrame = 'local') -&gt; BBox3D:\n    \"\"\"Return the bounding box of the cell box in the given coordinate system.\"\"\"\n    return BBox3D.from_pts(self.corners(frame))\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.HasAtomCell.is_orthogonal","title":"<code>is_orthogonal(tol=1e-08)</code>","text":"<p>Returns whether this cell is orthogonal (axes are at right angles.)</p> Source code in <code>atomlib/cell.py</code> <pre><code>def is_orthogonal(self, tol: float = 1e-8) -&gt; bool:\n    \"\"\"Returns whether this cell is orthogonal (axes are at right angles.)\"\"\"\n    return self.ortho.is_diagonal(tol=tol)\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.HasAtomCell.is_orthogonal_in_local","title":"<code>is_orthogonal_in_local(tol=1e-08)</code>","text":"<p>Returns whether this cell is orthogonal and aligned with the local coordinate system.</p> Source code in <code>atomlib/cell.py</code> <pre><code>def is_orthogonal_in_local(self, tol: float = 1e-8) -&gt; bool:\n    \"\"\"Returns whether this cell is orthogonal and aligned with the local coordinate system.\"\"\"\n    transform = (self.affine @ self.ortho).to_linear()\n    if not transform.is_scaled_orthogonal(tol):\n        return False\n    normed = transform.inner / numpy.linalg.norm(transform.inner, axis=-2, keepdims=True)\n    # every row of transform must be a +/- 1 times a basis vector (i, j, or k)\n    return all(\n        any(numpy.isclose(numpy.abs(numpy.dot(row, v)), 1., atol=tol) for v in numpy.eye(3))\n        for row in normed\n    )\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.HasAtomCell.to_ortho","title":"<code>to_ortho()</code>","text":"Source code in <code>atomlib/cell.py</code> <pre><code>def to_ortho(self) -&gt; AffineTransform3D:\n    return self.get_transform('local', 'cell_box')\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.HasAtomCell.strain_orthogonal","title":"<code>strain_orthogonal()</code>","text":"<p>Orthogonalize using strain.</p> <p>Strain is applied such that the x-axis remains fixed, and the y-axis remains in the xy plane. For small displacements, no hydrostatic strain is applied (volume is conserved).</p> Source code in <code>atomlib/cell.py</code> <pre><code>def strain_orthogonal(self: HasCellT) -&gt; HasCellT:\n    \"\"\"\n    Orthogonalize using strain.\n\n    Strain is applied such that the x-axis remains fixed, and the y-axis remains in the xy plane.\n    For small displacements, no hydrostatic strain is applied (volume is conserved).\n    \"\"\"\n    return self.with_cell(Cell(\n        affine=self.affine,\n        ortho=LinearTransform3D(),\n        cell_size=self.cell_size,\n        n_cells=self.n_cells,\n        pbc=self.pbc,\n    ))\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.HasAtomCell.explode_z","title":"<code>explode_z()</code>","text":"<p>Materialize repeated cells as one supercell in z.</p> Source code in <code>atomlib/cell.py</code> <pre><code>def explode_z(self: HasCellT) -&gt; HasCellT:\n    \"\"\"Materialize repeated cells as one supercell in z.\"\"\"\n    return self.with_cell(Cell(\n        affine=self.affine,\n        ortho=self.ortho,\n        cell_size=self.cell_size*[1, 1, self.n_cells[2]],\n        n_cells=[*self.n_cells[:2], 1],\n        cell_angle=self.cell_angle,\n        pbc=self.pbc,\n    ))\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.HasAtomCell.change_transform","title":"<code>change_transform(transform, frame_to=None, frame_from=None)</code>","text":"<p>Coordinate-change a transformation to 'frame_to' from 'frame_from'.</p> Source code in <code>atomlib/cell.py</code> <pre><code>def change_transform(self, transform: Transform3D,\n                     frame_to: t.Optional[CoordinateFrame] = None,\n                     frame_from: t.Optional[CoordinateFrame] = None) -&gt; Transform3D:\n    \"\"\"Coordinate-change a transformation to 'frame_to' from 'frame_from'.\"\"\"\n    if frame_to == frame_from and frame_to is not None:\n        return transform\n    coord_change = self.get_transform(frame_to, frame_from)\n    return coord_change @ transform @ coord_change.inverse()\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.HasAtomCell.assert_equal","title":"<code>assert_equal(other)</code>","text":"Source code in <code>atomlib/atoms.py</code> <pre><code>def assert_equal(self, other: t.Any):\n    assert isinstance(other, HasAtoms)\n    assert dict(self.schema) == dict(other.schema)\n    for col in self.schema.keys():\n        polars.testing.assert_series_equal(self[col], other[col], check_names=False, rtol=1e-3, atol=1e-8)\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.HasAtomCell.insert_column","title":"<code>insert_column(index, column)</code>","text":"Source code in <code>atomlib/atoms.py</code> <pre><code>@_fwd_frame_map\ndef insert_column(self, index: int, column: polars.Series) -&gt; polars.DataFrame:\n    return self._get_frame().insert_column(index, column)\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.HasAtomCell.get_column_index","title":"<code>get_column_index(name)</code>","text":"<p>Get the index of a column by name, raising <code>polars.ColumnNotFoundError</code> if it's not present.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>@_fwd_frame(polars.DataFrame.get_column_index)\ndef get_column_index(self, name: str) -&gt; int:\n    \"\"\"Get the index of a column by name, raising [`polars.ColumnNotFoundError`][polars.exceptions.ColumnNotFoundError] if it's not present.\"\"\"\n    ...\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.HasAtomCell.clone","title":"<code>clone()</code>","text":"<p>Return a copy of <code>self</code>.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>@_fwd_frame_map\ndef clone(self) -&gt; polars.DataFrame:\n    \"\"\"Return a copy of `self`.\"\"\"\n    return self._get_frame().clone()\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.HasAtomCell.drop","title":"<code>drop(*columns)</code>","text":"<p>Return <code>self</code> with the specified columns removed.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def drop(self, *columns: t.Union[str, t.Iterable[str]]) -&gt; polars.DataFrame:\n    \"\"\"Return `self` with the specified columns removed.\"\"\"\n    return self._get_frame().drop(*columns)\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.HasAtomCell.drop_nulls","title":"<code>drop_nulls(subset=None)</code>","text":"<p>Drop rows that contain nulls in any of columns <code>subset</code>.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>@_fwd_frame_map\ndef drop_nulls(self, subset: t.Union[str, t.Collection[str], None] = None) -&gt; polars.DataFrame:\n    \"\"\"Drop rows that contain nulls in any of columns `subset`.\"\"\"\n    return self._get_frame().drop_nulls(subset)\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.HasAtomCell.concat","title":"<code>concat(atoms, *, rechunk=True, how='vertical')</code>  <code>classmethod</code>","text":"<p>Concatenate multiple <code>Atoms</code> together, handling metadata appropriately.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>@classmethod\ndef concat(cls: t.Type[HasAtomsT],\n           atoms: t.Union[HasAtomsT, IntoAtoms, t.Iterable[t.Union[HasAtomsT, IntoAtoms]]], *,\n           rechunk: bool = True, how: ConcatMethod = 'vertical') -&gt; HasAtomsT:\n    \"\"\"Concatenate multiple `Atoms` together, handling metadata appropriately.\"\"\"\n    # this method is tricky. It needs to accept raw Atoms, as well as HasAtoms of the\n    # same type as ``cls``.\n    if _is_abstract(cls):\n        raise TypeError(f\"concat() must be called on a concrete class.\")\n\n    if isinstance(atoms, HasAtoms):\n        atoms = (atoms,)\n    dfs = [a.get_atoms('local').inner if isinstance(a, HasAtoms) else Atoms(t.cast(IntoAtoms, a)).inner for a in atoms]\n    representative = cls._combine_metadata(*(a for a in atoms if isinstance(a, HasAtoms)))\n\n    if len(dfs) == 0:\n        return representative.with_atoms(Atoms.empty(), 'local')\n\n    if how in ('vertical', 'vertical_relaxed'):\n        # get order from first member\n        cols = dfs[0].columns\n        dfs = [df.select(cols) for df in dfs]\n    elif how == 'inner':\n        cols = reduce(operator.and_, (df.schema.keys() for df in dfs))\n        schema = OrderedDict((col, dfs[0].schema[col]) for col in cols)\n        if len(schema) == 0:\n            raise ValueError(f\"Atoms have no columns in common\")\n\n        dfs = [_select_schema(df, schema) for df in dfs]\n        how = 'vertical'\n\n    return representative.with_atoms(Atoms(polars.concat(dfs, rechunk=rechunk, how=how)), 'local')\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.HasAtomCell.partition_by","title":"<code>partition_by(by, *more_by, maintain_order=True, include_key=True, as_dict=False)</code>","text":"<p>Group by the given columns and partition into separate dataframes.</p> <p>Return the partitions as a dictionary by specifying <code>as_dict=True</code>.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def partition_by(\n    self: HasAtomsT, by: t.Union[str, t.Sequence[str]], *more_by: str,\n    maintain_order: bool = True, include_key: bool = True, as_dict: bool = False\n) -&gt; t.Union[t.List[HasAtomsT], t.Dict[t.Any, HasAtomsT]]:\n    \"\"\"\n    Group by the given columns and partition into separate dataframes.\n\n    Return the partitions as a dictionary by specifying `as_dict=True`.\n    \"\"\"\n    if as_dict:\n        d = self._get_frame().partition_by(by, *more_by, maintain_order=maintain_order, include_key=include_key, as_dict=True)\n        return {k: self.with_atoms(Atoms(df, _unchecked=True)) for (k, df) in d.items()}\n\n    return [\n        self.with_atoms(Atoms(df, _unchecked=True))\n        for df in self._get_frame().partition_by(by, *more_by, maintain_order=maintain_order, include_key=include_key, as_dict=False)\n    ]\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.HasAtomCell.select_schema","title":"<code>select_schema(schema)</code>","text":"<p>Select columns from <code>self</code> and cast to the given schema. Raises <code>TypeError</code> if a column is not found or if it can't be cast.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def select_schema(self, schema: SchemaDict) -&gt; polars.DataFrame:\n    \"\"\"\n    Select columns from `self` and cast to the given schema.\n    Raises `TypeError` if a column is not found or if it can't be cast.\n    \"\"\"\n    return _select_schema(self, schema)\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.HasAtomCell.try_get_column","title":"<code>try_get_column(name)</code>","text":"<p>Try to get a column from <code>self</code>, returning <code>None</code> if it doesn't exist.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def try_get_column(self, name: str) -&gt; t.Optional[polars.Series]:\n    \"\"\"Try to get a column from `self`, returning `None` if it doesn't exist.\"\"\"\n    try:\n        return self.get_column(name)\n    except polars.ColumnNotFoundError:\n        return None\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.HasAtomCell.deduplicate","title":"<code>deduplicate(tol=0.001, subset=('x', 'y', 'z', 'symbol'), keep='first', maintain_order=True)</code>","text":"<p>De-duplicate atoms in <code>self</code>. Atoms of the same <code>symbol</code> that are closer than <code>tolerance</code> to each other (by Euclidian distance) will be removed, leaving only the atom specified by <code>keep</code> (defaults to the first atom).</p> <p>If <code>subset</code> is specified, only those columns will be included while assessing duplicates. Floating point columns other than 'x', 'y', and 'z' will not by toleranced.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def deduplicate(self: HasAtomsT, tol: float = 1e-3, subset: t.Iterable[str] = ('x', 'y', 'z', 'symbol'),\n                keep: UniqueKeepStrategy = 'first', maintain_order: bool = True) -&gt; HasAtomsT:\n    \"\"\"\n    De-duplicate atoms in `self`. Atoms of the same `symbol` that are closer than `tolerance`\n    to each other (by Euclidian distance) will be removed, leaving only the atom specified by\n    `keep` (defaults to the first atom).\n\n    If `subset` is specified, only those columns will be included while assessing duplicates.\n    Floating point columns other than 'x', 'y', and 'z' will not by toleranced.\n    \"\"\"\n    import scipy.spatial\n\n    cols = set((subset,) if isinstance(subset, str) else subset)\n\n    indices = numpy.arange(len(self))\n\n    spatial_cols = cols.intersection(('x', 'y', 'z'))\n    cols -= spatial_cols\n    if len(spatial_cols) &gt; 0:\n        coords = self.select([_coord_expr(col).alias(col) for col in spatial_cols]).to_numpy()\n        tree = scipy.spatial.KDTree(coords)\n\n        # TODO This is a bad algorithm\n        while True:\n            changed = False\n            for (i, j) in tree.query_pairs(tol, 2.):\n                # whenever we encounter a pair, ensure their index matches\n                i_i, i_j = indices[[i, j]]\n                if i_i != i_j:\n                    indices[i] = indices[j] = min(i_i, i_j)\n                    changed = True\n            if not changed:\n                break\n\n        self = self.with_column(polars.Series('_unique_pts', indices))\n        cols.add('_unique_pts')\n\n    frame = self._get_frame().unique(subset=list(cols), keep=keep, maintain_order=maintain_order)\n    if len(spatial_cols) &gt; 0:\n        frame = frame.drop('_unique_pts')\n\n    return self.with_atoms(Atoms(frame, _unchecked=True))\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.HasAtomCell.with_bounds","title":"<code>with_bounds(cell_size=None, cell_origin=None)</code>","text":"<p>Return a periodic cell with the given orthogonal cell dimensions.</p> <p>If cell_size is not specified, it will be assumed (and may be incorrect).</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def with_bounds(self, cell_size: t.Optional[VecLike] = None, cell_origin: t.Optional[VecLike] = None) -&gt; 'AtomCell':\n    \"\"\"\n    Return a periodic cell with the given orthogonal cell dimensions.\n\n    If cell_size is not specified, it will be assumed (and may be incorrect).\n    \"\"\"\n    # TODO: test this\n    from .atomcell import AtomCell\n\n    if cell_size is None:\n        warnings.warn(\"Cell boundary unknown. Defaulting to cell BBox\")\n        cell_size = self.bbox().size\n        cell_origin = self.bbox().min\n\n    # TODO test this origin code\n    cell = Cell.from_unit_cell(cell_size)\n    if cell_origin is not None:\n        cell = cell.transform_cell(AffineTransform3D.translate(to_vec3(cell_origin)))\n\n    return AtomCell(self.get_atoms(), cell, frame='local')\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.HasAtomCell.x","title":"<code>x()</code>","text":"Source code in <code>atomlib/atoms.py</code> <pre><code>def x(self) -&gt; polars.Expr:\n    return polars.col('coords').arr.get(0).alias('x')\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.HasAtomCell.y","title":"<code>y()</code>","text":"Source code in <code>atomlib/atoms.py</code> <pre><code>def y(self) -&gt; polars.Expr:\n    return polars.col('coords').arr.get(1).alias('y')\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.HasAtomCell.z","title":"<code>z()</code>","text":"Source code in <code>atomlib/atoms.py</code> <pre><code>def z(self) -&gt; polars.Expr:\n    return polars.col('coords').arr.get(2).alias('z')\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.HasAtomCell.types","title":"<code>types()</code>","text":"<p>Returns a <code>Series</code> of atom types (dtype <code>polars.Int32</code>).</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def types(self) -&gt; t.Optional[polars.Series]:\n    \"\"\"\n    Returns a [`Series`][polars.Series] of atom types (dtype [`polars.Int32`][polars.Int32]).\n\n    [polars.Series]: https://docs.pola.rs/py-polars/html/reference/series/index.html\n    \"\"\"\n    return self.try_get_column('type')\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.HasAtomCell.masses","title":"<code>masses()</code>","text":"<p>Returns a <code>Series</code> of atom masses (dtype <code>polars.Float32</code>).</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def masses(self) -&gt; t.Optional[polars.Series]:\n    \"\"\"\n    Returns a [`Series`][polars.Series] of atom masses (dtype [`polars.Float32`][polars.Float32]).\n\n    [polars.Series]: https://docs.pola.rs/py-polars/html/reference/series/index.html\n    \"\"\"\n    return self.try_get_column('mass')\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.HasAtomCell.pos","title":"<code>pos(x=None, y=None, z=None, *, tol=1e-06, **kwargs)</code>","text":"<p>Select all atoms at a given position.</p> <p>Formally, returns all atoms within a cube of radius <code>tol</code> centered at <code>(x,y,z)</code>, exclusive of the cube's surface.</p> <p>Additional parameters given as <code>kwargs</code> will be checked as additional parameters (with strict equality).</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def pos(self,\n        x: t.Union[t.Sequence[t.Optional[float]], float, None] = None,\n        y: t.Optional[float] = None, z: t.Optional[float] = None, *,\n        tol: float = 1e-6, **kwargs: t.Any) -&gt; polars.Expr:\n    \"\"\"\n    Select all atoms at a given position.\n\n    Formally, returns all atoms within a cube of radius ``tol``\n    centered at ``(x,y,z)``, exclusive of the cube's surface.\n\n    Additional parameters given as ``kwargs`` will be checked\n    as additional parameters (with strict equality).\n    \"\"\"\n\n    if isinstance(x, t.Sequence):\n        (x, y, z) = x\n\n    tol = abs(float(tol))\n    selection = polars.lit(True)\n    if x is not None:\n        selection &amp;= self.x().is_between(x - tol, x + tol, closed='none')\n    if y is not None:\n        selection &amp;= self.y().is_between(y - tol, y + tol, closed='none')\n    if z is not None:\n        selection &amp;= self.z().is_between(z - tol, z + tol, closed='none')\n    for (col, val) in kwargs.items():\n        selection &amp;= (polars.col(col) == val)\n\n    return selection\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.HasAtomCell.apply_occupancy","title":"<code>apply_occupancy(rng=None)</code>","text":"<p>For each atom in <code>self</code>, use its <code>frac_occupancy</code> to randomly decide whether to remove it.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def apply_occupancy(self: HasAtomsT, rng: t.Union[numpy.random.Generator, int, None] = None) -&gt; HasAtomsT:\n    \"\"\"\n    For each atom in `self`, use its `frac_occupancy` to randomly decide whether to remove it.\n    \"\"\"\n    if 'frac_occupancy' not in self.columns:\n        return self\n    rng = numpy.random.default_rng(seed=rng)\n\n    frac = self.select('frac_occupancy').to_series().to_numpy()\n    choice = rng.binomial(1, frac).astype(numpy.bool_)\n    return self.filter(polars.lit(choice))\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.HasAtomCell.get_frame","title":"<code>get_frame()</code>  <code>abstractmethod</code>","text":"<p>Get the coordinate frame atoms are stored in.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@abc.abstractmethod\ndef get_frame(self) -&gt; CoordinateFrame:\n    \"\"\"Get the coordinate frame atoms are stored in.\"\"\"\n    ...\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.HasAtomCell.with_atoms","title":"<code>with_atoms(atoms, frame=None)</code>  <code>abstractmethod</code>","text":"<p>Replace the atoms in <code>self</code>. If no coordinate frame is specified, keep the coordinate frame unchanged.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@abc.abstractmethod\ndef with_atoms(self: HasAtomCellT, atoms: HasAtoms, frame: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n    \"\"\"\n    Replace the atoms in ``self``. If no coordinate frame is specified, keep the coordinate frame unchanged.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.HasAtomCell.with_cell","title":"<code>with_cell(cell)</code>","text":"<p>Replace the cell in <code>self</code>, without touching the atomic coordinates.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def with_cell(self: HasAtomCellT, cell: Cell) -&gt; HasAtomCellT:\n    \"\"\"\n    Replace the cell in ``self``, without touching the atomic coordinates.\n    \"\"\"\n    return self.to_frame('local').with_cell(cell)\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.HasAtomCell.get_atomcell","title":"<code>get_atomcell()</code>","text":"Source code in <code>atomlib/atomcell.py</code> <pre><code>def get_atomcell(self) -&gt; AtomCell:\n    frame = self.get_frame()\n    return AtomCell(self.get_atoms(frame), self.get_cell(), frame=frame, keep_frame=True)\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.HasAtomCell.get_atoms","title":"<code>get_atoms(frame=None)</code>  <code>abstractmethod</code>","text":"<p>Get atoms contained in <code>self</code>, in the given coordinate frame.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@abc.abstractmethod\ndef get_atoms(self, frame: t.Optional[CoordinateFrame] = None) -&gt; Atoms:\n    \"\"\"Get atoms contained in ``self``, in the given coordinate frame.\"\"\"\n    ...\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.HasAtomCell.bbox_atoms","title":"<code>bbox_atoms(frame=None)</code>","text":"<p>Return the bounding box of all the atoms in <code>self</code>, in the given coordinate frame.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def bbox_atoms(self, frame: t.Optional[CoordinateFrame] = None) -&gt; BBox3D:\n    \"\"\"Return the bounding box of all the atoms in ``self``, in the given coordinate frame.\"\"\"\n    return self.get_atoms(frame).bbox()\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.HasAtomCell.bbox","title":"<code>bbox(frame='local')</code>","text":"<p>Return the combined bounding box of the cell and atoms in the given coordinate system. To get the cell or atoms bounding box only, use meth:<code>bbox_cell</code> or meth:<code>bbox_atoms</code>.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def bbox(self, frame: CoordinateFrame = 'local') -&gt; BBox3D:\n    \"\"\"\n    Return the combined bounding box of the cell and atoms in the given coordinate system.\n    To get the cell or atoms bounding box only, use :py:meth:`bbox_cell` or :py:meth:`bbox_atoms`.\n    \"\"\"\n    return self.bbox_atoms(frame) | self.bbox_cell(frame)\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.HasAtomCell.to_frame","title":"<code>to_frame(frame)</code>","text":"<p>Convert the stored Atoms to the given coordinate frame.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def to_frame(self: HasAtomCellT, frame: CoordinateFrame) -&gt; HasAtomCellT:\n    \"\"\"Convert the stored Atoms to the given coordinate frame.\"\"\"\n    return self.with_atoms(self.get_atoms(frame), frame)\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.HasAtomCell.transform_atoms","title":"<code>transform_atoms(transform, selection=None, *, frame='local', transform_velocities=False)</code>","text":"<p>Transform the atoms in <code>self</code> by <code>transform</code>. If <code>selection</code> is given, only transform the atoms in <code>selection</code>.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def transform_atoms(self: HasAtomCellT, transform: IntoTransform3D, selection: t.Optional[AtomSelection] = None, *,\n                    frame: CoordinateFrame = 'local', transform_velocities: bool = False) -&gt; HasAtomCellT:\n    \"\"\"\n    Transform the atoms in `self` by `transform`.\n    If `selection` is given, only transform the atoms in `selection`.\n    \"\"\"\n    transform = self.change_transform(Transform3D.make(transform), self.get_frame(), frame)\n    return self.with_atoms(self.get_atoms(self.get_frame()).transform(transform, selection, transform_velocities=transform_velocities))\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.HasAtomCell.transform_cell","title":"<code>transform_cell(transform, frame='local')</code>","text":"<p>Apply the given transform to the unit cell, without changing atom positions. The transform is applied in coordinate frame 'frame'.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def transform_cell(self: HasAtomCellT, transform: AffineTransform3D, frame: CoordinateFrame = 'local') -&gt; HasAtomCellT:\n    \"\"\"\n    Apply the given transform to the unit cell, without changing atom positions.\n    The transform is applied in coordinate frame 'frame'.\n    \"\"\"\n    return self.with_cell(self.get_cell().transform_cell(transform, frame=frame))\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.HasAtomCell.transform","title":"<code>transform(transform, frame='local')</code>","text":"Source code in <code>atomlib/atomcell.py</code> <pre><code>def transform(self: HasAtomCellT, transform: AffineTransform3D, frame: CoordinateFrame = 'local') -&gt; HasAtomCellT:\n    if isinstance(transform, Transform3D) and not isinstance(transform, AffineTransform3D):\n        raise ValueError(\"Non-affine transforms cannot change the box dimensions. Use 'transform_atoms' instead.\")\n    # TODO: cleanup once tests pass\n    # coordinate change the transform into atomic coordinates\n    new_cell = self.get_cell().transform_cell(transform, frame)\n    transform = self.get_cell().change_transform(transform, self.get_frame(), frame)\n    return self.with_atoms(self.get_atoms().transform(transform), self.get_frame()).with_cell(new_cell)\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.HasAtomCell.crop","title":"<code>crop(x_min=-numpy.inf, x_max=numpy.inf, y_min=-numpy.inf, y_max=numpy.inf, z_min=-numpy.inf, z_max=numpy.inf, *, frame='local')</code>","text":"<p>Crop atoms and cell to the given extents. For a non-orthogonal cell, this must be specified in cell coordinates. This function implicity <code>explode</code>s the cell as well.</p> <p>To crop atoms only, use <code>crop_atoms</code> instead.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def crop(self: HasAtomCellT, x_min: float = -numpy.inf, x_max: float = numpy.inf,\n         y_min: float = -numpy.inf, y_max: float = numpy.inf,\n         z_min: float = -numpy.inf, z_max: float = numpy.inf, *,\n         frame: CoordinateFrame = 'local') -&gt; HasAtomCellT:\n    \"\"\"\n    Crop atoms and cell to the given extents. For a non-orthogonal\n    cell, this must be specified in cell coordinates. This\n    function implicity `explode`s the cell as well.\n\n    To crop atoms only, use `crop_atoms` instead.\n    \"\"\"\n\n    cell = self.get_cell().crop(x_min, x_max, y_min, y_max, z_min, z_max, frame=frame)\n    atoms = self._transform_atoms_in_frame(frame, lambda atoms: atoms.crop_atoms(x_min, x_max, y_min, y_max, z_min, z_max))\n    return self.with_cell(cell).with_atoms(atoms)\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.HasAtomCell.crop_atoms","title":"<code>crop_atoms(x_min=-numpy.inf, x_max=numpy.inf, y_min=-numpy.inf, y_max=numpy.inf, z_min=-numpy.inf, z_max=numpy.inf, *, frame='local')</code>","text":"Source code in <code>atomlib/atomcell.py</code> <pre><code>def crop_atoms(self: HasAtomCellT, x_min: float = -numpy.inf, x_max: float = numpy.inf,\n               y_min: float = -numpy.inf, y_max: float = numpy.inf,\n               z_min: float = -numpy.inf, z_max: float = numpy.inf, *,\n               frame: CoordinateFrame = 'local') -&gt; HasAtomCellT:\n    atoms = self._transform_atoms_in_frame(frame, lambda atoms: atoms.crop_atoms(x_min, x_max, y_min, y_max, z_min, z_max))\n    return self.with_atoms(atoms)\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.HasAtomCell.crop_to_box","title":"<code>crop_to_box(eps=1e-05)</code>","text":"Source code in <code>atomlib/atomcell.py</code> <pre><code>def crop_to_box(self: HasAtomCellT, eps: float = 1e-5) -&gt; HasAtomCellT:\n    atoms = self._transform_atoms_in_frame('cell_box', lambda atoms: atoms.crop_atoms(*([-eps, 1-eps]*3)))\n    return self.with_atoms(atoms)\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.HasAtomCell.wrap","title":"<code>wrap(eps=1e-05)</code>","text":"<p>Wrap atoms around the cell boundaries.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def wrap(self: HasAtomCellT, eps: float = 1e-5) -&gt; HasAtomCellT:\n    \"\"\"Wrap atoms around the cell boundaries.\"\"\"\n    return self.with_atoms(self._transform_atoms_in_frame('cell_box', lambda a: a._wrap(eps)))\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.HasAtomCell.repeat","title":"<code>repeat(n)</code>","text":"<p>Tile the cell</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def repeat(self: HasAtomCellT, n: t.Union[int, VecLike]) -&gt; HasAtomCellT:\n    \"\"\"Tile the cell\"\"\"\n    ns = numpy.broadcast_to(n, 3)\n    if not numpy.issubdtype(ns.dtype, numpy.integer):\n        raise ValueError(f\"repeat() argument must be an integer or integer array.\")\n\n    cells = numpy.stack(numpy.meshgrid(*map(numpy.arange, ns))) \\\n        .reshape(3, -1).T.astype(float)\n    cells = cells * self.box_size\n\n    atoms = self.get_atoms('cell')\n    atoms = Atoms.concat([\n        atoms.transform(AffineTransform3D.translate(cell))\n        for cell in cells\n    ]) #.transform(self.cell.get_transform('local', 'cell_frac'))\n    return self.with_atoms(atoms, 'cell').with_cell(self.get_cell().repeat(ns))\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.HasAtomCell.repeat_to","title":"<code>repeat_to(size, crop=False)</code>","text":"<p>Repeat the cell so it is at least <code>size</code> along the crystal's axes.</p> <p>If <code>crop</code>, then crop the cell to exactly <code>size</code>. This may break periodicity. <code>crop</code> may be a vector, in which case you can specify cropping only along some axes.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def repeat_to(self: HasAtomCellT, size: VecLike, crop: t.Union[bool, t.Sequence[bool]] = False) -&gt; HasAtomCellT:\n    \"\"\"\n    Repeat the cell so it is at least ``size`` along the crystal's axes.\n\n    If ``crop``, then crop the cell to exactly ``size``. This may break periodicity.\n    ``crop`` may be a vector, in which case you can specify cropping only along some axes.\n    \"\"\"\n    size = to_vec3(size)\n    cell_size = self.cell_size * self.n_cells\n    repeat = numpy.maximum(numpy.ceil(size / cell_size).astype(int), 1)\n    atom_cell = self.repeat(repeat)\n\n    crop_v = to_vec3(crop, dtype=numpy.bool_)\n    if numpy.any(crop_v):\n        crop_x, crop_y, crop_z = crop_v\n        return atom_cell.crop(\n            x_max = size[0] if crop_x else numpy.inf,\n            y_max = size[1] if crop_y else numpy.inf,\n            z_max = size[2] if crop_z else numpy.inf,\n            frame='cell'\n        )\n\n    return atom_cell\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.HasAtomCell.repeat_x","title":"<code>repeat_x(n)</code>","text":"<p>Tile the cell in the x axis.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def repeat_x(self: HasAtomCellT, n: int) -&gt; HasAtomCellT:\n    \"\"\"Tile the cell in the x axis.\"\"\"\n    return self.repeat((n, 1, 1))\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.HasAtomCell.repeat_y","title":"<code>repeat_y(n)</code>","text":"<p>Tile the cell in the y axis.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def repeat_y(self: HasAtomCellT, n: int) -&gt; HasAtomCellT:\n    \"\"\"Tile the cell in the y axis.\"\"\"\n    return self.repeat((1, n, 1))\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.HasAtomCell.repeat_z","title":"<code>repeat_z(n)</code>","text":"<p>Tile the cell in the z axis.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def repeat_z(self: HasAtomCellT, n: int) -&gt; HasAtomCellT:\n    \"\"\"Tile the cell in the z axis.\"\"\"\n    return self.repeat((1, 1, n))\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.HasAtomCell.repeat_to_x","title":"<code>repeat_to_x(size, crop=False)</code>","text":"<p>Repeat the cell so it is at least size <code>size</code> along the x axis.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def repeat_to_x(self: HasAtomCellT, size: float, crop: bool = False) -&gt; HasAtomCellT:\n    \"\"\"Repeat the cell so it is at least size ``size`` along the x axis.\"\"\"\n    return self.repeat_to([size, 0., 0.], [crop, False, False])\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.HasAtomCell.repeat_to_y","title":"<code>repeat_to_y(size, crop=False)</code>","text":"<p>Repeat the cell so it is at least size <code>size</code> along the y axis.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def repeat_to_y(self: HasAtomCellT, size: float, crop: bool = False) -&gt; HasAtomCellT:\n    \"\"\"Repeat the cell so it is at least size ``size`` along the y axis.\"\"\"\n    return self.repeat_to([0., size, 0.], [False, crop, False])\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.HasAtomCell.repeat_to_z","title":"<code>repeat_to_z(size, crop=False)</code>","text":"<p>Repeat the cell so it is at least size <code>size</code> along the z axis.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def repeat_to_z(self: HasAtomCellT, size: float, crop: bool = False) -&gt; HasAtomCellT:\n    \"\"\"Repeat the cell so it is at least size ``size`` along the z axis.\"\"\"\n    return self.repeat_to([0., 0., size], [False, False, crop])\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.HasAtomCell.repeat_to_aspect","title":"<code>repeat_to_aspect(plane='xy', *, aspect=1.0, min_size=None, max_size=None)</code>","text":"<p>Repeat to optimize the aspect ratio in <code>plane</code>, while staying above <code>min_size</code> and under <code>max_size</code>.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def repeat_to_aspect(self: HasAtomCellT, plane: t.Literal['xy', 'xz', 'yz'] = 'xy', *,\n                     aspect: float = 1., min_size: t.Optional[VecLike] = None,\n                     max_size: t.Optional[VecLike] = None) -&gt; HasAtomCellT:\n    \"\"\"\n    Repeat to optimize the aspect ratio in ``plane``,\n    while staying above ``min_size`` and under ``max_size``.\n    \"\"\"\n    if min_size is None:\n        min_n = numpy.array([1, 1, 1], numpy.int_)\n    else:\n        min_n = numpy.maximum(numpy.ceil(to_vec3(min_size) / self.box_size), 1).astype(numpy.int_)\n\n    if max_size is None:\n        max_n = 3 * min_n\n    else:\n        max_n = numpy.maximum(numpy.floor(to_vec3(max_size) / self.box_size), 1).astype(numpy.int_)\n\n    if plane == 'xy':\n        indices = [0, 1]\n    elif plane == 'xz':\n        indices = [0, 2]\n    elif plane == 'yz':\n        indices = [1, 2]\n    else:\n        raise ValueError(f\"Invalid plane '{plane}'. Exepcted 'xy', 'xz', 'or 'yz'.\")\n\n    na = numpy.arange(min_n[indices[0]], max_n[indices[0]])\n    nb = numpy.arange(min_n[indices[1]], max_n[indices[1]])\n    (na, nb) = numpy.meshgrid(na, nb)\n\n    aspects = na * self.box_size[indices[0]] / (nb * self.box_size[indices[1]])\n    # cost function: log(aspect)^2  (so cost(0.5) == cost(2))\n    min_i = numpy.argmin(numpy.log(aspects / aspect)**2)\n    repeat = numpy.array([1, 1, 1], numpy.int_)\n    repeat[indices] = na.flatten()[min_i], nb.flatten()[min_i]\n    return self.repeat(repeat)\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.HasAtomCell.explode","title":"<code>explode()</code>","text":"<p>Materialize repeated cells as one supercell.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def explode(self: HasAtomCellT) -&gt; HasAtomCellT:\n    \"\"\"Materialize repeated cells as one supercell.\"\"\"\n    frame = self.get_frame()\n\n    return self.with_atoms(self.get_atoms('local'), 'local') \\\n        .with_cell(self.get_cell().explode()) \\\n        .to_frame(frame)\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.HasAtomCell.periodic_duplicate","title":"<code>periodic_duplicate(eps=1e-05)</code>","text":"<p>Add duplicate copies of atoms near periodic boundaries.</p> <p>For instance, an atom at a corner will be duplicated into 8 copies. This is mostly only useful for visualization.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def periodic_duplicate(self: HasAtomCellT, eps: float = 1e-5) -&gt; HasAtomCellT:\n    \"\"\"\n    Add duplicate copies of atoms near periodic boundaries.\n\n    For instance, an atom at a corner will be duplicated into 8 copies.\n    This is mostly only useful for visualization.\n    \"\"\"\n    frame_save = self.get_frame()\n    self = self.to_frame('cell_box').wrap(eps=eps)\n\n    for i in range(3):\n        self = self.concat((self,\n            self.filter(polars.col('coords').arr.get(i).abs() &lt;= eps, frame='cell_box')\n                .transform_atoms(AffineTransform3D.translate([1. if i == j else 0. for j in range(3)]), frame='cell_box')\n        ))\n\n    return self.to_frame(frame_save)\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.HasAtomCell.describe","title":"<code>describe(percentiles=(0.25, 0.5, 0.75), *, interpolation='nearest', frame=None)</code>","text":"<p>Return summary statistics for <code>self</code>.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_get\ndef describe(self, percentiles: t.Union[t.Sequence[float], float, None] = (0.25, 0.5, 0.75), *,\n             interpolation: RollingInterpolationMethod = 'nearest',\n             frame: t.Optional[CoordinateFrame] = None) -&gt; polars.DataFrame:\n    \"\"\"Return summary statistics for `self`.\"\"\"\n    ...\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.HasAtomCell.with_columns","title":"<code>with_columns(*exprs, frame=None, **named_exprs)</code>","text":"<p>Return a copy of <code>self</code> with the given columns added.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef with_columns(self: HasAtomCellT,\n                 *exprs: t.Union[IntoExpr, t.Iterable[IntoExpr]],\n                 frame: t.Optional[CoordinateFrame] = None,\n                 **named_exprs: IntoExpr) -&gt; HasAtomCellT:\n    \"\"\"Return a copy of ``self`` with the given columns added.\"\"\"\n    ...\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.HasAtomCell.get_column","title":"<code>get_column(name, *, frame=None)</code>","text":"<p>Get the specified column from <code>self</code>, raising <code>polars.ColumnNotFoundError</code> if it's not present.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_get\ndef get_column(self, name: str, *, frame: t.Optional[CoordinateFrame] = None) -&gt; polars.Series:\n    \"\"\"Get the specified column from `self`, raising [`polars.ColumnNotFoundError`][polars.exceptions.ColumnNotFoundError] if it's not present.\"\"\"\n    ...\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.HasAtomCell.get_columns","title":"<code>get_columns(*, frame=None)</code>","text":"<p>Get the specified columns from <code>self</code>, raising <code>polars.ColumnNotFoundError</code> if it's not present.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_get\ndef get_columns(self, *, frame: t.Optional[CoordinateFrame] = None) -&gt; t.List[polars.Series]:\n    \"\"\"Get the specified columns from `self`, raising [`polars.ColumnNotFoundError`][polars.exceptions.ColumnNotFoundError] if it's not present.\"\"\"\n    ...\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.HasAtomCell.group_by","title":"<code>group_by(*by, maintain_order=False, frame=None, **named_by)</code>","text":"Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_get\ndef group_by(self, *by: t.Union[IntoExpr, t.Iterable[IntoExpr]],\n             maintain_order: bool = False, frame: t.Optional[CoordinateFrame] = None,\n             **named_by: IntoExpr) -&gt; polars.dataframe.group_by.GroupBy:\n    ...\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.HasAtomCell.pipe","title":"<code>pipe(function, *args, **kwargs)</code>","text":"<p>Apply <code>function</code> to <code>self</code> (in method-call syntax).</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def pipe(self: HasAtomCellT, function: t.Callable[Concatenate[HasAtomCellT, P], T], *args: P.args, **kwargs: P.kwargs) -&gt; T:\n    \"\"\"Apply `function` to `self` (in method-call syntax).\"\"\"\n    return function(self, *args, **kwargs)\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.HasAtomCell.filter","title":"<code>filter(*predicates, frame=None, **constraints)</code>","text":"<p>Filter <code>self</code>, removing rows which evaluate to <code>False</code>.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef filter(\n    self: HasAtomCellT,\n    *predicates: t.Union[None, IntoExprColumn, t.Iterable[IntoExprColumn], bool, t.List[bool], numpy.ndarray],\n    frame: t.Optional[CoordinateFrame] = None,\n    **constraints: t.Any,\n) -&gt; HasAtomCellT:\n    \"\"\"Filter `self`, removing rows which evaluate to `False`.\"\"\"\n    ...\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.HasAtomCell.sort","title":"<code>sort(by, *more_by, descending=False, nulls_last=False)</code>","text":"<p>Sort the atoms in <code>self</code> by the given columns/expressions.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef sort(\n    self: HasAtomCellT,\n    by: t.Union[IntoExpr, t.Iterable[IntoExpr]],\n    *more_by: IntoExpr,\n    descending: t.Union[bool, t.Sequence[bool]] = False,\n    nulls_last: bool = False,\n) -&gt; HasAtomCellT:\n    \"\"\"\n    Sort the atoms in `self` by the given columns/expressions.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.HasAtomCell.slice","title":"<code>slice(offset, length=None, *, frame=None)</code>","text":"<p>Return a slice of the rows in <code>self</code>.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef slice(self: HasAtomCellT, offset: int, length: t.Optional[int] = None, *,\n          frame: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n    \"\"\"Return a slice of the rows in `self`.\"\"\"\n    ...\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.HasAtomCell.head","title":"<code>head(n=5, *, frame=None)</code>","text":"<p>Return the first <code>n</code> rows of <code>self</code>.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef head(self: HasAtomCellT, n: int = 5, *, frame: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n    \"\"\"Return the first `n` rows of `self`.\"\"\"\n    ...\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.HasAtomCell.tail","title":"<code>tail(n=5, *, frame=None)</code>","text":"<p>Return the last <code>n</code> rows of <code>self</code>.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef tail(self: HasAtomCellT, n: int = 5, *, frame: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n    \"\"\"Return the last `n` rows of `self`.\"\"\"\n    ...\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.HasAtomCell.fill_null","title":"<code>fill_null(value=None, strategy=None, limit=None, matches_supertype=True)</code>","text":"Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef fill_null(\n    self: HasAtomCellT, value: t.Any = None, strategy: t.Optional[FillNullStrategy] = None,\n    limit: t.Optional[int] = None, matches_supertype: bool = True,\n) -&gt; HasAtomCellT:\n    ...\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.HasAtomCell.fill_nan","title":"<code>fill_nan(value, *, frame=None)</code>","text":"Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef fill_nan(self: HasAtomCellT, value: t.Union[polars.Expr, int, float, None], *,\n             frame: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n    ...\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.HasAtomCell.select","title":"<code>select(*exprs, frame=None, **named_exprs)</code>","text":"<p>Select <code>exprs`` from ``self</code>, and return as a <code>polars.DataFrame</code>.</p> <p>Expressions may either be columns or expressions of columns.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_get\ndef select(\n    self, *exprs: t.Union[IntoExpr, t.Iterable[IntoExpr]],\n    frame: t.Optional[CoordinateFrame] = None,\n    **named_exprs: IntoExpr\n) -&gt; polars.DataFrame:\n    \"\"\"\n    Select `exprs`` from ``self`, and return as a `polars.DataFrame`.\n\n    Expressions may either be columns or expressions of columns.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.HasAtomCell.select_props","title":"<code>select_props(*exprs, frame=None, **named_exprs)</code>","text":"<p>Select <code>exprs</code> from <code>self</code>, while keeping required columns.</p> <p>Returns a HasAtoms.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef select_props(\n    self: HasAtomCellT,\n    *exprs: t.Union[IntoExpr, t.Iterable[IntoExpr]],\n    frame: t.Optional[CoordinateFrame] = None,\n    **named_exprs: IntoExpr\n) -&gt; HasAtomCellT:\n    \"\"\"\n    Select `exprs` from `self`, while keeping required columns.\n\n    Returns a HasAtoms.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.HasAtomCell.try_select","title":"<code>try_select(*exprs, frame=None, **named_exprs)</code>","text":"<p>Try to select <code>exprs</code> from <code>self</code>, and return as a <code>polars.DataFrame</code>.</p> <p>Expressions may either be columns or expressions of columns. Return <code>None</code> if any columns are missing.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_get\ndef try_select(\n    self, *exprs: t.Union[IntoExpr, t.Iterable[IntoExpr]],\n    frame: t.Optional[CoordinateFrame] = None,\n    **named_exprs: IntoExpr\n) -&gt; t.Optional[polars.DataFrame]:\n    \"\"\"\n    Try to select `exprs` from `self`, and return as a `polars.DataFrame`.\n\n    Expressions may either be columns or expressions of columns.\n    Return `None` if any columns are missing.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.HasAtomCell.round_near_zero","title":"<code>round_near_zero(tol=1e-14, *, frame=None)</code>","text":"<p>Round atom position values near zero to zero.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef round_near_zero(self: HasAtomCellT, tol: float = 1e-14, *,\n                    frame: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n    \"\"\"\n    Round atom position values near zero to zero.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.HasAtomCell.coords","title":"<code>coords(selection=None, *, frame=None)</code>","text":"<p>Returns a <code>(N, 3)</code> ndarray of atom coordinates (dtype <code>numpy.float64</code>).</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_get\ndef coords(self, selection: t.Optional[AtomSelection] = None, *, frame: t.Optional[CoordinateFrame] = None) -&gt; NDArray[numpy.float64]:\n    \"\"\"Returns a `(N, 3)` ndarray of atom coordinates (dtype ``numpy.float64``).\"\"\"\n    ...\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.HasAtomCell.velocities","title":"<code>velocities(selection=None, *, frame=None)</code>","text":"<p>Returns a <code>(N, 3)</code> ndarray of atom velocities (dtype <code>numpy.float64</code>).</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_get\ndef velocities(self, selection: t.Optional[AtomSelection] = None, *, frame: t.Optional[CoordinateFrame] = None) -&gt; t.Optional[NDArray[numpy.float64]]:\n    \"\"\"Returns a `(N, 3)` ndarray of atom velocities (dtype ``numpy.float64``).\"\"\"\n    ...\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.HasAtomCell.add_atom","title":"<code>add_atom(elem, /, x, y=None, z=None, *, frame=None, **kwargs)</code>","text":"<p>Return a copy of <code>self</code> with an extra atom.</p> <p>By default, all extra columns present in <code>self</code> must be specified as <code>**kwargs</code>.</p> <p>Try to avoid calling this in a loop (Use meth:<code>concat</code> instead).</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef add_atom(self: HasAtomCellT, elem: t.Union[int, str], /,  # type: ignore (spurious)\n             x: t.Union[ArrayLike, float],\n             y: t.Optional[float] = None,\n             z: t.Optional[float] = None, *,\n             frame: t.Optional[CoordinateFrame] = None,\n             **kwargs: t.Any) -&gt; HasAtomCellT:\n    \"\"\"\n    Return a copy of ``self`` with an extra atom.\n\n    By default, all extra columns present in ``self`` must be specified as ``**kwargs``.\n\n    Try to avoid calling this in a loop (Use :py:meth:`concat` instead).\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.HasAtomCell.with_index","title":"<code>with_index(index=None, *, frame=None)</code>","text":"<p>Returns <code>self</code> with a row index added in column 'i' (dtype polars.Int64). If <code>index</code> is not specified, defaults to an existing index or a new index.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef with_index(self: HasAtomCellT, index: t.Optional[AtomValues] = None, *,\n               frame: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n    \"\"\"\n    Returns ``self`` with a row index added in column 'i' (dtype polars.Int64).\n    If ``index`` is not specified, defaults to an existing index or a new index.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.HasAtomCell.with_wobble","title":"<code>with_wobble(wobble=None, *, frame=None)</code>","text":"<p>Return <code>self</code> with the given displacements in column 'wobble' (dtype polars.Float64). If <code>wobble</code> is not specified, defaults to the already-existing wobbles or 0.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef with_wobble(self: HasAtomCellT, wobble: t.Optional[AtomValues] = None, *,\n                frame: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n    \"\"\"\n    Return ``self`` with the given displacements in column 'wobble' (dtype polars.Float64).\n    If ``wobble`` is not specified, defaults to the already-existing wobbles or 0.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.HasAtomCell.with_occupancy","title":"<code>with_occupancy(frac_occupancy=None, *, frame=None)</code>","text":"<p>Return self with the given fractional occupancies. If <code>frac_occupancy</code> is not specified, defaults to the already-existing occupancies or 1.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef with_occupancy(self: HasAtomCellT, frac_occupancy: t.Optional[AtomValues] = None, *,\n                   frame: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n    \"\"\"\n    Return self with the given fractional occupancies. If ``frac_occupancy`` is not specified,\n    defaults to the already-existing occupancies or 1.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.HasAtomCell.apply_wobble","title":"<code>apply_wobble(rng=None, frame=None)</code>","text":"<p>Displace the atoms in <code>self</code> by the amount in the <code>wobble</code> column. <code>wobble</code> is interpretated as a mean-squared displacement, which is distributed equally over each axis.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef apply_wobble(self: HasAtomCellT, rng: t.Union[numpy.random.Generator, int, None] = None,\n                 frame: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n    \"\"\"\n    Displace the atoms in ``self`` by the amount in the `wobble` column.\n    ``wobble`` is interpretated as a mean-squared displacement, which is distributed\n    equally over each axis.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.HasAtomCell.with_type","title":"<code>with_type(types=None, *, frame=None)</code>","text":"<p>Return <code>self</code> with the given atom types in column 'type'. If <code>types</code> is not specified, use the already existing types or auto-assign them.</p> <p>When auto-assigning, each symbol is given a unique value, case-sensitive. Values are assigned from lowest atomic number to highest. For instance: <code>[\"Ag+\", \"Na\", \"H\", \"Ag\"]</code> =&gt; <code>[3, 11, 1, 2]</code></p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef with_type(self: HasAtomCellT, types: t.Optional[AtomValues] = None, *,\n              frame: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n    \"\"\"\n    Return ``self`` with the given atom types in column 'type'.\n    If ``types`` is not specified, use the already existing types or auto-assign them.\n\n    When auto-assigning, each symbol is given a unique value, case-sensitive.\n    Values are assigned from lowest atomic number to highest.\n    For instance: ``[\"Ag+\", \"Na\", \"H\", \"Ag\"]`` =&gt; ``[3, 11, 1, 2]``\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.HasAtomCell.with_mass","title":"<code>with_mass(mass=None, *, frame=None)</code>","text":"<p>Return <code>self</code> with the given atom masses in column 'mass'. If <code>mass</code> is not specified, use the already existing masses or auto-assign them.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef with_mass(self: HasAtomCellT, mass: t.Optional[ArrayLike] = None, *,\n              frame: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n    \"\"\"\n    Return ``self`` with the given atom masses in column 'mass'.\n    If ``mass`` is not specified, use the already existing masses or auto-assign them.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.HasAtomCell.with_symbol","title":"<code>with_symbol(symbols, selection=None, *, frame=None)</code>","text":"<p>Return <code>self</code> with the given atomic symbols.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef with_symbol(self: HasAtomCellT, symbols: ArrayLike, selection: t.Optional[AtomSelection] = None, *,\n                frame: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n    \"\"\"\n    Return ``self`` with the given atomic symbols.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.HasAtomCell.with_coords","title":"<code>with_coords(pts, selection=None, *, frame=None)</code>","text":"<p>Return <code>self</code> replaced with the given atomic positions.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef with_coords(self: HasAtomCellT, pts: ArrayLike, selection: t.Optional[AtomSelection] = None, *,\n                frame: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n    \"\"\"\n    Return ``self`` replaced with the given atomic positions.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.HasAtomCell.with_velocity","title":"<code>with_velocity(pts=None, selection=None, *, frame=None)</code>","text":"<p>Return <code>self</code> replaced with the given atomic velocities. If <code>pts</code> is not specified, use the already existing velocities or zero.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef with_velocity(self: HasAtomCellT, pts: t.Optional[ArrayLike] = None,\n                  selection: t.Optional[AtomSelection] = None, *,\n                  frame: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n    \"\"\"\n    Return ``self`` replaced with the given atomic velocities.\n    If ``pts`` is not specified, use the already existing velocities or zero.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell","title":"<code>AtomCell</code>  <code>dataclass</code>","text":"<p>             Bases: <code>AtomCellIOMixin</code>, <code>HasAtomCell</code></p> <p>Cell of atoms with known size and periodic boundary conditions.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@dataclass(init=False, repr=False, frozen=True)\nclass AtomCell(AtomCellIOMixin, HasAtomCell):\n    \"\"\"\n    Cell of atoms with known size and periodic boundary conditions.\n    \"\"\"\n\n    atoms: Atoms\n    \"\"\"Atoms in the cell. Stored in 'local' coordinates (i.e. relative to the enclosing group but not relative to box dimensions).\"\"\"\n\n    cell: Cell\n    \"\"\"Cell coordinate system.\"\"\"\n\n    frame: CoordinateFrame = 'local'\n    \"\"\"Coordinate frame 'atoms' are stored in.\"\"\"\n\n    def get_cell(self) -&gt; Cell:\n        return self.cell\n\n    def with_cell(self: AtomCellT, cell: Cell) -&gt; AtomCellT:\n        return self.__class__(self.atoms, cell, frame=self.frame, keep_frame=True)\n\n    def get_atoms(self, frame: t.Optional[CoordinateFrame] = None) -&gt; Atoms:\n        \"\"\"Get atoms contained in ``self``, in the given coordinate frame.\"\"\"\n\n        if frame is None or frame == self.get_frame():\n            return self.atoms\n        return self.atoms.transform(self.get_transform(frame, self.get_frame()))\n\n    def with_atoms(self: AtomCellT, atoms: HasAtoms, frame: t.Optional[CoordinateFrame] = None) -&gt; AtomCellT:\n        frame = frame if frame is not None else self.frame\n        return self.__class__(atoms.get_atoms(), cell=self.cell, frame=frame, keep_frame=True)\n        #return replace(self, atoms=atoms, frame = frame if frame is not None else self.frame, keep_frame=True)\n\n    def get_frame(self) -&gt; CoordinateFrame:\n        \"\"\"Get the coordinate frame atoms are stored in.\"\"\"\n        return self.frame\n\n    @classmethod\n    def _combine_metadata(cls: t.Type[AtomCellT], *atoms: HasAtoms, n: t.Optional[int] = None) -&gt; AtomCellT:\n        \"\"\"\n        When combining multiple :py:`HasAtoms`, check that they are compatible with each other,\n        and return a 'representative' which best represents the combined metadata.\n        Implementors should treat :py:`Atoms` as acceptable, but having no metadata.\n        \"\"\"\n        if n is not None:\n            rep = atoms[n]\n            if not isinstance(rep, AtomCell):\n                raise ValueError(f\"Atoms #{n} has no cell\")\n        else:\n            atom_cells = [a for a in atoms if isinstance(a, AtomCell)]\n            if len(atom_cells) == 0:\n                raise TypeError(f\"No AtomCells to combine\")\n            rep = atom_cells[0]\n            if not all(a.cell == rep.cell for a in atom_cells[1:]):\n                raise TypeError(f\"Can't combine AtomCells with different cells\")\n\n        return cls(Atoms.empty(), frame=rep.frame, cell=rep.cell)\n\n    @classmethod\n    def from_ortho(cls, atoms: IntoAtoms, ortho: LinearTransform3D, *,\n                   n_cells: t.Optional[VecLike] = None,\n                   frame: CoordinateFrame = 'local',\n                   keep_frame: bool = False):\n        \"\"\"\n        Make an atom cell given a list of atoms and an orthogonalization matrix.\n        Atoms are assumed to be in the coordinate system ``frame``.\n        \"\"\"\n        cell = Cell.from_ortho(ortho, n_cells)\n        return cls(atoms, cell, frame=frame, keep_frame=keep_frame)\n\n    @classmethod\n    def from_unit_cell(cls, atoms: IntoAtoms, cell_size: VecLike,\n                       cell_angle: t.Optional[VecLike] = None, *,\n                       n_cells: t.Optional[VecLike] = None,\n                       frame: CoordinateFrame = 'local',\n                       keep_frame: bool = False):\n        \"\"\"\n        Make a cell given a list of atoms and unit cell parameters.\n        Atoms are assumed to be in the coordinate system ``frame``.\n        \"\"\"\n        cell = Cell.from_unit_cell(cell_size, cell_angle, n_cells=n_cells)\n        return cls(atoms, cell, frame=frame, keep_frame=keep_frame)\n\n    def __init__(self, atoms: IntoAtoms, cell: Cell, *,\n                 frame: CoordinateFrame = 'local',\n                 keep_frame: bool = False):\n        atoms = Atoms(atoms)\n        # by default, store in local coordinates\n        if not keep_frame and frame != 'local':\n            atoms = atoms.transform(cell.get_transform('local', frame))\n            frame = 'local'\n\n        object.__setattr__(self, 'atoms', atoms)\n        object.__setattr__(self, 'cell', cell)\n        object.__setattr__(self, 'frame', frame)\n\n        self.__post_init__()\n\n    def __post_init__(self):\n        pass\n\n    def orthogonalize(self) -&gt; OrthoCell:\n        if self.is_orthogonal():\n            return OrthoCell(self.atoms, self.cell, frame=self.frame)\n        raise NotImplementedError()\n\n    def clone(self: AtomCellT) -&gt; AtomCellT:\n        \"\"\"Make a deep copy of `self`.\"\"\"\n        return self.__class__(**{field.name: copy.deepcopy(getattr(self, field.name)) for field in fields(self)})\n\n    def assert_equal(self, other: t.Any):\n        \"\"\"Assert this structure is equal to \"\"\"\n        assert isinstance(other, AtomCell)\n        self.cell.assert_equal(other.cell)\n        self.get_atoms('local').assert_equal(other.get_atoms('local'))\n\n    def _str_parts(self) -&gt; t.Iterable[t.Any]:\n        return (\n            f\"Cell size:  {self.cell.cell_size!s}\",\n            f\"Cell angle: {self.cell.cell_angle!s}\",\n            f\"# Cells: {self.cell.n_cells!s}\",\n            f\"Frame: {self.frame}\",\n            self.atoms,\n        )\n\n    def __str__(self) -&gt; str:\n        return \"\\n\".join(map(str, self._str_parts()))\n\n    def __repr__(self) -&gt; str:\n        return f\"{self.__class__.__name__}({self.atoms!r}, cell={self.cell!r}, frame={self.frame})\"\n\n    def _repr_pretty_(self, p, cycle: bool) -&gt; None:\n        p.text(f'{self.__class__.__name__}(...)') if cycle else p.text(str(self))\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.affine","title":"<code>affine: AffineTransform3D</code>  <code>property</code>","text":"<p>Affine transformation. Holds transformation from 'ortho' to 'local' coordinates, including rotation away from the standard crystal orientation.</p>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.ortho","title":"<code>ortho: LinearTransform3D</code>  <code>property</code>","text":"<p>Orthogonalization transformation. Skews but does not scale the crystal axes to cartesian axes.</p>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.metric","title":"<code>metric: LinearTransform3D</code>  <code>property</code>","text":"<p>Cell metric tensor</p> <p>Returns the dot product between every combination of basis vectors. :math:<code>\\mathbf{a} \\cdot \\mathbf{b} = a_i M_ij b_j</code></p>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.cell_size","title":"<code>cell_size: NDArray[numpy.float_]</code>  <code>property</code>","text":"<p>Unit cell size.</p>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.cell_angle","title":"<code>cell_angle: NDArray[numpy.float_]</code>  <code>property</code>","text":"<p>Unit cell angles, in radians.</p>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.n_cells","title":"<code>n_cells: NDArray[numpy.int_]</code>  <code>property</code>","text":"<p>Number of unit cells.</p>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.pbc","title":"<code>pbc: NDArray[numpy.bool_]</code>  <code>property</code>","text":"<p>Flags indicating the presence of periodic boundary conditions along each axis.</p>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.ortho_size","title":"<code>ortho_size: NDArray[numpy.float_]</code>  <code>property</code>","text":"<p>Return size of orthogonal unit cell.</p> <p>Equivalent to the diagonal of the orthogonalization matrix.</p>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.box_size","title":"<code>box_size: NDArray[numpy.float_]</code>  <code>property</code>","text":"<p>Return size of the cell box.</p> <p>Equivalent to <code>self.n_cells * self.cell_size</code>.</p>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.columns","title":"<code>columns: t.Sequence[str]</code>  <code>property</code>","text":"<p>Return the columns in <code>self</code>.</p>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.dtypes","title":"<code>dtypes: t.Sequence[polars.DataType]</code>  <code>property</code>","text":"<p>Return the datatypes in <code>self</code>.</p>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.schema","title":"<code>schema: SchemaDict</code>  <code>property</code>","text":"<p>Return the schema of <code>self</code>.</p>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.with_column","title":"<code>with_column = with_columns</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.unique","title":"<code>unique = deduplicate</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.atoms","title":"<code>atoms: Atoms</code>  <code>instance-attribute</code>","text":"<p>Atoms in the cell. Stored in 'local' coordinates (i.e. relative to the enclosing group but not relative to box dimensions).</p>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.cell","title":"<code>cell: Cell</code>  <code>instance-attribute</code>","text":"<p>Cell coordinate system.</p>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.frame","title":"<code>frame: CoordinateFrame = 'local'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Coordinate frame 'atoms' are stored in.</p>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.get_transform","title":"<code>get_transform(frame_to=None, frame_from=None)</code>","text":"<p>In the two-argument form, get the transform to 'frame_to' from 'frame_from'. In the one-argument form, get the transform from local coordinates to 'frame'.</p> Source code in <code>atomlib/cell.py</code> <pre><code>def get_transform(self, frame_to: t.Optional[CoordinateFrame] = None, frame_from: t.Optional[CoordinateFrame] = None) -&gt; AffineTransform3D:\n    \"\"\"\n    In the two-argument form, get the transform to 'frame_to' from 'frame_from'.\n    In the one-argument form, get the transform from local coordinates to 'frame'.\n    \"\"\"\n    transform_from = self._get_transform_to_local(frame_from) if frame_from is not None else AffineTransform3D()\n    transform_to = self._get_transform_to_local(frame_to) if frame_to is not None else AffineTransform3D()\n    if frame_from is not None and frame_to is not None and frame_from.lower() == frame_to.lower():\n        return AffineTransform3D()\n    return transform_to.inverse() @ transform_from\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.corners","title":"<code>corners(frame='local')</code>","text":"Source code in <code>atomlib/cell.py</code> <pre><code>def corners(self, frame: CoordinateFrame = 'local') -&gt; numpy.ndarray:\n    corners = numpy.array(list(itertools.product((0., 1.), repeat=3)))\n    return self.get_transform(frame, 'cell_box') @ corners\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.bbox_cell","title":"<code>bbox_cell(frame='local')</code>","text":"<p>Return the bounding box of the cell box in the given coordinate system.</p> Source code in <code>atomlib/cell.py</code> <pre><code>def bbox_cell(self, frame: CoordinateFrame = 'local') -&gt; BBox3D:\n    \"\"\"Return the bounding box of the cell box in the given coordinate system.\"\"\"\n    return BBox3D.from_pts(self.corners(frame))\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.bbox","title":"<code>bbox(frame='local')</code>","text":"<p>Return the combined bounding box of the cell and atoms in the given coordinate system. To get the cell or atoms bounding box only, use meth:<code>bbox_cell</code> or meth:<code>bbox_atoms</code>.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def bbox(self, frame: CoordinateFrame = 'local') -&gt; BBox3D:\n    \"\"\"\n    Return the combined bounding box of the cell and atoms in the given coordinate system.\n    To get the cell or atoms bounding box only, use :py:meth:`bbox_cell` or :py:meth:`bbox_atoms`.\n    \"\"\"\n    return self.bbox_atoms(frame) | self.bbox_cell(frame)\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.is_orthogonal","title":"<code>is_orthogonal(tol=1e-08)</code>","text":"<p>Returns whether this cell is orthogonal (axes are at right angles.)</p> Source code in <code>atomlib/cell.py</code> <pre><code>def is_orthogonal(self, tol: float = 1e-8) -&gt; bool:\n    \"\"\"Returns whether this cell is orthogonal (axes are at right angles.)\"\"\"\n    return self.ortho.is_diagonal(tol=tol)\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.is_orthogonal_in_local","title":"<code>is_orthogonal_in_local(tol=1e-08)</code>","text":"<p>Returns whether this cell is orthogonal and aligned with the local coordinate system.</p> Source code in <code>atomlib/cell.py</code> <pre><code>def is_orthogonal_in_local(self, tol: float = 1e-8) -&gt; bool:\n    \"\"\"Returns whether this cell is orthogonal and aligned with the local coordinate system.\"\"\"\n    transform = (self.affine @ self.ortho).to_linear()\n    if not transform.is_scaled_orthogonal(tol):\n        return False\n    normed = transform.inner / numpy.linalg.norm(transform.inner, axis=-2, keepdims=True)\n    # every row of transform must be a +/- 1 times a basis vector (i, j, or k)\n    return all(\n        any(numpy.isclose(numpy.abs(numpy.dot(row, v)), 1., atol=tol) for v in numpy.eye(3))\n        for row in normed\n    )\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.to_ortho","title":"<code>to_ortho()</code>","text":"Source code in <code>atomlib/cell.py</code> <pre><code>def to_ortho(self) -&gt; AffineTransform3D:\n    return self.get_transform('local', 'cell_box')\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.transform_cell","title":"<code>transform_cell(transform, frame='local')</code>","text":"<p>Apply the given transform to the unit cell, without changing atom positions. The transform is applied in coordinate frame 'frame'.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def transform_cell(self: HasAtomCellT, transform: AffineTransform3D, frame: CoordinateFrame = 'local') -&gt; HasAtomCellT:\n    \"\"\"\n    Apply the given transform to the unit cell, without changing atom positions.\n    The transform is applied in coordinate frame 'frame'.\n    \"\"\"\n    return self.with_cell(self.get_cell().transform_cell(transform, frame=frame))\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.strain_orthogonal","title":"<code>strain_orthogonal()</code>","text":"<p>Orthogonalize using strain.</p> <p>Strain is applied such that the x-axis remains fixed, and the y-axis remains in the xy plane. For small displacements, no hydrostatic strain is applied (volume is conserved).</p> Source code in <code>atomlib/cell.py</code> <pre><code>def strain_orthogonal(self: HasCellT) -&gt; HasCellT:\n    \"\"\"\n    Orthogonalize using strain.\n\n    Strain is applied such that the x-axis remains fixed, and the y-axis remains in the xy plane.\n    For small displacements, no hydrostatic strain is applied (volume is conserved).\n    \"\"\"\n    return self.with_cell(Cell(\n        affine=self.affine,\n        ortho=LinearTransform3D(),\n        cell_size=self.cell_size,\n        n_cells=self.n_cells,\n        pbc=self.pbc,\n    ))\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.repeat","title":"<code>repeat(n)</code>","text":"<p>Tile the cell</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def repeat(self: HasAtomCellT, n: t.Union[int, VecLike]) -&gt; HasAtomCellT:\n    \"\"\"Tile the cell\"\"\"\n    ns = numpy.broadcast_to(n, 3)\n    if not numpy.issubdtype(ns.dtype, numpy.integer):\n        raise ValueError(f\"repeat() argument must be an integer or integer array.\")\n\n    cells = numpy.stack(numpy.meshgrid(*map(numpy.arange, ns))) \\\n        .reshape(3, -1).T.astype(float)\n    cells = cells * self.box_size\n\n    atoms = self.get_atoms('cell')\n    atoms = Atoms.concat([\n        atoms.transform(AffineTransform3D.translate(cell))\n        for cell in cells\n    ]) #.transform(self.cell.get_transform('local', 'cell_frac'))\n    return self.with_atoms(atoms, 'cell').with_cell(self.get_cell().repeat(ns))\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.explode","title":"<code>explode()</code>","text":"<p>Materialize repeated cells as one supercell.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def explode(self: HasAtomCellT) -&gt; HasAtomCellT:\n    \"\"\"Materialize repeated cells as one supercell.\"\"\"\n    frame = self.get_frame()\n\n    return self.with_atoms(self.get_atoms('local'), 'local') \\\n        .with_cell(self.get_cell().explode()) \\\n        .to_frame(frame)\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.explode_z","title":"<code>explode_z()</code>","text":"<p>Materialize repeated cells as one supercell in z.</p> Source code in <code>atomlib/cell.py</code> <pre><code>def explode_z(self: HasCellT) -&gt; HasCellT:\n    \"\"\"Materialize repeated cells as one supercell in z.\"\"\"\n    return self.with_cell(Cell(\n        affine=self.affine,\n        ortho=self.ortho,\n        cell_size=self.cell_size*[1, 1, self.n_cells[2]],\n        n_cells=[*self.n_cells[:2], 1],\n        cell_angle=self.cell_angle,\n        pbc=self.pbc,\n    ))\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.crop","title":"<code>crop(x_min=-numpy.inf, x_max=numpy.inf, y_min=-numpy.inf, y_max=numpy.inf, z_min=-numpy.inf, z_max=numpy.inf, *, frame='local')</code>","text":"<p>Crop atoms and cell to the given extents. For a non-orthogonal cell, this must be specified in cell coordinates. This function implicity <code>explode</code>s the cell as well.</p> <p>To crop atoms only, use <code>crop_atoms</code> instead.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def crop(self: HasAtomCellT, x_min: float = -numpy.inf, x_max: float = numpy.inf,\n         y_min: float = -numpy.inf, y_max: float = numpy.inf,\n         z_min: float = -numpy.inf, z_max: float = numpy.inf, *,\n         frame: CoordinateFrame = 'local') -&gt; HasAtomCellT:\n    \"\"\"\n    Crop atoms and cell to the given extents. For a non-orthogonal\n    cell, this must be specified in cell coordinates. This\n    function implicity `explode`s the cell as well.\n\n    To crop atoms only, use `crop_atoms` instead.\n    \"\"\"\n\n    cell = self.get_cell().crop(x_min, x_max, y_min, y_max, z_min, z_max, frame=frame)\n    atoms = self._transform_atoms_in_frame(frame, lambda atoms: atoms.crop_atoms(x_min, x_max, y_min, y_max, z_min, z_max))\n    return self.with_cell(cell).with_atoms(atoms)\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.change_transform","title":"<code>change_transform(transform, frame_to=None, frame_from=None)</code>","text":"<p>Coordinate-change a transformation to 'frame_to' from 'frame_from'.</p> Source code in <code>atomlib/cell.py</code> <pre><code>def change_transform(self, transform: Transform3D,\n                     frame_to: t.Optional[CoordinateFrame] = None,\n                     frame_from: t.Optional[CoordinateFrame] = None) -&gt; Transform3D:\n    \"\"\"Coordinate-change a transformation to 'frame_to' from 'frame_from'.\"\"\"\n    if frame_to == frame_from and frame_to is not None:\n        return transform\n    coord_change = self.get_transform(frame_to, frame_from)\n    return coord_change @ transform @ coord_change.inverse()\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.describe","title":"<code>describe(percentiles=(0.25, 0.5, 0.75), *, interpolation='nearest', frame=None)</code>","text":"<p>Return summary statistics for <code>self</code>.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_get\ndef describe(self, percentiles: t.Union[t.Sequence[float], float, None] = (0.25, 0.5, 0.75), *,\n             interpolation: RollingInterpolationMethod = 'nearest',\n             frame: t.Optional[CoordinateFrame] = None) -&gt; polars.DataFrame:\n    \"\"\"Return summary statistics for `self`.\"\"\"\n    ...\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.with_columns","title":"<code>with_columns(*exprs, frame=None, **named_exprs)</code>","text":"<p>Return a copy of <code>self</code> with the given columns added.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef with_columns(self: HasAtomCellT,\n                 *exprs: t.Union[IntoExpr, t.Iterable[IntoExpr]],\n                 frame: t.Optional[CoordinateFrame] = None,\n                 **named_exprs: IntoExpr) -&gt; HasAtomCellT:\n    \"\"\"Return a copy of ``self`` with the given columns added.\"\"\"\n    ...\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.insert_column","title":"<code>insert_column(index, column)</code>","text":"Source code in <code>atomlib/atoms.py</code> <pre><code>@_fwd_frame_map\ndef insert_column(self, index: int, column: polars.Series) -&gt; polars.DataFrame:\n    return self._get_frame().insert_column(index, column)\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.get_column","title":"<code>get_column(name, *, frame=None)</code>","text":"<p>Get the specified column from <code>self</code>, raising <code>polars.ColumnNotFoundError</code> if it's not present.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_get\ndef get_column(self, name: str, *, frame: t.Optional[CoordinateFrame] = None) -&gt; polars.Series:\n    \"\"\"Get the specified column from `self`, raising [`polars.ColumnNotFoundError`][polars.exceptions.ColumnNotFoundError] if it's not present.\"\"\"\n    ...\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.get_columns","title":"<code>get_columns(*, frame=None)</code>","text":"<p>Get the specified columns from <code>self</code>, raising <code>polars.ColumnNotFoundError</code> if it's not present.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_get\ndef get_columns(self, *, frame: t.Optional[CoordinateFrame] = None) -&gt; t.List[polars.Series]:\n    \"\"\"Get the specified columns from `self`, raising [`polars.ColumnNotFoundError`][polars.exceptions.ColumnNotFoundError] if it's not present.\"\"\"\n    ...\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.get_column_index","title":"<code>get_column_index(name)</code>","text":"<p>Get the index of a column by name, raising <code>polars.ColumnNotFoundError</code> if it's not present.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>@_fwd_frame(polars.DataFrame.get_column_index)\ndef get_column_index(self, name: str) -&gt; int:\n    \"\"\"Get the index of a column by name, raising [`polars.ColumnNotFoundError`][polars.exceptions.ColumnNotFoundError] if it's not present.\"\"\"\n    ...\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.group_by","title":"<code>group_by(*by, maintain_order=False, frame=None, **named_by)</code>","text":"Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_get\ndef group_by(self, *by: t.Union[IntoExpr, t.Iterable[IntoExpr]],\n             maintain_order: bool = False, frame: t.Optional[CoordinateFrame] = None,\n             **named_by: IntoExpr) -&gt; polars.dataframe.group_by.GroupBy:\n    ...\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.pipe","title":"<code>pipe(function, *args, **kwargs)</code>","text":"<p>Apply <code>function</code> to <code>self</code> (in method-call syntax).</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def pipe(self: HasAtomCellT, function: t.Callable[Concatenate[HasAtomCellT, P], T], *args: P.args, **kwargs: P.kwargs) -&gt; T:\n    \"\"\"Apply `function` to `self` (in method-call syntax).\"\"\"\n    return function(self, *args, **kwargs)\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.drop","title":"<code>drop(*columns)</code>","text":"<p>Return <code>self</code> with the specified columns removed.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def drop(self, *columns: t.Union[str, t.Iterable[str]]) -&gt; polars.DataFrame:\n    \"\"\"Return `self` with the specified columns removed.\"\"\"\n    return self._get_frame().drop(*columns)\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.filter","title":"<code>filter(*predicates, frame=None, **constraints)</code>","text":"<p>Filter <code>self</code>, removing rows which evaluate to <code>False</code>.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef filter(\n    self: HasAtomCellT,\n    *predicates: t.Union[None, IntoExprColumn, t.Iterable[IntoExprColumn], bool, t.List[bool], numpy.ndarray],\n    frame: t.Optional[CoordinateFrame] = None,\n    **constraints: t.Any,\n) -&gt; HasAtomCellT:\n    \"\"\"Filter `self`, removing rows which evaluate to `False`.\"\"\"\n    ...\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.sort","title":"<code>sort(by, *more_by, descending=False, nulls_last=False)</code>","text":"<p>Sort the atoms in <code>self</code> by the given columns/expressions.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef sort(\n    self: HasAtomCellT,\n    by: t.Union[IntoExpr, t.Iterable[IntoExpr]],\n    *more_by: IntoExpr,\n    descending: t.Union[bool, t.Sequence[bool]] = False,\n    nulls_last: bool = False,\n) -&gt; HasAtomCellT:\n    \"\"\"\n    Sort the atoms in `self` by the given columns/expressions.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.slice","title":"<code>slice(offset, length=None, *, frame=None)</code>","text":"<p>Return a slice of the rows in <code>self</code>.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef slice(self: HasAtomCellT, offset: int, length: t.Optional[int] = None, *,\n          frame: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n    \"\"\"Return a slice of the rows in `self`.\"\"\"\n    ...\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.head","title":"<code>head(n=5, *, frame=None)</code>","text":"<p>Return the first <code>n</code> rows of <code>self</code>.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef head(self: HasAtomCellT, n: int = 5, *, frame: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n    \"\"\"Return the first `n` rows of `self`.\"\"\"\n    ...\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.tail","title":"<code>tail(n=5, *, frame=None)</code>","text":"<p>Return the last <code>n</code> rows of <code>self</code>.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef tail(self: HasAtomCellT, n: int = 5, *, frame: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n    \"\"\"Return the last `n` rows of `self`.\"\"\"\n    ...\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.drop_nulls","title":"<code>drop_nulls(subset=None)</code>","text":"<p>Drop rows that contain nulls in any of columns <code>subset</code>.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>@_fwd_frame_map\ndef drop_nulls(self, subset: t.Union[str, t.Collection[str], None] = None) -&gt; polars.DataFrame:\n    \"\"\"Drop rows that contain nulls in any of columns `subset`.\"\"\"\n    return self._get_frame().drop_nulls(subset)\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.fill_null","title":"<code>fill_null(value=None, strategy=None, limit=None, matches_supertype=True)</code>","text":"Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef fill_null(\n    self: HasAtomCellT, value: t.Any = None, strategy: t.Optional[FillNullStrategy] = None,\n    limit: t.Optional[int] = None, matches_supertype: bool = True,\n) -&gt; HasAtomCellT:\n    ...\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.fill_nan","title":"<code>fill_nan(value, *, frame=None)</code>","text":"Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef fill_nan(self: HasAtomCellT, value: t.Union[polars.Expr, int, float, None], *,\n             frame: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n    ...\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.concat","title":"<code>concat(atoms, *, rechunk=True, how='vertical')</code>  <code>classmethod</code>","text":"<p>Concatenate multiple <code>Atoms</code> together, handling metadata appropriately.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>@classmethod\ndef concat(cls: t.Type[HasAtomsT],\n           atoms: t.Union[HasAtomsT, IntoAtoms, t.Iterable[t.Union[HasAtomsT, IntoAtoms]]], *,\n           rechunk: bool = True, how: ConcatMethod = 'vertical') -&gt; HasAtomsT:\n    \"\"\"Concatenate multiple `Atoms` together, handling metadata appropriately.\"\"\"\n    # this method is tricky. It needs to accept raw Atoms, as well as HasAtoms of the\n    # same type as ``cls``.\n    if _is_abstract(cls):\n        raise TypeError(f\"concat() must be called on a concrete class.\")\n\n    if isinstance(atoms, HasAtoms):\n        atoms = (atoms,)\n    dfs = [a.get_atoms('local').inner if isinstance(a, HasAtoms) else Atoms(t.cast(IntoAtoms, a)).inner for a in atoms]\n    representative = cls._combine_metadata(*(a for a in atoms if isinstance(a, HasAtoms)))\n\n    if len(dfs) == 0:\n        return representative.with_atoms(Atoms.empty(), 'local')\n\n    if how in ('vertical', 'vertical_relaxed'):\n        # get order from first member\n        cols = dfs[0].columns\n        dfs = [df.select(cols) for df in dfs]\n    elif how == 'inner':\n        cols = reduce(operator.and_, (df.schema.keys() for df in dfs))\n        schema = OrderedDict((col, dfs[0].schema[col]) for col in cols)\n        if len(schema) == 0:\n            raise ValueError(f\"Atoms have no columns in common\")\n\n        dfs = [_select_schema(df, schema) for df in dfs]\n        how = 'vertical'\n\n    return representative.with_atoms(Atoms(polars.concat(dfs, rechunk=rechunk, how=how)), 'local')\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.partition_by","title":"<code>partition_by(by, *more_by, maintain_order=True, include_key=True, as_dict=False)</code>","text":"<p>Group by the given columns and partition into separate dataframes.</p> <p>Return the partitions as a dictionary by specifying <code>as_dict=True</code>.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def partition_by(\n    self: HasAtomsT, by: t.Union[str, t.Sequence[str]], *more_by: str,\n    maintain_order: bool = True, include_key: bool = True, as_dict: bool = False\n) -&gt; t.Union[t.List[HasAtomsT], t.Dict[t.Any, HasAtomsT]]:\n    \"\"\"\n    Group by the given columns and partition into separate dataframes.\n\n    Return the partitions as a dictionary by specifying `as_dict=True`.\n    \"\"\"\n    if as_dict:\n        d = self._get_frame().partition_by(by, *more_by, maintain_order=maintain_order, include_key=include_key, as_dict=True)\n        return {k: self.with_atoms(Atoms(df, _unchecked=True)) for (k, df) in d.items()}\n\n    return [\n        self.with_atoms(Atoms(df, _unchecked=True))\n        for df in self._get_frame().partition_by(by, *more_by, maintain_order=maintain_order, include_key=include_key, as_dict=False)\n    ]\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.select","title":"<code>select(*exprs, frame=None, **named_exprs)</code>","text":"<p>Select <code>exprs`` from ``self</code>, and return as a <code>polars.DataFrame</code>.</p> <p>Expressions may either be columns or expressions of columns.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_get\ndef select(\n    self, *exprs: t.Union[IntoExpr, t.Iterable[IntoExpr]],\n    frame: t.Optional[CoordinateFrame] = None,\n    **named_exprs: IntoExpr\n) -&gt; polars.DataFrame:\n    \"\"\"\n    Select `exprs`` from ``self`, and return as a `polars.DataFrame`.\n\n    Expressions may either be columns or expressions of columns.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.select_schema","title":"<code>select_schema(schema)</code>","text":"<p>Select columns from <code>self</code> and cast to the given schema. Raises <code>TypeError</code> if a column is not found or if it can't be cast.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def select_schema(self, schema: SchemaDict) -&gt; polars.DataFrame:\n    \"\"\"\n    Select columns from `self` and cast to the given schema.\n    Raises `TypeError` if a column is not found or if it can't be cast.\n    \"\"\"\n    return _select_schema(self, schema)\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.select_props","title":"<code>select_props(*exprs, frame=None, **named_exprs)</code>","text":"<p>Select <code>exprs</code> from <code>self</code>, while keeping required columns.</p> <p>Returns a HasAtoms.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef select_props(\n    self: HasAtomCellT,\n    *exprs: t.Union[IntoExpr, t.Iterable[IntoExpr]],\n    frame: t.Optional[CoordinateFrame] = None,\n    **named_exprs: IntoExpr\n) -&gt; HasAtomCellT:\n    \"\"\"\n    Select `exprs` from `self`, while keeping required columns.\n\n    Returns a HasAtoms.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.try_select","title":"<code>try_select(*exprs, frame=None, **named_exprs)</code>","text":"<p>Try to select <code>exprs</code> from <code>self</code>, and return as a <code>polars.DataFrame</code>.</p> <p>Expressions may either be columns or expressions of columns. Return <code>None</code> if any columns are missing.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_get\ndef try_select(\n    self, *exprs: t.Union[IntoExpr, t.Iterable[IntoExpr]],\n    frame: t.Optional[CoordinateFrame] = None,\n    **named_exprs: IntoExpr\n) -&gt; t.Optional[polars.DataFrame]:\n    \"\"\"\n    Try to select `exprs` from `self`, and return as a `polars.DataFrame`.\n\n    Expressions may either be columns or expressions of columns.\n    Return `None` if any columns are missing.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.try_get_column","title":"<code>try_get_column(name)</code>","text":"<p>Try to get a column from <code>self</code>, returning <code>None</code> if it doesn't exist.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def try_get_column(self, name: str) -&gt; t.Optional[polars.Series]:\n    \"\"\"Try to get a column from `self`, returning `None` if it doesn't exist.\"\"\"\n    try:\n        return self.get_column(name)\n    except polars.ColumnNotFoundError:\n        return None\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.bbox_atoms","title":"<code>bbox_atoms(frame=None)</code>","text":"<p>Return the bounding box of all the atoms in <code>self</code>, in the given coordinate frame.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def bbox_atoms(self, frame: t.Optional[CoordinateFrame] = None) -&gt; BBox3D:\n    \"\"\"Return the bounding box of all the atoms in ``self``, in the given coordinate frame.\"\"\"\n    return self.get_atoms(frame).bbox()\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.transform_atoms","title":"<code>transform_atoms(transform, selection=None, *, frame='local', transform_velocities=False)</code>","text":"<p>Transform the atoms in <code>self</code> by <code>transform</code>. If <code>selection</code> is given, only transform the atoms in <code>selection</code>.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def transform_atoms(self: HasAtomCellT, transform: IntoTransform3D, selection: t.Optional[AtomSelection] = None, *,\n                    frame: CoordinateFrame = 'local', transform_velocities: bool = False) -&gt; HasAtomCellT:\n    \"\"\"\n    Transform the atoms in `self` by `transform`.\n    If `selection` is given, only transform the atoms in `selection`.\n    \"\"\"\n    transform = self.change_transform(Transform3D.make(transform), self.get_frame(), frame)\n    return self.with_atoms(self.get_atoms(self.get_frame()).transform(transform, selection, transform_velocities=transform_velocities))\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.transform","title":"<code>transform(transform, frame='local')</code>","text":"Source code in <code>atomlib/atomcell.py</code> <pre><code>def transform(self: HasAtomCellT, transform: AffineTransform3D, frame: CoordinateFrame = 'local') -&gt; HasAtomCellT:\n    if isinstance(transform, Transform3D) and not isinstance(transform, AffineTransform3D):\n        raise ValueError(\"Non-affine transforms cannot change the box dimensions. Use 'transform_atoms' instead.\")\n    # TODO: cleanup once tests pass\n    # coordinate change the transform into atomic coordinates\n    new_cell = self.get_cell().transform_cell(transform, frame)\n    transform = self.get_cell().change_transform(transform, self.get_frame(), frame)\n    return self.with_atoms(self.get_atoms().transform(transform), self.get_frame()).with_cell(new_cell)\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.round_near_zero","title":"<code>round_near_zero(tol=1e-14, *, frame=None)</code>","text":"<p>Round atom position values near zero to zero.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef round_near_zero(self: HasAtomCellT, tol: float = 1e-14, *,\n                    frame: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n    \"\"\"\n    Round atom position values near zero to zero.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.crop_atoms","title":"<code>crop_atoms(x_min=-numpy.inf, x_max=numpy.inf, y_min=-numpy.inf, y_max=numpy.inf, z_min=-numpy.inf, z_max=numpy.inf, *, frame='local')</code>","text":"Source code in <code>atomlib/atomcell.py</code> <pre><code>def crop_atoms(self: HasAtomCellT, x_min: float = -numpy.inf, x_max: float = numpy.inf,\n               y_min: float = -numpy.inf, y_max: float = numpy.inf,\n               z_min: float = -numpy.inf, z_max: float = numpy.inf, *,\n               frame: CoordinateFrame = 'local') -&gt; HasAtomCellT:\n    atoms = self._transform_atoms_in_frame(frame, lambda atoms: atoms.crop_atoms(x_min, x_max, y_min, y_max, z_min, z_max))\n    return self.with_atoms(atoms)\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.deduplicate","title":"<code>deduplicate(tol=0.001, subset=('x', 'y', 'z', 'symbol'), keep='first', maintain_order=True)</code>","text":"<p>De-duplicate atoms in <code>self</code>. Atoms of the same <code>symbol</code> that are closer than <code>tolerance</code> to each other (by Euclidian distance) will be removed, leaving only the atom specified by <code>keep</code> (defaults to the first atom).</p> <p>If <code>subset</code> is specified, only those columns will be included while assessing duplicates. Floating point columns other than 'x', 'y', and 'z' will not by toleranced.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def deduplicate(self: HasAtomsT, tol: float = 1e-3, subset: t.Iterable[str] = ('x', 'y', 'z', 'symbol'),\n                keep: UniqueKeepStrategy = 'first', maintain_order: bool = True) -&gt; HasAtomsT:\n    \"\"\"\n    De-duplicate atoms in `self`. Atoms of the same `symbol` that are closer than `tolerance`\n    to each other (by Euclidian distance) will be removed, leaving only the atom specified by\n    `keep` (defaults to the first atom).\n\n    If `subset` is specified, only those columns will be included while assessing duplicates.\n    Floating point columns other than 'x', 'y', and 'z' will not by toleranced.\n    \"\"\"\n    import scipy.spatial\n\n    cols = set((subset,) if isinstance(subset, str) else subset)\n\n    indices = numpy.arange(len(self))\n\n    spatial_cols = cols.intersection(('x', 'y', 'z'))\n    cols -= spatial_cols\n    if len(spatial_cols) &gt; 0:\n        coords = self.select([_coord_expr(col).alias(col) for col in spatial_cols]).to_numpy()\n        tree = scipy.spatial.KDTree(coords)\n\n        # TODO This is a bad algorithm\n        while True:\n            changed = False\n            for (i, j) in tree.query_pairs(tol, 2.):\n                # whenever we encounter a pair, ensure their index matches\n                i_i, i_j = indices[[i, j]]\n                if i_i != i_j:\n                    indices[i] = indices[j] = min(i_i, i_j)\n                    changed = True\n            if not changed:\n                break\n\n        self = self.with_column(polars.Series('_unique_pts', indices))\n        cols.add('_unique_pts')\n\n    frame = self._get_frame().unique(subset=list(cols), keep=keep, maintain_order=maintain_order)\n    if len(spatial_cols) &gt; 0:\n        frame = frame.drop('_unique_pts')\n\n    return self.with_atoms(Atoms(frame, _unchecked=True))\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.with_bounds","title":"<code>with_bounds(cell_size=None, cell_origin=None)</code>","text":"<p>Return a periodic cell with the given orthogonal cell dimensions.</p> <p>If cell_size is not specified, it will be assumed (and may be incorrect).</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def with_bounds(self, cell_size: t.Optional[VecLike] = None, cell_origin: t.Optional[VecLike] = None) -&gt; 'AtomCell':\n    \"\"\"\n    Return a periodic cell with the given orthogonal cell dimensions.\n\n    If cell_size is not specified, it will be assumed (and may be incorrect).\n    \"\"\"\n    # TODO: test this\n    from .atomcell import AtomCell\n\n    if cell_size is None:\n        warnings.warn(\"Cell boundary unknown. Defaulting to cell BBox\")\n        cell_size = self.bbox().size\n        cell_origin = self.bbox().min\n\n    # TODO test this origin code\n    cell = Cell.from_unit_cell(cell_size)\n    if cell_origin is not None:\n        cell = cell.transform_cell(AffineTransform3D.translate(to_vec3(cell_origin)))\n\n    return AtomCell(self.get_atoms(), cell, frame='local')\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.coords","title":"<code>coords(selection=None, *, frame=None)</code>","text":"<p>Returns a <code>(N, 3)</code> ndarray of atom coordinates (dtype <code>numpy.float64</code>).</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_get\ndef coords(self, selection: t.Optional[AtomSelection] = None, *, frame: t.Optional[CoordinateFrame] = None) -&gt; NDArray[numpy.float64]:\n    \"\"\"Returns a `(N, 3)` ndarray of atom coordinates (dtype ``numpy.float64``).\"\"\"\n    ...\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.x","title":"<code>x()</code>","text":"Source code in <code>atomlib/atoms.py</code> <pre><code>def x(self) -&gt; polars.Expr:\n    return polars.col('coords').arr.get(0).alias('x')\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.y","title":"<code>y()</code>","text":"Source code in <code>atomlib/atoms.py</code> <pre><code>def y(self) -&gt; polars.Expr:\n    return polars.col('coords').arr.get(1).alias('y')\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.z","title":"<code>z()</code>","text":"Source code in <code>atomlib/atoms.py</code> <pre><code>def z(self) -&gt; polars.Expr:\n    return polars.col('coords').arr.get(2).alias('z')\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.velocities","title":"<code>velocities(selection=None, *, frame=None)</code>","text":"<p>Returns a <code>(N, 3)</code> ndarray of atom velocities (dtype <code>numpy.float64</code>).</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_get\ndef velocities(self, selection: t.Optional[AtomSelection] = None, *, frame: t.Optional[CoordinateFrame] = None) -&gt; t.Optional[NDArray[numpy.float64]]:\n    \"\"\"Returns a `(N, 3)` ndarray of atom velocities (dtype ``numpy.float64``).\"\"\"\n    ...\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.types","title":"<code>types()</code>","text":"<p>Returns a <code>Series</code> of atom types (dtype <code>polars.Int32</code>).</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def types(self) -&gt; t.Optional[polars.Series]:\n    \"\"\"\n    Returns a [`Series`][polars.Series] of atom types (dtype [`polars.Int32`][polars.Int32]).\n\n    [polars.Series]: https://docs.pola.rs/py-polars/html/reference/series/index.html\n    \"\"\"\n    return self.try_get_column('type')\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.masses","title":"<code>masses()</code>","text":"<p>Returns a <code>Series</code> of atom masses (dtype <code>polars.Float32</code>).</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def masses(self) -&gt; t.Optional[polars.Series]:\n    \"\"\"\n    Returns a [`Series`][polars.Series] of atom masses (dtype [`polars.Float32`][polars.Float32]).\n\n    [polars.Series]: https://docs.pola.rs/py-polars/html/reference/series/index.html\n    \"\"\"\n    return self.try_get_column('mass')\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.add_atom","title":"<code>add_atom(elem, /, x, y=None, z=None, *, frame=None, **kwargs)</code>","text":"<p>Return a copy of <code>self</code> with an extra atom.</p> <p>By default, all extra columns present in <code>self</code> must be specified as <code>**kwargs</code>.</p> <p>Try to avoid calling this in a loop (Use meth:<code>concat</code> instead).</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef add_atom(self: HasAtomCellT, elem: t.Union[int, str], /,  # type: ignore (spurious)\n             x: t.Union[ArrayLike, float],\n             y: t.Optional[float] = None,\n             z: t.Optional[float] = None, *,\n             frame: t.Optional[CoordinateFrame] = None,\n             **kwargs: t.Any) -&gt; HasAtomCellT:\n    \"\"\"\n    Return a copy of ``self`` with an extra atom.\n\n    By default, all extra columns present in ``self`` must be specified as ``**kwargs``.\n\n    Try to avoid calling this in a loop (Use :py:meth:`concat` instead).\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.pos","title":"<code>pos(x=None, y=None, z=None, *, tol=1e-06, **kwargs)</code>","text":"<p>Select all atoms at a given position.</p> <p>Formally, returns all atoms within a cube of radius <code>tol</code> centered at <code>(x,y,z)</code>, exclusive of the cube's surface.</p> <p>Additional parameters given as <code>kwargs</code> will be checked as additional parameters (with strict equality).</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def pos(self,\n        x: t.Union[t.Sequence[t.Optional[float]], float, None] = None,\n        y: t.Optional[float] = None, z: t.Optional[float] = None, *,\n        tol: float = 1e-6, **kwargs: t.Any) -&gt; polars.Expr:\n    \"\"\"\n    Select all atoms at a given position.\n\n    Formally, returns all atoms within a cube of radius ``tol``\n    centered at ``(x,y,z)``, exclusive of the cube's surface.\n\n    Additional parameters given as ``kwargs`` will be checked\n    as additional parameters (with strict equality).\n    \"\"\"\n\n    if isinstance(x, t.Sequence):\n        (x, y, z) = x\n\n    tol = abs(float(tol))\n    selection = polars.lit(True)\n    if x is not None:\n        selection &amp;= self.x().is_between(x - tol, x + tol, closed='none')\n    if y is not None:\n        selection &amp;= self.y().is_between(y - tol, y + tol, closed='none')\n    if z is not None:\n        selection &amp;= self.z().is_between(z - tol, z + tol, closed='none')\n    for (col, val) in kwargs.items():\n        selection &amp;= (polars.col(col) == val)\n\n    return selection\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.with_index","title":"<code>with_index(index=None, *, frame=None)</code>","text":"<p>Returns <code>self</code> with a row index added in column 'i' (dtype polars.Int64). If <code>index</code> is not specified, defaults to an existing index or a new index.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef with_index(self: HasAtomCellT, index: t.Optional[AtomValues] = None, *,\n               frame: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n    \"\"\"\n    Returns ``self`` with a row index added in column 'i' (dtype polars.Int64).\n    If ``index`` is not specified, defaults to an existing index or a new index.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.with_wobble","title":"<code>with_wobble(wobble=None, *, frame=None)</code>","text":"<p>Return <code>self</code> with the given displacements in column 'wobble' (dtype polars.Float64). If <code>wobble</code> is not specified, defaults to the already-existing wobbles or 0.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef with_wobble(self: HasAtomCellT, wobble: t.Optional[AtomValues] = None, *,\n                frame: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n    \"\"\"\n    Return ``self`` with the given displacements in column 'wobble' (dtype polars.Float64).\n    If ``wobble`` is not specified, defaults to the already-existing wobbles or 0.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.with_occupancy","title":"<code>with_occupancy(frac_occupancy=None, *, frame=None)</code>","text":"<p>Return self with the given fractional occupancies. If <code>frac_occupancy</code> is not specified, defaults to the already-existing occupancies or 1.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef with_occupancy(self: HasAtomCellT, frac_occupancy: t.Optional[AtomValues] = None, *,\n                   frame: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n    \"\"\"\n    Return self with the given fractional occupancies. If ``frac_occupancy`` is not specified,\n    defaults to the already-existing occupancies or 1.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.apply_wobble","title":"<code>apply_wobble(rng=None, frame=None)</code>","text":"<p>Displace the atoms in <code>self</code> by the amount in the <code>wobble</code> column. <code>wobble</code> is interpretated as a mean-squared displacement, which is distributed equally over each axis.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef apply_wobble(self: HasAtomCellT, rng: t.Union[numpy.random.Generator, int, None] = None,\n                 frame: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n    \"\"\"\n    Displace the atoms in ``self`` by the amount in the `wobble` column.\n    ``wobble`` is interpretated as a mean-squared displacement, which is distributed\n    equally over each axis.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.apply_occupancy","title":"<code>apply_occupancy(rng=None)</code>","text":"<p>For each atom in <code>self</code>, use its <code>frac_occupancy</code> to randomly decide whether to remove it.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def apply_occupancy(self: HasAtomsT, rng: t.Union[numpy.random.Generator, int, None] = None) -&gt; HasAtomsT:\n    \"\"\"\n    For each atom in `self`, use its `frac_occupancy` to randomly decide whether to remove it.\n    \"\"\"\n    if 'frac_occupancy' not in self.columns:\n        return self\n    rng = numpy.random.default_rng(seed=rng)\n\n    frac = self.select('frac_occupancy').to_series().to_numpy()\n    choice = rng.binomial(1, frac).astype(numpy.bool_)\n    return self.filter(polars.lit(choice))\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.with_type","title":"<code>with_type(types=None, *, frame=None)</code>","text":"<p>Return <code>self</code> with the given atom types in column 'type'. If <code>types</code> is not specified, use the already existing types or auto-assign them.</p> <p>When auto-assigning, each symbol is given a unique value, case-sensitive. Values are assigned from lowest atomic number to highest. For instance: <code>[\"Ag+\", \"Na\", \"H\", \"Ag\"]</code> =&gt; <code>[3, 11, 1, 2]</code></p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef with_type(self: HasAtomCellT, types: t.Optional[AtomValues] = None, *,\n              frame: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n    \"\"\"\n    Return ``self`` with the given atom types in column 'type'.\n    If ``types`` is not specified, use the already existing types or auto-assign them.\n\n    When auto-assigning, each symbol is given a unique value, case-sensitive.\n    Values are assigned from lowest atomic number to highest.\n    For instance: ``[\"Ag+\", \"Na\", \"H\", \"Ag\"]`` =&gt; ``[3, 11, 1, 2]``\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.with_mass","title":"<code>with_mass(mass=None, *, frame=None)</code>","text":"<p>Return <code>self</code> with the given atom masses in column 'mass'. If <code>mass</code> is not specified, use the already existing masses or auto-assign them.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef with_mass(self: HasAtomCellT, mass: t.Optional[ArrayLike] = None, *,\n              frame: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n    \"\"\"\n    Return ``self`` with the given atom masses in column 'mass'.\n    If ``mass`` is not specified, use the already existing masses or auto-assign them.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.with_symbol","title":"<code>with_symbol(symbols, selection=None, *, frame=None)</code>","text":"<p>Return <code>self</code> with the given atomic symbols.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef with_symbol(self: HasAtomCellT, symbols: ArrayLike, selection: t.Optional[AtomSelection] = None, *,\n                frame: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n    \"\"\"\n    Return ``self`` with the given atomic symbols.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.with_coords","title":"<code>with_coords(pts, selection=None, *, frame=None)</code>","text":"<p>Return <code>self</code> replaced with the given atomic positions.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef with_coords(self: HasAtomCellT, pts: ArrayLike, selection: t.Optional[AtomSelection] = None, *,\n                frame: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n    \"\"\"\n    Return ``self`` replaced with the given atomic positions.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.with_velocity","title":"<code>with_velocity(pts=None, selection=None, *, frame=None)</code>","text":"<p>Return <code>self</code> replaced with the given atomic velocities. If <code>pts</code> is not specified, use the already existing velocities or zero.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef with_velocity(self: HasAtomCellT, pts: t.Optional[ArrayLike] = None,\n                  selection: t.Optional[AtomSelection] = None, *,\n                  frame: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n    \"\"\"\n    Return ``self`` replaced with the given atomic velocities.\n    If ``pts`` is not specified, use the already existing velocities or zero.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.get_atomcell","title":"<code>get_atomcell()</code>","text":"Source code in <code>atomlib/atomcell.py</code> <pre><code>def get_atomcell(self) -&gt; AtomCell:\n    frame = self.get_frame()\n    return AtomCell(self.get_atoms(frame), self.get_cell(), frame=frame, keep_frame=True)\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.to_frame","title":"<code>to_frame(frame)</code>","text":"<p>Convert the stored Atoms to the given coordinate frame.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def to_frame(self: HasAtomCellT, frame: CoordinateFrame) -&gt; HasAtomCellT:\n    \"\"\"Convert the stored Atoms to the given coordinate frame.\"\"\"\n    return self.with_atoms(self.get_atoms(frame), frame)\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.crop_to_box","title":"<code>crop_to_box(eps=1e-05)</code>","text":"Source code in <code>atomlib/atomcell.py</code> <pre><code>def crop_to_box(self: HasAtomCellT, eps: float = 1e-5) -&gt; HasAtomCellT:\n    atoms = self._transform_atoms_in_frame('cell_box', lambda atoms: atoms.crop_atoms(*([-eps, 1-eps]*3)))\n    return self.with_atoms(atoms)\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.wrap","title":"<code>wrap(eps=1e-05)</code>","text":"<p>Wrap atoms around the cell boundaries.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def wrap(self: HasAtomCellT, eps: float = 1e-5) -&gt; HasAtomCellT:\n    \"\"\"Wrap atoms around the cell boundaries.\"\"\"\n    return self.with_atoms(self._transform_atoms_in_frame('cell_box', lambda a: a._wrap(eps)))\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.repeat_to","title":"<code>repeat_to(size, crop=False)</code>","text":"<p>Repeat the cell so it is at least <code>size</code> along the crystal's axes.</p> <p>If <code>crop</code>, then crop the cell to exactly <code>size</code>. This may break periodicity. <code>crop</code> may be a vector, in which case you can specify cropping only along some axes.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def repeat_to(self: HasAtomCellT, size: VecLike, crop: t.Union[bool, t.Sequence[bool]] = False) -&gt; HasAtomCellT:\n    \"\"\"\n    Repeat the cell so it is at least ``size`` along the crystal's axes.\n\n    If ``crop``, then crop the cell to exactly ``size``. This may break periodicity.\n    ``crop`` may be a vector, in which case you can specify cropping only along some axes.\n    \"\"\"\n    size = to_vec3(size)\n    cell_size = self.cell_size * self.n_cells\n    repeat = numpy.maximum(numpy.ceil(size / cell_size).astype(int), 1)\n    atom_cell = self.repeat(repeat)\n\n    crop_v = to_vec3(crop, dtype=numpy.bool_)\n    if numpy.any(crop_v):\n        crop_x, crop_y, crop_z = crop_v\n        return atom_cell.crop(\n            x_max = size[0] if crop_x else numpy.inf,\n            y_max = size[1] if crop_y else numpy.inf,\n            z_max = size[2] if crop_z else numpy.inf,\n            frame='cell'\n        )\n\n    return atom_cell\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.repeat_x","title":"<code>repeat_x(n)</code>","text":"<p>Tile the cell in the x axis.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def repeat_x(self: HasAtomCellT, n: int) -&gt; HasAtomCellT:\n    \"\"\"Tile the cell in the x axis.\"\"\"\n    return self.repeat((n, 1, 1))\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.repeat_y","title":"<code>repeat_y(n)</code>","text":"<p>Tile the cell in the y axis.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def repeat_y(self: HasAtomCellT, n: int) -&gt; HasAtomCellT:\n    \"\"\"Tile the cell in the y axis.\"\"\"\n    return self.repeat((1, n, 1))\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.repeat_z","title":"<code>repeat_z(n)</code>","text":"<p>Tile the cell in the z axis.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def repeat_z(self: HasAtomCellT, n: int) -&gt; HasAtomCellT:\n    \"\"\"Tile the cell in the z axis.\"\"\"\n    return self.repeat((1, 1, n))\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.repeat_to_x","title":"<code>repeat_to_x(size, crop=False)</code>","text":"<p>Repeat the cell so it is at least size <code>size</code> along the x axis.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def repeat_to_x(self: HasAtomCellT, size: float, crop: bool = False) -&gt; HasAtomCellT:\n    \"\"\"Repeat the cell so it is at least size ``size`` along the x axis.\"\"\"\n    return self.repeat_to([size, 0., 0.], [crop, False, False])\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.repeat_to_y","title":"<code>repeat_to_y(size, crop=False)</code>","text":"<p>Repeat the cell so it is at least size <code>size</code> along the y axis.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def repeat_to_y(self: HasAtomCellT, size: float, crop: bool = False) -&gt; HasAtomCellT:\n    \"\"\"Repeat the cell so it is at least size ``size`` along the y axis.\"\"\"\n    return self.repeat_to([0., size, 0.], [False, crop, False])\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.repeat_to_z","title":"<code>repeat_to_z(size, crop=False)</code>","text":"<p>Repeat the cell so it is at least size <code>size</code> along the z axis.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def repeat_to_z(self: HasAtomCellT, size: float, crop: bool = False) -&gt; HasAtomCellT:\n    \"\"\"Repeat the cell so it is at least size ``size`` along the z axis.\"\"\"\n    return self.repeat_to([0., 0., size], [False, False, crop])\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.repeat_to_aspect","title":"<code>repeat_to_aspect(plane='xy', *, aspect=1.0, min_size=None, max_size=None)</code>","text":"<p>Repeat to optimize the aspect ratio in <code>plane</code>, while staying above <code>min_size</code> and under <code>max_size</code>.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def repeat_to_aspect(self: HasAtomCellT, plane: t.Literal['xy', 'xz', 'yz'] = 'xy', *,\n                     aspect: float = 1., min_size: t.Optional[VecLike] = None,\n                     max_size: t.Optional[VecLike] = None) -&gt; HasAtomCellT:\n    \"\"\"\n    Repeat to optimize the aspect ratio in ``plane``,\n    while staying above ``min_size`` and under ``max_size``.\n    \"\"\"\n    if min_size is None:\n        min_n = numpy.array([1, 1, 1], numpy.int_)\n    else:\n        min_n = numpy.maximum(numpy.ceil(to_vec3(min_size) / self.box_size), 1).astype(numpy.int_)\n\n    if max_size is None:\n        max_n = 3 * min_n\n    else:\n        max_n = numpy.maximum(numpy.floor(to_vec3(max_size) / self.box_size), 1).astype(numpy.int_)\n\n    if plane == 'xy':\n        indices = [0, 1]\n    elif plane == 'xz':\n        indices = [0, 2]\n    elif plane == 'yz':\n        indices = [1, 2]\n    else:\n        raise ValueError(f\"Invalid plane '{plane}'. Exepcted 'xy', 'xz', 'or 'yz'.\")\n\n    na = numpy.arange(min_n[indices[0]], max_n[indices[0]])\n    nb = numpy.arange(min_n[indices[1]], max_n[indices[1]])\n    (na, nb) = numpy.meshgrid(na, nb)\n\n    aspects = na * self.box_size[indices[0]] / (nb * self.box_size[indices[1]])\n    # cost function: log(aspect)^2  (so cost(0.5) == cost(2))\n    min_i = numpy.argmin(numpy.log(aspects / aspect)**2)\n    repeat = numpy.array([1, 1, 1], numpy.int_)\n    repeat[indices] = na.flatten()[min_i], nb.flatten()[min_i]\n    return self.repeat(repeat)\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.periodic_duplicate","title":"<code>periodic_duplicate(eps=1e-05)</code>","text":"<p>Add duplicate copies of atoms near periodic boundaries.</p> <p>For instance, an atom at a corner will be duplicated into 8 copies. This is mostly only useful for visualization.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def periodic_duplicate(self: HasAtomCellT, eps: float = 1e-5) -&gt; HasAtomCellT:\n    \"\"\"\n    Add duplicate copies of atoms near periodic boundaries.\n\n    For instance, an atom at a corner will be duplicated into 8 copies.\n    This is mostly only useful for visualization.\n    \"\"\"\n    frame_save = self.get_frame()\n    self = self.to_frame('cell_box').wrap(eps=eps)\n\n    for i in range(3):\n        self = self.concat((self,\n            self.filter(polars.col('coords').arr.get(i).abs() &lt;= eps, frame='cell_box')\n                .transform_atoms(AffineTransform3D.translate([1. if i == j else 0. for j in range(3)]), frame='cell_box')\n        ))\n\n    return self.to_frame(frame_save)\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.read","title":"<code>read(path, ty=None)</code>  <code>classmethod</code>","text":"<p>Read a structure from a file.</p> <p>Supported types can be found in the io module. If no <code>ty</code> is specified, it is inferred from the file's extension.</p> Source code in <code>atomlib/mixins.py</code> <pre><code>@classmethod\ndef read(cls: t.Type[HasAtomsT], path: FileOrPath, ty: t.Optional[FileType] = None) -&gt; HasAtomsT:\n    \"\"\"\n    Read a structure from a file.\n\n    Supported types can be found in the [io][atomlib.io] module.\n    If no `ty` is specified, it is inferred from the file's extension.\n    \"\"\"\n    from .io import read\n    return _cast_atoms(read(path, ty), cls)  # type: ignore\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.read_cif","title":"<code>read_cif(f, block=None)</code>  <code>classmethod</code>","text":"<p>Read a structure from a CIF file.</p> <p>If <code>block</code> is specified, read data from the given block of the CIF file (index or name).</p> Source code in <code>atomlib/mixins.py</code> <pre><code>@classmethod\ndef read_cif(cls: t.Type[HasAtomsT], f: t.Union[FileOrPath, CIF, CIFDataBlock], block: t.Union[int, str, None] = None) -&gt; HasAtomsT:\n    \"\"\"\n    Read a structure from a CIF file.\n\n    If `block` is specified, read data from the given block of the CIF file (index or name).\n    \"\"\"\n    from .io import read_cif\n    return _cast_atoms(read_cif(f, block), cls)\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.read_xyz","title":"<code>read_xyz(f)</code>  <code>classmethod</code>","text":"<p>Read a structure from an XYZ file.</p> Source code in <code>atomlib/mixins.py</code> <pre><code>@classmethod\ndef read_xyz(cls: t.Type[HasAtomsT], f: t.Union[FileOrPath, XYZ]) -&gt; HasAtomsT:\n    \"\"\"Read a structure from an XYZ file.\"\"\"\n    from .io import read_xyz\n    return _cast_atoms(read_xyz(f), cls)\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.read_xsf","title":"<code>read_xsf(f)</code>  <code>classmethod</code>","text":"<p>Read a structure from an XSF file.</p> Source code in <code>atomlib/mixins.py</code> <pre><code>@classmethod\ndef read_xsf(cls: t.Type[HasAtomsT], f: t.Union[FileOrPath, XSF]) -&gt; HasAtomsT:\n    \"\"\"Read a structure from an XSF file.\"\"\"\n    from .io import read_xsf\n    return _cast_atoms(read_xsf(f), cls)\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.read_cfg","title":"<code>read_cfg(f)</code>  <code>classmethod</code>","text":"<p>Read a structure from a CFG file.</p> Source code in <code>atomlib/mixins.py</code> <pre><code>@classmethod\ndef read_cfg(cls: t.Type[HasAtomsT], f: t.Union[FileOrPath, CFG]) -&gt; HasAtomsT:\n    \"\"\"Read a structure from a CFG file.\"\"\"\n    from .io import read_cfg\n    return _cast_atoms(read_cfg(f), cls)\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.read_lmp","title":"<code>read_lmp(f, type_map=None)</code>  <code>classmethod</code>","text":"<p>Read a structure from a LAAMPS data file.</p> Source code in <code>atomlib/mixins.py</code> <pre><code>@classmethod\ndef read_lmp(cls: t.Type[HasAtomsT], f: t.Union[FileOrPath, LMP], type_map: t.Optional[t.Dict[int, t.Union[str, int]]] = None) -&gt; HasAtomsT:\n    \"\"\"Read a structure from a LAAMPS data file.\"\"\"\n    from .io import read_lmp\n    return _cast_atoms(read_lmp(f, type_map=type_map), cls)\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.write_cif","title":"<code>write_cif(f)</code>","text":"Source code in <code>atomlib/mixins.py</code> <pre><code>def write_cif(self, f: FileOrPath):\n    from .io import write_cif\n    write_cif(self, f)\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.write_xyz","title":"<code>write_xyz(f, fmt='exyz')</code>","text":"Source code in <code>atomlib/mixins.py</code> <pre><code>def write_xyz(self, f: FileOrPath, fmt: XYZFormat = 'exyz'):\n    from .io import write_xyz\n    write_xyz(self, f, fmt)\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.write_xsf","title":"<code>write_xsf(f)</code>","text":"Source code in <code>atomlib/mixins.py</code> <pre><code>def write_xsf(self, f: FileOrPath):\n    from .io import write_xsf\n    write_xsf(self, f)\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.write_cfg","title":"<code>write_cfg(f)</code>","text":"Source code in <code>atomlib/mixins.py</code> <pre><code>def write_cfg(self, f: FileOrPath):\n    from .io import write_cfg\n    write_cfg(self, f)\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.write_lmp","title":"<code>write_lmp(f)</code>","text":"Source code in <code>atomlib/mixins.py</code> <pre><code>def write_lmp(self, f: FileOrPath):\n    from .io import write_lmp\n    write_lmp(self, f)\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.write","title":"<code>write(path, ty=None)</code>","text":"<p>Write this structure to a file.</p> <p>A file type may be specified using <code>ty</code>. If no <code>ty</code> is specified, it is inferred from the path's extension.</p> Source code in <code>atomlib/mixins.py</code> <pre><code>def write(self, path: FileOrPath, ty: t.Optional[FileType] = None):\n    \"\"\"\n    Write this structure to a file.\n\n    A file type may be specified using `ty`.\n    If no `ty` is specified, it is inferred from the path's extension.\n    \"\"\"\n    from .io import write\n    write(self, path, ty)  # type: ignore\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.write_mslice","title":"<code>write_mslice(f, template=None, *, slice_thickness=None, scan_points=None, scan_extent=None, noise_sigma=None, conv_angle=None, energy=None, defocus=None, tilt=None, tds=None, n_cells=None)</code>","text":"<p>Write a structure to an mslice file.</p> <p><code>template</code> may be a file, path, or ElementTree containing an existing mslice file. Its structure will be modified to make the final output. If not specified, a default template will be used.</p> <p>Additional options modify simulation properties. If an option is not specified, the template's properties are used.</p> Source code in <code>atomlib/mixins.py</code> <pre><code>def write_mslice(self, f: BinaryFileOrPath, template: t.Optional[MSliceFile] = None, *,\n             slice_thickness: t.Optional[float] = None,  # angstrom\n             scan_points: t.Optional[ArrayLike] = None,\n             scan_extent: t.Optional[ArrayLike] = None,\n             noise_sigma: t.Optional[float] = None,  # angstrom\n             conv_angle: t.Optional[float] = None,  # mrad\n             energy: t.Optional[float] = None,  # keV\n             defocus: t.Optional[float] = None,  # angstrom\n             tilt: t.Optional[t.Tuple[float, float]] = None,  # (mrad, mrad)\n             tds: t.Optional[bool] = None,\n             n_cells: t.Optional[ArrayLike] = None):\n    \"\"\"\n    Write a structure to an mslice file.\n\n    `template` may be a file, path, or ElementTree containing an existing mslice file.\n    Its structure will be modified to make the final output. If not specified, a default\n    template will be used.\n\n    Additional options modify simulation properties. If an option is not specified, the\n    template's properties are used.\n    \"\"\"\n    from .io import write_mslice\n    return write_mslice(self, f, template, slice_thickness=slice_thickness,\n                        scan_points=scan_points, scan_extent=scan_extent,\n                        conv_angle=conv_angle, energy=energy, defocus=defocus,\n                        noise_sigma=noise_sigma, tilt=tilt, tds=tds, n_cells=n_cells)\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.write_qe","title":"<code>write_qe(f, pseudo=None)</code>","text":"Source code in <code>atomlib/mixins.py</code> <pre><code>def write_qe(self, f: FileOrPath, pseudo: t.Optional[t.Mapping[str, str]] = None):\n    from .io import write_qe\n    write_qe(self, f, pseudo)\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.get_cell","title":"<code>get_cell()</code>","text":"Source code in <code>atomlib/atomcell.py</code> <pre><code>def get_cell(self) -&gt; Cell:\n    return self.cell\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.with_cell","title":"<code>with_cell(cell)</code>","text":"Source code in <code>atomlib/atomcell.py</code> <pre><code>def with_cell(self: AtomCellT, cell: Cell) -&gt; AtomCellT:\n    return self.__class__(self.atoms, cell, frame=self.frame, keep_frame=True)\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.get_atoms","title":"<code>get_atoms(frame=None)</code>","text":"<p>Get atoms contained in <code>self</code>, in the given coordinate frame.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def get_atoms(self, frame: t.Optional[CoordinateFrame] = None) -&gt; Atoms:\n    \"\"\"Get atoms contained in ``self``, in the given coordinate frame.\"\"\"\n\n    if frame is None or frame == self.get_frame():\n        return self.atoms\n    return self.atoms.transform(self.get_transform(frame, self.get_frame()))\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.with_atoms","title":"<code>with_atoms(atoms, frame=None)</code>","text":"Source code in <code>atomlib/atomcell.py</code> <pre><code>def with_atoms(self: AtomCellT, atoms: HasAtoms, frame: t.Optional[CoordinateFrame] = None) -&gt; AtomCellT:\n    frame = frame if frame is not None else self.frame\n    return self.__class__(atoms.get_atoms(), cell=self.cell, frame=frame, keep_frame=True)\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.get_frame","title":"<code>get_frame()</code>","text":"<p>Get the coordinate frame atoms are stored in.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def get_frame(self) -&gt; CoordinateFrame:\n    \"\"\"Get the coordinate frame atoms are stored in.\"\"\"\n    return self.frame\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.from_ortho","title":"<code>from_ortho(atoms, ortho, *, n_cells=None, frame='local', keep_frame=False)</code>  <code>classmethod</code>","text":"<p>Make an atom cell given a list of atoms and an orthogonalization matrix. Atoms are assumed to be in the coordinate system <code>frame</code>.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@classmethod\ndef from_ortho(cls, atoms: IntoAtoms, ortho: LinearTransform3D, *,\n               n_cells: t.Optional[VecLike] = None,\n               frame: CoordinateFrame = 'local',\n               keep_frame: bool = False):\n    \"\"\"\n    Make an atom cell given a list of atoms and an orthogonalization matrix.\n    Atoms are assumed to be in the coordinate system ``frame``.\n    \"\"\"\n    cell = Cell.from_ortho(ortho, n_cells)\n    return cls(atoms, cell, frame=frame, keep_frame=keep_frame)\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.from_unit_cell","title":"<code>from_unit_cell(atoms, cell_size, cell_angle=None, *, n_cells=None, frame='local', keep_frame=False)</code>  <code>classmethod</code>","text":"<p>Make a cell given a list of atoms and unit cell parameters. Atoms are assumed to be in the coordinate system <code>frame</code>.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@classmethod\ndef from_unit_cell(cls, atoms: IntoAtoms, cell_size: VecLike,\n                   cell_angle: t.Optional[VecLike] = None, *,\n                   n_cells: t.Optional[VecLike] = None,\n                   frame: CoordinateFrame = 'local',\n                   keep_frame: bool = False):\n    \"\"\"\n    Make a cell given a list of atoms and unit cell parameters.\n    Atoms are assumed to be in the coordinate system ``frame``.\n    \"\"\"\n    cell = Cell.from_unit_cell(cell_size, cell_angle, n_cells=n_cells)\n    return cls(atoms, cell, frame=frame, keep_frame=keep_frame)\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.orthogonalize","title":"<code>orthogonalize()</code>","text":"Source code in <code>atomlib/atomcell.py</code> <pre><code>def orthogonalize(self) -&gt; OrthoCell:\n    if self.is_orthogonal():\n        return OrthoCell(self.atoms, self.cell, frame=self.frame)\n    raise NotImplementedError()\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.clone","title":"<code>clone()</code>","text":"<p>Make a deep copy of <code>self</code>.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def clone(self: AtomCellT) -&gt; AtomCellT:\n    \"\"\"Make a deep copy of `self`.\"\"\"\n    return self.__class__(**{field.name: copy.deepcopy(getattr(self, field.name)) for field in fields(self)})\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.AtomCell.assert_equal","title":"<code>assert_equal(other)</code>","text":"<p>Assert this structure is equal to</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def assert_equal(self, other: t.Any):\n    \"\"\"Assert this structure is equal to \"\"\"\n    assert isinstance(other, AtomCell)\n    self.cell.assert_equal(other.cell)\n    self.get_atoms('local').assert_equal(other.get_atoms('local'))\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell","title":"<code>OrthoCell</code>  <code>dataclass</code>","text":"<p>             Bases: <code>AtomCell</code></p> Source code in <code>atomlib/atomcell.py</code> <pre><code>class OrthoCell(AtomCell):\n    def __post_init__(self):\n        if not numpy.allclose(self.cell.cell_angle, numpy.pi/2.):\n            raise ValueError(f\"OrthoCell constructed with non-orthogonal angles: {self.cell.cell_angle}\")\n\n    def is_orthogonal(self, tol: float = 1e-8) -&gt; t.Literal[True]:\n        \"\"\"Returns whether this cell is orthogonal (axes are at right angles.)\"\"\"\n        return True\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.affine","title":"<code>affine: AffineTransform3D</code>  <code>property</code>","text":"<p>Affine transformation. Holds transformation from 'ortho' to 'local' coordinates, including rotation away from the standard crystal orientation.</p>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.ortho","title":"<code>ortho: LinearTransform3D</code>  <code>property</code>","text":"<p>Orthogonalization transformation. Skews but does not scale the crystal axes to cartesian axes.</p>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.metric","title":"<code>metric: LinearTransform3D</code>  <code>property</code>","text":"<p>Cell metric tensor</p> <p>Returns the dot product between every combination of basis vectors. :math:<code>\\mathbf{a} \\cdot \\mathbf{b} = a_i M_ij b_j</code></p>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.cell_size","title":"<code>cell_size: NDArray[numpy.float_]</code>  <code>property</code>","text":"<p>Unit cell size.</p>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.cell_angle","title":"<code>cell_angle: NDArray[numpy.float_]</code>  <code>property</code>","text":"<p>Unit cell angles, in radians.</p>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.n_cells","title":"<code>n_cells: NDArray[numpy.int_]</code>  <code>property</code>","text":"<p>Number of unit cells.</p>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.pbc","title":"<code>pbc: NDArray[numpy.bool_]</code>  <code>property</code>","text":"<p>Flags indicating the presence of periodic boundary conditions along each axis.</p>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.ortho_size","title":"<code>ortho_size: NDArray[numpy.float_]</code>  <code>property</code>","text":"<p>Return size of orthogonal unit cell.</p> <p>Equivalent to the diagonal of the orthogonalization matrix.</p>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.box_size","title":"<code>box_size: NDArray[numpy.float_]</code>  <code>property</code>","text":"<p>Return size of the cell box.</p> <p>Equivalent to <code>self.n_cells * self.cell_size</code>.</p>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.columns","title":"<code>columns: t.Sequence[str]</code>  <code>property</code>","text":"<p>Return the columns in <code>self</code>.</p>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.dtypes","title":"<code>dtypes: t.Sequence[polars.DataType]</code>  <code>property</code>","text":"<p>Return the datatypes in <code>self</code>.</p>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.schema","title":"<code>schema: SchemaDict</code>  <code>property</code>","text":"<p>Return the schema of <code>self</code>.</p>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.with_column","title":"<code>with_column = with_columns</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.unique","title":"<code>unique = deduplicate</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.atoms","title":"<code>atoms: Atoms</code>  <code>instance-attribute</code>","text":"<p>Atoms in the cell. Stored in 'local' coordinates (i.e. relative to the enclosing group but not relative to box dimensions).</p>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.cell","title":"<code>cell: Cell</code>  <code>instance-attribute</code>","text":"<p>Cell coordinate system.</p>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.frame","title":"<code>frame: CoordinateFrame = 'local'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Coordinate frame 'atoms' are stored in.</p>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.get_cell","title":"<code>get_cell()</code>","text":"Source code in <code>atomlib/atomcell.py</code> <pre><code>def get_cell(self) -&gt; Cell:\n    return self.cell\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.with_cell","title":"<code>with_cell(cell)</code>","text":"Source code in <code>atomlib/atomcell.py</code> <pre><code>def with_cell(self: AtomCellT, cell: Cell) -&gt; AtomCellT:\n    return self.__class__(self.atoms, cell, frame=self.frame, keep_frame=True)\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.get_transform","title":"<code>get_transform(frame_to=None, frame_from=None)</code>","text":"<p>In the two-argument form, get the transform to 'frame_to' from 'frame_from'. In the one-argument form, get the transform from local coordinates to 'frame'.</p> Source code in <code>atomlib/cell.py</code> <pre><code>def get_transform(self, frame_to: t.Optional[CoordinateFrame] = None, frame_from: t.Optional[CoordinateFrame] = None) -&gt; AffineTransform3D:\n    \"\"\"\n    In the two-argument form, get the transform to 'frame_to' from 'frame_from'.\n    In the one-argument form, get the transform from local coordinates to 'frame'.\n    \"\"\"\n    transform_from = self._get_transform_to_local(frame_from) if frame_from is not None else AffineTransform3D()\n    transform_to = self._get_transform_to_local(frame_to) if frame_to is not None else AffineTransform3D()\n    if frame_from is not None and frame_to is not None and frame_from.lower() == frame_to.lower():\n        return AffineTransform3D()\n    return transform_to.inverse() @ transform_from\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.corners","title":"<code>corners(frame='local')</code>","text":"Source code in <code>atomlib/cell.py</code> <pre><code>def corners(self, frame: CoordinateFrame = 'local') -&gt; numpy.ndarray:\n    corners = numpy.array(list(itertools.product((0., 1.), repeat=3)))\n    return self.get_transform(frame, 'cell_box') @ corners\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.bbox_cell","title":"<code>bbox_cell(frame='local')</code>","text":"<p>Return the bounding box of the cell box in the given coordinate system.</p> Source code in <code>atomlib/cell.py</code> <pre><code>def bbox_cell(self, frame: CoordinateFrame = 'local') -&gt; BBox3D:\n    \"\"\"Return the bounding box of the cell box in the given coordinate system.\"\"\"\n    return BBox3D.from_pts(self.corners(frame))\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.bbox","title":"<code>bbox(frame='local')</code>","text":"<p>Return the combined bounding box of the cell and atoms in the given coordinate system. To get the cell or atoms bounding box only, use meth:<code>bbox_cell</code> or meth:<code>bbox_atoms</code>.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def bbox(self, frame: CoordinateFrame = 'local') -&gt; BBox3D:\n    \"\"\"\n    Return the combined bounding box of the cell and atoms in the given coordinate system.\n    To get the cell or atoms bounding box only, use :py:meth:`bbox_cell` or :py:meth:`bbox_atoms`.\n    \"\"\"\n    return self.bbox_atoms(frame) | self.bbox_cell(frame)\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.is_orthogonal_in_local","title":"<code>is_orthogonal_in_local(tol=1e-08)</code>","text":"<p>Returns whether this cell is orthogonal and aligned with the local coordinate system.</p> Source code in <code>atomlib/cell.py</code> <pre><code>def is_orthogonal_in_local(self, tol: float = 1e-8) -&gt; bool:\n    \"\"\"Returns whether this cell is orthogonal and aligned with the local coordinate system.\"\"\"\n    transform = (self.affine @ self.ortho).to_linear()\n    if not transform.is_scaled_orthogonal(tol):\n        return False\n    normed = transform.inner / numpy.linalg.norm(transform.inner, axis=-2, keepdims=True)\n    # every row of transform must be a +/- 1 times a basis vector (i, j, or k)\n    return all(\n        any(numpy.isclose(numpy.abs(numpy.dot(row, v)), 1., atol=tol) for v in numpy.eye(3))\n        for row in normed\n    )\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.to_ortho","title":"<code>to_ortho()</code>","text":"Source code in <code>atomlib/cell.py</code> <pre><code>def to_ortho(self) -&gt; AffineTransform3D:\n    return self.get_transform('local', 'cell_box')\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.transform_cell","title":"<code>transform_cell(transform, frame='local')</code>","text":"<p>Apply the given transform to the unit cell, without changing atom positions. The transform is applied in coordinate frame 'frame'.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def transform_cell(self: HasAtomCellT, transform: AffineTransform3D, frame: CoordinateFrame = 'local') -&gt; HasAtomCellT:\n    \"\"\"\n    Apply the given transform to the unit cell, without changing atom positions.\n    The transform is applied in coordinate frame 'frame'.\n    \"\"\"\n    return self.with_cell(self.get_cell().transform_cell(transform, frame=frame))\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.strain_orthogonal","title":"<code>strain_orthogonal()</code>","text":"<p>Orthogonalize using strain.</p> <p>Strain is applied such that the x-axis remains fixed, and the y-axis remains in the xy plane. For small displacements, no hydrostatic strain is applied (volume is conserved).</p> Source code in <code>atomlib/cell.py</code> <pre><code>def strain_orthogonal(self: HasCellT) -&gt; HasCellT:\n    \"\"\"\n    Orthogonalize using strain.\n\n    Strain is applied such that the x-axis remains fixed, and the y-axis remains in the xy plane.\n    For small displacements, no hydrostatic strain is applied (volume is conserved).\n    \"\"\"\n    return self.with_cell(Cell(\n        affine=self.affine,\n        ortho=LinearTransform3D(),\n        cell_size=self.cell_size,\n        n_cells=self.n_cells,\n        pbc=self.pbc,\n    ))\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.repeat","title":"<code>repeat(n)</code>","text":"<p>Tile the cell</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def repeat(self: HasAtomCellT, n: t.Union[int, VecLike]) -&gt; HasAtomCellT:\n    \"\"\"Tile the cell\"\"\"\n    ns = numpy.broadcast_to(n, 3)\n    if not numpy.issubdtype(ns.dtype, numpy.integer):\n        raise ValueError(f\"repeat() argument must be an integer or integer array.\")\n\n    cells = numpy.stack(numpy.meshgrid(*map(numpy.arange, ns))) \\\n        .reshape(3, -1).T.astype(float)\n    cells = cells * self.box_size\n\n    atoms = self.get_atoms('cell')\n    atoms = Atoms.concat([\n        atoms.transform(AffineTransform3D.translate(cell))\n        for cell in cells\n    ]) #.transform(self.cell.get_transform('local', 'cell_frac'))\n    return self.with_atoms(atoms, 'cell').with_cell(self.get_cell().repeat(ns))\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.explode","title":"<code>explode()</code>","text":"<p>Materialize repeated cells as one supercell.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def explode(self: HasAtomCellT) -&gt; HasAtomCellT:\n    \"\"\"Materialize repeated cells as one supercell.\"\"\"\n    frame = self.get_frame()\n\n    return self.with_atoms(self.get_atoms('local'), 'local') \\\n        .with_cell(self.get_cell().explode()) \\\n        .to_frame(frame)\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.explode_z","title":"<code>explode_z()</code>","text":"<p>Materialize repeated cells as one supercell in z.</p> Source code in <code>atomlib/cell.py</code> <pre><code>def explode_z(self: HasCellT) -&gt; HasCellT:\n    \"\"\"Materialize repeated cells as one supercell in z.\"\"\"\n    return self.with_cell(Cell(\n        affine=self.affine,\n        ortho=self.ortho,\n        cell_size=self.cell_size*[1, 1, self.n_cells[2]],\n        n_cells=[*self.n_cells[:2], 1],\n        cell_angle=self.cell_angle,\n        pbc=self.pbc,\n    ))\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.crop","title":"<code>crop(x_min=-numpy.inf, x_max=numpy.inf, y_min=-numpy.inf, y_max=numpy.inf, z_min=-numpy.inf, z_max=numpy.inf, *, frame='local')</code>","text":"<p>Crop atoms and cell to the given extents. For a non-orthogonal cell, this must be specified in cell coordinates. This function implicity <code>explode</code>s the cell as well.</p> <p>To crop atoms only, use <code>crop_atoms</code> instead.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def crop(self: HasAtomCellT, x_min: float = -numpy.inf, x_max: float = numpy.inf,\n         y_min: float = -numpy.inf, y_max: float = numpy.inf,\n         z_min: float = -numpy.inf, z_max: float = numpy.inf, *,\n         frame: CoordinateFrame = 'local') -&gt; HasAtomCellT:\n    \"\"\"\n    Crop atoms and cell to the given extents. For a non-orthogonal\n    cell, this must be specified in cell coordinates. This\n    function implicity `explode`s the cell as well.\n\n    To crop atoms only, use `crop_atoms` instead.\n    \"\"\"\n\n    cell = self.get_cell().crop(x_min, x_max, y_min, y_max, z_min, z_max, frame=frame)\n    atoms = self._transform_atoms_in_frame(frame, lambda atoms: atoms.crop_atoms(x_min, x_max, y_min, y_max, z_min, z_max))\n    return self.with_cell(cell).with_atoms(atoms)\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.change_transform","title":"<code>change_transform(transform, frame_to=None, frame_from=None)</code>","text":"<p>Coordinate-change a transformation to 'frame_to' from 'frame_from'.</p> Source code in <code>atomlib/cell.py</code> <pre><code>def change_transform(self, transform: Transform3D,\n                     frame_to: t.Optional[CoordinateFrame] = None,\n                     frame_from: t.Optional[CoordinateFrame] = None) -&gt; Transform3D:\n    \"\"\"Coordinate-change a transformation to 'frame_to' from 'frame_from'.\"\"\"\n    if frame_to == frame_from and frame_to is not None:\n        return transform\n    coord_change = self.get_transform(frame_to, frame_from)\n    return coord_change @ transform @ coord_change.inverse()\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.assert_equal","title":"<code>assert_equal(other)</code>","text":"<p>Assert this structure is equal to</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def assert_equal(self, other: t.Any):\n    \"\"\"Assert this structure is equal to \"\"\"\n    assert isinstance(other, AtomCell)\n    self.cell.assert_equal(other.cell)\n    self.get_atoms('local').assert_equal(other.get_atoms('local'))\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.get_atoms","title":"<code>get_atoms(frame=None)</code>","text":"<p>Get atoms contained in <code>self</code>, in the given coordinate frame.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def get_atoms(self, frame: t.Optional[CoordinateFrame] = None) -&gt; Atoms:\n    \"\"\"Get atoms contained in ``self``, in the given coordinate frame.\"\"\"\n\n    if frame is None or frame == self.get_frame():\n        return self.atoms\n    return self.atoms.transform(self.get_transform(frame, self.get_frame()))\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.with_atoms","title":"<code>with_atoms(atoms, frame=None)</code>","text":"Source code in <code>atomlib/atomcell.py</code> <pre><code>def with_atoms(self: AtomCellT, atoms: HasAtoms, frame: t.Optional[CoordinateFrame] = None) -&gt; AtomCellT:\n    frame = frame if frame is not None else self.frame\n    return self.__class__(atoms.get_atoms(), cell=self.cell, frame=frame, keep_frame=True)\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.describe","title":"<code>describe(percentiles=(0.25, 0.5, 0.75), *, interpolation='nearest', frame=None)</code>","text":"<p>Return summary statistics for <code>self</code>.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_get\ndef describe(self, percentiles: t.Union[t.Sequence[float], float, None] = (0.25, 0.5, 0.75), *,\n             interpolation: RollingInterpolationMethod = 'nearest',\n             frame: t.Optional[CoordinateFrame] = None) -&gt; polars.DataFrame:\n    \"\"\"Return summary statistics for `self`.\"\"\"\n    ...\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.with_columns","title":"<code>with_columns(*exprs, frame=None, **named_exprs)</code>","text":"<p>Return a copy of <code>self</code> with the given columns added.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef with_columns(self: HasAtomCellT,\n                 *exprs: t.Union[IntoExpr, t.Iterable[IntoExpr]],\n                 frame: t.Optional[CoordinateFrame] = None,\n                 **named_exprs: IntoExpr) -&gt; HasAtomCellT:\n    \"\"\"Return a copy of ``self`` with the given columns added.\"\"\"\n    ...\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.insert_column","title":"<code>insert_column(index, column)</code>","text":"Source code in <code>atomlib/atoms.py</code> <pre><code>@_fwd_frame_map\ndef insert_column(self, index: int, column: polars.Series) -&gt; polars.DataFrame:\n    return self._get_frame().insert_column(index, column)\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.get_column","title":"<code>get_column(name, *, frame=None)</code>","text":"<p>Get the specified column from <code>self</code>, raising <code>polars.ColumnNotFoundError</code> if it's not present.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_get\ndef get_column(self, name: str, *, frame: t.Optional[CoordinateFrame] = None) -&gt; polars.Series:\n    \"\"\"Get the specified column from `self`, raising [`polars.ColumnNotFoundError`][polars.exceptions.ColumnNotFoundError] if it's not present.\"\"\"\n    ...\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.get_columns","title":"<code>get_columns(*, frame=None)</code>","text":"<p>Get the specified columns from <code>self</code>, raising <code>polars.ColumnNotFoundError</code> if it's not present.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_get\ndef get_columns(self, *, frame: t.Optional[CoordinateFrame] = None) -&gt; t.List[polars.Series]:\n    \"\"\"Get the specified columns from `self`, raising [`polars.ColumnNotFoundError`][polars.exceptions.ColumnNotFoundError] if it's not present.\"\"\"\n    ...\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.get_column_index","title":"<code>get_column_index(name)</code>","text":"<p>Get the index of a column by name, raising <code>polars.ColumnNotFoundError</code> if it's not present.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>@_fwd_frame(polars.DataFrame.get_column_index)\ndef get_column_index(self, name: str) -&gt; int:\n    \"\"\"Get the index of a column by name, raising [`polars.ColumnNotFoundError`][polars.exceptions.ColumnNotFoundError] if it's not present.\"\"\"\n    ...\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.group_by","title":"<code>group_by(*by, maintain_order=False, frame=None, **named_by)</code>","text":"Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_get\ndef group_by(self, *by: t.Union[IntoExpr, t.Iterable[IntoExpr]],\n             maintain_order: bool = False, frame: t.Optional[CoordinateFrame] = None,\n             **named_by: IntoExpr) -&gt; polars.dataframe.group_by.GroupBy:\n    ...\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.pipe","title":"<code>pipe(function, *args, **kwargs)</code>","text":"<p>Apply <code>function</code> to <code>self</code> (in method-call syntax).</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def pipe(self: HasAtomCellT, function: t.Callable[Concatenate[HasAtomCellT, P], T], *args: P.args, **kwargs: P.kwargs) -&gt; T:\n    \"\"\"Apply `function` to `self` (in method-call syntax).\"\"\"\n    return function(self, *args, **kwargs)\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.clone","title":"<code>clone()</code>","text":"<p>Make a deep copy of <code>self</code>.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def clone(self: AtomCellT) -&gt; AtomCellT:\n    \"\"\"Make a deep copy of `self`.\"\"\"\n    return self.__class__(**{field.name: copy.deepcopy(getattr(self, field.name)) for field in fields(self)})\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.drop","title":"<code>drop(*columns)</code>","text":"<p>Return <code>self</code> with the specified columns removed.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def drop(self, *columns: t.Union[str, t.Iterable[str]]) -&gt; polars.DataFrame:\n    \"\"\"Return `self` with the specified columns removed.\"\"\"\n    return self._get_frame().drop(*columns)\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.filter","title":"<code>filter(*predicates, frame=None, **constraints)</code>","text":"<p>Filter <code>self</code>, removing rows which evaluate to <code>False</code>.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef filter(\n    self: HasAtomCellT,\n    *predicates: t.Union[None, IntoExprColumn, t.Iterable[IntoExprColumn], bool, t.List[bool], numpy.ndarray],\n    frame: t.Optional[CoordinateFrame] = None,\n    **constraints: t.Any,\n) -&gt; HasAtomCellT:\n    \"\"\"Filter `self`, removing rows which evaluate to `False`.\"\"\"\n    ...\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.sort","title":"<code>sort(by, *more_by, descending=False, nulls_last=False)</code>","text":"<p>Sort the atoms in <code>self</code> by the given columns/expressions.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef sort(\n    self: HasAtomCellT,\n    by: t.Union[IntoExpr, t.Iterable[IntoExpr]],\n    *more_by: IntoExpr,\n    descending: t.Union[bool, t.Sequence[bool]] = False,\n    nulls_last: bool = False,\n) -&gt; HasAtomCellT:\n    \"\"\"\n    Sort the atoms in `self` by the given columns/expressions.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.slice","title":"<code>slice(offset, length=None, *, frame=None)</code>","text":"<p>Return a slice of the rows in <code>self</code>.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef slice(self: HasAtomCellT, offset: int, length: t.Optional[int] = None, *,\n          frame: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n    \"\"\"Return a slice of the rows in `self`.\"\"\"\n    ...\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.head","title":"<code>head(n=5, *, frame=None)</code>","text":"<p>Return the first <code>n</code> rows of <code>self</code>.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef head(self: HasAtomCellT, n: int = 5, *, frame: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n    \"\"\"Return the first `n` rows of `self`.\"\"\"\n    ...\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.tail","title":"<code>tail(n=5, *, frame=None)</code>","text":"<p>Return the last <code>n</code> rows of <code>self</code>.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef tail(self: HasAtomCellT, n: int = 5, *, frame: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n    \"\"\"Return the last `n` rows of `self`.\"\"\"\n    ...\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.drop_nulls","title":"<code>drop_nulls(subset=None)</code>","text":"<p>Drop rows that contain nulls in any of columns <code>subset</code>.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>@_fwd_frame_map\ndef drop_nulls(self, subset: t.Union[str, t.Collection[str], None] = None) -&gt; polars.DataFrame:\n    \"\"\"Drop rows that contain nulls in any of columns `subset`.\"\"\"\n    return self._get_frame().drop_nulls(subset)\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.fill_null","title":"<code>fill_null(value=None, strategy=None, limit=None, matches_supertype=True)</code>","text":"Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef fill_null(\n    self: HasAtomCellT, value: t.Any = None, strategy: t.Optional[FillNullStrategy] = None,\n    limit: t.Optional[int] = None, matches_supertype: bool = True,\n) -&gt; HasAtomCellT:\n    ...\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.fill_nan","title":"<code>fill_nan(value, *, frame=None)</code>","text":"Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef fill_nan(self: HasAtomCellT, value: t.Union[polars.Expr, int, float, None], *,\n             frame: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n    ...\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.concat","title":"<code>concat(atoms, *, rechunk=True, how='vertical')</code>  <code>classmethod</code>","text":"<p>Concatenate multiple <code>Atoms</code> together, handling metadata appropriately.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>@classmethod\ndef concat(cls: t.Type[HasAtomsT],\n           atoms: t.Union[HasAtomsT, IntoAtoms, t.Iterable[t.Union[HasAtomsT, IntoAtoms]]], *,\n           rechunk: bool = True, how: ConcatMethod = 'vertical') -&gt; HasAtomsT:\n    \"\"\"Concatenate multiple `Atoms` together, handling metadata appropriately.\"\"\"\n    # this method is tricky. It needs to accept raw Atoms, as well as HasAtoms of the\n    # same type as ``cls``.\n    if _is_abstract(cls):\n        raise TypeError(f\"concat() must be called on a concrete class.\")\n\n    if isinstance(atoms, HasAtoms):\n        atoms = (atoms,)\n    dfs = [a.get_atoms('local').inner if isinstance(a, HasAtoms) else Atoms(t.cast(IntoAtoms, a)).inner for a in atoms]\n    representative = cls._combine_metadata(*(a for a in atoms if isinstance(a, HasAtoms)))\n\n    if len(dfs) == 0:\n        return representative.with_atoms(Atoms.empty(), 'local')\n\n    if how in ('vertical', 'vertical_relaxed'):\n        # get order from first member\n        cols = dfs[0].columns\n        dfs = [df.select(cols) for df in dfs]\n    elif how == 'inner':\n        cols = reduce(operator.and_, (df.schema.keys() for df in dfs))\n        schema = OrderedDict((col, dfs[0].schema[col]) for col in cols)\n        if len(schema) == 0:\n            raise ValueError(f\"Atoms have no columns in common\")\n\n        dfs = [_select_schema(df, schema) for df in dfs]\n        how = 'vertical'\n\n    return representative.with_atoms(Atoms(polars.concat(dfs, rechunk=rechunk, how=how)), 'local')\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.partition_by","title":"<code>partition_by(by, *more_by, maintain_order=True, include_key=True, as_dict=False)</code>","text":"<p>Group by the given columns and partition into separate dataframes.</p> <p>Return the partitions as a dictionary by specifying <code>as_dict=True</code>.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def partition_by(\n    self: HasAtomsT, by: t.Union[str, t.Sequence[str]], *more_by: str,\n    maintain_order: bool = True, include_key: bool = True, as_dict: bool = False\n) -&gt; t.Union[t.List[HasAtomsT], t.Dict[t.Any, HasAtomsT]]:\n    \"\"\"\n    Group by the given columns and partition into separate dataframes.\n\n    Return the partitions as a dictionary by specifying `as_dict=True`.\n    \"\"\"\n    if as_dict:\n        d = self._get_frame().partition_by(by, *more_by, maintain_order=maintain_order, include_key=include_key, as_dict=True)\n        return {k: self.with_atoms(Atoms(df, _unchecked=True)) for (k, df) in d.items()}\n\n    return [\n        self.with_atoms(Atoms(df, _unchecked=True))\n        for df in self._get_frame().partition_by(by, *more_by, maintain_order=maintain_order, include_key=include_key, as_dict=False)\n    ]\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.select","title":"<code>select(*exprs, frame=None, **named_exprs)</code>","text":"<p>Select <code>exprs`` from ``self</code>, and return as a <code>polars.DataFrame</code>.</p> <p>Expressions may either be columns or expressions of columns.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_get\ndef select(\n    self, *exprs: t.Union[IntoExpr, t.Iterable[IntoExpr]],\n    frame: t.Optional[CoordinateFrame] = None,\n    **named_exprs: IntoExpr\n) -&gt; polars.DataFrame:\n    \"\"\"\n    Select `exprs`` from ``self`, and return as a `polars.DataFrame`.\n\n    Expressions may either be columns or expressions of columns.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.select_schema","title":"<code>select_schema(schema)</code>","text":"<p>Select columns from <code>self</code> and cast to the given schema. Raises <code>TypeError</code> if a column is not found or if it can't be cast.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def select_schema(self, schema: SchemaDict) -&gt; polars.DataFrame:\n    \"\"\"\n    Select columns from `self` and cast to the given schema.\n    Raises `TypeError` if a column is not found or if it can't be cast.\n    \"\"\"\n    return _select_schema(self, schema)\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.select_props","title":"<code>select_props(*exprs, frame=None, **named_exprs)</code>","text":"<p>Select <code>exprs</code> from <code>self</code>, while keeping required columns.</p> <p>Returns a HasAtoms.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef select_props(\n    self: HasAtomCellT,\n    *exprs: t.Union[IntoExpr, t.Iterable[IntoExpr]],\n    frame: t.Optional[CoordinateFrame] = None,\n    **named_exprs: IntoExpr\n) -&gt; HasAtomCellT:\n    \"\"\"\n    Select `exprs` from `self`, while keeping required columns.\n\n    Returns a HasAtoms.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.try_select","title":"<code>try_select(*exprs, frame=None, **named_exprs)</code>","text":"<p>Try to select <code>exprs</code> from <code>self</code>, and return as a <code>polars.DataFrame</code>.</p> <p>Expressions may either be columns or expressions of columns. Return <code>None</code> if any columns are missing.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_get\ndef try_select(\n    self, *exprs: t.Union[IntoExpr, t.Iterable[IntoExpr]],\n    frame: t.Optional[CoordinateFrame] = None,\n    **named_exprs: IntoExpr\n) -&gt; t.Optional[polars.DataFrame]:\n    \"\"\"\n    Try to select `exprs` from `self`, and return as a `polars.DataFrame`.\n\n    Expressions may either be columns or expressions of columns.\n    Return `None` if any columns are missing.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.try_get_column","title":"<code>try_get_column(name)</code>","text":"<p>Try to get a column from <code>self</code>, returning <code>None</code> if it doesn't exist.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def try_get_column(self, name: str) -&gt; t.Optional[polars.Series]:\n    \"\"\"Try to get a column from `self`, returning `None` if it doesn't exist.\"\"\"\n    try:\n        return self.get_column(name)\n    except polars.ColumnNotFoundError:\n        return None\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.bbox_atoms","title":"<code>bbox_atoms(frame=None)</code>","text":"<p>Return the bounding box of all the atoms in <code>self</code>, in the given coordinate frame.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def bbox_atoms(self, frame: t.Optional[CoordinateFrame] = None) -&gt; BBox3D:\n    \"\"\"Return the bounding box of all the atoms in ``self``, in the given coordinate frame.\"\"\"\n    return self.get_atoms(frame).bbox()\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.transform_atoms","title":"<code>transform_atoms(transform, selection=None, *, frame='local', transform_velocities=False)</code>","text":"<p>Transform the atoms in <code>self</code> by <code>transform</code>. If <code>selection</code> is given, only transform the atoms in <code>selection</code>.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def transform_atoms(self: HasAtomCellT, transform: IntoTransform3D, selection: t.Optional[AtomSelection] = None, *,\n                    frame: CoordinateFrame = 'local', transform_velocities: bool = False) -&gt; HasAtomCellT:\n    \"\"\"\n    Transform the atoms in `self` by `transform`.\n    If `selection` is given, only transform the atoms in `selection`.\n    \"\"\"\n    transform = self.change_transform(Transform3D.make(transform), self.get_frame(), frame)\n    return self.with_atoms(self.get_atoms(self.get_frame()).transform(transform, selection, transform_velocities=transform_velocities))\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.transform","title":"<code>transform(transform, frame='local')</code>","text":"Source code in <code>atomlib/atomcell.py</code> <pre><code>def transform(self: HasAtomCellT, transform: AffineTransform3D, frame: CoordinateFrame = 'local') -&gt; HasAtomCellT:\n    if isinstance(transform, Transform3D) and not isinstance(transform, AffineTransform3D):\n        raise ValueError(\"Non-affine transforms cannot change the box dimensions. Use 'transform_atoms' instead.\")\n    # TODO: cleanup once tests pass\n    # coordinate change the transform into atomic coordinates\n    new_cell = self.get_cell().transform_cell(transform, frame)\n    transform = self.get_cell().change_transform(transform, self.get_frame(), frame)\n    return self.with_atoms(self.get_atoms().transform(transform), self.get_frame()).with_cell(new_cell)\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.round_near_zero","title":"<code>round_near_zero(tol=1e-14, *, frame=None)</code>","text":"<p>Round atom position values near zero to zero.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef round_near_zero(self: HasAtomCellT, tol: float = 1e-14, *,\n                    frame: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n    \"\"\"\n    Round atom position values near zero to zero.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.crop_atoms","title":"<code>crop_atoms(x_min=-numpy.inf, x_max=numpy.inf, y_min=-numpy.inf, y_max=numpy.inf, z_min=-numpy.inf, z_max=numpy.inf, *, frame='local')</code>","text":"Source code in <code>atomlib/atomcell.py</code> <pre><code>def crop_atoms(self: HasAtomCellT, x_min: float = -numpy.inf, x_max: float = numpy.inf,\n               y_min: float = -numpy.inf, y_max: float = numpy.inf,\n               z_min: float = -numpy.inf, z_max: float = numpy.inf, *,\n               frame: CoordinateFrame = 'local') -&gt; HasAtomCellT:\n    atoms = self._transform_atoms_in_frame(frame, lambda atoms: atoms.crop_atoms(x_min, x_max, y_min, y_max, z_min, z_max))\n    return self.with_atoms(atoms)\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.deduplicate","title":"<code>deduplicate(tol=0.001, subset=('x', 'y', 'z', 'symbol'), keep='first', maintain_order=True)</code>","text":"<p>De-duplicate atoms in <code>self</code>. Atoms of the same <code>symbol</code> that are closer than <code>tolerance</code> to each other (by Euclidian distance) will be removed, leaving only the atom specified by <code>keep</code> (defaults to the first atom).</p> <p>If <code>subset</code> is specified, only those columns will be included while assessing duplicates. Floating point columns other than 'x', 'y', and 'z' will not by toleranced.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def deduplicate(self: HasAtomsT, tol: float = 1e-3, subset: t.Iterable[str] = ('x', 'y', 'z', 'symbol'),\n                keep: UniqueKeepStrategy = 'first', maintain_order: bool = True) -&gt; HasAtomsT:\n    \"\"\"\n    De-duplicate atoms in `self`. Atoms of the same `symbol` that are closer than `tolerance`\n    to each other (by Euclidian distance) will be removed, leaving only the atom specified by\n    `keep` (defaults to the first atom).\n\n    If `subset` is specified, only those columns will be included while assessing duplicates.\n    Floating point columns other than 'x', 'y', and 'z' will not by toleranced.\n    \"\"\"\n    import scipy.spatial\n\n    cols = set((subset,) if isinstance(subset, str) else subset)\n\n    indices = numpy.arange(len(self))\n\n    spatial_cols = cols.intersection(('x', 'y', 'z'))\n    cols -= spatial_cols\n    if len(spatial_cols) &gt; 0:\n        coords = self.select([_coord_expr(col).alias(col) for col in spatial_cols]).to_numpy()\n        tree = scipy.spatial.KDTree(coords)\n\n        # TODO This is a bad algorithm\n        while True:\n            changed = False\n            for (i, j) in tree.query_pairs(tol, 2.):\n                # whenever we encounter a pair, ensure their index matches\n                i_i, i_j = indices[[i, j]]\n                if i_i != i_j:\n                    indices[i] = indices[j] = min(i_i, i_j)\n                    changed = True\n            if not changed:\n                break\n\n        self = self.with_column(polars.Series('_unique_pts', indices))\n        cols.add('_unique_pts')\n\n    frame = self._get_frame().unique(subset=list(cols), keep=keep, maintain_order=maintain_order)\n    if len(spatial_cols) &gt; 0:\n        frame = frame.drop('_unique_pts')\n\n    return self.with_atoms(Atoms(frame, _unchecked=True))\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.with_bounds","title":"<code>with_bounds(cell_size=None, cell_origin=None)</code>","text":"<p>Return a periodic cell with the given orthogonal cell dimensions.</p> <p>If cell_size is not specified, it will be assumed (and may be incorrect).</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def with_bounds(self, cell_size: t.Optional[VecLike] = None, cell_origin: t.Optional[VecLike] = None) -&gt; 'AtomCell':\n    \"\"\"\n    Return a periodic cell with the given orthogonal cell dimensions.\n\n    If cell_size is not specified, it will be assumed (and may be incorrect).\n    \"\"\"\n    # TODO: test this\n    from .atomcell import AtomCell\n\n    if cell_size is None:\n        warnings.warn(\"Cell boundary unknown. Defaulting to cell BBox\")\n        cell_size = self.bbox().size\n        cell_origin = self.bbox().min\n\n    # TODO test this origin code\n    cell = Cell.from_unit_cell(cell_size)\n    if cell_origin is not None:\n        cell = cell.transform_cell(AffineTransform3D.translate(to_vec3(cell_origin)))\n\n    return AtomCell(self.get_atoms(), cell, frame='local')\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.coords","title":"<code>coords(selection=None, *, frame=None)</code>","text":"<p>Returns a <code>(N, 3)</code> ndarray of atom coordinates (dtype <code>numpy.float64</code>).</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_get\ndef coords(self, selection: t.Optional[AtomSelection] = None, *, frame: t.Optional[CoordinateFrame] = None) -&gt; NDArray[numpy.float64]:\n    \"\"\"Returns a `(N, 3)` ndarray of atom coordinates (dtype ``numpy.float64``).\"\"\"\n    ...\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.x","title":"<code>x()</code>","text":"Source code in <code>atomlib/atoms.py</code> <pre><code>def x(self) -&gt; polars.Expr:\n    return polars.col('coords').arr.get(0).alias('x')\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.y","title":"<code>y()</code>","text":"Source code in <code>atomlib/atoms.py</code> <pre><code>def y(self) -&gt; polars.Expr:\n    return polars.col('coords').arr.get(1).alias('y')\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.z","title":"<code>z()</code>","text":"Source code in <code>atomlib/atoms.py</code> <pre><code>def z(self) -&gt; polars.Expr:\n    return polars.col('coords').arr.get(2).alias('z')\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.velocities","title":"<code>velocities(selection=None, *, frame=None)</code>","text":"<p>Returns a <code>(N, 3)</code> ndarray of atom velocities (dtype <code>numpy.float64</code>).</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_get\ndef velocities(self, selection: t.Optional[AtomSelection] = None, *, frame: t.Optional[CoordinateFrame] = None) -&gt; t.Optional[NDArray[numpy.float64]]:\n    \"\"\"Returns a `(N, 3)` ndarray of atom velocities (dtype ``numpy.float64``).\"\"\"\n    ...\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.types","title":"<code>types()</code>","text":"<p>Returns a <code>Series</code> of atom types (dtype <code>polars.Int32</code>).</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def types(self) -&gt; t.Optional[polars.Series]:\n    \"\"\"\n    Returns a [`Series`][polars.Series] of atom types (dtype [`polars.Int32`][polars.Int32]).\n\n    [polars.Series]: https://docs.pola.rs/py-polars/html/reference/series/index.html\n    \"\"\"\n    return self.try_get_column('type')\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.masses","title":"<code>masses()</code>","text":"<p>Returns a <code>Series</code> of atom masses (dtype <code>polars.Float32</code>).</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def masses(self) -&gt; t.Optional[polars.Series]:\n    \"\"\"\n    Returns a [`Series`][polars.Series] of atom masses (dtype [`polars.Float32`][polars.Float32]).\n\n    [polars.Series]: https://docs.pola.rs/py-polars/html/reference/series/index.html\n    \"\"\"\n    return self.try_get_column('mass')\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.add_atom","title":"<code>add_atom(elem, /, x, y=None, z=None, *, frame=None, **kwargs)</code>","text":"<p>Return a copy of <code>self</code> with an extra atom.</p> <p>By default, all extra columns present in <code>self</code> must be specified as <code>**kwargs</code>.</p> <p>Try to avoid calling this in a loop (Use meth:<code>concat</code> instead).</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef add_atom(self: HasAtomCellT, elem: t.Union[int, str], /,  # type: ignore (spurious)\n             x: t.Union[ArrayLike, float],\n             y: t.Optional[float] = None,\n             z: t.Optional[float] = None, *,\n             frame: t.Optional[CoordinateFrame] = None,\n             **kwargs: t.Any) -&gt; HasAtomCellT:\n    \"\"\"\n    Return a copy of ``self`` with an extra atom.\n\n    By default, all extra columns present in ``self`` must be specified as ``**kwargs``.\n\n    Try to avoid calling this in a loop (Use :py:meth:`concat` instead).\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.pos","title":"<code>pos(x=None, y=None, z=None, *, tol=1e-06, **kwargs)</code>","text":"<p>Select all atoms at a given position.</p> <p>Formally, returns all atoms within a cube of radius <code>tol</code> centered at <code>(x,y,z)</code>, exclusive of the cube's surface.</p> <p>Additional parameters given as <code>kwargs</code> will be checked as additional parameters (with strict equality).</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def pos(self,\n        x: t.Union[t.Sequence[t.Optional[float]], float, None] = None,\n        y: t.Optional[float] = None, z: t.Optional[float] = None, *,\n        tol: float = 1e-6, **kwargs: t.Any) -&gt; polars.Expr:\n    \"\"\"\n    Select all atoms at a given position.\n\n    Formally, returns all atoms within a cube of radius ``tol``\n    centered at ``(x,y,z)``, exclusive of the cube's surface.\n\n    Additional parameters given as ``kwargs`` will be checked\n    as additional parameters (with strict equality).\n    \"\"\"\n\n    if isinstance(x, t.Sequence):\n        (x, y, z) = x\n\n    tol = abs(float(tol))\n    selection = polars.lit(True)\n    if x is not None:\n        selection &amp;= self.x().is_between(x - tol, x + tol, closed='none')\n    if y is not None:\n        selection &amp;= self.y().is_between(y - tol, y + tol, closed='none')\n    if z is not None:\n        selection &amp;= self.z().is_between(z - tol, z + tol, closed='none')\n    for (col, val) in kwargs.items():\n        selection &amp;= (polars.col(col) == val)\n\n    return selection\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.with_index","title":"<code>with_index(index=None, *, frame=None)</code>","text":"<p>Returns <code>self</code> with a row index added in column 'i' (dtype polars.Int64). If <code>index</code> is not specified, defaults to an existing index or a new index.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef with_index(self: HasAtomCellT, index: t.Optional[AtomValues] = None, *,\n               frame: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n    \"\"\"\n    Returns ``self`` with a row index added in column 'i' (dtype polars.Int64).\n    If ``index`` is not specified, defaults to an existing index or a new index.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.with_wobble","title":"<code>with_wobble(wobble=None, *, frame=None)</code>","text":"<p>Return <code>self</code> with the given displacements in column 'wobble' (dtype polars.Float64). If <code>wobble</code> is not specified, defaults to the already-existing wobbles or 0.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef with_wobble(self: HasAtomCellT, wobble: t.Optional[AtomValues] = None, *,\n                frame: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n    \"\"\"\n    Return ``self`` with the given displacements in column 'wobble' (dtype polars.Float64).\n    If ``wobble`` is not specified, defaults to the already-existing wobbles or 0.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.with_occupancy","title":"<code>with_occupancy(frac_occupancy=None, *, frame=None)</code>","text":"<p>Return self with the given fractional occupancies. If <code>frac_occupancy</code> is not specified, defaults to the already-existing occupancies or 1.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef with_occupancy(self: HasAtomCellT, frac_occupancy: t.Optional[AtomValues] = None, *,\n                   frame: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n    \"\"\"\n    Return self with the given fractional occupancies. If ``frac_occupancy`` is not specified,\n    defaults to the already-existing occupancies or 1.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.apply_wobble","title":"<code>apply_wobble(rng=None, frame=None)</code>","text":"<p>Displace the atoms in <code>self</code> by the amount in the <code>wobble</code> column. <code>wobble</code> is interpretated as a mean-squared displacement, which is distributed equally over each axis.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef apply_wobble(self: HasAtomCellT, rng: t.Union[numpy.random.Generator, int, None] = None,\n                 frame: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n    \"\"\"\n    Displace the atoms in ``self`` by the amount in the `wobble` column.\n    ``wobble`` is interpretated as a mean-squared displacement, which is distributed\n    equally over each axis.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.apply_occupancy","title":"<code>apply_occupancy(rng=None)</code>","text":"<p>For each atom in <code>self</code>, use its <code>frac_occupancy</code> to randomly decide whether to remove it.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def apply_occupancy(self: HasAtomsT, rng: t.Union[numpy.random.Generator, int, None] = None) -&gt; HasAtomsT:\n    \"\"\"\n    For each atom in `self`, use its `frac_occupancy` to randomly decide whether to remove it.\n    \"\"\"\n    if 'frac_occupancy' not in self.columns:\n        return self\n    rng = numpy.random.default_rng(seed=rng)\n\n    frac = self.select('frac_occupancy').to_series().to_numpy()\n    choice = rng.binomial(1, frac).astype(numpy.bool_)\n    return self.filter(polars.lit(choice))\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.with_type","title":"<code>with_type(types=None, *, frame=None)</code>","text":"<p>Return <code>self</code> with the given atom types in column 'type'. If <code>types</code> is not specified, use the already existing types or auto-assign them.</p> <p>When auto-assigning, each symbol is given a unique value, case-sensitive. Values are assigned from lowest atomic number to highest. For instance: <code>[\"Ag+\", \"Na\", \"H\", \"Ag\"]</code> =&gt; <code>[3, 11, 1, 2]</code></p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef with_type(self: HasAtomCellT, types: t.Optional[AtomValues] = None, *,\n              frame: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n    \"\"\"\n    Return ``self`` with the given atom types in column 'type'.\n    If ``types`` is not specified, use the already existing types or auto-assign them.\n\n    When auto-assigning, each symbol is given a unique value, case-sensitive.\n    Values are assigned from lowest atomic number to highest.\n    For instance: ``[\"Ag+\", \"Na\", \"H\", \"Ag\"]`` =&gt; ``[3, 11, 1, 2]``\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.with_mass","title":"<code>with_mass(mass=None, *, frame=None)</code>","text":"<p>Return <code>self</code> with the given atom masses in column 'mass'. If <code>mass</code> is not specified, use the already existing masses or auto-assign them.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef with_mass(self: HasAtomCellT, mass: t.Optional[ArrayLike] = None, *,\n              frame: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n    \"\"\"\n    Return ``self`` with the given atom masses in column 'mass'.\n    If ``mass`` is not specified, use the already existing masses or auto-assign them.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.with_symbol","title":"<code>with_symbol(symbols, selection=None, *, frame=None)</code>","text":"<p>Return <code>self</code> with the given atomic symbols.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef with_symbol(self: HasAtomCellT, symbols: ArrayLike, selection: t.Optional[AtomSelection] = None, *,\n                frame: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n    \"\"\"\n    Return ``self`` with the given atomic symbols.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.with_coords","title":"<code>with_coords(pts, selection=None, *, frame=None)</code>","text":"<p>Return <code>self</code> replaced with the given atomic positions.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef with_coords(self: HasAtomCellT, pts: ArrayLike, selection: t.Optional[AtomSelection] = None, *,\n                frame: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n    \"\"\"\n    Return ``self`` replaced with the given atomic positions.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.with_velocity","title":"<code>with_velocity(pts=None, selection=None, *, frame=None)</code>","text":"<p>Return <code>self</code> replaced with the given atomic velocities. If <code>pts</code> is not specified, use the already existing velocities or zero.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@_fwd_atoms_transform\ndef with_velocity(self: HasAtomCellT, pts: t.Optional[ArrayLike] = None,\n                  selection: t.Optional[AtomSelection] = None, *,\n                  frame: t.Optional[CoordinateFrame] = None) -&gt; HasAtomCellT:\n    \"\"\"\n    Return ``self`` replaced with the given atomic velocities.\n    If ``pts`` is not specified, use the already existing velocities or zero.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.get_frame","title":"<code>get_frame()</code>","text":"<p>Get the coordinate frame atoms are stored in.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def get_frame(self) -&gt; CoordinateFrame:\n    \"\"\"Get the coordinate frame atoms are stored in.\"\"\"\n    return self.frame\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.get_atomcell","title":"<code>get_atomcell()</code>","text":"Source code in <code>atomlib/atomcell.py</code> <pre><code>def get_atomcell(self) -&gt; AtomCell:\n    frame = self.get_frame()\n    return AtomCell(self.get_atoms(frame), self.get_cell(), frame=frame, keep_frame=True)\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.to_frame","title":"<code>to_frame(frame)</code>","text":"<p>Convert the stored Atoms to the given coordinate frame.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def to_frame(self: HasAtomCellT, frame: CoordinateFrame) -&gt; HasAtomCellT:\n    \"\"\"Convert the stored Atoms to the given coordinate frame.\"\"\"\n    return self.with_atoms(self.get_atoms(frame), frame)\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.crop_to_box","title":"<code>crop_to_box(eps=1e-05)</code>","text":"Source code in <code>atomlib/atomcell.py</code> <pre><code>def crop_to_box(self: HasAtomCellT, eps: float = 1e-5) -&gt; HasAtomCellT:\n    atoms = self._transform_atoms_in_frame('cell_box', lambda atoms: atoms.crop_atoms(*([-eps, 1-eps]*3)))\n    return self.with_atoms(atoms)\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.wrap","title":"<code>wrap(eps=1e-05)</code>","text":"<p>Wrap atoms around the cell boundaries.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def wrap(self: HasAtomCellT, eps: float = 1e-5) -&gt; HasAtomCellT:\n    \"\"\"Wrap atoms around the cell boundaries.\"\"\"\n    return self.with_atoms(self._transform_atoms_in_frame('cell_box', lambda a: a._wrap(eps)))\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.repeat_to","title":"<code>repeat_to(size, crop=False)</code>","text":"<p>Repeat the cell so it is at least <code>size</code> along the crystal's axes.</p> <p>If <code>crop</code>, then crop the cell to exactly <code>size</code>. This may break periodicity. <code>crop</code> may be a vector, in which case you can specify cropping only along some axes.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def repeat_to(self: HasAtomCellT, size: VecLike, crop: t.Union[bool, t.Sequence[bool]] = False) -&gt; HasAtomCellT:\n    \"\"\"\n    Repeat the cell so it is at least ``size`` along the crystal's axes.\n\n    If ``crop``, then crop the cell to exactly ``size``. This may break periodicity.\n    ``crop`` may be a vector, in which case you can specify cropping only along some axes.\n    \"\"\"\n    size = to_vec3(size)\n    cell_size = self.cell_size * self.n_cells\n    repeat = numpy.maximum(numpy.ceil(size / cell_size).astype(int), 1)\n    atom_cell = self.repeat(repeat)\n\n    crop_v = to_vec3(crop, dtype=numpy.bool_)\n    if numpy.any(crop_v):\n        crop_x, crop_y, crop_z = crop_v\n        return atom_cell.crop(\n            x_max = size[0] if crop_x else numpy.inf,\n            y_max = size[1] if crop_y else numpy.inf,\n            z_max = size[2] if crop_z else numpy.inf,\n            frame='cell'\n        )\n\n    return atom_cell\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.repeat_x","title":"<code>repeat_x(n)</code>","text":"<p>Tile the cell in the x axis.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def repeat_x(self: HasAtomCellT, n: int) -&gt; HasAtomCellT:\n    \"\"\"Tile the cell in the x axis.\"\"\"\n    return self.repeat((n, 1, 1))\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.repeat_y","title":"<code>repeat_y(n)</code>","text":"<p>Tile the cell in the y axis.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def repeat_y(self: HasAtomCellT, n: int) -&gt; HasAtomCellT:\n    \"\"\"Tile the cell in the y axis.\"\"\"\n    return self.repeat((1, n, 1))\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.repeat_z","title":"<code>repeat_z(n)</code>","text":"<p>Tile the cell in the z axis.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def repeat_z(self: HasAtomCellT, n: int) -&gt; HasAtomCellT:\n    \"\"\"Tile the cell in the z axis.\"\"\"\n    return self.repeat((1, 1, n))\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.repeat_to_x","title":"<code>repeat_to_x(size, crop=False)</code>","text":"<p>Repeat the cell so it is at least size <code>size</code> along the x axis.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def repeat_to_x(self: HasAtomCellT, size: float, crop: bool = False) -&gt; HasAtomCellT:\n    \"\"\"Repeat the cell so it is at least size ``size`` along the x axis.\"\"\"\n    return self.repeat_to([size, 0., 0.], [crop, False, False])\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.repeat_to_y","title":"<code>repeat_to_y(size, crop=False)</code>","text":"<p>Repeat the cell so it is at least size <code>size</code> along the y axis.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def repeat_to_y(self: HasAtomCellT, size: float, crop: bool = False) -&gt; HasAtomCellT:\n    \"\"\"Repeat the cell so it is at least size ``size`` along the y axis.\"\"\"\n    return self.repeat_to([0., size, 0.], [False, crop, False])\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.repeat_to_z","title":"<code>repeat_to_z(size, crop=False)</code>","text":"<p>Repeat the cell so it is at least size <code>size</code> along the z axis.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def repeat_to_z(self: HasAtomCellT, size: float, crop: bool = False) -&gt; HasAtomCellT:\n    \"\"\"Repeat the cell so it is at least size ``size`` along the z axis.\"\"\"\n    return self.repeat_to([0., 0., size], [False, False, crop])\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.repeat_to_aspect","title":"<code>repeat_to_aspect(plane='xy', *, aspect=1.0, min_size=None, max_size=None)</code>","text":"<p>Repeat to optimize the aspect ratio in <code>plane</code>, while staying above <code>min_size</code> and under <code>max_size</code>.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def repeat_to_aspect(self: HasAtomCellT, plane: t.Literal['xy', 'xz', 'yz'] = 'xy', *,\n                     aspect: float = 1., min_size: t.Optional[VecLike] = None,\n                     max_size: t.Optional[VecLike] = None) -&gt; HasAtomCellT:\n    \"\"\"\n    Repeat to optimize the aspect ratio in ``plane``,\n    while staying above ``min_size`` and under ``max_size``.\n    \"\"\"\n    if min_size is None:\n        min_n = numpy.array([1, 1, 1], numpy.int_)\n    else:\n        min_n = numpy.maximum(numpy.ceil(to_vec3(min_size) / self.box_size), 1).astype(numpy.int_)\n\n    if max_size is None:\n        max_n = 3 * min_n\n    else:\n        max_n = numpy.maximum(numpy.floor(to_vec3(max_size) / self.box_size), 1).astype(numpy.int_)\n\n    if plane == 'xy':\n        indices = [0, 1]\n    elif plane == 'xz':\n        indices = [0, 2]\n    elif plane == 'yz':\n        indices = [1, 2]\n    else:\n        raise ValueError(f\"Invalid plane '{plane}'. Exepcted 'xy', 'xz', 'or 'yz'.\")\n\n    na = numpy.arange(min_n[indices[0]], max_n[indices[0]])\n    nb = numpy.arange(min_n[indices[1]], max_n[indices[1]])\n    (na, nb) = numpy.meshgrid(na, nb)\n\n    aspects = na * self.box_size[indices[0]] / (nb * self.box_size[indices[1]])\n    # cost function: log(aspect)^2  (so cost(0.5) == cost(2))\n    min_i = numpy.argmin(numpy.log(aspects / aspect)**2)\n    repeat = numpy.array([1, 1, 1], numpy.int_)\n    repeat[indices] = na.flatten()[min_i], nb.flatten()[min_i]\n    return self.repeat(repeat)\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.periodic_duplicate","title":"<code>periodic_duplicate(eps=1e-05)</code>","text":"<p>Add duplicate copies of atoms near periodic boundaries.</p> <p>For instance, an atom at a corner will be duplicated into 8 copies. This is mostly only useful for visualization.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def periodic_duplicate(self: HasAtomCellT, eps: float = 1e-5) -&gt; HasAtomCellT:\n    \"\"\"\n    Add duplicate copies of atoms near periodic boundaries.\n\n    For instance, an atom at a corner will be duplicated into 8 copies.\n    This is mostly only useful for visualization.\n    \"\"\"\n    frame_save = self.get_frame()\n    self = self.to_frame('cell_box').wrap(eps=eps)\n\n    for i in range(3):\n        self = self.concat((self,\n            self.filter(polars.col('coords').arr.get(i).abs() &lt;= eps, frame='cell_box')\n                .transform_atoms(AffineTransform3D.translate([1. if i == j else 0. for j in range(3)]), frame='cell_box')\n        ))\n\n    return self.to_frame(frame_save)\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.read","title":"<code>read(path, ty=None)</code>  <code>classmethod</code>","text":"<p>Read a structure from a file.</p> <p>Supported types can be found in the io module. If no <code>ty</code> is specified, it is inferred from the file's extension.</p> Source code in <code>atomlib/mixins.py</code> <pre><code>@classmethod\ndef read(cls: t.Type[HasAtomsT], path: FileOrPath, ty: t.Optional[FileType] = None) -&gt; HasAtomsT:\n    \"\"\"\n    Read a structure from a file.\n\n    Supported types can be found in the [io][atomlib.io] module.\n    If no `ty` is specified, it is inferred from the file's extension.\n    \"\"\"\n    from .io import read\n    return _cast_atoms(read(path, ty), cls)  # type: ignore\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.read_cif","title":"<code>read_cif(f, block=None)</code>  <code>classmethod</code>","text":"<p>Read a structure from a CIF file.</p> <p>If <code>block</code> is specified, read data from the given block of the CIF file (index or name).</p> Source code in <code>atomlib/mixins.py</code> <pre><code>@classmethod\ndef read_cif(cls: t.Type[HasAtomsT], f: t.Union[FileOrPath, CIF, CIFDataBlock], block: t.Union[int, str, None] = None) -&gt; HasAtomsT:\n    \"\"\"\n    Read a structure from a CIF file.\n\n    If `block` is specified, read data from the given block of the CIF file (index or name).\n    \"\"\"\n    from .io import read_cif\n    return _cast_atoms(read_cif(f, block), cls)\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.read_xyz","title":"<code>read_xyz(f)</code>  <code>classmethod</code>","text":"<p>Read a structure from an XYZ file.</p> Source code in <code>atomlib/mixins.py</code> <pre><code>@classmethod\ndef read_xyz(cls: t.Type[HasAtomsT], f: t.Union[FileOrPath, XYZ]) -&gt; HasAtomsT:\n    \"\"\"Read a structure from an XYZ file.\"\"\"\n    from .io import read_xyz\n    return _cast_atoms(read_xyz(f), cls)\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.read_xsf","title":"<code>read_xsf(f)</code>  <code>classmethod</code>","text":"<p>Read a structure from an XSF file.</p> Source code in <code>atomlib/mixins.py</code> <pre><code>@classmethod\ndef read_xsf(cls: t.Type[HasAtomsT], f: t.Union[FileOrPath, XSF]) -&gt; HasAtomsT:\n    \"\"\"Read a structure from an XSF file.\"\"\"\n    from .io import read_xsf\n    return _cast_atoms(read_xsf(f), cls)\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.read_cfg","title":"<code>read_cfg(f)</code>  <code>classmethod</code>","text":"<p>Read a structure from a CFG file.</p> Source code in <code>atomlib/mixins.py</code> <pre><code>@classmethod\ndef read_cfg(cls: t.Type[HasAtomsT], f: t.Union[FileOrPath, CFG]) -&gt; HasAtomsT:\n    \"\"\"Read a structure from a CFG file.\"\"\"\n    from .io import read_cfg\n    return _cast_atoms(read_cfg(f), cls)\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.read_lmp","title":"<code>read_lmp(f, type_map=None)</code>  <code>classmethod</code>","text":"<p>Read a structure from a LAAMPS data file.</p> Source code in <code>atomlib/mixins.py</code> <pre><code>@classmethod\ndef read_lmp(cls: t.Type[HasAtomsT], f: t.Union[FileOrPath, LMP], type_map: t.Optional[t.Dict[int, t.Union[str, int]]] = None) -&gt; HasAtomsT:\n    \"\"\"Read a structure from a LAAMPS data file.\"\"\"\n    from .io import read_lmp\n    return _cast_atoms(read_lmp(f, type_map=type_map), cls)\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.write_cif","title":"<code>write_cif(f)</code>","text":"Source code in <code>atomlib/mixins.py</code> <pre><code>def write_cif(self, f: FileOrPath):\n    from .io import write_cif\n    write_cif(self, f)\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.write_xyz","title":"<code>write_xyz(f, fmt='exyz')</code>","text":"Source code in <code>atomlib/mixins.py</code> <pre><code>def write_xyz(self, f: FileOrPath, fmt: XYZFormat = 'exyz'):\n    from .io import write_xyz\n    write_xyz(self, f, fmt)\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.write_xsf","title":"<code>write_xsf(f)</code>","text":"Source code in <code>atomlib/mixins.py</code> <pre><code>def write_xsf(self, f: FileOrPath):\n    from .io import write_xsf\n    write_xsf(self, f)\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.write_cfg","title":"<code>write_cfg(f)</code>","text":"Source code in <code>atomlib/mixins.py</code> <pre><code>def write_cfg(self, f: FileOrPath):\n    from .io import write_cfg\n    write_cfg(self, f)\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.write_lmp","title":"<code>write_lmp(f)</code>","text":"Source code in <code>atomlib/mixins.py</code> <pre><code>def write_lmp(self, f: FileOrPath):\n    from .io import write_lmp\n    write_lmp(self, f)\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.write","title":"<code>write(path, ty=None)</code>","text":"<p>Write this structure to a file.</p> <p>A file type may be specified using <code>ty</code>. If no <code>ty</code> is specified, it is inferred from the path's extension.</p> Source code in <code>atomlib/mixins.py</code> <pre><code>def write(self, path: FileOrPath, ty: t.Optional[FileType] = None):\n    \"\"\"\n    Write this structure to a file.\n\n    A file type may be specified using `ty`.\n    If no `ty` is specified, it is inferred from the path's extension.\n    \"\"\"\n    from .io import write\n    write(self, path, ty)  # type: ignore\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.write_mslice","title":"<code>write_mslice(f, template=None, *, slice_thickness=None, scan_points=None, scan_extent=None, noise_sigma=None, conv_angle=None, energy=None, defocus=None, tilt=None, tds=None, n_cells=None)</code>","text":"<p>Write a structure to an mslice file.</p> <p><code>template</code> may be a file, path, or ElementTree containing an existing mslice file. Its structure will be modified to make the final output. If not specified, a default template will be used.</p> <p>Additional options modify simulation properties. If an option is not specified, the template's properties are used.</p> Source code in <code>atomlib/mixins.py</code> <pre><code>def write_mslice(self, f: BinaryFileOrPath, template: t.Optional[MSliceFile] = None, *,\n             slice_thickness: t.Optional[float] = None,  # angstrom\n             scan_points: t.Optional[ArrayLike] = None,\n             scan_extent: t.Optional[ArrayLike] = None,\n             noise_sigma: t.Optional[float] = None,  # angstrom\n             conv_angle: t.Optional[float] = None,  # mrad\n             energy: t.Optional[float] = None,  # keV\n             defocus: t.Optional[float] = None,  # angstrom\n             tilt: t.Optional[t.Tuple[float, float]] = None,  # (mrad, mrad)\n             tds: t.Optional[bool] = None,\n             n_cells: t.Optional[ArrayLike] = None):\n    \"\"\"\n    Write a structure to an mslice file.\n\n    `template` may be a file, path, or ElementTree containing an existing mslice file.\n    Its structure will be modified to make the final output. If not specified, a default\n    template will be used.\n\n    Additional options modify simulation properties. If an option is not specified, the\n    template's properties are used.\n    \"\"\"\n    from .io import write_mslice\n    return write_mslice(self, f, template, slice_thickness=slice_thickness,\n                        scan_points=scan_points, scan_extent=scan_extent,\n                        conv_angle=conv_angle, energy=energy, defocus=defocus,\n                        noise_sigma=noise_sigma, tilt=tilt, tds=tds, n_cells=n_cells)\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.write_qe","title":"<code>write_qe(f, pseudo=None)</code>","text":"Source code in <code>atomlib/mixins.py</code> <pre><code>def write_qe(self, f: FileOrPath, pseudo: t.Optional[t.Mapping[str, str]] = None):\n    from .io import write_qe\n    write_qe(self, f, pseudo)\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.from_ortho","title":"<code>from_ortho(atoms, ortho, *, n_cells=None, frame='local', keep_frame=False)</code>  <code>classmethod</code>","text":"<p>Make an atom cell given a list of atoms and an orthogonalization matrix. Atoms are assumed to be in the coordinate system <code>frame</code>.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@classmethod\ndef from_ortho(cls, atoms: IntoAtoms, ortho: LinearTransform3D, *,\n               n_cells: t.Optional[VecLike] = None,\n               frame: CoordinateFrame = 'local',\n               keep_frame: bool = False):\n    \"\"\"\n    Make an atom cell given a list of atoms and an orthogonalization matrix.\n    Atoms are assumed to be in the coordinate system ``frame``.\n    \"\"\"\n    cell = Cell.from_ortho(ortho, n_cells)\n    return cls(atoms, cell, frame=frame, keep_frame=keep_frame)\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.from_unit_cell","title":"<code>from_unit_cell(atoms, cell_size, cell_angle=None, *, n_cells=None, frame='local', keep_frame=False)</code>  <code>classmethod</code>","text":"<p>Make a cell given a list of atoms and unit cell parameters. Atoms are assumed to be in the coordinate system <code>frame</code>.</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>@classmethod\ndef from_unit_cell(cls, atoms: IntoAtoms, cell_size: VecLike,\n                   cell_angle: t.Optional[VecLike] = None, *,\n                   n_cells: t.Optional[VecLike] = None,\n                   frame: CoordinateFrame = 'local',\n                   keep_frame: bool = False):\n    \"\"\"\n    Make a cell given a list of atoms and unit cell parameters.\n    Atoms are assumed to be in the coordinate system ``frame``.\n    \"\"\"\n    cell = Cell.from_unit_cell(cell_size, cell_angle, n_cells=n_cells)\n    return cls(atoms, cell, frame=frame, keep_frame=keep_frame)\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.orthogonalize","title":"<code>orthogonalize()</code>","text":"Source code in <code>atomlib/atomcell.py</code> <pre><code>def orthogonalize(self) -&gt; OrthoCell:\n    if self.is_orthogonal():\n        return OrthoCell(self.atoms, self.cell, frame=self.frame)\n    raise NotImplementedError()\n</code></pre>"},{"location":"api/atomcell/#atomlib.atomcell.OrthoCell.is_orthogonal","title":"<code>is_orthogonal(tol=1e-08)</code>","text":"<p>Returns whether this cell is orthogonal (axes are at right angles.)</p> Source code in <code>atomlib/atomcell.py</code> <pre><code>def is_orthogonal(self, tol: float = 1e-8) -&gt; t.Literal[True]:\n    \"\"\"Returns whether this cell is orthogonal (axes are at right angles.)\"\"\"\n    return True\n</code></pre>"},{"location":"api/atoms/","title":"<code>atomlib.atoms</code>","text":"<p>Raw atoms collection</p> <p>This module defines <code>Atoms</code>, which holds a collection of atoms with no cell or periodicity. <code>Atoms</code> is essentially a wrapper around a <code>polars.DataFrame</code>.</p>"},{"location":"api/atoms/#atomlib.atoms.SchemaDict","title":"<code>SchemaDict: TypeAlias = OrderedDict[str, polars.DataType]</code>  <code>module-attribute</code>","text":""},{"location":"api/atoms/#atomlib.atoms.IntoExprColumn","title":"<code>IntoExprColumn: TypeAlias = polars.type_aliases.IntoExprColumn</code>  <code>module-attribute</code>","text":""},{"location":"api/atoms/#atomlib.atoms.IntoExpr","title":"<code>IntoExpr: TypeAlias = polars.type_aliases.IntoExpr</code>  <code>module-attribute</code>","text":""},{"location":"api/atoms/#atomlib.atoms.UniqueKeepStrategy","title":"<code>UniqueKeepStrategy: TypeAlias = polars.type_aliases.UniqueKeepStrategy</code>  <code>module-attribute</code>","text":""},{"location":"api/atoms/#atomlib.atoms.FillNullStrategy","title":"<code>FillNullStrategy: TypeAlias = polars.type_aliases.FillNullStrategy</code>  <code>module-attribute</code>","text":""},{"location":"api/atoms/#atomlib.atoms.RollingInterpolationMethod","title":"<code>RollingInterpolationMethod: TypeAlias = polars.type_aliases.RollingInterpolationMethod</code>  <code>module-attribute</code>","text":""},{"location":"api/atoms/#atomlib.atoms.ConcatMethod","title":"<code>ConcatMethod: TypeAlias = t.Literal['horizontal', 'vertical', 'diagonal', 'inner', 'align']</code>  <code>module-attribute</code>","text":""},{"location":"api/atoms/#atomlib.atoms.IntoAtoms","title":"<code>IntoAtoms = t.Union[t.Dict[str, t.Sequence[t.Any]], t.Sequence[t.Any], numpy.ndarray, polars.DataFrame, 'Atoms']</code>  <code>module-attribute</code>","text":"<p>A type convertible into an <code>Atoms</code>.</p>"},{"location":"api/atoms/#atomlib.atoms.AtomSelection","title":"<code>AtomSelection = t.Union[IntoExprColumn, NDArray[numpy.bool_], ArrayLike, t.Mapping[str, t.Any]]</code>  <code>module-attribute</code>","text":"<p>Polars expression selecting a subset of atoms from an Atoms. Can be used with many Atoms methods.</p>"},{"location":"api/atoms/#atomlib.atoms.AtomValues","title":"<code>AtomValues = t.Union[IntoExprColumn, NDArray[numpy.generic], ArrayLike, t.Mapping[str, t.Any]]</code>  <code>module-attribute</code>","text":"<p>Array, value, or polars expression mapping atom symbols to values. Can be used with <code>with_*</code> methods on Atoms</p>"},{"location":"api/atoms/#atomlib.atoms.HasAtomsT","title":"<code>HasAtomsT = t.TypeVar('HasAtomsT', bound='HasAtoms')</code>  <code>module-attribute</code>","text":""},{"location":"api/atoms/#atomlib.atoms.HasAtoms","title":"<code>HasAtoms</code>","text":"<p>             Bases: <code>ABC</code></p> <p>Abstract class representing any (possibly compound) collection of atoms.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>class HasAtoms(abc.ABC):\n    \"\"\"Abstract class representing any (possibly compound) collection of atoms.\"\"\"\n\n    # abstract methods\n\n    @abc.abstractmethod\n    def get_atoms(self, frame: t.Literal['local'] = 'local') -&gt; Atoms:\n        \"\"\"Get atoms contained in `self`. This should be a low cost method.\"\"\"\n        ...\n\n    @abc.abstractmethod\n    def with_atoms(self: HasAtomsT, atoms: HasAtoms, frame: t.Literal['local'] = 'local') -&gt; HasAtomsT:\n        ...\n\n    @classmethod\n    @abc.abstractmethod\n    def _combine_metadata(cls: t.Type[HasAtomsT], *atoms: HasAtoms) -&gt; HasAtomsT:\n        \"\"\"\n        When combining multiple ``HasAtoms``, check that they are compatible with each other,\n        and return a 'representative' which best represents the combined metadata.\n        Implementors should treat `Atoms` as acceptable, but having no metadata.\n        \"\"\"\n        ...\n\n    def _get_frame(self) -&gt; polars.DataFrame:\n        return self.get_atoms().inner\n\n    # dataframe methods\n\n    @property\n    @_fwd_frame(lambda df: df.columns)\n    def columns(self) -&gt; t.Sequence[str]:\n        \"\"\"Return the columns in `self`.\"\"\"\n        ...\n\n    @property\n    @_fwd_frame(lambda df: df.dtypes)\n    def dtypes(self) -&gt; t.Sequence[polars.DataType]:\n        \"\"\"Return the datatypes in `self`.\"\"\"\n        ...\n\n    @property\n    @_fwd_frame(lambda df: df.schema)\n    def schema(self) -&gt; SchemaDict:\n        \"\"\"Return the schema of `self`.\"\"\"\n        ...\n\n    @_fwd_frame(polars.DataFrame.describe)\n    def describe(self, percentiles: t.Union[t.Sequence[float], float, None] = (0.25, 0.5, 0.75), *,\n                 interpolation: RollingInterpolationMethod = 'nearest') -&gt; polars.DataFrame:\n        \"\"\"Return summary statistics for `self`.\"\"\"\n        ...\n\n    @_fwd_frame_map\n    def with_columns(self,\n                     *exprs: t.Union[IntoExpr, t.Iterable[IntoExpr]],\n                     **named_exprs: IntoExpr) -&gt; polars.DataFrame:\n        \"\"\"Return a copy of `self` with the given columns added.\"\"\"\n        return self._get_frame().with_columns(*exprs, **named_exprs)\n\n    with_column = with_columns\n\n    @_fwd_frame_map\n    def insert_column(self, index: int, column: polars.Series) -&gt; polars.DataFrame:\n        return self._get_frame().insert_column(index, column)\n\n    @_fwd_frame(polars.DataFrame.get_column)\n    def get_column(self, name: str) -&gt; polars.Series:\n        \"\"\"Get the specified column from `self`, raising [`polars.ColumnNotFoundError`][polars.exceptions.ColumnNotFoundError] if it's not present.\"\"\"\n        ...\n\n    @_fwd_frame(polars.DataFrame.get_columns)\n    def get_columns(self) -&gt; t.List[polars.Series]:\n        \"\"\"Get the specified columns from `self`, raising [`polars.ColumnNotFoundError`][polars.exceptions.ColumnNotFoundError] if it's not present.\"\"\"\n        ...\n\n    @_fwd_frame(polars.DataFrame.get_column_index)\n    def get_column_index(self, name: str) -&gt; int:\n        \"\"\"Get the index of a column by name, raising [`polars.ColumnNotFoundError`][polars.exceptions.ColumnNotFoundError] if it's not present.\"\"\"\n        ...\n\n    @_fwd_frame(polars.DataFrame.group_by)\n    def group_by(self, *by: t.Union[IntoExpr, t.Iterable[IntoExpr]], maintain_order: bool = False,\n                 **named_by: IntoExpr) -&gt; polars.dataframe.group_by.GroupBy:\n        ...\n\n    def pipe(self: HasAtomsT, function: t.Callable[Concatenate[HasAtomsT, P], T], *args: P.args, **kwargs: P.kwargs) -&gt; T:\n        \"\"\"Apply `function` to `self` (in method-call syntax).\"\"\"\n        return function(self, *args, **kwargs)\n\n    @_fwd_frame_map\n    def clone(self) -&gt; polars.DataFrame:\n        \"\"\"Return a copy of `self`.\"\"\"\n        return self._get_frame().clone()\n\n    def drop(self, *columns: t.Union[str, t.Iterable[str]]) -&gt; polars.DataFrame:\n        \"\"\"Return `self` with the specified columns removed.\"\"\"\n        return self._get_frame().drop(*columns)\n\n    # row-wise operations\n\n    def filter(\n        self: HasAtomsT,\n        *predicates: t.Union[None, IntoExprColumn, t.Iterable[IntoExprColumn], bool, t.List[bool], numpy.ndarray],\n        **constraints: t.Any,\n    ) -&gt; HasAtomsT:\n        \"\"\"Filter `self`, removing rows which evaluate to `False`.\"\"\"\n        # TODO clean up\n        preds_not_none: t.Tuple[t.Union[IntoExprColumn, t.Iterable[IntoExprColumn], bool, t.List[bool], numpy.ndarray], ...]\n        preds_not_none = tuple(filter(lambda p: p is not None, predicates))  # type: ignore\n        if not len(preds_not_none) and not len(constraints):\n            return self\n        return self.with_atoms(Atoms(self._get_frame().filter(*preds_not_none, **constraints), _unchecked=True))\n\n    @_fwd_frame_map\n    def sort(\n        self,\n        by: t.Union[IntoExpr, t.Iterable[IntoExpr]],\n        *more_by: IntoExpr,\n        descending: t.Union[bool, t.Sequence[bool]] = False,\n        nulls_last: bool = False,\n    ) -&gt; polars.DataFrame:\n        \"\"\"\n        Sort the atoms in `self` by the given columns/expressions.\n        \"\"\"\n        return self._get_frame().sort(\n            by, *more_by, descending=descending, nulls_last=nulls_last\n        )\n\n    @_fwd_frame_map\n    def slice(self, offset: int, length: t.Optional[int] = None) -&gt; polars.DataFrame:\n        \"\"\"Return a slice of the rows in `self`.\"\"\"\n        return self._get_frame().slice(offset, length)\n\n    @_fwd_frame_map\n    def head(self, n: int = 5) -&gt; polars.DataFrame:\n        \"\"\"Return the first `n` rows of `self`.\"\"\"\n        return self._get_frame().head(n)\n\n    @_fwd_frame_map\n    def tail(self, n: int = 5) -&gt; polars.DataFrame:\n        \"\"\"Return the last `n` rows of `self`.\"\"\"\n        return self._get_frame().tail(n)\n\n    @_fwd_frame_map\n    def drop_nulls(self, subset: t.Union[str, t.Collection[str], None] = None) -&gt; polars.DataFrame:\n        \"\"\"Drop rows that contain nulls in any of columns `subset`.\"\"\"\n        return self._get_frame().drop_nulls(subset)\n\n    @_fwd_frame_map\n    def fill_null(\n        self, value: t.Any = None, strategy: t.Optional[FillNullStrategy] = None,\n        limit: t.Optional[int] = None, matches_supertype: bool = True,\n    ) -&gt; polars.DataFrame:\n        \"\"\"Fill null values in `self`, using the specified value or strategy.\"\"\"\n        return self._get_frame().fill_null(value, strategy, limit, matches_supertype=matches_supertype)\n\n    @_fwd_frame_map\n    def fill_nan(self, value: t.Union[polars.Expr, int, float, None]) -&gt; polars.DataFrame:\n        \"\"\"Fill floating-point NaN values in `self`.\"\"\"\n        return self._get_frame().fill_nan(value)\n\n    @classmethod\n    def concat(cls: t.Type[HasAtomsT],\n               atoms: t.Union[HasAtomsT, IntoAtoms, t.Iterable[t.Union[HasAtomsT, IntoAtoms]]], *,\n               rechunk: bool = True, how: ConcatMethod = 'vertical') -&gt; HasAtomsT:\n        \"\"\"Concatenate multiple `Atoms` together, handling metadata appropriately.\"\"\"\n        # this method is tricky. It needs to accept raw Atoms, as well as HasAtoms of the\n        # same type as ``cls``.\n        if _is_abstract(cls):\n            raise TypeError(f\"concat() must be called on a concrete class.\")\n\n        if isinstance(atoms, HasAtoms):\n            atoms = (atoms,)\n        dfs = [a.get_atoms('local').inner if isinstance(a, HasAtoms) else Atoms(t.cast(IntoAtoms, a)).inner for a in atoms]\n        representative = cls._combine_metadata(*(a for a in atoms if isinstance(a, HasAtoms)))\n\n        if len(dfs) == 0:\n            return representative.with_atoms(Atoms.empty(), 'local')\n\n        if how in ('vertical', 'vertical_relaxed'):\n            # get order from first member\n            cols = dfs[0].columns\n            dfs = [df.select(cols) for df in dfs]\n        elif how == 'inner':\n            cols = reduce(operator.and_, (df.schema.keys() for df in dfs))\n            schema = OrderedDict((col, dfs[0].schema[col]) for col in cols)\n            if len(schema) == 0:\n                raise ValueError(f\"Atoms have no columns in common\")\n\n            dfs = [_select_schema(df, schema) for df in dfs]\n            how = 'vertical'\n\n        return representative.with_atoms(Atoms(polars.concat(dfs, rechunk=rechunk, how=how)), 'local')\n\n    @t.overload\n    def partition_by(\n        self: HasAtomsT, by: t.Union[str, t.Sequence[str]], *more_by: str,\n        maintain_order: bool = True, include_key: bool = True, as_dict: t.Literal[False] = False\n    ) -&gt; t.List[HasAtomsT]:\n        ...\n\n    @t.overload\n    def partition_by(\n        self: HasAtomsT, by: t.Union[str, t.Sequence[str]], *more_by: str,\n        maintain_order: bool = True, include_key: bool = True, as_dict: t.Literal[True] = ...\n    ) -&gt; t.Dict[t.Any, HasAtomsT]:\n        ...\n\n    def partition_by(\n        self: HasAtomsT, by: t.Union[str, t.Sequence[str]], *more_by: str,\n        maintain_order: bool = True, include_key: bool = True, as_dict: bool = False\n    ) -&gt; t.Union[t.List[HasAtomsT], t.Dict[t.Any, HasAtomsT]]:\n        \"\"\"\n        Group by the given columns and partition into separate dataframes.\n\n        Return the partitions as a dictionary by specifying `as_dict=True`.\n        \"\"\"\n        if as_dict:\n            d = self._get_frame().partition_by(by, *more_by, maintain_order=maintain_order, include_key=include_key, as_dict=True)\n            return {k: self.with_atoms(Atoms(df, _unchecked=True)) for (k, df) in d.items()}\n\n        return [\n            self.with_atoms(Atoms(df, _unchecked=True))\n            for df in self._get_frame().partition_by(by, *more_by, maintain_order=maintain_order, include_key=include_key, as_dict=False)\n        ]\n\n    # column-wise operations\n\n    @_fwd_frame(polars.DataFrame.select)\n    def select(\n        self,\n        *exprs: t.Union[IntoExpr, t.Iterable[IntoExpr]],\n        **named_exprs: IntoExpr,\n    ):\n        \"\"\"\n        Select `exprs` from `self`, and return as a `polars.DataFrame`.\n\n        Expressions may either be columns or expressions of columns.\n        \"\"\"\n        ...\n\n    # some helpers we add\n\n    def select_schema(self, schema: SchemaDict) -&gt; polars.DataFrame:\n        \"\"\"\n        Select columns from `self` and cast to the given schema.\n        Raises `TypeError` if a column is not found or if it can't be cast.\n        \"\"\"\n        return _select_schema(self, schema)\n\n    def select_props(\n        self: HasAtomsT,\n        *exprs: t.Union[IntoExpr, t.Iterable[IntoExpr]],\n        **named_exprs: IntoExpr\n    ) -&gt; HasAtomsT:\n        \"\"\"\n        Select `exprs` from `self`, while keeping required columns.\n\n        Returns a HasAtoms.\n        \"\"\"\n        props = self._get_frame().lazy().select(*exprs, **named_exprs).drop(_REQUIRED_COLUMNS).collect(_eager=True)\n        return self.with_atoms(\n            Atoms(self._get_frame().select(_REQUIRED_COLUMNS).hstack(props), _unchecked=False)\n        )\n\n    def try_select(\n        self,\n        *exprs: t.Union[IntoExpr, t.Iterable[IntoExpr]],\n        **named_exprs: IntoExpr,\n    ) -&gt; t.Optional[polars.DataFrame]:\n        \"\"\"\n        Try to select `exprs` from `self`, and return as a `DataFrame`.\n\n        Expressions may either be columns or expressions of columns.\n        Return `None` if any columns are missing.\n        \"\"\"\n        try:\n            return self._get_frame().select(*exprs, **named_exprs)\n        except polars.ColumnNotFoundError:\n            return None\n\n    def try_get_column(self, name: str) -&gt; t.Optional[polars.Series]:\n        \"\"\"Try to get a column from `self`, returning `None` if it doesn't exist.\"\"\"\n        try:\n            return self.get_column(name)\n        except polars.ColumnNotFoundError:\n            return None\n\n    def assert_equal(self, other: t.Any):\n        assert isinstance(other, HasAtoms)\n        assert dict(self.schema) == dict(other.schema)\n        for col in self.schema.keys():\n            polars.testing.assert_series_equal(self[col], other[col], check_names=False, rtol=1e-3, atol=1e-8)\n\n    # dunders\n\n    @_fwd_frame(polars.DataFrame.__len__)\n    def __len__(self) -&gt; int:\n        \"\"\"Return the number of atoms in `self`.\"\"\"\n        ...\n\n    @_fwd_frame(polars.DataFrame.__contains__)\n    def __contains__(self, key: str) -&gt; bool:\n        \"\"\"Return whether `self` contains the given column.\"\"\"\n        ...\n\n    def __add__(self: HasAtomsT, other: IntoAtoms) -&gt; HasAtomsT:\n        return self.__class__.concat((self, other), how='inner')\n\n    def __radd__(self: HasAtomsT, other: IntoAtoms) -&gt; HasAtomsT:\n        return self.__class__.concat((other, self), how='inner')\n\n    def __getitem__(self, column: str) -&gt; polars.Series:\n        try:\n            return self.get_column(column)\n        except polars.ColumnNotFoundError:\n            if column in ('x', 'y', 'z'):\n                return self.select(_coord_expr(column)).to_series()\n            raise\n\n    @_fwd_frame(polars.DataFrame.__dataframe__)\n    def __dataframe__(self, nan_as_null: bool = False, allow_copy: bool = True) -&gt; polars.interchange.dataframe.PolarsDataFrame:\n        ...\n\n    # atoms-specific methods\n\n    def bbox_atoms(self) -&gt; BBox3D:\n        \"\"\"Return the bounding box of all the atoms in ``self``.\"\"\"\n        return BBox3D.from_pts(self.coords())\n\n    bbox = bbox_atoms\n\n    def transform_atoms(self: HasAtomsT, transform: IntoTransform3D, selection: t.Optional[AtomSelection] = None, *, transform_velocities: bool = False) -&gt; HasAtomsT:\n        \"\"\"\n        Transform the atoms in `self` by `transform`.\n        If `selection` is given, only transform the atoms in `selection`.\n        \"\"\"\n        transform = Transform3D.make(transform)\n        selection = _selection_to_numpy(self, selection)\n        transformed = self.with_coords(Transform3D.make(transform) @ self.coords(selection), selection)\n        # try to transform velocities as well\n        if transform_velocities and (velocities := self.velocities(selection)) is not None:\n            return transformed.with_velocity(transform.transform_vec(velocities), selection)\n        return transformed\n\n    transform = transform_atoms\n\n    def round_near_zero(self: HasAtomsT, tol: float = 1e-14) -&gt; HasAtomsT:\n        \"\"\"\n        Round atom position values near zero to zero.\n        \"\"\"\n        return self.with_columns(coords=polars.concat_list(\n            polars.when(_coord_expr(col).abs() &gt;= tol).then(_coord_expr(col)).otherwise(polars.lit(0.))\n            for col in range(3)\n        ).list.to_array(3))\n\n    def crop(self: HasAtomsT, x_min: float = -numpy.inf, x_max: float = numpy.inf,\n             y_min: float = -numpy.inf, y_max: float = numpy.inf,\n             z_min: float = -numpy.inf, z_max: float = numpy.inf) -&gt; HasAtomsT:\n        \"\"\"\n        Crop, removing all atoms outside of the specified region, inclusive.\n        \"\"\"\n\n        return self.filter(\n            self.x().is_between(x_min, x_max, closed='both'),\n            self.y().is_between(y_min, y_max, closed='both'),\n            self.z().is_between(z_min, z_max, closed='both'),\n        )\n\n    crop_atoms = crop\n\n    def _wrap(self: HasAtomsT, eps: float = 1e-5) -&gt; HasAtomsT:\n        coords = (self.coords() + eps) % 1. - eps\n        return self.with_coords(coords)\n\n    def deduplicate(self: HasAtomsT, tol: float = 1e-3, subset: t.Iterable[str] = ('x', 'y', 'z', 'symbol'),\n                    keep: UniqueKeepStrategy = 'first', maintain_order: bool = True) -&gt; HasAtomsT:\n        \"\"\"\n        De-duplicate atoms in `self`. Atoms of the same `symbol` that are closer than `tolerance`\n        to each other (by Euclidian distance) will be removed, leaving only the atom specified by\n        `keep` (defaults to the first atom).\n\n        If `subset` is specified, only those columns will be included while assessing duplicates.\n        Floating point columns other than 'x', 'y', and 'z' will not by toleranced.\n        \"\"\"\n        import scipy.spatial\n\n        cols = set((subset,) if isinstance(subset, str) else subset)\n\n        indices = numpy.arange(len(self))\n\n        spatial_cols = cols.intersection(('x', 'y', 'z'))\n        cols -= spatial_cols\n        if len(spatial_cols) &gt; 0:\n            coords = self.select([_coord_expr(col).alias(col) for col in spatial_cols]).to_numpy()\n            tree = scipy.spatial.KDTree(coords)\n\n            # TODO This is a bad algorithm\n            while True:\n                changed = False\n                for (i, j) in tree.query_pairs(tol, 2.):\n                    # whenever we encounter a pair, ensure their index matches\n                    i_i, i_j = indices[[i, j]]\n                    if i_i != i_j:\n                        indices[i] = indices[j] = min(i_i, i_j)\n                        changed = True\n                if not changed:\n                    break\n\n            self = self.with_column(polars.Series('_unique_pts', indices))\n            cols.add('_unique_pts')\n\n        frame = self._get_frame().unique(subset=list(cols), keep=keep, maintain_order=maintain_order)\n        if len(spatial_cols) &gt; 0:\n            frame = frame.drop('_unique_pts')\n\n        return self.with_atoms(Atoms(frame, _unchecked=True))\n\n    unique = deduplicate\n\n    def with_bounds(self, cell_size: t.Optional[VecLike] = None, cell_origin: t.Optional[VecLike] = None) -&gt; 'AtomCell':\n        \"\"\"\n        Return a periodic cell with the given orthogonal cell dimensions.\n\n        If cell_size is not specified, it will be assumed (and may be incorrect).\n        \"\"\"\n        # TODO: test this\n        from .atomcell import AtomCell\n\n        if cell_size is None:\n            warnings.warn(\"Cell boundary unknown. Defaulting to cell BBox\")\n            cell_size = self.bbox().size\n            cell_origin = self.bbox().min\n\n        # TODO test this origin code\n        cell = Cell.from_unit_cell(cell_size)\n        if cell_origin is not None:\n            cell = cell.transform_cell(AffineTransform3D.translate(to_vec3(cell_origin)))\n\n        return AtomCell(self.get_atoms(), cell, frame='local')\n\n    # property getters and setters\n\n    def coords(self, selection: t.Optional[AtomSelection] = None, *, frame: t.Literal['local'] = 'local') -&gt; NDArray[numpy.float64]:\n        \"\"\"Return a `(N, 3)` ndarray of atom coordinates (dtype [`numpy.float64`][numpy.float64]).\"\"\"\n        df = self if selection is None else self.filter(_selection_to_expr(self, selection))\n        return df.get_column('coords').to_numpy().astype(numpy.float64)\n\n    def x(self) -&gt; polars.Expr:\n        return polars.col('coords').arr.get(0).alias('x')\n\n    def y(self) -&gt; polars.Expr:\n        return polars.col('coords').arr.get(1).alias('y')\n\n    def z(self) -&gt; polars.Expr:\n        return polars.col('coords').arr.get(2).alias('z')\n\n    def velocities(self, selection: t.Optional[AtomSelection] = None) -&gt; t.Optional[NDArray[numpy.float64]]:\n        \"\"\"Return a `(N, 3)` ndarray of atom velocities (dtype [`numpy.float64`][numpy.float64]).\"\"\"\n        if 'velocity' not in self:\n            return None\n\n        df = self if selection is None else self.filter(_selection_to_expr(self, selection))\n        return df.get_column('velocity').to_numpy().astype(numpy.float64)\n\n    def types(self) -&gt; t.Optional[polars.Series]:\n        \"\"\"\n        Returns a [`Series`][polars.Series] of atom types (dtype [`polars.Int32`][polars.Int32]).\n\n        [polars.Series]: https://docs.pola.rs/py-polars/html/reference/series/index.html\n        \"\"\"\n        return self.try_get_column('type')\n\n    def masses(self) -&gt; t.Optional[polars.Series]:\n        \"\"\"\n        Returns a [`Series`][polars.Series] of atom masses (dtype [`polars.Float32`][polars.Float32]).\n\n        [polars.Series]: https://docs.pola.rs/py-polars/html/reference/series/index.html\n        \"\"\"\n        return self.try_get_column('mass')\n\n    @t.overload\n    def add_atom(self: HasAtomsT, elem: t.Union[int, str], x: ArrayLike, /, *,\n                 y: None = None, z: None = None,\n                 **kwargs: t.Any) -&gt; HasAtomsT:\n        ...\n\n    @t.overload\n    def add_atom(self: HasAtomsT, elem: t.Union[int, str], /,\n                 x: float, y: float, z: float,\n                 **kwargs: t.Any) -&gt; HasAtomsT:\n        ...\n\n    def add_atom(self: HasAtomsT, elem: t.Union[int, str], /,\n                 x: t.Union[ArrayLike, float],\n                 y: t.Optional[float] = None,\n                 z: t.Optional[float] = None,\n                 **kwargs: t.Any) -&gt; HasAtomsT:\n        \"\"\"\n        Return a copy of `self` with an extra atom.\n\n        By default, all extra columns present in `self` must be specified as `**kwargs`.\n\n        Try to avoid calling this in a loop (Use [`HasAtoms.concat`][atomlib.atoms.HasAtoms.concat] instead).\n        \"\"\"\n        if isinstance(elem, int):\n            kwargs.update(elem=elem)\n        else:\n            kwargs.update(symbol=elem)\n        if hasattr(x, '__len__') and len(x) &gt; 1:  # type: ignore\n            (x, y, z) = to_vec3(x)\n        elif y is None or z is None:\n            raise ValueError(f\"Must specify vector of positions or x, y, &amp; z.\")\n\n        sym = get_sym(elem) if isinstance(elem, int) else elem\n        d: t.Dict[str, t.Any] = {'x': x, 'y': y, 'z': z, 'symbol': sym, **kwargs}\n        return self.concat(\n            (self, Atoms(d).select_schema(self.schema)),\n            how='vertical'\n        )\n\n    @t.overload\n    def pos(self, x: t.Sequence[t.Optional[float]], /, *,\n            y: None = None, z: None = None,\n            tol: float = 1e-6, **kwargs: t.Any) -&gt; polars.Expr:\n        ...\n\n    @t.overload\n    def pos(self, x: t.Optional[float] = None, y: t.Optional[float] = None, z: t.Optional[float] = None, *,\n            tol: float = 1e-6, **kwargs: t.Any) -&gt; polars.Expr:\n        ...\n\n    def pos(self,\n            x: t.Union[t.Sequence[t.Optional[float]], float, None] = None,\n            y: t.Optional[float] = None, z: t.Optional[float] = None, *,\n            tol: float = 1e-6, **kwargs: t.Any) -&gt; polars.Expr:\n        \"\"\"\n        Select all atoms at a given position.\n\n        Formally, returns all atoms within a cube of radius ``tol``\n        centered at ``(x,y,z)``, exclusive of the cube's surface.\n\n        Additional parameters given as ``kwargs`` will be checked\n        as additional parameters (with strict equality).\n        \"\"\"\n\n        if isinstance(x, t.Sequence):\n            (x, y, z) = x\n\n        tol = abs(float(tol))\n        selection = polars.lit(True)\n        if x is not None:\n            selection &amp;= self.x().is_between(x - tol, x + tol, closed='none')\n        if y is not None:\n            selection &amp;= self.y().is_between(y - tol, y + tol, closed='none')\n        if z is not None:\n            selection &amp;= self.z().is_between(z - tol, z + tol, closed='none')\n        for (col, val) in kwargs.items():\n            selection &amp;= (polars.col(col) == val)\n\n        return selection\n\n    def with_index(self: HasAtomsT, index: t.Optional[AtomValues] = None) -&gt; HasAtomsT:\n        \"\"\"\n        Returns `self` with a row index added in column 'i' (dtype [`polars.Int64`][polars.Int64]).\n        If `index` is not specified, defaults to an existing index or a new index.\n        \"\"\"\n        if index is None and 'i' in self.columns:\n            return self\n        if index is None:\n            index = numpy.arange(len(self), dtype=numpy.int64)\n        return self.with_column(_values_to_expr(self, index, polars.Int64).alias('i'))\n\n    def with_wobble(self: HasAtomsT, wobble: t.Optional[AtomValues] = None) -&gt; HasAtomsT:\n        \"\"\"\n        Return `self` with the given displacements in column 'wobble' (dtype [`polars.Float64`][polars.Float64]).\n        If `wobble` is not specified, defaults to the already-existing wobbles or 0.\n        \"\"\"\n        if wobble is None and 'wobble' in self.columns:\n            return self\n        wobble = 0. if wobble is None else wobble\n        return self.with_column(_values_to_expr(self, wobble, polars.Float64).alias('wobble'))\n\n    def with_occupancy(self: HasAtomsT, frac_occupancy: t.Optional[AtomValues] = None) -&gt; HasAtomsT:\n        \"\"\"\n        Return self with the given fractional occupancies. If `frac_occupancy` is not specified,\n        defaults to the already-existing occupancies or 1.\n        \"\"\"\n        if frac_occupancy is None and 'frac_occupancy' in self.columns:\n            return self\n        frac_occupancy = 1. if frac_occupancy is None else frac_occupancy\n        return self.with_column(_values_to_expr(self, frac_occupancy, polars.Float64).alias('frac_occupancy'))\n\n    def apply_wobble(self: HasAtomsT, rng: t.Union[numpy.random.Generator, int, None] = None) -&gt; HasAtomsT:\n        \"\"\"\n        Displace the atoms in `self` by the amount in the `wobble` column.\n        `wobble` is interpretated as a mean-squared displacement, which is distributed\n        equally over each axis.\n        \"\"\"\n        if 'wobble' not in self.columns:\n            return self\n        rng = numpy.random.default_rng(seed=rng)\n\n        stddev = self.select((polars.col('wobble') / 3.).sqrt()).to_series().to_numpy()\n        coords = self.coords()\n        coords += stddev[:, None] * rng.standard_normal(coords.shape)\n        return self.with_coords(coords)\n\n    def apply_occupancy(self: HasAtomsT, rng: t.Union[numpy.random.Generator, int, None] = None) -&gt; HasAtomsT:\n        \"\"\"\n        For each atom in `self`, use its `frac_occupancy` to randomly decide whether to remove it.\n        \"\"\"\n        if 'frac_occupancy' not in self.columns:\n            return self\n        rng = numpy.random.default_rng(seed=rng)\n\n        frac = self.select('frac_occupancy').to_series().to_numpy()\n        choice = rng.binomial(1, frac).astype(numpy.bool_)\n        return self.filter(polars.lit(choice))\n\n    def with_type(self: HasAtomsT, types: t.Optional[AtomValues] = None) -&gt; HasAtomsT:\n        \"\"\"\n        Return `self` with the given atom types in column 'type'.\n        If `types` is not specified, use the already existing types or auto-assign them.\n\n        When auto-assigning, each symbol is given a unique value, case-sensitive.\n        Values are assigned from lowest atomic number to highest.\n        For instance: `[\"Ag+\", \"Na\", \"H\", \"Ag\"]` =&gt; `[3, 11, 1, 2]`\n        \"\"\"\n        if types is not None:\n            return self.with_columns(type=_values_to_expr(self, types, polars.Int32))\n        if 'type' in self.columns:\n            return self\n\n        unique = Atoms(self._get_frame().unique(maintain_order=False, subset=['elem', 'symbol']).sort(['elem', 'symbol']), _unchecked=True)\n        new = self.with_column(polars.Series('type', values=numpy.zeros(len(self)), dtype=polars.Int32))\n\n        logging.warning(\"Auto-assigning element types\")\n        for (i, (elem, sym)) in enumerate(unique.select(('elem', 'symbol')).rows()):\n            print(f\"Assigning type {i+1} to element '{sym}'\")\n            new = new.with_column(polars.when((polars.col('elem') == elem) &amp; (polars.col('symbol') == sym))\n                                        .then(polars.lit(i+1))\n                                        .otherwise(polars.col('type'))\n                                        .alias('type'))\n\n        assert (new.get_column('type') == 0).sum() == 0\n        return new\n\n    def with_mass(self: HasAtomsT, mass: t.Optional[ArrayLike] = None) -&gt; HasAtomsT:\n        \"\"\"\n        Return `self` with the given atom masses in column 'mass'.\n        If `mass` is not specified, use the already existing masses or auto-assign them.\n        \"\"\"\n        if mass is not None:\n            return self.with_column(_values_to_expr(self, mass, polars.Float32).alias('mass'))\n        if 'mass' in self.columns:\n            return self\n\n        unique_elems = self.get_column('elem').unique()\n        new = self.with_column(polars.Series('mass', values=numpy.zeros(len(self)), dtype=polars.Float32))\n\n        logging.warning(\"Auto-assigning element masses\")\n        for elem in unique_elems:\n            new = new.with_column(polars.when(polars.col('elem') == elem)\n                                        .then(polars.lit(get_mass(elem)))\n                                        .otherwise(polars.col('mass'))\n                                        .alias('mass'))\n\n        assert (new.get_column('mass').abs() &lt; 1e-10).sum() == 0\n        return new\n\n    def with_symbol(self: HasAtomsT, symbols: ArrayLike, selection: t.Optional[AtomSelection] = None) -&gt; HasAtomsT:\n        \"\"\"\n        Return `self` with the given atomic symbols.\n        \"\"\"\n        if selection is not None:\n            selection = _selection_to_numpy(self, selection)\n            new_symbols = self.get_column('symbol')\n            new_symbols[selection] = polars.Series(list(numpy.broadcast_to(symbols, len(selection))), dtype=polars.Utf8)\n            symbols = new_symbols\n\n        # TODO better cast here\n        symbols = polars.Series('symbol', list(numpy.broadcast_to(symbols, len(self))), dtype=polars.Utf8)\n        return self.with_columns((symbols, get_elem(symbols)))\n\n    def with_coords(self: HasAtomsT, pts: ArrayLike, selection: t.Optional[AtomSelection] = None, *, frame: t.Literal['local'] = 'local') -&gt; HasAtomsT:\n        \"\"\"\n        Return `self` replaced with the given atomic positions.\n        \"\"\"\n        if selection is not None:\n            selection = _selection_to_numpy(self, selection)\n            new_pts = self.coords()\n            pts = numpy.atleast_2d(pts)\n            assert pts.shape[-1] == 3\n            new_pts[selection] = pts\n            pts = new_pts\n\n        pts = numpy.broadcast_to(pts, (len(self), 3))\n        return self.with_columns(polars.Series('coords', pts, polars.Array(polars.Float64, 3)))\n\n    def with_velocity(self: HasAtomsT, pts: t.Optional[ArrayLike] = None,\n                      selection: t.Optional[AtomSelection] = None) -&gt; HasAtomsT:\n        \"\"\"\n        Return `self` replaced with the given atomic velocities.\n        If `pts` is not specified, use the already existing velocities or zero.\n        \"\"\"\n        if pts is None:\n            if 'velocity' in self:\n                return self\n            all_pts = numpy.zeros((len(self), 3))\n        else:\n            all_pts = self['velocity'].to_numpy()\n\n        if selection is None:\n            all_pts = pts or all_pts\n        elif pts is not None:\n            selection = _selection_to_numpy(self, selection)\n            all_pts = numpy.require(all_pts, requirements=['WRITEABLE'])\n            pts = numpy.atleast_2d(pts)\n            assert pts.shape[-1] == 3\n            all_pts[selection] = pts\n\n        all_pts = numpy.broadcast_to(all_pts, (len(self), 3))\n        return self.with_columns(polars.Series('velocity', all_pts, polars.Array(polars.Float64, 3)))\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.HasAtoms.columns","title":"<code>columns: t.Sequence[str]</code>  <code>property</code>","text":"<p>Return the columns in <code>self</code>.</p>"},{"location":"api/atoms/#atomlib.atoms.HasAtoms.dtypes","title":"<code>dtypes: t.Sequence[polars.DataType]</code>  <code>property</code>","text":"<p>Return the datatypes in <code>self</code>.</p>"},{"location":"api/atoms/#atomlib.atoms.HasAtoms.schema","title":"<code>schema: SchemaDict</code>  <code>property</code>","text":"<p>Return the schema of <code>self</code>.</p>"},{"location":"api/atoms/#atomlib.atoms.HasAtoms.with_column","title":"<code>with_column = with_columns</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/atoms/#atomlib.atoms.HasAtoms.bbox","title":"<code>bbox = bbox_atoms</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/atoms/#atomlib.atoms.HasAtoms.transform","title":"<code>transform = transform_atoms</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/atoms/#atomlib.atoms.HasAtoms.crop_atoms","title":"<code>crop_atoms = crop</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/atoms/#atomlib.atoms.HasAtoms.unique","title":"<code>unique = deduplicate</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/atoms/#atomlib.atoms.HasAtoms.get_atoms","title":"<code>get_atoms(frame='local')</code>  <code>abstractmethod</code>","text":"<p>Get atoms contained in <code>self</code>. This should be a low cost method.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>@abc.abstractmethod\ndef get_atoms(self, frame: t.Literal['local'] = 'local') -&gt; Atoms:\n    \"\"\"Get atoms contained in `self`. This should be a low cost method.\"\"\"\n    ...\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.HasAtoms.with_atoms","title":"<code>with_atoms(atoms, frame='local')</code>  <code>abstractmethod</code>","text":"Source code in <code>atomlib/atoms.py</code> <pre><code>@abc.abstractmethod\ndef with_atoms(self: HasAtomsT, atoms: HasAtoms, frame: t.Literal['local'] = 'local') -&gt; HasAtomsT:\n    ...\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.HasAtoms.describe","title":"<code>describe(percentiles=(0.25, 0.5, 0.75), *, interpolation='nearest')</code>","text":"<p>Return summary statistics for <code>self</code>.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>@_fwd_frame(polars.DataFrame.describe)\ndef describe(self, percentiles: t.Union[t.Sequence[float], float, None] = (0.25, 0.5, 0.75), *,\n             interpolation: RollingInterpolationMethod = 'nearest') -&gt; polars.DataFrame:\n    \"\"\"Return summary statistics for `self`.\"\"\"\n    ...\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.HasAtoms.with_columns","title":"<code>with_columns(*exprs, **named_exprs)</code>","text":"<p>Return a copy of <code>self</code> with the given columns added.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>@_fwd_frame_map\ndef with_columns(self,\n                 *exprs: t.Union[IntoExpr, t.Iterable[IntoExpr]],\n                 **named_exprs: IntoExpr) -&gt; polars.DataFrame:\n    \"\"\"Return a copy of `self` with the given columns added.\"\"\"\n    return self._get_frame().with_columns(*exprs, **named_exprs)\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.HasAtoms.insert_column","title":"<code>insert_column(index, column)</code>","text":"Source code in <code>atomlib/atoms.py</code> <pre><code>@_fwd_frame_map\ndef insert_column(self, index: int, column: polars.Series) -&gt; polars.DataFrame:\n    return self._get_frame().insert_column(index, column)\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.HasAtoms.get_column","title":"<code>get_column(name)</code>","text":"<p>Get the specified column from <code>self</code>, raising <code>polars.ColumnNotFoundError</code> if it's not present.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>@_fwd_frame(polars.DataFrame.get_column)\ndef get_column(self, name: str) -&gt; polars.Series:\n    \"\"\"Get the specified column from `self`, raising [`polars.ColumnNotFoundError`][polars.exceptions.ColumnNotFoundError] if it's not present.\"\"\"\n    ...\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.HasAtoms.get_columns","title":"<code>get_columns()</code>","text":"<p>Get the specified columns from <code>self</code>, raising <code>polars.ColumnNotFoundError</code> if it's not present.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>@_fwd_frame(polars.DataFrame.get_columns)\ndef get_columns(self) -&gt; t.List[polars.Series]:\n    \"\"\"Get the specified columns from `self`, raising [`polars.ColumnNotFoundError`][polars.exceptions.ColumnNotFoundError] if it's not present.\"\"\"\n    ...\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.HasAtoms.get_column_index","title":"<code>get_column_index(name)</code>","text":"<p>Get the index of a column by name, raising <code>polars.ColumnNotFoundError</code> if it's not present.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>@_fwd_frame(polars.DataFrame.get_column_index)\ndef get_column_index(self, name: str) -&gt; int:\n    \"\"\"Get the index of a column by name, raising [`polars.ColumnNotFoundError`][polars.exceptions.ColumnNotFoundError] if it's not present.\"\"\"\n    ...\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.HasAtoms.group_by","title":"<code>group_by(*by, maintain_order=False, **named_by)</code>","text":"Source code in <code>atomlib/atoms.py</code> <pre><code>@_fwd_frame(polars.DataFrame.group_by)\ndef group_by(self, *by: t.Union[IntoExpr, t.Iterable[IntoExpr]], maintain_order: bool = False,\n             **named_by: IntoExpr) -&gt; polars.dataframe.group_by.GroupBy:\n    ...\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.HasAtoms.pipe","title":"<code>pipe(function, *args, **kwargs)</code>","text":"<p>Apply <code>function</code> to <code>self</code> (in method-call syntax).</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def pipe(self: HasAtomsT, function: t.Callable[Concatenate[HasAtomsT, P], T], *args: P.args, **kwargs: P.kwargs) -&gt; T:\n    \"\"\"Apply `function` to `self` (in method-call syntax).\"\"\"\n    return function(self, *args, **kwargs)\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.HasAtoms.clone","title":"<code>clone()</code>","text":"<p>Return a copy of <code>self</code>.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>@_fwd_frame_map\ndef clone(self) -&gt; polars.DataFrame:\n    \"\"\"Return a copy of `self`.\"\"\"\n    return self._get_frame().clone()\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.HasAtoms.drop","title":"<code>drop(*columns)</code>","text":"<p>Return <code>self</code> with the specified columns removed.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def drop(self, *columns: t.Union[str, t.Iterable[str]]) -&gt; polars.DataFrame:\n    \"\"\"Return `self` with the specified columns removed.\"\"\"\n    return self._get_frame().drop(*columns)\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.HasAtoms.filter","title":"<code>filter(*predicates, **constraints)</code>","text":"<p>Filter <code>self</code>, removing rows which evaluate to <code>False</code>.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def filter(\n    self: HasAtomsT,\n    *predicates: t.Union[None, IntoExprColumn, t.Iterable[IntoExprColumn], bool, t.List[bool], numpy.ndarray],\n    **constraints: t.Any,\n) -&gt; HasAtomsT:\n    \"\"\"Filter `self`, removing rows which evaluate to `False`.\"\"\"\n    # TODO clean up\n    preds_not_none: t.Tuple[t.Union[IntoExprColumn, t.Iterable[IntoExprColumn], bool, t.List[bool], numpy.ndarray], ...]\n    preds_not_none = tuple(filter(lambda p: p is not None, predicates))  # type: ignore\n    if not len(preds_not_none) and not len(constraints):\n        return self\n    return self.with_atoms(Atoms(self._get_frame().filter(*preds_not_none, **constraints), _unchecked=True))\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.HasAtoms.sort","title":"<code>sort(by, *more_by, descending=False, nulls_last=False)</code>","text":"<p>Sort the atoms in <code>self</code> by the given columns/expressions.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>@_fwd_frame_map\ndef sort(\n    self,\n    by: t.Union[IntoExpr, t.Iterable[IntoExpr]],\n    *more_by: IntoExpr,\n    descending: t.Union[bool, t.Sequence[bool]] = False,\n    nulls_last: bool = False,\n) -&gt; polars.DataFrame:\n    \"\"\"\n    Sort the atoms in `self` by the given columns/expressions.\n    \"\"\"\n    return self._get_frame().sort(\n        by, *more_by, descending=descending, nulls_last=nulls_last\n    )\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.HasAtoms.slice","title":"<code>slice(offset, length=None)</code>","text":"<p>Return a slice of the rows in <code>self</code>.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>@_fwd_frame_map\ndef slice(self, offset: int, length: t.Optional[int] = None) -&gt; polars.DataFrame:\n    \"\"\"Return a slice of the rows in `self`.\"\"\"\n    return self._get_frame().slice(offset, length)\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.HasAtoms.head","title":"<code>head(n=5)</code>","text":"<p>Return the first <code>n</code> rows of <code>self</code>.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>@_fwd_frame_map\ndef head(self, n: int = 5) -&gt; polars.DataFrame:\n    \"\"\"Return the first `n` rows of `self`.\"\"\"\n    return self._get_frame().head(n)\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.HasAtoms.tail","title":"<code>tail(n=5)</code>","text":"<p>Return the last <code>n</code> rows of <code>self</code>.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>@_fwd_frame_map\ndef tail(self, n: int = 5) -&gt; polars.DataFrame:\n    \"\"\"Return the last `n` rows of `self`.\"\"\"\n    return self._get_frame().tail(n)\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.HasAtoms.drop_nulls","title":"<code>drop_nulls(subset=None)</code>","text":"<p>Drop rows that contain nulls in any of columns <code>subset</code>.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>@_fwd_frame_map\ndef drop_nulls(self, subset: t.Union[str, t.Collection[str], None] = None) -&gt; polars.DataFrame:\n    \"\"\"Drop rows that contain nulls in any of columns `subset`.\"\"\"\n    return self._get_frame().drop_nulls(subset)\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.HasAtoms.fill_null","title":"<code>fill_null(value=None, strategy=None, limit=None, matches_supertype=True)</code>","text":"<p>Fill null values in <code>self</code>, using the specified value or strategy.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>@_fwd_frame_map\ndef fill_null(\n    self, value: t.Any = None, strategy: t.Optional[FillNullStrategy] = None,\n    limit: t.Optional[int] = None, matches_supertype: bool = True,\n) -&gt; polars.DataFrame:\n    \"\"\"Fill null values in `self`, using the specified value or strategy.\"\"\"\n    return self._get_frame().fill_null(value, strategy, limit, matches_supertype=matches_supertype)\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.HasAtoms.fill_nan","title":"<code>fill_nan(value)</code>","text":"<p>Fill floating-point NaN values in <code>self</code>.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>@_fwd_frame_map\ndef fill_nan(self, value: t.Union[polars.Expr, int, float, None]) -&gt; polars.DataFrame:\n    \"\"\"Fill floating-point NaN values in `self`.\"\"\"\n    return self._get_frame().fill_nan(value)\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.HasAtoms.concat","title":"<code>concat(atoms, *, rechunk=True, how='vertical')</code>  <code>classmethod</code>","text":"<p>Concatenate multiple <code>Atoms</code> together, handling metadata appropriately.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>@classmethod\ndef concat(cls: t.Type[HasAtomsT],\n           atoms: t.Union[HasAtomsT, IntoAtoms, t.Iterable[t.Union[HasAtomsT, IntoAtoms]]], *,\n           rechunk: bool = True, how: ConcatMethod = 'vertical') -&gt; HasAtomsT:\n    \"\"\"Concatenate multiple `Atoms` together, handling metadata appropriately.\"\"\"\n    # this method is tricky. It needs to accept raw Atoms, as well as HasAtoms of the\n    # same type as ``cls``.\n    if _is_abstract(cls):\n        raise TypeError(f\"concat() must be called on a concrete class.\")\n\n    if isinstance(atoms, HasAtoms):\n        atoms = (atoms,)\n    dfs = [a.get_atoms('local').inner if isinstance(a, HasAtoms) else Atoms(t.cast(IntoAtoms, a)).inner for a in atoms]\n    representative = cls._combine_metadata(*(a for a in atoms if isinstance(a, HasAtoms)))\n\n    if len(dfs) == 0:\n        return representative.with_atoms(Atoms.empty(), 'local')\n\n    if how in ('vertical', 'vertical_relaxed'):\n        # get order from first member\n        cols = dfs[0].columns\n        dfs = [df.select(cols) for df in dfs]\n    elif how == 'inner':\n        cols = reduce(operator.and_, (df.schema.keys() for df in dfs))\n        schema = OrderedDict((col, dfs[0].schema[col]) for col in cols)\n        if len(schema) == 0:\n            raise ValueError(f\"Atoms have no columns in common\")\n\n        dfs = [_select_schema(df, schema) for df in dfs]\n        how = 'vertical'\n\n    return representative.with_atoms(Atoms(polars.concat(dfs, rechunk=rechunk, how=how)), 'local')\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.HasAtoms.partition_by","title":"<code>partition_by(by, *more_by, maintain_order=True, include_key=True, as_dict=False)</code>","text":"<p>Group by the given columns and partition into separate dataframes.</p> <p>Return the partitions as a dictionary by specifying <code>as_dict=True</code>.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def partition_by(\n    self: HasAtomsT, by: t.Union[str, t.Sequence[str]], *more_by: str,\n    maintain_order: bool = True, include_key: bool = True, as_dict: bool = False\n) -&gt; t.Union[t.List[HasAtomsT], t.Dict[t.Any, HasAtomsT]]:\n    \"\"\"\n    Group by the given columns and partition into separate dataframes.\n\n    Return the partitions as a dictionary by specifying `as_dict=True`.\n    \"\"\"\n    if as_dict:\n        d = self._get_frame().partition_by(by, *more_by, maintain_order=maintain_order, include_key=include_key, as_dict=True)\n        return {k: self.with_atoms(Atoms(df, _unchecked=True)) for (k, df) in d.items()}\n\n    return [\n        self.with_atoms(Atoms(df, _unchecked=True))\n        for df in self._get_frame().partition_by(by, *more_by, maintain_order=maintain_order, include_key=include_key, as_dict=False)\n    ]\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.HasAtoms.select","title":"<code>select(*exprs, **named_exprs)</code>","text":"<p>Select <code>exprs</code> from <code>self</code>, and return as a <code>polars.DataFrame</code>.</p> <p>Expressions may either be columns or expressions of columns.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>@_fwd_frame(polars.DataFrame.select)\ndef select(\n    self,\n    *exprs: t.Union[IntoExpr, t.Iterable[IntoExpr]],\n    **named_exprs: IntoExpr,\n):\n    \"\"\"\n    Select `exprs` from `self`, and return as a `polars.DataFrame`.\n\n    Expressions may either be columns or expressions of columns.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.HasAtoms.select_schema","title":"<code>select_schema(schema)</code>","text":"<p>Select columns from <code>self</code> and cast to the given schema. Raises <code>TypeError</code> if a column is not found or if it can't be cast.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def select_schema(self, schema: SchemaDict) -&gt; polars.DataFrame:\n    \"\"\"\n    Select columns from `self` and cast to the given schema.\n    Raises `TypeError` if a column is not found or if it can't be cast.\n    \"\"\"\n    return _select_schema(self, schema)\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.HasAtoms.select_props","title":"<code>select_props(*exprs, **named_exprs)</code>","text":"<p>Select <code>exprs</code> from <code>self</code>, while keeping required columns.</p> <p>Returns a HasAtoms.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def select_props(\n    self: HasAtomsT,\n    *exprs: t.Union[IntoExpr, t.Iterable[IntoExpr]],\n    **named_exprs: IntoExpr\n) -&gt; HasAtomsT:\n    \"\"\"\n    Select `exprs` from `self`, while keeping required columns.\n\n    Returns a HasAtoms.\n    \"\"\"\n    props = self._get_frame().lazy().select(*exprs, **named_exprs).drop(_REQUIRED_COLUMNS).collect(_eager=True)\n    return self.with_atoms(\n        Atoms(self._get_frame().select(_REQUIRED_COLUMNS).hstack(props), _unchecked=False)\n    )\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.HasAtoms.try_select","title":"<code>try_select(*exprs, **named_exprs)</code>","text":"<p>Try to select <code>exprs</code> from <code>self</code>, and return as a <code>DataFrame</code>.</p> <p>Expressions may either be columns or expressions of columns. Return <code>None</code> if any columns are missing.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def try_select(\n    self,\n    *exprs: t.Union[IntoExpr, t.Iterable[IntoExpr]],\n    **named_exprs: IntoExpr,\n) -&gt; t.Optional[polars.DataFrame]:\n    \"\"\"\n    Try to select `exprs` from `self`, and return as a `DataFrame`.\n\n    Expressions may either be columns or expressions of columns.\n    Return `None` if any columns are missing.\n    \"\"\"\n    try:\n        return self._get_frame().select(*exprs, **named_exprs)\n    except polars.ColumnNotFoundError:\n        return None\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.HasAtoms.try_get_column","title":"<code>try_get_column(name)</code>","text":"<p>Try to get a column from <code>self</code>, returning <code>None</code> if it doesn't exist.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def try_get_column(self, name: str) -&gt; t.Optional[polars.Series]:\n    \"\"\"Try to get a column from `self`, returning `None` if it doesn't exist.\"\"\"\n    try:\n        return self.get_column(name)\n    except polars.ColumnNotFoundError:\n        return None\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.HasAtoms.assert_equal","title":"<code>assert_equal(other)</code>","text":"Source code in <code>atomlib/atoms.py</code> <pre><code>def assert_equal(self, other: t.Any):\n    assert isinstance(other, HasAtoms)\n    assert dict(self.schema) == dict(other.schema)\n    for col in self.schema.keys():\n        polars.testing.assert_series_equal(self[col], other[col], check_names=False, rtol=1e-3, atol=1e-8)\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.HasAtoms.bbox_atoms","title":"<code>bbox_atoms()</code>","text":"<p>Return the bounding box of all the atoms in <code>self</code>.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def bbox_atoms(self) -&gt; BBox3D:\n    \"\"\"Return the bounding box of all the atoms in ``self``.\"\"\"\n    return BBox3D.from_pts(self.coords())\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.HasAtoms.transform_atoms","title":"<code>transform_atoms(transform, selection=None, *, transform_velocities=False)</code>","text":"<p>Transform the atoms in <code>self</code> by <code>transform</code>. If <code>selection</code> is given, only transform the atoms in <code>selection</code>.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def transform_atoms(self: HasAtomsT, transform: IntoTransform3D, selection: t.Optional[AtomSelection] = None, *, transform_velocities: bool = False) -&gt; HasAtomsT:\n    \"\"\"\n    Transform the atoms in `self` by `transform`.\n    If `selection` is given, only transform the atoms in `selection`.\n    \"\"\"\n    transform = Transform3D.make(transform)\n    selection = _selection_to_numpy(self, selection)\n    transformed = self.with_coords(Transform3D.make(transform) @ self.coords(selection), selection)\n    # try to transform velocities as well\n    if transform_velocities and (velocities := self.velocities(selection)) is not None:\n        return transformed.with_velocity(transform.transform_vec(velocities), selection)\n    return transformed\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.HasAtoms.round_near_zero","title":"<code>round_near_zero(tol=1e-14)</code>","text":"<p>Round atom position values near zero to zero.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def round_near_zero(self: HasAtomsT, tol: float = 1e-14) -&gt; HasAtomsT:\n    \"\"\"\n    Round atom position values near zero to zero.\n    \"\"\"\n    return self.with_columns(coords=polars.concat_list(\n        polars.when(_coord_expr(col).abs() &gt;= tol).then(_coord_expr(col)).otherwise(polars.lit(0.))\n        for col in range(3)\n    ).list.to_array(3))\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.HasAtoms.crop","title":"<code>crop(x_min=-numpy.inf, x_max=numpy.inf, y_min=-numpy.inf, y_max=numpy.inf, z_min=-numpy.inf, z_max=numpy.inf)</code>","text":"<p>Crop, removing all atoms outside of the specified region, inclusive.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def crop(self: HasAtomsT, x_min: float = -numpy.inf, x_max: float = numpy.inf,\n         y_min: float = -numpy.inf, y_max: float = numpy.inf,\n         z_min: float = -numpy.inf, z_max: float = numpy.inf) -&gt; HasAtomsT:\n    \"\"\"\n    Crop, removing all atoms outside of the specified region, inclusive.\n    \"\"\"\n\n    return self.filter(\n        self.x().is_between(x_min, x_max, closed='both'),\n        self.y().is_between(y_min, y_max, closed='both'),\n        self.z().is_between(z_min, z_max, closed='both'),\n    )\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.HasAtoms.deduplicate","title":"<code>deduplicate(tol=0.001, subset=('x', 'y', 'z', 'symbol'), keep='first', maintain_order=True)</code>","text":"<p>De-duplicate atoms in <code>self</code>. Atoms of the same <code>symbol</code> that are closer than <code>tolerance</code> to each other (by Euclidian distance) will be removed, leaving only the atom specified by <code>keep</code> (defaults to the first atom).</p> <p>If <code>subset</code> is specified, only those columns will be included while assessing duplicates. Floating point columns other than 'x', 'y', and 'z' will not by toleranced.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def deduplicate(self: HasAtomsT, tol: float = 1e-3, subset: t.Iterable[str] = ('x', 'y', 'z', 'symbol'),\n                keep: UniqueKeepStrategy = 'first', maintain_order: bool = True) -&gt; HasAtomsT:\n    \"\"\"\n    De-duplicate atoms in `self`. Atoms of the same `symbol` that are closer than `tolerance`\n    to each other (by Euclidian distance) will be removed, leaving only the atom specified by\n    `keep` (defaults to the first atom).\n\n    If `subset` is specified, only those columns will be included while assessing duplicates.\n    Floating point columns other than 'x', 'y', and 'z' will not by toleranced.\n    \"\"\"\n    import scipy.spatial\n\n    cols = set((subset,) if isinstance(subset, str) else subset)\n\n    indices = numpy.arange(len(self))\n\n    spatial_cols = cols.intersection(('x', 'y', 'z'))\n    cols -= spatial_cols\n    if len(spatial_cols) &gt; 0:\n        coords = self.select([_coord_expr(col).alias(col) for col in spatial_cols]).to_numpy()\n        tree = scipy.spatial.KDTree(coords)\n\n        # TODO This is a bad algorithm\n        while True:\n            changed = False\n            for (i, j) in tree.query_pairs(tol, 2.):\n                # whenever we encounter a pair, ensure their index matches\n                i_i, i_j = indices[[i, j]]\n                if i_i != i_j:\n                    indices[i] = indices[j] = min(i_i, i_j)\n                    changed = True\n            if not changed:\n                break\n\n        self = self.with_column(polars.Series('_unique_pts', indices))\n        cols.add('_unique_pts')\n\n    frame = self._get_frame().unique(subset=list(cols), keep=keep, maintain_order=maintain_order)\n    if len(spatial_cols) &gt; 0:\n        frame = frame.drop('_unique_pts')\n\n    return self.with_atoms(Atoms(frame, _unchecked=True))\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.HasAtoms.with_bounds","title":"<code>with_bounds(cell_size=None, cell_origin=None)</code>","text":"<p>Return a periodic cell with the given orthogonal cell dimensions.</p> <p>If cell_size is not specified, it will be assumed (and may be incorrect).</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def with_bounds(self, cell_size: t.Optional[VecLike] = None, cell_origin: t.Optional[VecLike] = None) -&gt; 'AtomCell':\n    \"\"\"\n    Return a periodic cell with the given orthogonal cell dimensions.\n\n    If cell_size is not specified, it will be assumed (and may be incorrect).\n    \"\"\"\n    # TODO: test this\n    from .atomcell import AtomCell\n\n    if cell_size is None:\n        warnings.warn(\"Cell boundary unknown. Defaulting to cell BBox\")\n        cell_size = self.bbox().size\n        cell_origin = self.bbox().min\n\n    # TODO test this origin code\n    cell = Cell.from_unit_cell(cell_size)\n    if cell_origin is not None:\n        cell = cell.transform_cell(AffineTransform3D.translate(to_vec3(cell_origin)))\n\n    return AtomCell(self.get_atoms(), cell, frame='local')\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.HasAtoms.coords","title":"<code>coords(selection=None, *, frame='local')</code>","text":"<p>Return a <code>(N, 3)</code> ndarray of atom coordinates (dtype <code>numpy.float64</code>).</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def coords(self, selection: t.Optional[AtomSelection] = None, *, frame: t.Literal['local'] = 'local') -&gt; NDArray[numpy.float64]:\n    \"\"\"Return a `(N, 3)` ndarray of atom coordinates (dtype [`numpy.float64`][numpy.float64]).\"\"\"\n    df = self if selection is None else self.filter(_selection_to_expr(self, selection))\n    return df.get_column('coords').to_numpy().astype(numpy.float64)\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.HasAtoms.x","title":"<code>x()</code>","text":"Source code in <code>atomlib/atoms.py</code> <pre><code>def x(self) -&gt; polars.Expr:\n    return polars.col('coords').arr.get(0).alias('x')\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.HasAtoms.y","title":"<code>y()</code>","text":"Source code in <code>atomlib/atoms.py</code> <pre><code>def y(self) -&gt; polars.Expr:\n    return polars.col('coords').arr.get(1).alias('y')\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.HasAtoms.z","title":"<code>z()</code>","text":"Source code in <code>atomlib/atoms.py</code> <pre><code>def z(self) -&gt; polars.Expr:\n    return polars.col('coords').arr.get(2).alias('z')\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.HasAtoms.velocities","title":"<code>velocities(selection=None)</code>","text":"<p>Return a <code>(N, 3)</code> ndarray of atom velocities (dtype <code>numpy.float64</code>).</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def velocities(self, selection: t.Optional[AtomSelection] = None) -&gt; t.Optional[NDArray[numpy.float64]]:\n    \"\"\"Return a `(N, 3)` ndarray of atom velocities (dtype [`numpy.float64`][numpy.float64]).\"\"\"\n    if 'velocity' not in self:\n        return None\n\n    df = self if selection is None else self.filter(_selection_to_expr(self, selection))\n    return df.get_column('velocity').to_numpy().astype(numpy.float64)\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.HasAtoms.types","title":"<code>types()</code>","text":"<p>Returns a <code>Series</code> of atom types (dtype <code>polars.Int32</code>).</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def types(self) -&gt; t.Optional[polars.Series]:\n    \"\"\"\n    Returns a [`Series`][polars.Series] of atom types (dtype [`polars.Int32`][polars.Int32]).\n\n    [polars.Series]: https://docs.pola.rs/py-polars/html/reference/series/index.html\n    \"\"\"\n    return self.try_get_column('type')\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.HasAtoms.masses","title":"<code>masses()</code>","text":"<p>Returns a <code>Series</code> of atom masses (dtype <code>polars.Float32</code>).</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def masses(self) -&gt; t.Optional[polars.Series]:\n    \"\"\"\n    Returns a [`Series`][polars.Series] of atom masses (dtype [`polars.Float32`][polars.Float32]).\n\n    [polars.Series]: https://docs.pola.rs/py-polars/html/reference/series/index.html\n    \"\"\"\n    return self.try_get_column('mass')\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.HasAtoms.add_atom","title":"<code>add_atom(elem, /, x, y=None, z=None, **kwargs)</code>","text":"<p>Return a copy of <code>self</code> with an extra atom.</p> <p>By default, all extra columns present in <code>self</code> must be specified as <code>**kwargs</code>.</p> <p>Try to avoid calling this in a loop (Use <code>HasAtoms.concat</code> instead).</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def add_atom(self: HasAtomsT, elem: t.Union[int, str], /,\n             x: t.Union[ArrayLike, float],\n             y: t.Optional[float] = None,\n             z: t.Optional[float] = None,\n             **kwargs: t.Any) -&gt; HasAtomsT:\n    \"\"\"\n    Return a copy of `self` with an extra atom.\n\n    By default, all extra columns present in `self` must be specified as `**kwargs`.\n\n    Try to avoid calling this in a loop (Use [`HasAtoms.concat`][atomlib.atoms.HasAtoms.concat] instead).\n    \"\"\"\n    if isinstance(elem, int):\n        kwargs.update(elem=elem)\n    else:\n        kwargs.update(symbol=elem)\n    if hasattr(x, '__len__') and len(x) &gt; 1:  # type: ignore\n        (x, y, z) = to_vec3(x)\n    elif y is None or z is None:\n        raise ValueError(f\"Must specify vector of positions or x, y, &amp; z.\")\n\n    sym = get_sym(elem) if isinstance(elem, int) else elem\n    d: t.Dict[str, t.Any] = {'x': x, 'y': y, 'z': z, 'symbol': sym, **kwargs}\n    return self.concat(\n        (self, Atoms(d).select_schema(self.schema)),\n        how='vertical'\n    )\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.HasAtoms.pos","title":"<code>pos(x=None, y=None, z=None, *, tol=1e-06, **kwargs)</code>","text":"<p>Select all atoms at a given position.</p> <p>Formally, returns all atoms within a cube of radius <code>tol</code> centered at <code>(x,y,z)</code>, exclusive of the cube's surface.</p> <p>Additional parameters given as <code>kwargs</code> will be checked as additional parameters (with strict equality).</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def pos(self,\n        x: t.Union[t.Sequence[t.Optional[float]], float, None] = None,\n        y: t.Optional[float] = None, z: t.Optional[float] = None, *,\n        tol: float = 1e-6, **kwargs: t.Any) -&gt; polars.Expr:\n    \"\"\"\n    Select all atoms at a given position.\n\n    Formally, returns all atoms within a cube of radius ``tol``\n    centered at ``(x,y,z)``, exclusive of the cube's surface.\n\n    Additional parameters given as ``kwargs`` will be checked\n    as additional parameters (with strict equality).\n    \"\"\"\n\n    if isinstance(x, t.Sequence):\n        (x, y, z) = x\n\n    tol = abs(float(tol))\n    selection = polars.lit(True)\n    if x is not None:\n        selection &amp;= self.x().is_between(x - tol, x + tol, closed='none')\n    if y is not None:\n        selection &amp;= self.y().is_between(y - tol, y + tol, closed='none')\n    if z is not None:\n        selection &amp;= self.z().is_between(z - tol, z + tol, closed='none')\n    for (col, val) in kwargs.items():\n        selection &amp;= (polars.col(col) == val)\n\n    return selection\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.HasAtoms.with_index","title":"<code>with_index(index=None)</code>","text":"<p>Returns <code>self</code> with a row index added in column 'i' (dtype <code>polars.Int64</code>). If <code>index</code> is not specified, defaults to an existing index or a new index.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def with_index(self: HasAtomsT, index: t.Optional[AtomValues] = None) -&gt; HasAtomsT:\n    \"\"\"\n    Returns `self` with a row index added in column 'i' (dtype [`polars.Int64`][polars.Int64]).\n    If `index` is not specified, defaults to an existing index or a new index.\n    \"\"\"\n    if index is None and 'i' in self.columns:\n        return self\n    if index is None:\n        index = numpy.arange(len(self), dtype=numpy.int64)\n    return self.with_column(_values_to_expr(self, index, polars.Int64).alias('i'))\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.HasAtoms.with_wobble","title":"<code>with_wobble(wobble=None)</code>","text":"<p>Return <code>self</code> with the given displacements in column 'wobble' (dtype <code>polars.Float64</code>). If <code>wobble</code> is not specified, defaults to the already-existing wobbles or 0.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def with_wobble(self: HasAtomsT, wobble: t.Optional[AtomValues] = None) -&gt; HasAtomsT:\n    \"\"\"\n    Return `self` with the given displacements in column 'wobble' (dtype [`polars.Float64`][polars.Float64]).\n    If `wobble` is not specified, defaults to the already-existing wobbles or 0.\n    \"\"\"\n    if wobble is None and 'wobble' in self.columns:\n        return self\n    wobble = 0. if wobble is None else wobble\n    return self.with_column(_values_to_expr(self, wobble, polars.Float64).alias('wobble'))\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.HasAtoms.with_occupancy","title":"<code>with_occupancy(frac_occupancy=None)</code>","text":"<p>Return self with the given fractional occupancies. If <code>frac_occupancy</code> is not specified, defaults to the already-existing occupancies or 1.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def with_occupancy(self: HasAtomsT, frac_occupancy: t.Optional[AtomValues] = None) -&gt; HasAtomsT:\n    \"\"\"\n    Return self with the given fractional occupancies. If `frac_occupancy` is not specified,\n    defaults to the already-existing occupancies or 1.\n    \"\"\"\n    if frac_occupancy is None and 'frac_occupancy' in self.columns:\n        return self\n    frac_occupancy = 1. if frac_occupancy is None else frac_occupancy\n    return self.with_column(_values_to_expr(self, frac_occupancy, polars.Float64).alias('frac_occupancy'))\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.HasAtoms.apply_wobble","title":"<code>apply_wobble(rng=None)</code>","text":"<p>Displace the atoms in <code>self</code> by the amount in the <code>wobble</code> column. <code>wobble</code> is interpretated as a mean-squared displacement, which is distributed equally over each axis.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def apply_wobble(self: HasAtomsT, rng: t.Union[numpy.random.Generator, int, None] = None) -&gt; HasAtomsT:\n    \"\"\"\n    Displace the atoms in `self` by the amount in the `wobble` column.\n    `wobble` is interpretated as a mean-squared displacement, which is distributed\n    equally over each axis.\n    \"\"\"\n    if 'wobble' not in self.columns:\n        return self\n    rng = numpy.random.default_rng(seed=rng)\n\n    stddev = self.select((polars.col('wobble') / 3.).sqrt()).to_series().to_numpy()\n    coords = self.coords()\n    coords += stddev[:, None] * rng.standard_normal(coords.shape)\n    return self.with_coords(coords)\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.HasAtoms.apply_occupancy","title":"<code>apply_occupancy(rng=None)</code>","text":"<p>For each atom in <code>self</code>, use its <code>frac_occupancy</code> to randomly decide whether to remove it.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def apply_occupancy(self: HasAtomsT, rng: t.Union[numpy.random.Generator, int, None] = None) -&gt; HasAtomsT:\n    \"\"\"\n    For each atom in `self`, use its `frac_occupancy` to randomly decide whether to remove it.\n    \"\"\"\n    if 'frac_occupancy' not in self.columns:\n        return self\n    rng = numpy.random.default_rng(seed=rng)\n\n    frac = self.select('frac_occupancy').to_series().to_numpy()\n    choice = rng.binomial(1, frac).astype(numpy.bool_)\n    return self.filter(polars.lit(choice))\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.HasAtoms.with_type","title":"<code>with_type(types=None)</code>","text":"<p>Return <code>self</code> with the given atom types in column 'type'. If <code>types</code> is not specified, use the already existing types or auto-assign them.</p> <p>When auto-assigning, each symbol is given a unique value, case-sensitive. Values are assigned from lowest atomic number to highest. For instance: <code>[\"Ag+\", \"Na\", \"H\", \"Ag\"]</code> =&gt; <code>[3, 11, 1, 2]</code></p> Source code in <code>atomlib/atoms.py</code> <pre><code>def with_type(self: HasAtomsT, types: t.Optional[AtomValues] = None) -&gt; HasAtomsT:\n    \"\"\"\n    Return `self` with the given atom types in column 'type'.\n    If `types` is not specified, use the already existing types or auto-assign them.\n\n    When auto-assigning, each symbol is given a unique value, case-sensitive.\n    Values are assigned from lowest atomic number to highest.\n    For instance: `[\"Ag+\", \"Na\", \"H\", \"Ag\"]` =&gt; `[3, 11, 1, 2]`\n    \"\"\"\n    if types is not None:\n        return self.with_columns(type=_values_to_expr(self, types, polars.Int32))\n    if 'type' in self.columns:\n        return self\n\n    unique = Atoms(self._get_frame().unique(maintain_order=False, subset=['elem', 'symbol']).sort(['elem', 'symbol']), _unchecked=True)\n    new = self.with_column(polars.Series('type', values=numpy.zeros(len(self)), dtype=polars.Int32))\n\n    logging.warning(\"Auto-assigning element types\")\n    for (i, (elem, sym)) in enumerate(unique.select(('elem', 'symbol')).rows()):\n        print(f\"Assigning type {i+1} to element '{sym}'\")\n        new = new.with_column(polars.when((polars.col('elem') == elem) &amp; (polars.col('symbol') == sym))\n                                    .then(polars.lit(i+1))\n                                    .otherwise(polars.col('type'))\n                                    .alias('type'))\n\n    assert (new.get_column('type') == 0).sum() == 0\n    return new\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.HasAtoms.with_mass","title":"<code>with_mass(mass=None)</code>","text":"<p>Return <code>self</code> with the given atom masses in column 'mass'. If <code>mass</code> is not specified, use the already existing masses or auto-assign them.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def with_mass(self: HasAtomsT, mass: t.Optional[ArrayLike] = None) -&gt; HasAtomsT:\n    \"\"\"\n    Return `self` with the given atom masses in column 'mass'.\n    If `mass` is not specified, use the already existing masses or auto-assign them.\n    \"\"\"\n    if mass is not None:\n        return self.with_column(_values_to_expr(self, mass, polars.Float32).alias('mass'))\n    if 'mass' in self.columns:\n        return self\n\n    unique_elems = self.get_column('elem').unique()\n    new = self.with_column(polars.Series('mass', values=numpy.zeros(len(self)), dtype=polars.Float32))\n\n    logging.warning(\"Auto-assigning element masses\")\n    for elem in unique_elems:\n        new = new.with_column(polars.when(polars.col('elem') == elem)\n                                    .then(polars.lit(get_mass(elem)))\n                                    .otherwise(polars.col('mass'))\n                                    .alias('mass'))\n\n    assert (new.get_column('mass').abs() &lt; 1e-10).sum() == 0\n    return new\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.HasAtoms.with_symbol","title":"<code>with_symbol(symbols, selection=None)</code>","text":"<p>Return <code>self</code> with the given atomic symbols.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def with_symbol(self: HasAtomsT, symbols: ArrayLike, selection: t.Optional[AtomSelection] = None) -&gt; HasAtomsT:\n    \"\"\"\n    Return `self` with the given atomic symbols.\n    \"\"\"\n    if selection is not None:\n        selection = _selection_to_numpy(self, selection)\n        new_symbols = self.get_column('symbol')\n        new_symbols[selection] = polars.Series(list(numpy.broadcast_to(symbols, len(selection))), dtype=polars.Utf8)\n        symbols = new_symbols\n\n    # TODO better cast here\n    symbols = polars.Series('symbol', list(numpy.broadcast_to(symbols, len(self))), dtype=polars.Utf8)\n    return self.with_columns((symbols, get_elem(symbols)))\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.HasAtoms.with_coords","title":"<code>with_coords(pts, selection=None, *, frame='local')</code>","text":"<p>Return <code>self</code> replaced with the given atomic positions.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def with_coords(self: HasAtomsT, pts: ArrayLike, selection: t.Optional[AtomSelection] = None, *, frame: t.Literal['local'] = 'local') -&gt; HasAtomsT:\n    \"\"\"\n    Return `self` replaced with the given atomic positions.\n    \"\"\"\n    if selection is not None:\n        selection = _selection_to_numpy(self, selection)\n        new_pts = self.coords()\n        pts = numpy.atleast_2d(pts)\n        assert pts.shape[-1] == 3\n        new_pts[selection] = pts\n        pts = new_pts\n\n    pts = numpy.broadcast_to(pts, (len(self), 3))\n    return self.with_columns(polars.Series('coords', pts, polars.Array(polars.Float64, 3)))\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.HasAtoms.with_velocity","title":"<code>with_velocity(pts=None, selection=None)</code>","text":"<p>Return <code>self</code> replaced with the given atomic velocities. If <code>pts</code> is not specified, use the already existing velocities or zero.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def with_velocity(self: HasAtomsT, pts: t.Optional[ArrayLike] = None,\n                  selection: t.Optional[AtomSelection] = None) -&gt; HasAtomsT:\n    \"\"\"\n    Return `self` replaced with the given atomic velocities.\n    If `pts` is not specified, use the already existing velocities or zero.\n    \"\"\"\n    if pts is None:\n        if 'velocity' in self:\n            return self\n        all_pts = numpy.zeros((len(self), 3))\n    else:\n        all_pts = self['velocity'].to_numpy()\n\n    if selection is None:\n        all_pts = pts or all_pts\n    elif pts is not None:\n        selection = _selection_to_numpy(self, selection)\n        all_pts = numpy.require(all_pts, requirements=['WRITEABLE'])\n        pts = numpy.atleast_2d(pts)\n        assert pts.shape[-1] == 3\n        all_pts[selection] = pts\n\n    all_pts = numpy.broadcast_to(all_pts, (len(self), 3))\n    return self.with_columns(polars.Series('velocity', all_pts, polars.Array(polars.Float64, 3)))\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.Atoms","title":"<code>Atoms</code>","text":"<p>             Bases: <code>AtomsIOMixin</code>, <code>HasAtoms</code></p> <p>A collection of atoms, absent any implied coordinate system. Implemented as a wrapper around a <code>polars.DataFrame</code>.</p> <p>Must contain the following columns:</p> <ul> <li>coords: array of [x, y, z] positions, float</li> <li>elem: atomic number, int</li> <li>symbol: atomic symbol (may contain charges)</li> </ul> <p>In addition, it commonly contains the following columns:</p> <ul> <li>i: Initial atom number</li> <li>wobble: Isotropic Debye-Waller mean-squared deviation ( = B*3/8pi^2, dimensions of [Length^2]) <li>frac_occupancy: Fractional occupancy, [0., 1.]</li> <li>mass: Atomic mass, in g/mol (approx. Da)</li> <li>velocity: array of [x, y, z] velocities, float, dimensions of length/time</li> <li>type: Numeric atom type, as used by programs like LAMMPS</li> Source code in <code>atomlib/atoms.py</code> <pre><code>class Atoms(AtomsIOMixin, HasAtoms):\n    \"\"\"\n    A collection of atoms, absent any implied coordinate system.\n    Implemented as a wrapper around a [`polars.DataFrame`][polars.DataFrame].\n\n    Must contain the following columns:\n\n    - coords: array of [x, y, z] positions, float\n    - elem: atomic number, int\n    - symbol: atomic symbol (may contain charges)\n\n    In addition, it commonly contains the following columns:\n\n    - i: Initial atom number\n    - wobble: Isotropic Debye-Waller mean-squared deviation (&lt;u^2&gt; = B*3/8pi^2, dimensions of [Length^2])\n    - frac_occupancy: Fractional occupancy, [0., 1.]\n    - mass: Atomic mass, in g/mol (approx. Da)\n    - velocity: array of [x, y, z] velocities, float, dimensions of length/time\n    - type: Numeric atom type, as used by programs like LAMMPS\n\n    [polars.DataFrame]: https://docs.pola.rs/py-polars/html/reference/dataframe/index.html\n    \"\"\"\n\n    def __init__(self, data: t.Optional[IntoAtoms] = None, columns: t.Optional[t.Sequence[str]] = None,\n                 orient: t.Union[t.Literal['row'], t.Literal['col'], None] = None,\n                 _unchecked: bool = False):\n        self._bbox: t.Optional[BBox3D] = None\n        self.inner: polars.DataFrame\n\n        if data is None:\n            assert columns is None\n            self.inner = polars.DataFrame([\n                polars.Series('coords', (), dtype=polars.Array(polars.Float64, 3)),\n                polars.Series('elem', (), dtype=polars.Int8),\n                polars.Series('symbol', (), dtype=polars.Utf8),\n            ])\n        elif isinstance(data, polars.DataFrame):\n            self.inner = data\n        elif isinstance(data, Atoms):\n            self.inner = data.inner\n            _unchecked = True\n        else:\n            self.inner = polars.DataFrame(data, schema=columns, orient=orient)\n\n        if not _unchecked:\n            # stack ('x', 'y', 'z') -&gt; 'coords'\n            self.inner = _with_columns_stacked(self.inner, ('x', 'y', 'z'), 'coords')\n            self.inner = _with_columns_stacked(self.inner, ('v_x', 'v_y', 'v_z'), 'velocity')\n\n            missing: t.Tuple[str, ...] = tuple(set(['symbol', 'elem']) - set(self.columns))\n            if len(missing) &gt; 1:\n                raise ValueError(\"'Atoms' missing columns 'elem' and/or 'symbol'.\")\n            # fill 'symbol' from 'elem' or vice-versa\n            if missing == ('symbol',):\n                self.inner = self.inner.with_columns(get_sym(self.inner['elem']))\n            elif missing == ('elem',):\n                # by convention, add before 'symbol' column\n                self.inner = self.inner.insert_column(\n                    self.inner.get_column_index('symbol'),\n                    get_elem(self.inner['symbol']),\n                )\n\n            # cast to standard dtypes\n            self.inner = self.inner.with_columns([\n                self.inner[col].cast(dtype)\n                for (col, dtype) in _COLUMN_DTYPES.items() if col in self.inner\n            ])\n\n            self._validate_atoms()\n\n    @staticmethod\n    def empty() -&gt; Atoms:\n        \"\"\"\n        Return an empty Atoms with only the mandatory columns.\n        \"\"\"\n        return Atoms()\n\n    def _validate_atoms(self):\n        missing = [col for col in _REQUIRED_COLUMNS if col not in self.columns]\n        if len(missing):\n            raise ValueError(f\"'Atoms' missing column(s) {', '.join(map(repr, missing))}\")\n\n    def get_atoms(self, frame: t.Literal['local'] = 'local') -&gt; Atoms:\n        if frame != 'local':\n            raise ValueError(f\"Atoms without a cell only support the 'local' coordinate frame, not '{frame}'.\")\n        return self\n\n    def with_atoms(self, atoms: HasAtoms, frame: t.Literal['local'] = 'local') -&gt; Atoms:\n        if frame != 'local':\n            raise ValueError(f\"Atoms without a cell only support the 'local' coordinate frame, not '{frame}'.\")\n        return atoms.get_atoms()\n\n    @classmethod\n    def _combine_metadata(cls: t.Type[Atoms], *atoms: HasAtoms) -&gt; Atoms:\n        return cls.empty()\n\n    def bbox(self) -&gt; BBox3D:\n        \"\"\"Return the bounding box of all the points in `self`.\"\"\"\n        if self._bbox is None:\n            self._bbox = BBox3D.from_pts(self.coords())\n\n        return self._bbox\n\n    def __str__(self) -&gt; str:\n        return f\"Atoms, {self.inner!s}\"\n\n    def __repr__(self) -&gt; str:\n        buf = StringIO()\n        buf.write(\"Atoms([\\n\")\n\n        for series in self.inner.to_dict().values():\n            buf.write(f\"    Series({series.name!r}, {series.to_list()!r}, dtype={series.dtype!r}),\\n\")\n\n        buf.write(\"])\\n\")\n        return buf.getvalue()\n\n    def _repr_pretty_(self, p, cycle: bool) -&gt; None:\n        p.text('Atoms(...)') if cycle else p.text(str(self))\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.Atoms.columns","title":"<code>columns: t.Sequence[str]</code>  <code>property</code>","text":"<p>Return the columns in <code>self</code>.</p>"},{"location":"api/atoms/#atomlib.atoms.Atoms.dtypes","title":"<code>dtypes: t.Sequence[polars.DataType]</code>  <code>property</code>","text":"<p>Return the datatypes in <code>self</code>.</p>"},{"location":"api/atoms/#atomlib.atoms.Atoms.schema","title":"<code>schema: SchemaDict</code>  <code>property</code>","text":"<p>Return the schema of <code>self</code>.</p>"},{"location":"api/atoms/#atomlib.atoms.Atoms.with_column","title":"<code>with_column = with_columns</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/atoms/#atomlib.atoms.Atoms.transform","title":"<code>transform = transform_atoms</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/atoms/#atomlib.atoms.Atoms.crop_atoms","title":"<code>crop_atoms = crop</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/atoms/#atomlib.atoms.Atoms.unique","title":"<code>unique = deduplicate</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/atoms/#atomlib.atoms.Atoms.inner","title":"<code>inner: polars.DataFrame</code>  <code>instance-attribute</code>","text":""},{"location":"api/atoms/#atomlib.atoms.Atoms.describe","title":"<code>describe(percentiles=(0.25, 0.5, 0.75), *, interpolation='nearest')</code>","text":"<p>Return summary statistics for <code>self</code>.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>@_fwd_frame(polars.DataFrame.describe)\ndef describe(self, percentiles: t.Union[t.Sequence[float], float, None] = (0.25, 0.5, 0.75), *,\n             interpolation: RollingInterpolationMethod = 'nearest') -&gt; polars.DataFrame:\n    \"\"\"Return summary statistics for `self`.\"\"\"\n    ...\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.Atoms.with_columns","title":"<code>with_columns(*exprs, **named_exprs)</code>","text":"<p>Return a copy of <code>self</code> with the given columns added.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>@_fwd_frame_map\ndef with_columns(self,\n                 *exprs: t.Union[IntoExpr, t.Iterable[IntoExpr]],\n                 **named_exprs: IntoExpr) -&gt; polars.DataFrame:\n    \"\"\"Return a copy of `self` with the given columns added.\"\"\"\n    return self._get_frame().with_columns(*exprs, **named_exprs)\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.Atoms.insert_column","title":"<code>insert_column(index, column)</code>","text":"Source code in <code>atomlib/atoms.py</code> <pre><code>@_fwd_frame_map\ndef insert_column(self, index: int, column: polars.Series) -&gt; polars.DataFrame:\n    return self._get_frame().insert_column(index, column)\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.Atoms.get_column","title":"<code>get_column(name)</code>","text":"<p>Get the specified column from <code>self</code>, raising <code>polars.ColumnNotFoundError</code> if it's not present.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>@_fwd_frame(polars.DataFrame.get_column)\ndef get_column(self, name: str) -&gt; polars.Series:\n    \"\"\"Get the specified column from `self`, raising [`polars.ColumnNotFoundError`][polars.exceptions.ColumnNotFoundError] if it's not present.\"\"\"\n    ...\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.Atoms.get_columns","title":"<code>get_columns()</code>","text":"<p>Get the specified columns from <code>self</code>, raising <code>polars.ColumnNotFoundError</code> if it's not present.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>@_fwd_frame(polars.DataFrame.get_columns)\ndef get_columns(self) -&gt; t.List[polars.Series]:\n    \"\"\"Get the specified columns from `self`, raising [`polars.ColumnNotFoundError`][polars.exceptions.ColumnNotFoundError] if it's not present.\"\"\"\n    ...\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.Atoms.get_column_index","title":"<code>get_column_index(name)</code>","text":"<p>Get the index of a column by name, raising <code>polars.ColumnNotFoundError</code> if it's not present.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>@_fwd_frame(polars.DataFrame.get_column_index)\ndef get_column_index(self, name: str) -&gt; int:\n    \"\"\"Get the index of a column by name, raising [`polars.ColumnNotFoundError`][polars.exceptions.ColumnNotFoundError] if it's not present.\"\"\"\n    ...\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.Atoms.group_by","title":"<code>group_by(*by, maintain_order=False, **named_by)</code>","text":"Source code in <code>atomlib/atoms.py</code> <pre><code>@_fwd_frame(polars.DataFrame.group_by)\ndef group_by(self, *by: t.Union[IntoExpr, t.Iterable[IntoExpr]], maintain_order: bool = False,\n             **named_by: IntoExpr) -&gt; polars.dataframe.group_by.GroupBy:\n    ...\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.Atoms.pipe","title":"<code>pipe(function, *args, **kwargs)</code>","text":"<p>Apply <code>function</code> to <code>self</code> (in method-call syntax).</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def pipe(self: HasAtomsT, function: t.Callable[Concatenate[HasAtomsT, P], T], *args: P.args, **kwargs: P.kwargs) -&gt; T:\n    \"\"\"Apply `function` to `self` (in method-call syntax).\"\"\"\n    return function(self, *args, **kwargs)\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.Atoms.clone","title":"<code>clone()</code>","text":"<p>Return a copy of <code>self</code>.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>@_fwd_frame_map\ndef clone(self) -&gt; polars.DataFrame:\n    \"\"\"Return a copy of `self`.\"\"\"\n    return self._get_frame().clone()\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.Atoms.drop","title":"<code>drop(*columns)</code>","text":"<p>Return <code>self</code> with the specified columns removed.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def drop(self, *columns: t.Union[str, t.Iterable[str]]) -&gt; polars.DataFrame:\n    \"\"\"Return `self` with the specified columns removed.\"\"\"\n    return self._get_frame().drop(*columns)\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.Atoms.filter","title":"<code>filter(*predicates, **constraints)</code>","text":"<p>Filter <code>self</code>, removing rows which evaluate to <code>False</code>.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def filter(\n    self: HasAtomsT,\n    *predicates: t.Union[None, IntoExprColumn, t.Iterable[IntoExprColumn], bool, t.List[bool], numpy.ndarray],\n    **constraints: t.Any,\n) -&gt; HasAtomsT:\n    \"\"\"Filter `self`, removing rows which evaluate to `False`.\"\"\"\n    # TODO clean up\n    preds_not_none: t.Tuple[t.Union[IntoExprColumn, t.Iterable[IntoExprColumn], bool, t.List[bool], numpy.ndarray], ...]\n    preds_not_none = tuple(filter(lambda p: p is not None, predicates))  # type: ignore\n    if not len(preds_not_none) and not len(constraints):\n        return self\n    return self.with_atoms(Atoms(self._get_frame().filter(*preds_not_none, **constraints), _unchecked=True))\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.Atoms.sort","title":"<code>sort(by, *more_by, descending=False, nulls_last=False)</code>","text":"<p>Sort the atoms in <code>self</code> by the given columns/expressions.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>@_fwd_frame_map\ndef sort(\n    self,\n    by: t.Union[IntoExpr, t.Iterable[IntoExpr]],\n    *more_by: IntoExpr,\n    descending: t.Union[bool, t.Sequence[bool]] = False,\n    nulls_last: bool = False,\n) -&gt; polars.DataFrame:\n    \"\"\"\n    Sort the atoms in `self` by the given columns/expressions.\n    \"\"\"\n    return self._get_frame().sort(\n        by, *more_by, descending=descending, nulls_last=nulls_last\n    )\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.Atoms.slice","title":"<code>slice(offset, length=None)</code>","text":"<p>Return a slice of the rows in <code>self</code>.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>@_fwd_frame_map\ndef slice(self, offset: int, length: t.Optional[int] = None) -&gt; polars.DataFrame:\n    \"\"\"Return a slice of the rows in `self`.\"\"\"\n    return self._get_frame().slice(offset, length)\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.Atoms.head","title":"<code>head(n=5)</code>","text":"<p>Return the first <code>n</code> rows of <code>self</code>.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>@_fwd_frame_map\ndef head(self, n: int = 5) -&gt; polars.DataFrame:\n    \"\"\"Return the first `n` rows of `self`.\"\"\"\n    return self._get_frame().head(n)\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.Atoms.tail","title":"<code>tail(n=5)</code>","text":"<p>Return the last <code>n</code> rows of <code>self</code>.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>@_fwd_frame_map\ndef tail(self, n: int = 5) -&gt; polars.DataFrame:\n    \"\"\"Return the last `n` rows of `self`.\"\"\"\n    return self._get_frame().tail(n)\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.Atoms.drop_nulls","title":"<code>drop_nulls(subset=None)</code>","text":"<p>Drop rows that contain nulls in any of columns <code>subset</code>.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>@_fwd_frame_map\ndef drop_nulls(self, subset: t.Union[str, t.Collection[str], None] = None) -&gt; polars.DataFrame:\n    \"\"\"Drop rows that contain nulls in any of columns `subset`.\"\"\"\n    return self._get_frame().drop_nulls(subset)\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.Atoms.fill_null","title":"<code>fill_null(value=None, strategy=None, limit=None, matches_supertype=True)</code>","text":"<p>Fill null values in <code>self</code>, using the specified value or strategy.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>@_fwd_frame_map\ndef fill_null(\n    self, value: t.Any = None, strategy: t.Optional[FillNullStrategy] = None,\n    limit: t.Optional[int] = None, matches_supertype: bool = True,\n) -&gt; polars.DataFrame:\n    \"\"\"Fill null values in `self`, using the specified value or strategy.\"\"\"\n    return self._get_frame().fill_null(value, strategy, limit, matches_supertype=matches_supertype)\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.Atoms.fill_nan","title":"<code>fill_nan(value)</code>","text":"<p>Fill floating-point NaN values in <code>self</code>.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>@_fwd_frame_map\ndef fill_nan(self, value: t.Union[polars.Expr, int, float, None]) -&gt; polars.DataFrame:\n    \"\"\"Fill floating-point NaN values in `self`.\"\"\"\n    return self._get_frame().fill_nan(value)\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.Atoms.concat","title":"<code>concat(atoms, *, rechunk=True, how='vertical')</code>  <code>classmethod</code>","text":"<p>Concatenate multiple <code>Atoms</code> together, handling metadata appropriately.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>@classmethod\ndef concat(cls: t.Type[HasAtomsT],\n           atoms: t.Union[HasAtomsT, IntoAtoms, t.Iterable[t.Union[HasAtomsT, IntoAtoms]]], *,\n           rechunk: bool = True, how: ConcatMethod = 'vertical') -&gt; HasAtomsT:\n    \"\"\"Concatenate multiple `Atoms` together, handling metadata appropriately.\"\"\"\n    # this method is tricky. It needs to accept raw Atoms, as well as HasAtoms of the\n    # same type as ``cls``.\n    if _is_abstract(cls):\n        raise TypeError(f\"concat() must be called on a concrete class.\")\n\n    if isinstance(atoms, HasAtoms):\n        atoms = (atoms,)\n    dfs = [a.get_atoms('local').inner if isinstance(a, HasAtoms) else Atoms(t.cast(IntoAtoms, a)).inner for a in atoms]\n    representative = cls._combine_metadata(*(a for a in atoms if isinstance(a, HasAtoms)))\n\n    if len(dfs) == 0:\n        return representative.with_atoms(Atoms.empty(), 'local')\n\n    if how in ('vertical', 'vertical_relaxed'):\n        # get order from first member\n        cols = dfs[0].columns\n        dfs = [df.select(cols) for df in dfs]\n    elif how == 'inner':\n        cols = reduce(operator.and_, (df.schema.keys() for df in dfs))\n        schema = OrderedDict((col, dfs[0].schema[col]) for col in cols)\n        if len(schema) == 0:\n            raise ValueError(f\"Atoms have no columns in common\")\n\n        dfs = [_select_schema(df, schema) for df in dfs]\n        how = 'vertical'\n\n    return representative.with_atoms(Atoms(polars.concat(dfs, rechunk=rechunk, how=how)), 'local')\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.Atoms.partition_by","title":"<code>partition_by(by, *more_by, maintain_order=True, include_key=True, as_dict=False)</code>","text":"<p>Group by the given columns and partition into separate dataframes.</p> <p>Return the partitions as a dictionary by specifying <code>as_dict=True</code>.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def partition_by(\n    self: HasAtomsT, by: t.Union[str, t.Sequence[str]], *more_by: str,\n    maintain_order: bool = True, include_key: bool = True, as_dict: bool = False\n) -&gt; t.Union[t.List[HasAtomsT], t.Dict[t.Any, HasAtomsT]]:\n    \"\"\"\n    Group by the given columns and partition into separate dataframes.\n\n    Return the partitions as a dictionary by specifying `as_dict=True`.\n    \"\"\"\n    if as_dict:\n        d = self._get_frame().partition_by(by, *more_by, maintain_order=maintain_order, include_key=include_key, as_dict=True)\n        return {k: self.with_atoms(Atoms(df, _unchecked=True)) for (k, df) in d.items()}\n\n    return [\n        self.with_atoms(Atoms(df, _unchecked=True))\n        for df in self._get_frame().partition_by(by, *more_by, maintain_order=maintain_order, include_key=include_key, as_dict=False)\n    ]\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.Atoms.select","title":"<code>select(*exprs, **named_exprs)</code>","text":"<p>Select <code>exprs</code> from <code>self</code>, and return as a <code>polars.DataFrame</code>.</p> <p>Expressions may either be columns or expressions of columns.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>@_fwd_frame(polars.DataFrame.select)\ndef select(\n    self,\n    *exprs: t.Union[IntoExpr, t.Iterable[IntoExpr]],\n    **named_exprs: IntoExpr,\n):\n    \"\"\"\n    Select `exprs` from `self`, and return as a `polars.DataFrame`.\n\n    Expressions may either be columns or expressions of columns.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.Atoms.select_schema","title":"<code>select_schema(schema)</code>","text":"<p>Select columns from <code>self</code> and cast to the given schema. Raises <code>TypeError</code> if a column is not found or if it can't be cast.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def select_schema(self, schema: SchemaDict) -&gt; polars.DataFrame:\n    \"\"\"\n    Select columns from `self` and cast to the given schema.\n    Raises `TypeError` if a column is not found or if it can't be cast.\n    \"\"\"\n    return _select_schema(self, schema)\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.Atoms.select_props","title":"<code>select_props(*exprs, **named_exprs)</code>","text":"<p>Select <code>exprs</code> from <code>self</code>, while keeping required columns.</p> <p>Returns a HasAtoms.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def select_props(\n    self: HasAtomsT,\n    *exprs: t.Union[IntoExpr, t.Iterable[IntoExpr]],\n    **named_exprs: IntoExpr\n) -&gt; HasAtomsT:\n    \"\"\"\n    Select `exprs` from `self`, while keeping required columns.\n\n    Returns a HasAtoms.\n    \"\"\"\n    props = self._get_frame().lazy().select(*exprs, **named_exprs).drop(_REQUIRED_COLUMNS).collect(_eager=True)\n    return self.with_atoms(\n        Atoms(self._get_frame().select(_REQUIRED_COLUMNS).hstack(props), _unchecked=False)\n    )\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.Atoms.try_select","title":"<code>try_select(*exprs, **named_exprs)</code>","text":"<p>Try to select <code>exprs</code> from <code>self</code>, and return as a <code>DataFrame</code>.</p> <p>Expressions may either be columns or expressions of columns. Return <code>None</code> if any columns are missing.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def try_select(\n    self,\n    *exprs: t.Union[IntoExpr, t.Iterable[IntoExpr]],\n    **named_exprs: IntoExpr,\n) -&gt; t.Optional[polars.DataFrame]:\n    \"\"\"\n    Try to select `exprs` from `self`, and return as a `DataFrame`.\n\n    Expressions may either be columns or expressions of columns.\n    Return `None` if any columns are missing.\n    \"\"\"\n    try:\n        return self._get_frame().select(*exprs, **named_exprs)\n    except polars.ColumnNotFoundError:\n        return None\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.Atoms.try_get_column","title":"<code>try_get_column(name)</code>","text":"<p>Try to get a column from <code>self</code>, returning <code>None</code> if it doesn't exist.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def try_get_column(self, name: str) -&gt; t.Optional[polars.Series]:\n    \"\"\"Try to get a column from `self`, returning `None` if it doesn't exist.\"\"\"\n    try:\n        return self.get_column(name)\n    except polars.ColumnNotFoundError:\n        return None\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.Atoms.assert_equal","title":"<code>assert_equal(other)</code>","text":"Source code in <code>atomlib/atoms.py</code> <pre><code>def assert_equal(self, other: t.Any):\n    assert isinstance(other, HasAtoms)\n    assert dict(self.schema) == dict(other.schema)\n    for col in self.schema.keys():\n        polars.testing.assert_series_equal(self[col], other[col], check_names=False, rtol=1e-3, atol=1e-8)\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.Atoms.bbox_atoms","title":"<code>bbox_atoms()</code>","text":"<p>Return the bounding box of all the atoms in <code>self</code>.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def bbox_atoms(self) -&gt; BBox3D:\n    \"\"\"Return the bounding box of all the atoms in ``self``.\"\"\"\n    return BBox3D.from_pts(self.coords())\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.Atoms.transform_atoms","title":"<code>transform_atoms(transform, selection=None, *, transform_velocities=False)</code>","text":"<p>Transform the atoms in <code>self</code> by <code>transform</code>. If <code>selection</code> is given, only transform the atoms in <code>selection</code>.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def transform_atoms(self: HasAtomsT, transform: IntoTransform3D, selection: t.Optional[AtomSelection] = None, *, transform_velocities: bool = False) -&gt; HasAtomsT:\n    \"\"\"\n    Transform the atoms in `self` by `transform`.\n    If `selection` is given, only transform the atoms in `selection`.\n    \"\"\"\n    transform = Transform3D.make(transform)\n    selection = _selection_to_numpy(self, selection)\n    transformed = self.with_coords(Transform3D.make(transform) @ self.coords(selection), selection)\n    # try to transform velocities as well\n    if transform_velocities and (velocities := self.velocities(selection)) is not None:\n        return transformed.with_velocity(transform.transform_vec(velocities), selection)\n    return transformed\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.Atoms.round_near_zero","title":"<code>round_near_zero(tol=1e-14)</code>","text":"<p>Round atom position values near zero to zero.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def round_near_zero(self: HasAtomsT, tol: float = 1e-14) -&gt; HasAtomsT:\n    \"\"\"\n    Round atom position values near zero to zero.\n    \"\"\"\n    return self.with_columns(coords=polars.concat_list(\n        polars.when(_coord_expr(col).abs() &gt;= tol).then(_coord_expr(col)).otherwise(polars.lit(0.))\n        for col in range(3)\n    ).list.to_array(3))\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.Atoms.crop","title":"<code>crop(x_min=-numpy.inf, x_max=numpy.inf, y_min=-numpy.inf, y_max=numpy.inf, z_min=-numpy.inf, z_max=numpy.inf)</code>","text":"<p>Crop, removing all atoms outside of the specified region, inclusive.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def crop(self: HasAtomsT, x_min: float = -numpy.inf, x_max: float = numpy.inf,\n         y_min: float = -numpy.inf, y_max: float = numpy.inf,\n         z_min: float = -numpy.inf, z_max: float = numpy.inf) -&gt; HasAtomsT:\n    \"\"\"\n    Crop, removing all atoms outside of the specified region, inclusive.\n    \"\"\"\n\n    return self.filter(\n        self.x().is_between(x_min, x_max, closed='both'),\n        self.y().is_between(y_min, y_max, closed='both'),\n        self.z().is_between(z_min, z_max, closed='both'),\n    )\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.Atoms.deduplicate","title":"<code>deduplicate(tol=0.001, subset=('x', 'y', 'z', 'symbol'), keep='first', maintain_order=True)</code>","text":"<p>De-duplicate atoms in <code>self</code>. Atoms of the same <code>symbol</code> that are closer than <code>tolerance</code> to each other (by Euclidian distance) will be removed, leaving only the atom specified by <code>keep</code> (defaults to the first atom).</p> <p>If <code>subset</code> is specified, only those columns will be included while assessing duplicates. Floating point columns other than 'x', 'y', and 'z' will not by toleranced.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def deduplicate(self: HasAtomsT, tol: float = 1e-3, subset: t.Iterable[str] = ('x', 'y', 'z', 'symbol'),\n                keep: UniqueKeepStrategy = 'first', maintain_order: bool = True) -&gt; HasAtomsT:\n    \"\"\"\n    De-duplicate atoms in `self`. Atoms of the same `symbol` that are closer than `tolerance`\n    to each other (by Euclidian distance) will be removed, leaving only the atom specified by\n    `keep` (defaults to the first atom).\n\n    If `subset` is specified, only those columns will be included while assessing duplicates.\n    Floating point columns other than 'x', 'y', and 'z' will not by toleranced.\n    \"\"\"\n    import scipy.spatial\n\n    cols = set((subset,) if isinstance(subset, str) else subset)\n\n    indices = numpy.arange(len(self))\n\n    spatial_cols = cols.intersection(('x', 'y', 'z'))\n    cols -= spatial_cols\n    if len(spatial_cols) &gt; 0:\n        coords = self.select([_coord_expr(col).alias(col) for col in spatial_cols]).to_numpy()\n        tree = scipy.spatial.KDTree(coords)\n\n        # TODO This is a bad algorithm\n        while True:\n            changed = False\n            for (i, j) in tree.query_pairs(tol, 2.):\n                # whenever we encounter a pair, ensure their index matches\n                i_i, i_j = indices[[i, j]]\n                if i_i != i_j:\n                    indices[i] = indices[j] = min(i_i, i_j)\n                    changed = True\n            if not changed:\n                break\n\n        self = self.with_column(polars.Series('_unique_pts', indices))\n        cols.add('_unique_pts')\n\n    frame = self._get_frame().unique(subset=list(cols), keep=keep, maintain_order=maintain_order)\n    if len(spatial_cols) &gt; 0:\n        frame = frame.drop('_unique_pts')\n\n    return self.with_atoms(Atoms(frame, _unchecked=True))\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.Atoms.with_bounds","title":"<code>with_bounds(cell_size=None, cell_origin=None)</code>","text":"<p>Return a periodic cell with the given orthogonal cell dimensions.</p> <p>If cell_size is not specified, it will be assumed (and may be incorrect).</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def with_bounds(self, cell_size: t.Optional[VecLike] = None, cell_origin: t.Optional[VecLike] = None) -&gt; 'AtomCell':\n    \"\"\"\n    Return a periodic cell with the given orthogonal cell dimensions.\n\n    If cell_size is not specified, it will be assumed (and may be incorrect).\n    \"\"\"\n    # TODO: test this\n    from .atomcell import AtomCell\n\n    if cell_size is None:\n        warnings.warn(\"Cell boundary unknown. Defaulting to cell BBox\")\n        cell_size = self.bbox().size\n        cell_origin = self.bbox().min\n\n    # TODO test this origin code\n    cell = Cell.from_unit_cell(cell_size)\n    if cell_origin is not None:\n        cell = cell.transform_cell(AffineTransform3D.translate(to_vec3(cell_origin)))\n\n    return AtomCell(self.get_atoms(), cell, frame='local')\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.Atoms.coords","title":"<code>coords(selection=None, *, frame='local')</code>","text":"<p>Return a <code>(N, 3)</code> ndarray of atom coordinates (dtype <code>numpy.float64</code>).</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def coords(self, selection: t.Optional[AtomSelection] = None, *, frame: t.Literal['local'] = 'local') -&gt; NDArray[numpy.float64]:\n    \"\"\"Return a `(N, 3)` ndarray of atom coordinates (dtype [`numpy.float64`][numpy.float64]).\"\"\"\n    df = self if selection is None else self.filter(_selection_to_expr(self, selection))\n    return df.get_column('coords').to_numpy().astype(numpy.float64)\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.Atoms.x","title":"<code>x()</code>","text":"Source code in <code>atomlib/atoms.py</code> <pre><code>def x(self) -&gt; polars.Expr:\n    return polars.col('coords').arr.get(0).alias('x')\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.Atoms.y","title":"<code>y()</code>","text":"Source code in <code>atomlib/atoms.py</code> <pre><code>def y(self) -&gt; polars.Expr:\n    return polars.col('coords').arr.get(1).alias('y')\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.Atoms.z","title":"<code>z()</code>","text":"Source code in <code>atomlib/atoms.py</code> <pre><code>def z(self) -&gt; polars.Expr:\n    return polars.col('coords').arr.get(2).alias('z')\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.Atoms.velocities","title":"<code>velocities(selection=None)</code>","text":"<p>Return a <code>(N, 3)</code> ndarray of atom velocities (dtype <code>numpy.float64</code>).</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def velocities(self, selection: t.Optional[AtomSelection] = None) -&gt; t.Optional[NDArray[numpy.float64]]:\n    \"\"\"Return a `(N, 3)` ndarray of atom velocities (dtype [`numpy.float64`][numpy.float64]).\"\"\"\n    if 'velocity' not in self:\n        return None\n\n    df = self if selection is None else self.filter(_selection_to_expr(self, selection))\n    return df.get_column('velocity').to_numpy().astype(numpy.float64)\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.Atoms.types","title":"<code>types()</code>","text":"<p>Returns a <code>Series</code> of atom types (dtype <code>polars.Int32</code>).</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def types(self) -&gt; t.Optional[polars.Series]:\n    \"\"\"\n    Returns a [`Series`][polars.Series] of atom types (dtype [`polars.Int32`][polars.Int32]).\n\n    [polars.Series]: https://docs.pola.rs/py-polars/html/reference/series/index.html\n    \"\"\"\n    return self.try_get_column('type')\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.Atoms.masses","title":"<code>masses()</code>","text":"<p>Returns a <code>Series</code> of atom masses (dtype <code>polars.Float32</code>).</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def masses(self) -&gt; t.Optional[polars.Series]:\n    \"\"\"\n    Returns a [`Series`][polars.Series] of atom masses (dtype [`polars.Float32`][polars.Float32]).\n\n    [polars.Series]: https://docs.pola.rs/py-polars/html/reference/series/index.html\n    \"\"\"\n    return self.try_get_column('mass')\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.Atoms.add_atom","title":"<code>add_atom(elem, /, x, y=None, z=None, **kwargs)</code>","text":"<p>Return a copy of <code>self</code> with an extra atom.</p> <p>By default, all extra columns present in <code>self</code> must be specified as <code>**kwargs</code>.</p> <p>Try to avoid calling this in a loop (Use <code>HasAtoms.concat</code> instead).</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def add_atom(self: HasAtomsT, elem: t.Union[int, str], /,\n             x: t.Union[ArrayLike, float],\n             y: t.Optional[float] = None,\n             z: t.Optional[float] = None,\n             **kwargs: t.Any) -&gt; HasAtomsT:\n    \"\"\"\n    Return a copy of `self` with an extra atom.\n\n    By default, all extra columns present in `self` must be specified as `**kwargs`.\n\n    Try to avoid calling this in a loop (Use [`HasAtoms.concat`][atomlib.atoms.HasAtoms.concat] instead).\n    \"\"\"\n    if isinstance(elem, int):\n        kwargs.update(elem=elem)\n    else:\n        kwargs.update(symbol=elem)\n    if hasattr(x, '__len__') and len(x) &gt; 1:  # type: ignore\n        (x, y, z) = to_vec3(x)\n    elif y is None or z is None:\n        raise ValueError(f\"Must specify vector of positions or x, y, &amp; z.\")\n\n    sym = get_sym(elem) if isinstance(elem, int) else elem\n    d: t.Dict[str, t.Any] = {'x': x, 'y': y, 'z': z, 'symbol': sym, **kwargs}\n    return self.concat(\n        (self, Atoms(d).select_schema(self.schema)),\n        how='vertical'\n    )\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.Atoms.pos","title":"<code>pos(x=None, y=None, z=None, *, tol=1e-06, **kwargs)</code>","text":"<p>Select all atoms at a given position.</p> <p>Formally, returns all atoms within a cube of radius <code>tol</code> centered at <code>(x,y,z)</code>, exclusive of the cube's surface.</p> <p>Additional parameters given as <code>kwargs</code> will be checked as additional parameters (with strict equality).</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def pos(self,\n        x: t.Union[t.Sequence[t.Optional[float]], float, None] = None,\n        y: t.Optional[float] = None, z: t.Optional[float] = None, *,\n        tol: float = 1e-6, **kwargs: t.Any) -&gt; polars.Expr:\n    \"\"\"\n    Select all atoms at a given position.\n\n    Formally, returns all atoms within a cube of radius ``tol``\n    centered at ``(x,y,z)``, exclusive of the cube's surface.\n\n    Additional parameters given as ``kwargs`` will be checked\n    as additional parameters (with strict equality).\n    \"\"\"\n\n    if isinstance(x, t.Sequence):\n        (x, y, z) = x\n\n    tol = abs(float(tol))\n    selection = polars.lit(True)\n    if x is not None:\n        selection &amp;= self.x().is_between(x - tol, x + tol, closed='none')\n    if y is not None:\n        selection &amp;= self.y().is_between(y - tol, y + tol, closed='none')\n    if z is not None:\n        selection &amp;= self.z().is_between(z - tol, z + tol, closed='none')\n    for (col, val) in kwargs.items():\n        selection &amp;= (polars.col(col) == val)\n\n    return selection\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.Atoms.with_index","title":"<code>with_index(index=None)</code>","text":"<p>Returns <code>self</code> with a row index added in column 'i' (dtype <code>polars.Int64</code>). If <code>index</code> is not specified, defaults to an existing index or a new index.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def with_index(self: HasAtomsT, index: t.Optional[AtomValues] = None) -&gt; HasAtomsT:\n    \"\"\"\n    Returns `self` with a row index added in column 'i' (dtype [`polars.Int64`][polars.Int64]).\n    If `index` is not specified, defaults to an existing index or a new index.\n    \"\"\"\n    if index is None and 'i' in self.columns:\n        return self\n    if index is None:\n        index = numpy.arange(len(self), dtype=numpy.int64)\n    return self.with_column(_values_to_expr(self, index, polars.Int64).alias('i'))\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.Atoms.with_wobble","title":"<code>with_wobble(wobble=None)</code>","text":"<p>Return <code>self</code> with the given displacements in column 'wobble' (dtype <code>polars.Float64</code>). If <code>wobble</code> is not specified, defaults to the already-existing wobbles or 0.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def with_wobble(self: HasAtomsT, wobble: t.Optional[AtomValues] = None) -&gt; HasAtomsT:\n    \"\"\"\n    Return `self` with the given displacements in column 'wobble' (dtype [`polars.Float64`][polars.Float64]).\n    If `wobble` is not specified, defaults to the already-existing wobbles or 0.\n    \"\"\"\n    if wobble is None and 'wobble' in self.columns:\n        return self\n    wobble = 0. if wobble is None else wobble\n    return self.with_column(_values_to_expr(self, wobble, polars.Float64).alias('wobble'))\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.Atoms.with_occupancy","title":"<code>with_occupancy(frac_occupancy=None)</code>","text":"<p>Return self with the given fractional occupancies. If <code>frac_occupancy</code> is not specified, defaults to the already-existing occupancies or 1.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def with_occupancy(self: HasAtomsT, frac_occupancy: t.Optional[AtomValues] = None) -&gt; HasAtomsT:\n    \"\"\"\n    Return self with the given fractional occupancies. If `frac_occupancy` is not specified,\n    defaults to the already-existing occupancies or 1.\n    \"\"\"\n    if frac_occupancy is None and 'frac_occupancy' in self.columns:\n        return self\n    frac_occupancy = 1. if frac_occupancy is None else frac_occupancy\n    return self.with_column(_values_to_expr(self, frac_occupancy, polars.Float64).alias('frac_occupancy'))\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.Atoms.apply_wobble","title":"<code>apply_wobble(rng=None)</code>","text":"<p>Displace the atoms in <code>self</code> by the amount in the <code>wobble</code> column. <code>wobble</code> is interpretated as a mean-squared displacement, which is distributed equally over each axis.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def apply_wobble(self: HasAtomsT, rng: t.Union[numpy.random.Generator, int, None] = None) -&gt; HasAtomsT:\n    \"\"\"\n    Displace the atoms in `self` by the amount in the `wobble` column.\n    `wobble` is interpretated as a mean-squared displacement, which is distributed\n    equally over each axis.\n    \"\"\"\n    if 'wobble' not in self.columns:\n        return self\n    rng = numpy.random.default_rng(seed=rng)\n\n    stddev = self.select((polars.col('wobble') / 3.).sqrt()).to_series().to_numpy()\n    coords = self.coords()\n    coords += stddev[:, None] * rng.standard_normal(coords.shape)\n    return self.with_coords(coords)\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.Atoms.apply_occupancy","title":"<code>apply_occupancy(rng=None)</code>","text":"<p>For each atom in <code>self</code>, use its <code>frac_occupancy</code> to randomly decide whether to remove it.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def apply_occupancy(self: HasAtomsT, rng: t.Union[numpy.random.Generator, int, None] = None) -&gt; HasAtomsT:\n    \"\"\"\n    For each atom in `self`, use its `frac_occupancy` to randomly decide whether to remove it.\n    \"\"\"\n    if 'frac_occupancy' not in self.columns:\n        return self\n    rng = numpy.random.default_rng(seed=rng)\n\n    frac = self.select('frac_occupancy').to_series().to_numpy()\n    choice = rng.binomial(1, frac).astype(numpy.bool_)\n    return self.filter(polars.lit(choice))\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.Atoms.with_type","title":"<code>with_type(types=None)</code>","text":"<p>Return <code>self</code> with the given atom types in column 'type'. If <code>types</code> is not specified, use the already existing types or auto-assign them.</p> <p>When auto-assigning, each symbol is given a unique value, case-sensitive. Values are assigned from lowest atomic number to highest. For instance: <code>[\"Ag+\", \"Na\", \"H\", \"Ag\"]</code> =&gt; <code>[3, 11, 1, 2]</code></p> Source code in <code>atomlib/atoms.py</code> <pre><code>def with_type(self: HasAtomsT, types: t.Optional[AtomValues] = None) -&gt; HasAtomsT:\n    \"\"\"\n    Return `self` with the given atom types in column 'type'.\n    If `types` is not specified, use the already existing types or auto-assign them.\n\n    When auto-assigning, each symbol is given a unique value, case-sensitive.\n    Values are assigned from lowest atomic number to highest.\n    For instance: `[\"Ag+\", \"Na\", \"H\", \"Ag\"]` =&gt; `[3, 11, 1, 2]`\n    \"\"\"\n    if types is not None:\n        return self.with_columns(type=_values_to_expr(self, types, polars.Int32))\n    if 'type' in self.columns:\n        return self\n\n    unique = Atoms(self._get_frame().unique(maintain_order=False, subset=['elem', 'symbol']).sort(['elem', 'symbol']), _unchecked=True)\n    new = self.with_column(polars.Series('type', values=numpy.zeros(len(self)), dtype=polars.Int32))\n\n    logging.warning(\"Auto-assigning element types\")\n    for (i, (elem, sym)) in enumerate(unique.select(('elem', 'symbol')).rows()):\n        print(f\"Assigning type {i+1} to element '{sym}'\")\n        new = new.with_column(polars.when((polars.col('elem') == elem) &amp; (polars.col('symbol') == sym))\n                                    .then(polars.lit(i+1))\n                                    .otherwise(polars.col('type'))\n                                    .alias('type'))\n\n    assert (new.get_column('type') == 0).sum() == 0\n    return new\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.Atoms.with_mass","title":"<code>with_mass(mass=None)</code>","text":"<p>Return <code>self</code> with the given atom masses in column 'mass'. If <code>mass</code> is not specified, use the already existing masses or auto-assign them.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def with_mass(self: HasAtomsT, mass: t.Optional[ArrayLike] = None) -&gt; HasAtomsT:\n    \"\"\"\n    Return `self` with the given atom masses in column 'mass'.\n    If `mass` is not specified, use the already existing masses or auto-assign them.\n    \"\"\"\n    if mass is not None:\n        return self.with_column(_values_to_expr(self, mass, polars.Float32).alias('mass'))\n    if 'mass' in self.columns:\n        return self\n\n    unique_elems = self.get_column('elem').unique()\n    new = self.with_column(polars.Series('mass', values=numpy.zeros(len(self)), dtype=polars.Float32))\n\n    logging.warning(\"Auto-assigning element masses\")\n    for elem in unique_elems:\n        new = new.with_column(polars.when(polars.col('elem') == elem)\n                                    .then(polars.lit(get_mass(elem)))\n                                    .otherwise(polars.col('mass'))\n                                    .alias('mass'))\n\n    assert (new.get_column('mass').abs() &lt; 1e-10).sum() == 0\n    return new\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.Atoms.with_symbol","title":"<code>with_symbol(symbols, selection=None)</code>","text":"<p>Return <code>self</code> with the given atomic symbols.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def with_symbol(self: HasAtomsT, symbols: ArrayLike, selection: t.Optional[AtomSelection] = None) -&gt; HasAtomsT:\n    \"\"\"\n    Return `self` with the given atomic symbols.\n    \"\"\"\n    if selection is not None:\n        selection = _selection_to_numpy(self, selection)\n        new_symbols = self.get_column('symbol')\n        new_symbols[selection] = polars.Series(list(numpy.broadcast_to(symbols, len(selection))), dtype=polars.Utf8)\n        symbols = new_symbols\n\n    # TODO better cast here\n    symbols = polars.Series('symbol', list(numpy.broadcast_to(symbols, len(self))), dtype=polars.Utf8)\n    return self.with_columns((symbols, get_elem(symbols)))\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.Atoms.with_coords","title":"<code>with_coords(pts, selection=None, *, frame='local')</code>","text":"<p>Return <code>self</code> replaced with the given atomic positions.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def with_coords(self: HasAtomsT, pts: ArrayLike, selection: t.Optional[AtomSelection] = None, *, frame: t.Literal['local'] = 'local') -&gt; HasAtomsT:\n    \"\"\"\n    Return `self` replaced with the given atomic positions.\n    \"\"\"\n    if selection is not None:\n        selection = _selection_to_numpy(self, selection)\n        new_pts = self.coords()\n        pts = numpy.atleast_2d(pts)\n        assert pts.shape[-1] == 3\n        new_pts[selection] = pts\n        pts = new_pts\n\n    pts = numpy.broadcast_to(pts, (len(self), 3))\n    return self.with_columns(polars.Series('coords', pts, polars.Array(polars.Float64, 3)))\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.Atoms.with_velocity","title":"<code>with_velocity(pts=None, selection=None)</code>","text":"<p>Return <code>self</code> replaced with the given atomic velocities. If <code>pts</code> is not specified, use the already existing velocities or zero.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def with_velocity(self: HasAtomsT, pts: t.Optional[ArrayLike] = None,\n                  selection: t.Optional[AtomSelection] = None) -&gt; HasAtomsT:\n    \"\"\"\n    Return `self` replaced with the given atomic velocities.\n    If `pts` is not specified, use the already existing velocities or zero.\n    \"\"\"\n    if pts is None:\n        if 'velocity' in self:\n            return self\n        all_pts = numpy.zeros((len(self), 3))\n    else:\n        all_pts = self['velocity'].to_numpy()\n\n    if selection is None:\n        all_pts = pts or all_pts\n    elif pts is not None:\n        selection = _selection_to_numpy(self, selection)\n        all_pts = numpy.require(all_pts, requirements=['WRITEABLE'])\n        pts = numpy.atleast_2d(pts)\n        assert pts.shape[-1] == 3\n        all_pts[selection] = pts\n\n    all_pts = numpy.broadcast_to(all_pts, (len(self), 3))\n    return self.with_columns(polars.Series('velocity', all_pts, polars.Array(polars.Float64, 3)))\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.Atoms.read","title":"<code>read(path, ty=None)</code>  <code>classmethod</code>","text":"<p>Read a structure from a file.</p> <p>Supported types can be found in the io module. If no <code>ty</code> is specified, it is inferred from the file's extension.</p> Source code in <code>atomlib/mixins.py</code> <pre><code>@classmethod\ndef read(cls: t.Type[HasAtomsT], path: FileOrPath, ty: t.Optional[FileType] = None) -&gt; HasAtomsT:\n    \"\"\"\n    Read a structure from a file.\n\n    Supported types can be found in the [io][atomlib.io] module.\n    If no `ty` is specified, it is inferred from the file's extension.\n    \"\"\"\n    from .io import read\n    return _cast_atoms(read(path, ty), cls)  # type: ignore\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.Atoms.read_cif","title":"<code>read_cif(f, block=None)</code>  <code>classmethod</code>","text":"<p>Read a structure from a CIF file.</p> <p>If <code>block</code> is specified, read data from the given block of the CIF file (index or name).</p> Source code in <code>atomlib/mixins.py</code> <pre><code>@classmethod\ndef read_cif(cls: t.Type[HasAtomsT], f: t.Union[FileOrPath, CIF, CIFDataBlock], block: t.Union[int, str, None] = None) -&gt; HasAtomsT:\n    \"\"\"\n    Read a structure from a CIF file.\n\n    If `block` is specified, read data from the given block of the CIF file (index or name).\n    \"\"\"\n    from .io import read_cif\n    return _cast_atoms(read_cif(f, block), cls)\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.Atoms.read_xyz","title":"<code>read_xyz(f)</code>  <code>classmethod</code>","text":"<p>Read a structure from an XYZ file.</p> Source code in <code>atomlib/mixins.py</code> <pre><code>@classmethod\ndef read_xyz(cls: t.Type[HasAtomsT], f: t.Union[FileOrPath, XYZ]) -&gt; HasAtomsT:\n    \"\"\"Read a structure from an XYZ file.\"\"\"\n    from .io import read_xyz\n    return _cast_atoms(read_xyz(f), cls)\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.Atoms.read_xsf","title":"<code>read_xsf(f)</code>  <code>classmethod</code>","text":"<p>Read a structure from an XSF file.</p> Source code in <code>atomlib/mixins.py</code> <pre><code>@classmethod\ndef read_xsf(cls: t.Type[HasAtomsT], f: t.Union[FileOrPath, XSF]) -&gt; HasAtomsT:\n    \"\"\"Read a structure from an XSF file.\"\"\"\n    from .io import read_xsf\n    return _cast_atoms(read_xsf(f), cls)\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.Atoms.read_cfg","title":"<code>read_cfg(f)</code>  <code>classmethod</code>","text":"<p>Read a structure from a CFG file.</p> Source code in <code>atomlib/mixins.py</code> <pre><code>@classmethod\ndef read_cfg(cls: t.Type[HasAtomsT], f: t.Union[FileOrPath, CFG]) -&gt; HasAtomsT:\n    \"\"\"Read a structure from a CFG file.\"\"\"\n    from .io import read_cfg\n    return _cast_atoms(read_cfg(f), cls)\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.Atoms.read_lmp","title":"<code>read_lmp(f, type_map=None)</code>  <code>classmethod</code>","text":"<p>Read a structure from a LAAMPS data file.</p> Source code in <code>atomlib/mixins.py</code> <pre><code>@classmethod\ndef read_lmp(cls: t.Type[HasAtomsT], f: t.Union[FileOrPath, LMP], type_map: t.Optional[t.Dict[int, t.Union[str, int]]] = None) -&gt; HasAtomsT:\n    \"\"\"Read a structure from a LAAMPS data file.\"\"\"\n    from .io import read_lmp\n    return _cast_atoms(read_lmp(f, type_map=type_map), cls)\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.Atoms.write_cif","title":"<code>write_cif(f)</code>","text":"Source code in <code>atomlib/mixins.py</code> <pre><code>def write_cif(self, f: FileOrPath):\n    from .io import write_cif\n    write_cif(self, f)\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.Atoms.write_xyz","title":"<code>write_xyz(f, fmt='exyz')</code>","text":"Source code in <code>atomlib/mixins.py</code> <pre><code>def write_xyz(self, f: FileOrPath, fmt: XYZFormat = 'exyz'):\n    from .io import write_xyz\n    write_xyz(self, f, fmt)\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.Atoms.write_xsf","title":"<code>write_xsf(f)</code>","text":"Source code in <code>atomlib/mixins.py</code> <pre><code>def write_xsf(self, f: FileOrPath):\n    from .io import write_xsf\n    write_xsf(self, f)\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.Atoms.write_cfg","title":"<code>write_cfg(f)</code>","text":"Source code in <code>atomlib/mixins.py</code> <pre><code>def write_cfg(self, f: FileOrPath):\n    from .io import write_cfg\n    write_cfg(self, f)\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.Atoms.write_lmp","title":"<code>write_lmp(f)</code>","text":"Source code in <code>atomlib/mixins.py</code> <pre><code>def write_lmp(self, f: FileOrPath):\n    from .io import write_lmp\n    write_lmp(self, f)\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.Atoms.write","title":"<code>write(path, ty=None)</code>","text":"<p>Write this structure to a file.</p> <p>A file type may be specified using <code>ty</code>. If no <code>ty</code> is specified, it is inferred from the path's extension.</p> Source code in <code>atomlib/mixins.py</code> <pre><code>def write(self, path: FileOrPath, ty: t.Optional[FileType] = None):\n    \"\"\"\n    Write this structure to a file.\n\n    A file type may be specified using `ty`.\n    If no `ty` is specified, it is inferred from the path's extension.\n    \"\"\"\n    from .io import write\n    write(self, path, ty)  # type: ignore\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.Atoms.empty","title":"<code>empty()</code>  <code>staticmethod</code>","text":"<p>Return an empty Atoms with only the mandatory columns.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>@staticmethod\ndef empty() -&gt; Atoms:\n    \"\"\"\n    Return an empty Atoms with only the mandatory columns.\n    \"\"\"\n    return Atoms()\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.Atoms.get_atoms","title":"<code>get_atoms(frame='local')</code>","text":"Source code in <code>atomlib/atoms.py</code> <pre><code>def get_atoms(self, frame: t.Literal['local'] = 'local') -&gt; Atoms:\n    if frame != 'local':\n        raise ValueError(f\"Atoms without a cell only support the 'local' coordinate frame, not '{frame}'.\")\n    return self\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.Atoms.with_atoms","title":"<code>with_atoms(atoms, frame='local')</code>","text":"Source code in <code>atomlib/atoms.py</code> <pre><code>def with_atoms(self, atoms: HasAtoms, frame: t.Literal['local'] = 'local') -&gt; Atoms:\n    if frame != 'local':\n        raise ValueError(f\"Atoms without a cell only support the 'local' coordinate frame, not '{frame}'.\")\n    return atoms.get_atoms()\n</code></pre>"},{"location":"api/atoms/#atomlib.atoms.Atoms.bbox","title":"<code>bbox()</code>","text":"<p>Return the bounding box of all the points in <code>self</code>.</p> Source code in <code>atomlib/atoms.py</code> <pre><code>def bbox(self) -&gt; BBox3D:\n    \"\"\"Return the bounding box of all the points in `self`.\"\"\"\n    if self._bbox is None:\n        self._bbox = BBox3D.from_pts(self.coords())\n\n    return self._bbox\n</code></pre>"},{"location":"api/bbox/","title":"<code>atomlib.bbox</code>","text":""},{"location":"api/bbox/#atomlib.bbox.BBox3D","title":"<code>BBox3D</code>","text":"<p>3D Bounding Box</p> Source code in <code>atomlib/bbox.py</code> <pre><code>class BBox3D:\n    \"\"\"3D Bounding Box\"\"\"\n\n    def __init__(self, min: VecLike, max: VecLike):\n        # shape: (3, 2)\n        # self._inner[1, 0]: min of y\n        min, max = to_vec3(min), to_vec3(max)\n        self.inner: numpy.ndarray = numpy.stack((min, max), axis=-1)\n\n    def transform_from_unit(self) -&gt; AffineTransform3D:\n        \"\"\"Return the transform which transforms a unit bbox to `self`.\"\"\"\n        from .transform import AffineTransform3D\n        return AffineTransform3D.translate(self.min).scale(self.max - self.min)\n\n    def transform_to_unit(self) -&gt; AffineTransform3D:\n        \"\"\"Return the transform which transforms `self` to a unit bbox.\"\"\"\n        return self.transform_from_unit().inverse()\n\n    @classmethod\n    def unit(cls) -&gt; BBox3D:\n        \"\"\"Return a unit bbox (cube from [0,0,0] to [1,1,1]).\"\"\"\n        return cls([0., 0., 0.], [1., 1., 1.])\n\n    @property\n    def min(self) -&gt; Vec3:\n        return self.inner[:, 0]\n\n    @property\n    def max(self) -&gt; Vec3:\n        return self.inner[:, 1]\n\n    @property\n    def x(self) -&gt; numpy.ndarray:\n        return self.inner[0]\n\n    @property\n    def y(self) -&gt; numpy.ndarray:\n        return self.inner[1]\n\n    @property\n    def z(self) -&gt; numpy.ndarray:\n        return self.inner[2]\n\n    @property\n    def size(self) -&gt; Vec3:\n        return self.max - self.min\n\n    def volume(self) -&gt; float:\n        return float(numpy.prod(self.size))\n\n    def corners(self) -&gt; numpy.ndarray:\n        \"\"\"Return a (8, 3) ndarray containing the corners of self.\"\"\"\n        return numpy.stack(list(map(numpy.ravel, numpy.meshgrid(*self.inner))), axis=-1)\n\n    def pad(self, amount: t.Union[float, VecLike]) -&gt; BBox3D:\n        \"\"\"\n        Pad the given BBox by `amount`. If a vector [x, y, z] is given,\n        pad each axis by the given amount.\n        \"\"\"\n        amount_v = numpy.broadcast_to(amount, 3)\n\n        return type(self)(\n            self.min - amount_v,\n            self.max + amount_v\n        )\n\n    @classmethod\n    def from_pts(cls, pts: t.Union[numpy.ndarray, t.Sequence[Vec3]]) -&gt; BBox3D:\n        \"\"\"Construct a BBox containing 'pts'.\"\"\"\n        pts = numpy.atleast_2d(pts).reshape(-1, 3)\n        return cls(numpy.nanmin(pts, axis=0), numpy.nanmax(pts, axis=0))\n\n    def __or__(self, other: t.Union[Vec3, BBox3D]) -&gt; BBox3D:\n        if isinstance(other, numpy.ndarray):\n            return self.from_pts((self.min, self.max, other))\n\n        return type(self)(\n            numpy.nanmin(((self.min, other.min)), axis=0),\n            numpy.nanmax(((self.max, other.max)), axis=0),\n        )\n\n    __ror__ = __or__\n\n    def __and__(self, other: BBox3D) -&gt; BBox3D:\n        return type(self)(\n            numpy.nanmax(((self.min, other.min)), axis=0),\n            numpy.nanmin(((self.max, other.max)), axis=0),\n        )\n\n    def __repr__(self) -&gt; str:\n        return f\"BBox({self.min}, {self.max})\"\n</code></pre>"},{"location":"api/bbox/#atomlib.bbox.BBox3D.inner","title":"<code>inner: numpy.ndarray = numpy.stack((min, max), axis=-1)</code>  <code>instance-attribute</code>","text":""},{"location":"api/bbox/#atomlib.bbox.BBox3D.min","title":"<code>min: Vec3</code>  <code>property</code>","text":""},{"location":"api/bbox/#atomlib.bbox.BBox3D.max","title":"<code>max: Vec3</code>  <code>property</code>","text":""},{"location":"api/bbox/#atomlib.bbox.BBox3D.x","title":"<code>x: numpy.ndarray</code>  <code>property</code>","text":""},{"location":"api/bbox/#atomlib.bbox.BBox3D.y","title":"<code>y: numpy.ndarray</code>  <code>property</code>","text":""},{"location":"api/bbox/#atomlib.bbox.BBox3D.z","title":"<code>z: numpy.ndarray</code>  <code>property</code>","text":""},{"location":"api/bbox/#atomlib.bbox.BBox3D.size","title":"<code>size: Vec3</code>  <code>property</code>","text":""},{"location":"api/bbox/#atomlib.bbox.BBox3D.transform_from_unit","title":"<code>transform_from_unit()</code>","text":"<p>Return the transform which transforms a unit bbox to <code>self</code>.</p> Source code in <code>atomlib/bbox.py</code> <pre><code>def transform_from_unit(self) -&gt; AffineTransform3D:\n    \"\"\"Return the transform which transforms a unit bbox to `self`.\"\"\"\n    from .transform import AffineTransform3D\n    return AffineTransform3D.translate(self.min).scale(self.max - self.min)\n</code></pre>"},{"location":"api/bbox/#atomlib.bbox.BBox3D.transform_to_unit","title":"<code>transform_to_unit()</code>","text":"<p>Return the transform which transforms <code>self</code> to a unit bbox.</p> Source code in <code>atomlib/bbox.py</code> <pre><code>def transform_to_unit(self) -&gt; AffineTransform3D:\n    \"\"\"Return the transform which transforms `self` to a unit bbox.\"\"\"\n    return self.transform_from_unit().inverse()\n</code></pre>"},{"location":"api/bbox/#atomlib.bbox.BBox3D.unit","title":"<code>unit()</code>  <code>classmethod</code>","text":"<p>Return a unit bbox (cube from [0,0,0] to [1,1,1]).</p> Source code in <code>atomlib/bbox.py</code> <pre><code>@classmethod\ndef unit(cls) -&gt; BBox3D:\n    \"\"\"Return a unit bbox (cube from [0,0,0] to [1,1,1]).\"\"\"\n    return cls([0., 0., 0.], [1., 1., 1.])\n</code></pre>"},{"location":"api/bbox/#atomlib.bbox.BBox3D.volume","title":"<code>volume()</code>","text":"Source code in <code>atomlib/bbox.py</code> <pre><code>def volume(self) -&gt; float:\n    return float(numpy.prod(self.size))\n</code></pre>"},{"location":"api/bbox/#atomlib.bbox.BBox3D.corners","title":"<code>corners()</code>","text":"<p>Return a (8, 3) ndarray containing the corners of self.</p> Source code in <code>atomlib/bbox.py</code> <pre><code>def corners(self) -&gt; numpy.ndarray:\n    \"\"\"Return a (8, 3) ndarray containing the corners of self.\"\"\"\n    return numpy.stack(list(map(numpy.ravel, numpy.meshgrid(*self.inner))), axis=-1)\n</code></pre>"},{"location":"api/bbox/#atomlib.bbox.BBox3D.pad","title":"<code>pad(amount)</code>","text":"<p>Pad the given BBox by <code>amount</code>. If a vector [x, y, z] is given, pad each axis by the given amount.</p> Source code in <code>atomlib/bbox.py</code> <pre><code>def pad(self, amount: t.Union[float, VecLike]) -&gt; BBox3D:\n    \"\"\"\n    Pad the given BBox by `amount`. If a vector [x, y, z] is given,\n    pad each axis by the given amount.\n    \"\"\"\n    amount_v = numpy.broadcast_to(amount, 3)\n\n    return type(self)(\n        self.min - amount_v,\n        self.max + amount_v\n    )\n</code></pre>"},{"location":"api/bbox/#atomlib.bbox.BBox3D.from_pts","title":"<code>from_pts(pts)</code>  <code>classmethod</code>","text":"<p>Construct a BBox containing 'pts'.</p> Source code in <code>atomlib/bbox.py</code> <pre><code>@classmethod\ndef from_pts(cls, pts: t.Union[numpy.ndarray, t.Sequence[Vec3]]) -&gt; BBox3D:\n    \"\"\"Construct a BBox containing 'pts'.\"\"\"\n    pts = numpy.atleast_2d(pts).reshape(-1, 3)\n    return cls(numpy.nanmin(pts, axis=0), numpy.nanmax(pts, axis=0))\n</code></pre>"},{"location":"api/cell/","title":"<code>atomlib.cell</code>","text":"<p>Crystallographic unit cell.</p> <p>This module defines class:<code>structlib.HasCell</code> and the concrete class:<code>structlib.Cell</code>, the core types for dealing with crystallographic unit cells and their associated coordinate frames.</p>"},{"location":"api/cell/#atomlib.cell.CoordinateFrame","title":"<code>CoordinateFrame = t.Literal['cell', 'cell_frac', 'cell_box', 'ortho', 'ortho_frac', 'ortho_box', 'linear', 'local', 'global']</code>  <code>module-attribute</code>","text":"<p>A coordinate frame to use.</p> <ul> <li><code>cell</code>: Real-space units along crystal axes</li> <li><code>cell_frac</code>: Fraction of unit cells</li> <li><code>cell_box</code>: Fraction of cell box</li> <li><code>ortho</code>: Real-space units along orthogonal cell</li> <li><code>ortho_frac</code>: Fraction of orthogonal cell</li> <li><code>ortho_box</code>: Fraction of orthogonal box</li> <li><code>linear</code>: Angstroms in local coordinate system (without affine transformation)</li> <li><code>local</code>: Angstroms in local coordinate system (with affine transformation)</li> <li><code>global</code>: Angstroms in global coordinate system (with all transformations)</li> </ul> <p>For more information, see the documentation at Coordinate systems, or the example notebook at <code>examples/coords.ipynb</code>.</p>"},{"location":"api/cell/#atomlib.cell.HasCellT","title":"<code>HasCellT = t.TypeVar('HasCellT', bound='HasCell')</code>  <code>module-attribute</code>","text":""},{"location":"api/cell/#atomlib.cell.HasCell","title":"<code>HasCell</code>","text":"Source code in <code>atomlib/cell.py</code> <pre><code>class HasCell:\n    # abstract methods\n\n    @abc.abstractmethod\n    def get_cell(self) -&gt; Cell:\n        \"\"\"Get the cell contained in ``self``. This should be a low cost method.\"\"\"\n        ...\n\n    @abc.abstractmethod\n    def with_cell(self: HasCellT, cell: Cell) -&gt; HasCellT:\n        \"\"\"Replace the cell in ``self`` with ``cell``.\"\"\"\n        ...\n\n    # getters\n\n    @property\n    def affine(self) -&gt; AffineTransform3D:\n        \"\"\"\n        Affine transformation. Holds transformation from 'ortho' to 'local' coordinates,\n        including rotation away from the standard crystal orientation.\n        \"\"\"\n        return self.get_cell()._affine\n\n    @property\n    def ortho(self) -&gt; LinearTransform3D:\n        \"\"\"\n        Orthogonalization transformation. Skews but does not scale the crystal axes to cartesian axes.\n        \"\"\"\n        return self.get_cell()._ortho\n\n    @property\n    def metric(self) -&gt; LinearTransform3D:\n        r\"\"\"\n        Cell metric tensor\n\n        Returns the dot product between every combination of basis vectors.\n        :math:`\\mathbf{a} \\cdot \\mathbf{b} = a_i M_ij b_j`\n        \"\"\"\n        ortho = self.get_cell()._ortho.scale(self.cell_size)\n        return ortho.T @ ortho\n\n    @property\n    def cell_size(self) -&gt; NDArray[numpy.float_]:\n        \"\"\"Unit cell size.\"\"\"\n        return self.get_cell()._cell_size\n\n    @property\n    def cell_angle(self) -&gt; NDArray[numpy.float_]:\n        \"\"\"Unit cell angles, in radians.\"\"\"\n        return self.get_cell()._cell_angle\n\n    @property\n    def n_cells(self) -&gt; NDArray[numpy.int_]:\n        \"\"\"Number of unit cells.\"\"\"\n        return self.get_cell()._n_cells\n\n    @property\n    def pbc(self) -&gt; NDArray[numpy.bool_]:\n        \"\"\"Flags indicating the presence of periodic boundary conditions along each axis.\"\"\"\n        return self.get_cell()._pbc\n\n    @property\n    def ortho_size(self) -&gt; NDArray[numpy.float_]:\n        \"\"\"\n        Return size of orthogonal unit cell.\n\n        Equivalent to the diagonal of the orthogonalization matrix.\n        \"\"\"\n        return self.cell_size * numpy.diag(self.ortho.inner)\n\n    @property\n    def box_size(self) -&gt; NDArray[numpy.float_]:\n        \"\"\"\n        Return size of the cell box.\n\n        Equivalent to ``self.n_cells * self.cell_size``.\n        \"\"\"\n        return self.n_cells * self.cell_size\n\n    # get transforms\n\n    def _get_transform_to_local(self, frame: CoordinateFrame) -&gt; AffineTransform3D:\n        \"\"\"Get the transform from 'frame' to local coordinates.\"\"\"\n        frame = t.cast(CoordinateFrame, frame.lower())\n\n        if frame == 'local' or frame == 'global':\n            return LinearTransform3D()\n\n        if frame == 'linear':\n            return self.affine.to_translation()\n\n        if frame.startswith('cell'):\n            transform = self.affine @ self.ortho\n            cell_size = self.cell_size\n        elif frame.startswith('ortho'):\n            transform = self.affine\n            cell_size = self.ortho_size\n        else:\n            raise ValueError(f\"Unknown coordinate frame '{frame}'\")\n\n        if '_' not in frame:\n            return transform\n        end = frame.split('_', 2)[1]\n        if end == 'frac':\n            return transform @ LinearTransform3D.scale(cell_size)\n        if end == 'box':\n            return transform @ LinearTransform3D.scale(cell_size * self.n_cells)\n        raise ValueError(f\"Unknown coordinate frame '{frame}'\")\n\n    def get_transform(self, frame_to: t.Optional[CoordinateFrame] = None, frame_from: t.Optional[CoordinateFrame] = None) -&gt; AffineTransform3D:\n        \"\"\"\n        In the two-argument form, get the transform to 'frame_to' from 'frame_from'.\n        In the one-argument form, get the transform from local coordinates to 'frame'.\n        \"\"\"\n        transform_from = self._get_transform_to_local(frame_from) if frame_from is not None else AffineTransform3D()\n        transform_to = self._get_transform_to_local(frame_to) if frame_to is not None else AffineTransform3D()\n        if frame_from is not None and frame_to is not None and frame_from.lower() == frame_to.lower():\n            return AffineTransform3D()\n        return transform_to.inverse() @ transform_from\n\n    def corners(self, frame: CoordinateFrame = 'local') -&gt; numpy.ndarray:\n        corners = numpy.array(list(itertools.product((0., 1.), repeat=3)))\n        return self.get_transform(frame, 'cell_box') @ corners\n\n    def bbox_cell(self, frame: CoordinateFrame = 'local') -&gt; BBox3D:\n        \"\"\"Return the bounding box of the cell box in the given coordinate system.\"\"\"\n        return BBox3D.from_pts(self.corners(frame))\n\n    bbox = bbox_cell\n\n    def is_orthogonal(self, tol: float = 1e-8) -&gt; bool:\n        \"\"\"Returns whether this cell is orthogonal (axes are at right angles.)\"\"\"\n        return self.ortho.is_diagonal(tol=tol)\n\n    def is_orthogonal_in_local(self, tol: float = 1e-8) -&gt; bool:\n        \"\"\"Returns whether this cell is orthogonal and aligned with the local coordinate system.\"\"\"\n        transform = (self.affine @ self.ortho).to_linear()\n        if not transform.is_scaled_orthogonal(tol):\n            return False\n        normed = transform.inner / numpy.linalg.norm(transform.inner, axis=-2, keepdims=True)\n        # every row of transform must be a +/- 1 times a basis vector (i, j, or k)\n        return all(\n            any(numpy.isclose(numpy.abs(numpy.dot(row, v)), 1., atol=tol) for v in numpy.eye(3))\n            for row in normed\n        )\n\n    def _cell_size_in_local(self) -&gt; Vec3:\n        \"\"\"Calculate cell_size in the local coordinate system. Assumes ``self.is_orthogonal_in_local()``.\"\"\"\n        return numpy.abs(self.get_transform('local', 'ortho').transform_vec(self.cell_size))\n\n    def _box_size_in_local(self) -&gt; Vec3:\n        \"\"\"Calculate box_size in the local coordinate system. Assumes ``self.is_orthogonal_in_local()``.\"\"\"\n        return numpy.abs(self.get_transform('local', 'ortho').transform_vec(self.box_size))\n\n    def _n_cells_in_local(self) -&gt; NDArray[numpy.int_]:\n        \"\"\"Calculate n_cells after any local rotation. Assumes ``self.is_orthogonal_in_local()``.\"\"\"\n        return numpy.abs(numpy.round(self.get_transform('local', 'ortho').transform_vec(self.n_cells)).astype(int))\n\n    def to_ortho(self) -&gt; AffineTransform3D:\n        return self.get_transform('local', 'cell_box')\n\n    def transform_cell(self: HasCellT, transform: AffineTransform3D, frame: CoordinateFrame = 'local') -&gt; HasCellT:\n        \"\"\"\n        Apply the given transform to the unit cell, and return a new `Cell`.\n        The transform is applied in coordinate frame 'frame'.\n        Orthogonal and affine transformations are applied to the affine matrix component,\n        while skew and scaling is applied to the orthogonalization matrix/cell_size.\n        \"\"\"\n        transform = t.cast(AffineTransform3D, self.change_transform(transform, 'local', frame))\n        if not transform.to_linear().is_orthogonal():\n            raise NotImplementedError()\n        return self.with_cell(Cell(\n            affine=transform @ self.affine,\n            ortho=self.ortho,\n            cell_size=self.cell_size,\n            cell_angle=self.cell_angle,\n            n_cells=self.n_cells,\n            pbc=self.pbc,\n        ))\n\n    def strain_orthogonal(self: HasCellT) -&gt; HasCellT:\n        \"\"\"\n        Orthogonalize using strain.\n\n        Strain is applied such that the x-axis remains fixed, and the y-axis remains in the xy plane.\n        For small displacements, no hydrostatic strain is applied (volume is conserved).\n        \"\"\"\n        return self.with_cell(Cell(\n            affine=self.affine,\n            ortho=LinearTransform3D(),\n            cell_size=self.cell_size,\n            n_cells=self.n_cells,\n            pbc=self.pbc,\n        ))\n\n    def repeat(self: HasCellT, n: t.Union[int, VecLike]) -&gt; HasCellT:\n        \"\"\"Tile the cell by `n` in each dimension.\"\"\"\n        ns = numpy.broadcast_to(n, 3)\n        if not numpy.issubdtype(ns.dtype, numpy.integer):\n            raise ValueError(f\"repeat() argument must be an integer or integer array.\")\n        return self.with_cell(Cell(\n            affine=self.affine,\n            ortho=self.ortho,\n            cell_size=self.cell_size,\n            cell_angle=self.cell_angle,\n            n_cells=self.n_cells * numpy.broadcast_to(n, 3),\n            pbc = self.pbc | (ns &gt; 1)  # assume periodic along repeated directions\n        ))\n\n    def explode(self: HasCellT) -&gt; HasCellT:\n        \"\"\"Materialize repeated cells as one supercell.\"\"\"\n        return self.with_cell(Cell(\n            affine=self.affine,\n            ortho=self.ortho,\n            cell_size=self.cell_size*self.n_cells,\n            cell_angle=self.cell_angle,\n            pbc=self.pbc,\n        ))\n\n    def explode_z(self: HasCellT) -&gt; HasCellT:\n        \"\"\"Materialize repeated cells as one supercell in z.\"\"\"\n        return self.with_cell(Cell(\n            affine=self.affine,\n            ortho=self.ortho,\n            cell_size=self.cell_size*[1, 1, self.n_cells[2]],\n            n_cells=[*self.n_cells[:2], 1],\n            cell_angle=self.cell_angle,\n            pbc=self.pbc,\n        ))\n\n    def crop(self: HasCellT, x_min: float = -numpy.inf, x_max: float = numpy.inf,\n             y_min: float = -numpy.inf, y_max: float = numpy.inf,\n             z_min: float = -numpy.inf, z_max: float = numpy.inf, *,\n             frame: CoordinateFrame = 'local') -&gt; HasCellT:\n        \"\"\"\n        Crop 'cell' to the given extents. For a non-orthogonal\n        cell, this must be specified in cell coordinates. This\n        function implicity `explode`s the cell as well.\n        \"\"\"\n\n        if not frame.lower().startswith('cell'):\n            if not self.is_orthogonal():\n                raise ValueError(\"Cannot crop a non-orthogonal cell in orthogonal coordinates. Use crop_atoms instead.\")\n\n        min = to_vec3([x_min, y_min, z_min])\n        max = to_vec3([x_max, y_max, z_max])\n        (min, max) = self.get_transform('cell_box', frame).transform([min, max])\n        new_box = BBox3D(min, max) &amp; BBox3D.unit()\n        cropped = (new_box.min &gt; 0.) | (new_box.max &lt; 1.)\n\n        return self.with_cell(Cell(\n            affine=self.affine @ AffineTransform3D.translate(-new_box.min),\n            ortho=self.ortho,\n            cell_size=new_box.size * self.cell_size * numpy.where(cropped, self.n_cells, 1),\n            n_cells=numpy.where(cropped, 1, self.n_cells),\n            cell_angle=self.cell_angle,\n            pbc=self.pbc &amp; ~cropped  # remove periodicity along cropped directions\n        ))\n\n    @t.overload\n    def change_transform(self, transform: AffineTransform3D,\n                         frame_to: t.Optional[CoordinateFrame] = None,\n                         frame_from: t.Optional[CoordinateFrame] = None) -&gt; AffineTransform3D:\n        ...\n\n    @t.overload\n    def change_transform(self, transform: Transform3D,\n                         frame_to: t.Optional[CoordinateFrame] = None,\n                         frame_from: t.Optional[CoordinateFrame] = None) -&gt; Transform3D:\n        ...\n\n    def change_transform(self, transform: Transform3D,\n                         frame_to: t.Optional[CoordinateFrame] = None,\n                         frame_from: t.Optional[CoordinateFrame] = None) -&gt; Transform3D:\n        \"\"\"Coordinate-change a transformation to 'frame_to' from 'frame_from'.\"\"\"\n        if frame_to == frame_from and frame_to is not None:\n            return transform\n        coord_change = self.get_transform(frame_to, frame_from)\n        return coord_change @ transform @ coord_change.inverse()\n\n    def assert_equal(self, other: t.Any):\n        assert isinstance(other, HasCell) and type(self) == type(other)\n        numpy.testing.assert_array_almost_equal(self.affine.inner, other.affine.inner, 6)\n        numpy.testing.assert_array_almost_equal(self.ortho.inner, other.ortho.inner, 6)\n        numpy.testing.assert_array_almost_equal(self.cell_size, other.cell_size, 6)\n        numpy.testing.assert_array_equal(self.n_cells, other.n_cells)\n        numpy.testing.assert_array_equal(self.pbc, other.pbc)\n</code></pre>"},{"location":"api/cell/#atomlib.cell.HasCell.affine","title":"<code>affine: AffineTransform3D</code>  <code>property</code>","text":"<p>Affine transformation. Holds transformation from 'ortho' to 'local' coordinates, including rotation away from the standard crystal orientation.</p>"},{"location":"api/cell/#atomlib.cell.HasCell.ortho","title":"<code>ortho: LinearTransform3D</code>  <code>property</code>","text":"<p>Orthogonalization transformation. Skews but does not scale the crystal axes to cartesian axes.</p>"},{"location":"api/cell/#atomlib.cell.HasCell.metric","title":"<code>metric: LinearTransform3D</code>  <code>property</code>","text":"<p>Cell metric tensor</p> <p>Returns the dot product between every combination of basis vectors. :math:<code>\\mathbf{a} \\cdot \\mathbf{b} = a_i M_ij b_j</code></p>"},{"location":"api/cell/#atomlib.cell.HasCell.cell_size","title":"<code>cell_size: NDArray[numpy.float_]</code>  <code>property</code>","text":"<p>Unit cell size.</p>"},{"location":"api/cell/#atomlib.cell.HasCell.cell_angle","title":"<code>cell_angle: NDArray[numpy.float_]</code>  <code>property</code>","text":"<p>Unit cell angles, in radians.</p>"},{"location":"api/cell/#atomlib.cell.HasCell.n_cells","title":"<code>n_cells: NDArray[numpy.int_]</code>  <code>property</code>","text":"<p>Number of unit cells.</p>"},{"location":"api/cell/#atomlib.cell.HasCell.pbc","title":"<code>pbc: NDArray[numpy.bool_]</code>  <code>property</code>","text":"<p>Flags indicating the presence of periodic boundary conditions along each axis.</p>"},{"location":"api/cell/#atomlib.cell.HasCell.ortho_size","title":"<code>ortho_size: NDArray[numpy.float_]</code>  <code>property</code>","text":"<p>Return size of orthogonal unit cell.</p> <p>Equivalent to the diagonal of the orthogonalization matrix.</p>"},{"location":"api/cell/#atomlib.cell.HasCell.box_size","title":"<code>box_size: NDArray[numpy.float_]</code>  <code>property</code>","text":"<p>Return size of the cell box.</p> <p>Equivalent to <code>self.n_cells * self.cell_size</code>.</p>"},{"location":"api/cell/#atomlib.cell.HasCell.bbox","title":"<code>bbox = bbox_cell</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/cell/#atomlib.cell.HasCell.get_cell","title":"<code>get_cell()</code>  <code>abstractmethod</code>","text":"<p>Get the cell contained in <code>self</code>. This should be a low cost method.</p> Source code in <code>atomlib/cell.py</code> <pre><code>@abc.abstractmethod\ndef get_cell(self) -&gt; Cell:\n    \"\"\"Get the cell contained in ``self``. This should be a low cost method.\"\"\"\n    ...\n</code></pre>"},{"location":"api/cell/#atomlib.cell.HasCell.with_cell","title":"<code>with_cell(cell)</code>  <code>abstractmethod</code>","text":"<p>Replace the cell in <code>self</code> with <code>cell</code>.</p> Source code in <code>atomlib/cell.py</code> <pre><code>@abc.abstractmethod\ndef with_cell(self: HasCellT, cell: Cell) -&gt; HasCellT:\n    \"\"\"Replace the cell in ``self`` with ``cell``.\"\"\"\n    ...\n</code></pre>"},{"location":"api/cell/#atomlib.cell.HasCell.get_transform","title":"<code>get_transform(frame_to=None, frame_from=None)</code>","text":"<p>In the two-argument form, get the transform to 'frame_to' from 'frame_from'. In the one-argument form, get the transform from local coordinates to 'frame'.</p> Source code in <code>atomlib/cell.py</code> <pre><code>def get_transform(self, frame_to: t.Optional[CoordinateFrame] = None, frame_from: t.Optional[CoordinateFrame] = None) -&gt; AffineTransform3D:\n    \"\"\"\n    In the two-argument form, get the transform to 'frame_to' from 'frame_from'.\n    In the one-argument form, get the transform from local coordinates to 'frame'.\n    \"\"\"\n    transform_from = self._get_transform_to_local(frame_from) if frame_from is not None else AffineTransform3D()\n    transform_to = self._get_transform_to_local(frame_to) if frame_to is not None else AffineTransform3D()\n    if frame_from is not None and frame_to is not None and frame_from.lower() == frame_to.lower():\n        return AffineTransform3D()\n    return transform_to.inverse() @ transform_from\n</code></pre>"},{"location":"api/cell/#atomlib.cell.HasCell.corners","title":"<code>corners(frame='local')</code>","text":"Source code in <code>atomlib/cell.py</code> <pre><code>def corners(self, frame: CoordinateFrame = 'local') -&gt; numpy.ndarray:\n    corners = numpy.array(list(itertools.product((0., 1.), repeat=3)))\n    return self.get_transform(frame, 'cell_box') @ corners\n</code></pre>"},{"location":"api/cell/#atomlib.cell.HasCell.bbox_cell","title":"<code>bbox_cell(frame='local')</code>","text":"<p>Return the bounding box of the cell box in the given coordinate system.</p> Source code in <code>atomlib/cell.py</code> <pre><code>def bbox_cell(self, frame: CoordinateFrame = 'local') -&gt; BBox3D:\n    \"\"\"Return the bounding box of the cell box in the given coordinate system.\"\"\"\n    return BBox3D.from_pts(self.corners(frame))\n</code></pre>"},{"location":"api/cell/#atomlib.cell.HasCell.is_orthogonal","title":"<code>is_orthogonal(tol=1e-08)</code>","text":"<p>Returns whether this cell is orthogonal (axes are at right angles.)</p> Source code in <code>atomlib/cell.py</code> <pre><code>def is_orthogonal(self, tol: float = 1e-8) -&gt; bool:\n    \"\"\"Returns whether this cell is orthogonal (axes are at right angles.)\"\"\"\n    return self.ortho.is_diagonal(tol=tol)\n</code></pre>"},{"location":"api/cell/#atomlib.cell.HasCell.is_orthogonal_in_local","title":"<code>is_orthogonal_in_local(tol=1e-08)</code>","text":"<p>Returns whether this cell is orthogonal and aligned with the local coordinate system.</p> Source code in <code>atomlib/cell.py</code> <pre><code>def is_orthogonal_in_local(self, tol: float = 1e-8) -&gt; bool:\n    \"\"\"Returns whether this cell is orthogonal and aligned with the local coordinate system.\"\"\"\n    transform = (self.affine @ self.ortho).to_linear()\n    if not transform.is_scaled_orthogonal(tol):\n        return False\n    normed = transform.inner / numpy.linalg.norm(transform.inner, axis=-2, keepdims=True)\n    # every row of transform must be a +/- 1 times a basis vector (i, j, or k)\n    return all(\n        any(numpy.isclose(numpy.abs(numpy.dot(row, v)), 1., atol=tol) for v in numpy.eye(3))\n        for row in normed\n    )\n</code></pre>"},{"location":"api/cell/#atomlib.cell.HasCell.to_ortho","title":"<code>to_ortho()</code>","text":"Source code in <code>atomlib/cell.py</code> <pre><code>def to_ortho(self) -&gt; AffineTransform3D:\n    return self.get_transform('local', 'cell_box')\n</code></pre>"},{"location":"api/cell/#atomlib.cell.HasCell.transform_cell","title":"<code>transform_cell(transform, frame='local')</code>","text":"<p>Apply the given transform to the unit cell, and return a new <code>Cell</code>. The transform is applied in coordinate frame 'frame'. Orthogonal and affine transformations are applied to the affine matrix component, while skew and scaling is applied to the orthogonalization matrix/cell_size.</p> Source code in <code>atomlib/cell.py</code> <pre><code>def transform_cell(self: HasCellT, transform: AffineTransform3D, frame: CoordinateFrame = 'local') -&gt; HasCellT:\n    \"\"\"\n    Apply the given transform to the unit cell, and return a new `Cell`.\n    The transform is applied in coordinate frame 'frame'.\n    Orthogonal and affine transformations are applied to the affine matrix component,\n    while skew and scaling is applied to the orthogonalization matrix/cell_size.\n    \"\"\"\n    transform = t.cast(AffineTransform3D, self.change_transform(transform, 'local', frame))\n    if not transform.to_linear().is_orthogonal():\n        raise NotImplementedError()\n    return self.with_cell(Cell(\n        affine=transform @ self.affine,\n        ortho=self.ortho,\n        cell_size=self.cell_size,\n        cell_angle=self.cell_angle,\n        n_cells=self.n_cells,\n        pbc=self.pbc,\n    ))\n</code></pre>"},{"location":"api/cell/#atomlib.cell.HasCell.strain_orthogonal","title":"<code>strain_orthogonal()</code>","text":"<p>Orthogonalize using strain.</p> <p>Strain is applied such that the x-axis remains fixed, and the y-axis remains in the xy plane. For small displacements, no hydrostatic strain is applied (volume is conserved).</p> Source code in <code>atomlib/cell.py</code> <pre><code>def strain_orthogonal(self: HasCellT) -&gt; HasCellT:\n    \"\"\"\n    Orthogonalize using strain.\n\n    Strain is applied such that the x-axis remains fixed, and the y-axis remains in the xy plane.\n    For small displacements, no hydrostatic strain is applied (volume is conserved).\n    \"\"\"\n    return self.with_cell(Cell(\n        affine=self.affine,\n        ortho=LinearTransform3D(),\n        cell_size=self.cell_size,\n        n_cells=self.n_cells,\n        pbc=self.pbc,\n    ))\n</code></pre>"},{"location":"api/cell/#atomlib.cell.HasCell.repeat","title":"<code>repeat(n)</code>","text":"<p>Tile the cell by <code>n</code> in each dimension.</p> Source code in <code>atomlib/cell.py</code> <pre><code>def repeat(self: HasCellT, n: t.Union[int, VecLike]) -&gt; HasCellT:\n    \"\"\"Tile the cell by `n` in each dimension.\"\"\"\n    ns = numpy.broadcast_to(n, 3)\n    if not numpy.issubdtype(ns.dtype, numpy.integer):\n        raise ValueError(f\"repeat() argument must be an integer or integer array.\")\n    return self.with_cell(Cell(\n        affine=self.affine,\n        ortho=self.ortho,\n        cell_size=self.cell_size,\n        cell_angle=self.cell_angle,\n        n_cells=self.n_cells * numpy.broadcast_to(n, 3),\n        pbc = self.pbc | (ns &gt; 1)  # assume periodic along repeated directions\n    ))\n</code></pre>"},{"location":"api/cell/#atomlib.cell.HasCell.explode","title":"<code>explode()</code>","text":"<p>Materialize repeated cells as one supercell.</p> Source code in <code>atomlib/cell.py</code> <pre><code>def explode(self: HasCellT) -&gt; HasCellT:\n    \"\"\"Materialize repeated cells as one supercell.\"\"\"\n    return self.with_cell(Cell(\n        affine=self.affine,\n        ortho=self.ortho,\n        cell_size=self.cell_size*self.n_cells,\n        cell_angle=self.cell_angle,\n        pbc=self.pbc,\n    ))\n</code></pre>"},{"location":"api/cell/#atomlib.cell.HasCell.explode_z","title":"<code>explode_z()</code>","text":"<p>Materialize repeated cells as one supercell in z.</p> Source code in <code>atomlib/cell.py</code> <pre><code>def explode_z(self: HasCellT) -&gt; HasCellT:\n    \"\"\"Materialize repeated cells as one supercell in z.\"\"\"\n    return self.with_cell(Cell(\n        affine=self.affine,\n        ortho=self.ortho,\n        cell_size=self.cell_size*[1, 1, self.n_cells[2]],\n        n_cells=[*self.n_cells[:2], 1],\n        cell_angle=self.cell_angle,\n        pbc=self.pbc,\n    ))\n</code></pre>"},{"location":"api/cell/#atomlib.cell.HasCell.crop","title":"<code>crop(x_min=-numpy.inf, x_max=numpy.inf, y_min=-numpy.inf, y_max=numpy.inf, z_min=-numpy.inf, z_max=numpy.inf, *, frame='local')</code>","text":"<p>Crop 'cell' to the given extents. For a non-orthogonal cell, this must be specified in cell coordinates. This function implicity <code>explode</code>s the cell as well.</p> Source code in <code>atomlib/cell.py</code> <pre><code>def crop(self: HasCellT, x_min: float = -numpy.inf, x_max: float = numpy.inf,\n         y_min: float = -numpy.inf, y_max: float = numpy.inf,\n         z_min: float = -numpy.inf, z_max: float = numpy.inf, *,\n         frame: CoordinateFrame = 'local') -&gt; HasCellT:\n    \"\"\"\n    Crop 'cell' to the given extents. For a non-orthogonal\n    cell, this must be specified in cell coordinates. This\n    function implicity `explode`s the cell as well.\n    \"\"\"\n\n    if not frame.lower().startswith('cell'):\n        if not self.is_orthogonal():\n            raise ValueError(\"Cannot crop a non-orthogonal cell in orthogonal coordinates. Use crop_atoms instead.\")\n\n    min = to_vec3([x_min, y_min, z_min])\n    max = to_vec3([x_max, y_max, z_max])\n    (min, max) = self.get_transform('cell_box', frame).transform([min, max])\n    new_box = BBox3D(min, max) &amp; BBox3D.unit()\n    cropped = (new_box.min &gt; 0.) | (new_box.max &lt; 1.)\n\n    return self.with_cell(Cell(\n        affine=self.affine @ AffineTransform3D.translate(-new_box.min),\n        ortho=self.ortho,\n        cell_size=new_box.size * self.cell_size * numpy.where(cropped, self.n_cells, 1),\n        n_cells=numpy.where(cropped, 1, self.n_cells),\n        cell_angle=self.cell_angle,\n        pbc=self.pbc &amp; ~cropped  # remove periodicity along cropped directions\n    ))\n</code></pre>"},{"location":"api/cell/#atomlib.cell.HasCell.change_transform","title":"<code>change_transform(transform, frame_to=None, frame_from=None)</code>","text":"<p>Coordinate-change a transformation to 'frame_to' from 'frame_from'.</p> Source code in <code>atomlib/cell.py</code> <pre><code>def change_transform(self, transform: Transform3D,\n                     frame_to: t.Optional[CoordinateFrame] = None,\n                     frame_from: t.Optional[CoordinateFrame] = None) -&gt; Transform3D:\n    \"\"\"Coordinate-change a transformation to 'frame_to' from 'frame_from'.\"\"\"\n    if frame_to == frame_from and frame_to is not None:\n        return transform\n    coord_change = self.get_transform(frame_to, frame_from)\n    return coord_change @ transform @ coord_change.inverse()\n</code></pre>"},{"location":"api/cell/#atomlib.cell.HasCell.assert_equal","title":"<code>assert_equal(other)</code>","text":"Source code in <code>atomlib/cell.py</code> <pre><code>def assert_equal(self, other: t.Any):\n    assert isinstance(other, HasCell) and type(self) == type(other)\n    numpy.testing.assert_array_almost_equal(self.affine.inner, other.affine.inner, 6)\n    numpy.testing.assert_array_almost_equal(self.ortho.inner, other.ortho.inner, 6)\n    numpy.testing.assert_array_almost_equal(self.cell_size, other.cell_size, 6)\n    numpy.testing.assert_array_equal(self.n_cells, other.n_cells)\n    numpy.testing.assert_array_equal(self.pbc, other.pbc)\n</code></pre>"},{"location":"api/cell/#atomlib.cell.Cell","title":"<code>Cell</code>  <code>dataclass</code>","text":"<p>             Bases: <code>HasCell</code></p> <p>Internal class for representing the coordinate systems of a crystal.</p> <p>The overall transformation from crystal coordinates to real-space coordinates is is split into four transformations, applied from bottom to top. First is <code>n_cells</code>, which scales from fractions of a unit cell to fractions of a supercell. Next is <code>cell_size</code>, which scales to real-space units. <code>ortho</code> is an orthogonalization matrix, a det = 1 upper-triangular matrix which transforms crystal axes to an orthogonal coordinate system. Finally, <code>affine</code> contains any remaining transformations to the local coordinate system, which atoms are stored in.</p> Source code in <code>atomlib/cell.py</code> <pre><code>@dataclass(frozen=True, init=False)\nclass Cell(HasCell):\n    \"\"\"\n    Internal class for representing the coordinate systems of a crystal.\n\n    The overall transformation from crystal coordinates to real-space coordinates is\n    is split into four transformations, applied from bottom to top. First is ``n_cells``,\n    which scales from fractions of a unit cell to fractions of a supercell. Next is\n    ``cell_size``, which scales to real-space units. ``ortho`` is an orthogonalization\n    matrix, a det = 1 upper-triangular matrix which transforms crystal axes to\n    an orthogonal coordinate system. Finally, ``affine`` contains any remaining\n    transformations to the local coordinate system, which atoms are stored in.\n    \"\"\"\n\n    def get_cell(self) -&gt; Cell:\n        return self\n\n    def with_cell(self: Cell, cell: Cell) -&gt; Cell:\n        return cell\n\n    _affine: AffineTransform3D = AffineTransform3D()\n    \"\"\"\n    Affine transformation. Holds transformation from 'ortho' to 'local' coordinates,\n    including rotation away from the standard crystal orientation.\n    \"\"\"\n\n    _ortho: LinearTransform3D = LinearTransform3D()\n    \"\"\"\n    Orthogonalization transformation. Skews but does not scale the crystal axes to cartesian axes.\n    \"\"\"\n\n    _cell_size: NDArray[numpy.float_]\n    \"\"\"Unit cell size.\"\"\"\n    _cell_angle: NDArray[numpy.float_] = field(default_factory=lambda: numpy.full(3, numpy.pi/2.))\n    \"\"\"Unit cell angles, in radians.\"\"\"\n    _n_cells: NDArray[numpy.int_] = field(default_factory=lambda: numpy.ones(3, numpy.int_))\n    \"\"\"Number of unit cells.\"\"\"\n    _pbc: NDArray[numpy.bool_] = field(default_factory=lambda: numpy.ones(3, numpy.bool_))\n    \"\"\"Flags indicating the presence of periodic boundary conditions along each axis.\"\"\"\n\n    def __init__(self, *,\n        affine: t.Optional[AffineTransform3D] = None, ortho: t.Optional[LinearTransform3D] = None,\n        cell_size: VecLike, cell_angle: t.Optional[VecLike] = None,\n        n_cells: t.Optional[VecLike] = None, pbc: t.Optional[VecLike] = None):\n\n        object.__setattr__(self, '_affine', AffineTransform3D() if affine is None else affine)\n        object.__setattr__(self, '_ortho', LinearTransform3D() if ortho is None else ortho)\n        object.__setattr__(self, '_cell_size', to_vec3(cell_size))\n        object.__setattr__(self, '_cell_angle', numpy.full(3, numpy.pi/2.) if cell_angle is None else to_vec3(cell_angle))\n        object.__setattr__(self, '_n_cells', numpy.ones(3, numpy.int_) if n_cells is None else to_vec3(n_cells, numpy.int_))\n        object.__setattr__(self, '_pbc', numpy.ones(3, numpy.bool_) if pbc is None else to_vec3(pbc, numpy.bool_))\n\n    @staticmethod\n    def from_unit_cell(cell_size: VecLike, cell_angle: t.Optional[VecLike] = None, n_cells: t.Optional[VecLike] = None,\n                       pbc: t.Optional[VecLike] = None):\n        return Cell(\n            ortho=cell_to_ortho([1.]*3, cell_angle),\n            n_cells=to_vec3([1]*3 if n_cells is None else n_cells, numpy.int_),\n            cell_size=to_vec3(cell_size),\n            cell_angle=to_vec3([numpy.pi/2.]*3 if cell_angle is None else cell_angle),\n            pbc=pbc\n        )\n\n    @staticmethod\n    def from_ortho(ortho: AffineTransform3D, n_cells: t.Optional[VecLike] = None, pbc: t.Optional[VecLike] = None):\n        lin = ortho.to_linear()\n        # decompose into orthogonal and upper triangular\n        q, r = numpy.linalg.qr(lin.inner)\n\n        # flip QR decomposition so R has positive diagonals\n        signs = numpy.sign(numpy.diagonal(r))\n        # multiply flips to columns of Q, rows of R\n        q = q * signs; r = r * signs[:, None]\n        #numpy.testing.assert_allclose(q @ r, lin.inner)\n        if numpy.linalg.det(q) &lt; 0:\n            warn(\"Crystal is left-handed. This is currently unsupported, and may cause errors.\")\n            # currently, behavior is to leave `ortho` proper, and move the inversion into the affine transform\n\n        cell_size, cell_angle = ortho_to_cell(lin)\n        return Cell(\n            affine=LinearTransform3D(q).translate(ortho.translation()),\n            ortho=LinearTransform3D(r / cell_size).round_near_zero(),\n            cell_size=cell_size, cell_angle=cell_angle,\n            n_cells=to_vec3([1]*3 if n_cells is None else n_cells, numpy.int_),\n            pbc=pbc,\n        )\n\n    def __str__(self) -&gt; str:\n        return \"\\n\".join((\n            self.__class__.__name__,\n            f\"Cell size: {self.cell_size!r}\",\n            f\"Cell angle: {self.cell_angle!r}\",\n            f\"# cells: {self.n_cells!r}\",\n            f\"pbc: {self.pbc!r}\",\n        ))\n\n    def __repr__(self) -&gt; str:\n        return (\n            f\"{self.__class__.__name__}(\"\n            f\"ortho={self.ortho}, affine={self.affine}, cell_size={self.cell_size}, \"\n            f\"cell_angle={self.cell_angle}, n_cells={self.n_cells}, pbc={self.pbc})\"\n        )\n\n    def _repr_pretty_(self, p, cycle: bool) -&gt; None:\n        p.text(f\"{self.__class__.__name__}(...)\") if cycle else p.text(str(self))\n</code></pre>"},{"location":"api/cell/#atomlib.cell.Cell.affine","title":"<code>affine: AffineTransform3D</code>  <code>property</code>","text":"<p>Affine transformation. Holds transformation from 'ortho' to 'local' coordinates, including rotation away from the standard crystal orientation.</p>"},{"location":"api/cell/#atomlib.cell.Cell.ortho","title":"<code>ortho: LinearTransform3D</code>  <code>property</code>","text":"<p>Orthogonalization transformation. Skews but does not scale the crystal axes to cartesian axes.</p>"},{"location":"api/cell/#atomlib.cell.Cell.metric","title":"<code>metric: LinearTransform3D</code>  <code>property</code>","text":"<p>Cell metric tensor</p> <p>Returns the dot product between every combination of basis vectors. :math:<code>\\mathbf{a} \\cdot \\mathbf{b} = a_i M_ij b_j</code></p>"},{"location":"api/cell/#atomlib.cell.Cell.cell_size","title":"<code>cell_size: NDArray[numpy.float_]</code>  <code>property</code>","text":"<p>Unit cell size.</p>"},{"location":"api/cell/#atomlib.cell.Cell.cell_angle","title":"<code>cell_angle: NDArray[numpy.float_]</code>  <code>property</code>","text":"<p>Unit cell angles, in radians.</p>"},{"location":"api/cell/#atomlib.cell.Cell.n_cells","title":"<code>n_cells: NDArray[numpy.int_]</code>  <code>property</code>","text":"<p>Number of unit cells.</p>"},{"location":"api/cell/#atomlib.cell.Cell.pbc","title":"<code>pbc: NDArray[numpy.bool_]</code>  <code>property</code>","text":"<p>Flags indicating the presence of periodic boundary conditions along each axis.</p>"},{"location":"api/cell/#atomlib.cell.Cell.ortho_size","title":"<code>ortho_size: NDArray[numpy.float_]</code>  <code>property</code>","text":"<p>Return size of orthogonal unit cell.</p> <p>Equivalent to the diagonal of the orthogonalization matrix.</p>"},{"location":"api/cell/#atomlib.cell.Cell.box_size","title":"<code>box_size: NDArray[numpy.float_]</code>  <code>property</code>","text":"<p>Return size of the cell box.</p> <p>Equivalent to <code>self.n_cells * self.cell_size</code>.</p>"},{"location":"api/cell/#atomlib.cell.Cell.bbox","title":"<code>bbox = bbox_cell</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/cell/#atomlib.cell.Cell.get_transform","title":"<code>get_transform(frame_to=None, frame_from=None)</code>","text":"<p>In the two-argument form, get the transform to 'frame_to' from 'frame_from'. In the one-argument form, get the transform from local coordinates to 'frame'.</p> Source code in <code>atomlib/cell.py</code> <pre><code>def get_transform(self, frame_to: t.Optional[CoordinateFrame] = None, frame_from: t.Optional[CoordinateFrame] = None) -&gt; AffineTransform3D:\n    \"\"\"\n    In the two-argument form, get the transform to 'frame_to' from 'frame_from'.\n    In the one-argument form, get the transform from local coordinates to 'frame'.\n    \"\"\"\n    transform_from = self._get_transform_to_local(frame_from) if frame_from is not None else AffineTransform3D()\n    transform_to = self._get_transform_to_local(frame_to) if frame_to is not None else AffineTransform3D()\n    if frame_from is not None and frame_to is not None and frame_from.lower() == frame_to.lower():\n        return AffineTransform3D()\n    return transform_to.inverse() @ transform_from\n</code></pre>"},{"location":"api/cell/#atomlib.cell.Cell.corners","title":"<code>corners(frame='local')</code>","text":"Source code in <code>atomlib/cell.py</code> <pre><code>def corners(self, frame: CoordinateFrame = 'local') -&gt; numpy.ndarray:\n    corners = numpy.array(list(itertools.product((0., 1.), repeat=3)))\n    return self.get_transform(frame, 'cell_box') @ corners\n</code></pre>"},{"location":"api/cell/#atomlib.cell.Cell.bbox_cell","title":"<code>bbox_cell(frame='local')</code>","text":"<p>Return the bounding box of the cell box in the given coordinate system.</p> Source code in <code>atomlib/cell.py</code> <pre><code>def bbox_cell(self, frame: CoordinateFrame = 'local') -&gt; BBox3D:\n    \"\"\"Return the bounding box of the cell box in the given coordinate system.\"\"\"\n    return BBox3D.from_pts(self.corners(frame))\n</code></pre>"},{"location":"api/cell/#atomlib.cell.Cell.is_orthogonal","title":"<code>is_orthogonal(tol=1e-08)</code>","text":"<p>Returns whether this cell is orthogonal (axes are at right angles.)</p> Source code in <code>atomlib/cell.py</code> <pre><code>def is_orthogonal(self, tol: float = 1e-8) -&gt; bool:\n    \"\"\"Returns whether this cell is orthogonal (axes are at right angles.)\"\"\"\n    return self.ortho.is_diagonal(tol=tol)\n</code></pre>"},{"location":"api/cell/#atomlib.cell.Cell.is_orthogonal_in_local","title":"<code>is_orthogonal_in_local(tol=1e-08)</code>","text":"<p>Returns whether this cell is orthogonal and aligned with the local coordinate system.</p> Source code in <code>atomlib/cell.py</code> <pre><code>def is_orthogonal_in_local(self, tol: float = 1e-8) -&gt; bool:\n    \"\"\"Returns whether this cell is orthogonal and aligned with the local coordinate system.\"\"\"\n    transform = (self.affine @ self.ortho).to_linear()\n    if not transform.is_scaled_orthogonal(tol):\n        return False\n    normed = transform.inner / numpy.linalg.norm(transform.inner, axis=-2, keepdims=True)\n    # every row of transform must be a +/- 1 times a basis vector (i, j, or k)\n    return all(\n        any(numpy.isclose(numpy.abs(numpy.dot(row, v)), 1., atol=tol) for v in numpy.eye(3))\n        for row in normed\n    )\n</code></pre>"},{"location":"api/cell/#atomlib.cell.Cell.to_ortho","title":"<code>to_ortho()</code>","text":"Source code in <code>atomlib/cell.py</code> <pre><code>def to_ortho(self) -&gt; AffineTransform3D:\n    return self.get_transform('local', 'cell_box')\n</code></pre>"},{"location":"api/cell/#atomlib.cell.Cell.transform_cell","title":"<code>transform_cell(transform, frame='local')</code>","text":"<p>Apply the given transform to the unit cell, and return a new <code>Cell</code>. The transform is applied in coordinate frame 'frame'. Orthogonal and affine transformations are applied to the affine matrix component, while skew and scaling is applied to the orthogonalization matrix/cell_size.</p> Source code in <code>atomlib/cell.py</code> <pre><code>def transform_cell(self: HasCellT, transform: AffineTransform3D, frame: CoordinateFrame = 'local') -&gt; HasCellT:\n    \"\"\"\n    Apply the given transform to the unit cell, and return a new `Cell`.\n    The transform is applied in coordinate frame 'frame'.\n    Orthogonal and affine transformations are applied to the affine matrix component,\n    while skew and scaling is applied to the orthogonalization matrix/cell_size.\n    \"\"\"\n    transform = t.cast(AffineTransform3D, self.change_transform(transform, 'local', frame))\n    if not transform.to_linear().is_orthogonal():\n        raise NotImplementedError()\n    return self.with_cell(Cell(\n        affine=transform @ self.affine,\n        ortho=self.ortho,\n        cell_size=self.cell_size,\n        cell_angle=self.cell_angle,\n        n_cells=self.n_cells,\n        pbc=self.pbc,\n    ))\n</code></pre>"},{"location":"api/cell/#atomlib.cell.Cell.strain_orthogonal","title":"<code>strain_orthogonal()</code>","text":"<p>Orthogonalize using strain.</p> <p>Strain is applied such that the x-axis remains fixed, and the y-axis remains in the xy plane. For small displacements, no hydrostatic strain is applied (volume is conserved).</p> Source code in <code>atomlib/cell.py</code> <pre><code>def strain_orthogonal(self: HasCellT) -&gt; HasCellT:\n    \"\"\"\n    Orthogonalize using strain.\n\n    Strain is applied such that the x-axis remains fixed, and the y-axis remains in the xy plane.\n    For small displacements, no hydrostatic strain is applied (volume is conserved).\n    \"\"\"\n    return self.with_cell(Cell(\n        affine=self.affine,\n        ortho=LinearTransform3D(),\n        cell_size=self.cell_size,\n        n_cells=self.n_cells,\n        pbc=self.pbc,\n    ))\n</code></pre>"},{"location":"api/cell/#atomlib.cell.Cell.repeat","title":"<code>repeat(n)</code>","text":"<p>Tile the cell by <code>n</code> in each dimension.</p> Source code in <code>atomlib/cell.py</code> <pre><code>def repeat(self: HasCellT, n: t.Union[int, VecLike]) -&gt; HasCellT:\n    \"\"\"Tile the cell by `n` in each dimension.\"\"\"\n    ns = numpy.broadcast_to(n, 3)\n    if not numpy.issubdtype(ns.dtype, numpy.integer):\n        raise ValueError(f\"repeat() argument must be an integer or integer array.\")\n    return self.with_cell(Cell(\n        affine=self.affine,\n        ortho=self.ortho,\n        cell_size=self.cell_size,\n        cell_angle=self.cell_angle,\n        n_cells=self.n_cells * numpy.broadcast_to(n, 3),\n        pbc = self.pbc | (ns &gt; 1)  # assume periodic along repeated directions\n    ))\n</code></pre>"},{"location":"api/cell/#atomlib.cell.Cell.explode","title":"<code>explode()</code>","text":"<p>Materialize repeated cells as one supercell.</p> Source code in <code>atomlib/cell.py</code> <pre><code>def explode(self: HasCellT) -&gt; HasCellT:\n    \"\"\"Materialize repeated cells as one supercell.\"\"\"\n    return self.with_cell(Cell(\n        affine=self.affine,\n        ortho=self.ortho,\n        cell_size=self.cell_size*self.n_cells,\n        cell_angle=self.cell_angle,\n        pbc=self.pbc,\n    ))\n</code></pre>"},{"location":"api/cell/#atomlib.cell.Cell.explode_z","title":"<code>explode_z()</code>","text":"<p>Materialize repeated cells as one supercell in z.</p> Source code in <code>atomlib/cell.py</code> <pre><code>def explode_z(self: HasCellT) -&gt; HasCellT:\n    \"\"\"Materialize repeated cells as one supercell in z.\"\"\"\n    return self.with_cell(Cell(\n        affine=self.affine,\n        ortho=self.ortho,\n        cell_size=self.cell_size*[1, 1, self.n_cells[2]],\n        n_cells=[*self.n_cells[:2], 1],\n        cell_angle=self.cell_angle,\n        pbc=self.pbc,\n    ))\n</code></pre>"},{"location":"api/cell/#atomlib.cell.Cell.crop","title":"<code>crop(x_min=-numpy.inf, x_max=numpy.inf, y_min=-numpy.inf, y_max=numpy.inf, z_min=-numpy.inf, z_max=numpy.inf, *, frame='local')</code>","text":"<p>Crop 'cell' to the given extents. For a non-orthogonal cell, this must be specified in cell coordinates. This function implicity <code>explode</code>s the cell as well.</p> Source code in <code>atomlib/cell.py</code> <pre><code>def crop(self: HasCellT, x_min: float = -numpy.inf, x_max: float = numpy.inf,\n         y_min: float = -numpy.inf, y_max: float = numpy.inf,\n         z_min: float = -numpy.inf, z_max: float = numpy.inf, *,\n         frame: CoordinateFrame = 'local') -&gt; HasCellT:\n    \"\"\"\n    Crop 'cell' to the given extents. For a non-orthogonal\n    cell, this must be specified in cell coordinates. This\n    function implicity `explode`s the cell as well.\n    \"\"\"\n\n    if not frame.lower().startswith('cell'):\n        if not self.is_orthogonal():\n            raise ValueError(\"Cannot crop a non-orthogonal cell in orthogonal coordinates. Use crop_atoms instead.\")\n\n    min = to_vec3([x_min, y_min, z_min])\n    max = to_vec3([x_max, y_max, z_max])\n    (min, max) = self.get_transform('cell_box', frame).transform([min, max])\n    new_box = BBox3D(min, max) &amp; BBox3D.unit()\n    cropped = (new_box.min &gt; 0.) | (new_box.max &lt; 1.)\n\n    return self.with_cell(Cell(\n        affine=self.affine @ AffineTransform3D.translate(-new_box.min),\n        ortho=self.ortho,\n        cell_size=new_box.size * self.cell_size * numpy.where(cropped, self.n_cells, 1),\n        n_cells=numpy.where(cropped, 1, self.n_cells),\n        cell_angle=self.cell_angle,\n        pbc=self.pbc &amp; ~cropped  # remove periodicity along cropped directions\n    ))\n</code></pre>"},{"location":"api/cell/#atomlib.cell.Cell.change_transform","title":"<code>change_transform(transform, frame_to=None, frame_from=None)</code>","text":"<p>Coordinate-change a transformation to 'frame_to' from 'frame_from'.</p> Source code in <code>atomlib/cell.py</code> <pre><code>def change_transform(self, transform: Transform3D,\n                     frame_to: t.Optional[CoordinateFrame] = None,\n                     frame_from: t.Optional[CoordinateFrame] = None) -&gt; Transform3D:\n    \"\"\"Coordinate-change a transformation to 'frame_to' from 'frame_from'.\"\"\"\n    if frame_to == frame_from and frame_to is not None:\n        return transform\n    coord_change = self.get_transform(frame_to, frame_from)\n    return coord_change @ transform @ coord_change.inverse()\n</code></pre>"},{"location":"api/cell/#atomlib.cell.Cell.assert_equal","title":"<code>assert_equal(other)</code>","text":"Source code in <code>atomlib/cell.py</code> <pre><code>def assert_equal(self, other: t.Any):\n    assert isinstance(other, HasCell) and type(self) == type(other)\n    numpy.testing.assert_array_almost_equal(self.affine.inner, other.affine.inner, 6)\n    numpy.testing.assert_array_almost_equal(self.ortho.inner, other.ortho.inner, 6)\n    numpy.testing.assert_array_almost_equal(self.cell_size, other.cell_size, 6)\n    numpy.testing.assert_array_equal(self.n_cells, other.n_cells)\n    numpy.testing.assert_array_equal(self.pbc, other.pbc)\n</code></pre>"},{"location":"api/cell/#atomlib.cell.Cell.get_cell","title":"<code>get_cell()</code>","text":"Source code in <code>atomlib/cell.py</code> <pre><code>def get_cell(self) -&gt; Cell:\n    return self\n</code></pre>"},{"location":"api/cell/#atomlib.cell.Cell.with_cell","title":"<code>with_cell(cell)</code>","text":"Source code in <code>atomlib/cell.py</code> <pre><code>def with_cell(self: Cell, cell: Cell) -&gt; Cell:\n    return cell\n</code></pre>"},{"location":"api/cell/#atomlib.cell.Cell.from_unit_cell","title":"<code>from_unit_cell(cell_size, cell_angle=None, n_cells=None, pbc=None)</code>  <code>staticmethod</code>","text":"Source code in <code>atomlib/cell.py</code> <pre><code>@staticmethod\ndef from_unit_cell(cell_size: VecLike, cell_angle: t.Optional[VecLike] = None, n_cells: t.Optional[VecLike] = None,\n                   pbc: t.Optional[VecLike] = None):\n    return Cell(\n        ortho=cell_to_ortho([1.]*3, cell_angle),\n        n_cells=to_vec3([1]*3 if n_cells is None else n_cells, numpy.int_),\n        cell_size=to_vec3(cell_size),\n        cell_angle=to_vec3([numpy.pi/2.]*3 if cell_angle is None else cell_angle),\n        pbc=pbc\n    )\n</code></pre>"},{"location":"api/cell/#atomlib.cell.Cell.from_ortho","title":"<code>from_ortho(ortho, n_cells=None, pbc=None)</code>  <code>staticmethod</code>","text":"Source code in <code>atomlib/cell.py</code> <pre><code>@staticmethod\ndef from_ortho(ortho: AffineTransform3D, n_cells: t.Optional[VecLike] = None, pbc: t.Optional[VecLike] = None):\n    lin = ortho.to_linear()\n    # decompose into orthogonal and upper triangular\n    q, r = numpy.linalg.qr(lin.inner)\n\n    # flip QR decomposition so R has positive diagonals\n    signs = numpy.sign(numpy.diagonal(r))\n    # multiply flips to columns of Q, rows of R\n    q = q * signs; r = r * signs[:, None]\n    #numpy.testing.assert_allclose(q @ r, lin.inner)\n    if numpy.linalg.det(q) &lt; 0:\n        warn(\"Crystal is left-handed. This is currently unsupported, and may cause errors.\")\n        # currently, behavior is to leave `ortho` proper, and move the inversion into the affine transform\n\n    cell_size, cell_angle = ortho_to_cell(lin)\n    return Cell(\n        affine=LinearTransform3D(q).translate(ortho.translation()),\n        ortho=LinearTransform3D(r / cell_size).round_near_zero(),\n        cell_size=cell_size, cell_angle=cell_angle,\n        n_cells=to_vec3([1]*3 if n_cells is None else n_cells, numpy.int_),\n        pbc=pbc,\n    )\n</code></pre>"},{"location":"api/cell/#atomlib.cell.cell_to_ortho","title":"<code>cell_to_ortho(cell_size, cell_angle=None)</code>","text":"<p>Get orthogonalization transform from unit cell parameters (which turns fractional cell coordinates into real-space coordinates). .</p> Source code in <code>atomlib/cell.py</code> <pre><code>def cell_to_ortho(cell_size: VecLike, cell_angle: t.Optional[VecLike] = None) -&gt; LinearTransform3D:\n    \"\"\"\n    Get orthogonalization transform from unit cell parameters (which turns fractional cell coordinates into real-space coordinates).\n    .\"\"\"\n    (a, b, c) = _validate_cell_size(cell_size)\n    cell_angle = _validate_cell_angle(cell_angle)\n\n    if numpy.allclose(cell_angle.view(numpy.ndarray), numpy.pi/2.):\n        return LinearTransform3D.scale(a, b, c)\n\n    (alpha, beta, gamma) = cell_angle\n    alphastar = numpy.cos(beta) * numpy.cos(gamma) - numpy.cos(alpha)\n    alphastar /= numpy.sin(beta) * numpy.sin(gamma)\n    alphastar = numpy.arccos(alphastar)\n    assert not numpy.isnan(alphastar)\n\n    # aligns a axis along x\n    # aligns b axis in the x-y plane\n    return LinearTransform3D(numpy.array([\n        [a,  b * numpy.cos(gamma),  c * numpy.cos(beta)],\n        [0.,  b * numpy.sin(gamma), -c * numpy.sin(beta) * numpy.cos(alphastar)],\n        [0.,  0.,                     c * numpy.sin(beta) * numpy.sin(alphastar)],\n    ], dtype=float)).round_near_zero()\n</code></pre>"},{"location":"api/cell/#atomlib.cell.ortho_to_cell","title":"<code>ortho_to_cell(ortho)</code>","text":"<p>Get unit cell parameters (cell_size, cell_angle) from orthogonalization transform.</p> Source code in <code>atomlib/cell.py</code> <pre><code>def ortho_to_cell(ortho: LinearTransform3D) -&gt; t.Tuple[Vec3, Vec3]:\n    \"\"\"Get unit cell parameters (cell_size, cell_angle) from orthogonalization transform.\"\"\"\n    # TODO suspect\n    cell_size = numpy.linalg.norm(ortho.inner, axis=-2)\n    cell_size = _validate_cell_size(cell_size)\n    normed = ortho.inner / cell_size\n    cosines = numpy.array([\n        numpy.dot(normed[..., 1], normed[..., 2]), # alpha\n        numpy.dot(normed[..., 2], normed[..., 0]), # beta\n        numpy.dot(normed[..., 0], normed[..., 1]), # gamma\n    ])\n    cell_angle = numpy.arccos(cosines)\n    cell_angle = _validate_cell_angle(cell_angle)\n\n    return (cell_size, cell_angle)\n</code></pre>"},{"location":"api/cell/#atomlib.cell.plane_to_zone","title":"<code>plane_to_zone(metric, plane, reduce=True)</code>","text":"<p>Return the zone axis associated with a given crystallographic plane. If <code>reduce</code> is True, call <code>reduce_vec</code> before returning. Otherwise, return a unit vector.</p> Source code in <code>atomlib/cell.py</code> <pre><code>def plane_to_zone(metric: LinearTransform3D, plane: VecLike, reduce: bool = True) -&gt; Vec3:\n    \"\"\"\n    Return the zone axis associated with a given crystallographic plane.\n    If `reduce` is True, call `reduce_vec` before returning. Otherwise,\n    return a unit vector.\n    \"\"\"\n\n    plane = to_vec3(plane)\n    if metric.is_orthogonal():\n        return plane\n\n    # reciprocal lattice is transpose of inverse of real lattice\n    # [b1 b2 b3]^T = [a1 a2 a3]^-1\n    # so real indices [uvw] = O^-1 O^-1^T (hkl)\n    # O^-1 O^-1^T = (O^T O)^-1 = M^-1\n    # in other words, we are raising the index of the tensor,\n    # converting a covector into a vector\n    zone = metric.inverse() @ plane\n\n    if reduce:\n        return to_vec3(reduce_vec(zone))\n    # otherwise reduce to unit vector\n    return zone / float(numpy.linalg.norm(zone))\n</code></pre>"},{"location":"api/cell/#atomlib.cell.zone_to_plane","title":"<code>zone_to_plane(metric, zone, reduce=True)</code>","text":"<p>Return the crystallographic plane associated with a given zone axis. If <code>reduce</code> is True, call <code>reduce_vec</code> before returning. Otherwise, return a unit vector.</p> Source code in <code>atomlib/cell.py</code> <pre><code>def zone_to_plane(metric: LinearTransform3D, zone: VecLike, reduce: bool = True) -&gt; Vec3:\n    \"\"\"\n    Return the crystallographic plane associated with a given zone axis.\n    If `reduce` is True, call `reduce_vec` before returning. Otherwise,\n    return a unit vector.\n    \"\"\"\n\n    zone = to_vec3(zone)\n    if metric.is_orthogonal():\n        return zone\n\n    plane = metric @ zone\n\n    if reduce:\n        return to_vec3(reduce_vec(plane))\n    # otherwise reduce to unit vector\n    return plane / float(numpy.linalg.norm(plane))\n</code></pre>"},{"location":"api/defect/","title":"<code>atomlib.defect</code>","text":"<p>A collection of functions for inserting dislocations into structures.</p>"},{"location":"api/defect/#atomlib.defect.CutType","title":"<code>CutType = t.Literal['shift', 'add', 'rm']</code>  <code>module-attribute</code>","text":"<p>Cut plane to use when creating a (non-screw) dislocation.</p>"},{"location":"api/defect/#atomlib.defect.ellip_pi","title":"<code>ellip_pi(n, m)</code>","text":"<p>Complete elliptic integral of the third kind, \\(\\Pi(n | m)\\).</p> <p>Follows the definition of Wolfram Mathworld.</p> Source code in <code>atomlib/defect.py</code> <pre><code>def ellip_pi(n: NDArray[numpy.float_], m: NDArray[numpy.float_]) -&gt; NDArray[numpy.float_]:\n    \"\"\"\n    Complete elliptic integral of the third kind, $\\\\Pi(n | m)$.\n\n    Follows the definition of [Wolfram Mathworld][wolfram_ellip_pi].\n\n    [wolfram_ellip_pi]: https://mathworld.wolfram.com/EllipticIntegraloftheThirdKind.html\n    \"\"\"\n    from scipy.special import elliprf, elliprj\n\n    y = 1 - m\n    assert numpy.all(y &gt; 0)\n\n    rf = elliprf(0, y, 1)\n    rj = elliprj(0, y, 1, 1 - n)\n    return rf + rj * n / 3\n</code></pre>"},{"location":"api/defect/#atomlib.defect.stacking_fault","title":"<code>stacking_fault(atoms, pos, shift, plane)</code>","text":"<p>Add a stacking fault to the structure.</p> <p>The fault plane will pass through the position <code>pos</code>, with normal <code>plane</code>. Atoms above <code>plane</code> will be shifted by the vector <code>shift</code>.</p> <p>If there is a component of <code>shift</code> parallel to <code>plane</code>, applying the shift will create (or remove) volume. In this case, atoms are added (or removed) accordingly. If <code>shift</code> \\(\\cdot\\) <code>plane</code> is positive, atoms are added.</p> <p>In general, adding a stacking fault will not preserve a cell's periodicity. Please verify this for your usecase.</p> <p>Parameters:</p> Name Type Description Default <code>atoms</code> <code>HasAtomsT</code> <p>Structure to add fault to</p> required <code>pos</code> <code>VecLike</code> <p>Position on fault plane</p> required <code>shift</code> <code>VecLike</code> <p>Vector to shift by</p> required <code>plane</code> <code>VecLike</code> <p>Normal to fault plane</p> required <p>Returns:</p> Type Description <code>HasAtomsT</code> <p>Structure with a stacking fault added</p> Source code in <code>atomlib/defect.py</code> <pre><code>def stacking_fault(atoms: HasAtomsT, pos: VecLike, shift: VecLike, plane: VecLike) -&gt; HasAtomsT:\n    \"\"\"\n    Add a stacking fault to the structure.\n\n    The fault plane will pass through the position `pos`, with normal `plane`.\n    Atoms above `plane` will be shifted by the vector `shift`.\n\n    If there is a component of `shift` parallel to `plane`, applying the shift\n    will create (or remove) volume. In this case, atoms are added (or removed)\n    accordingly. If `shift` $\\\\cdot$ `plane` is positive, atoms are added.\n\n    In general, adding a stacking fault will not preserve a cell's periodicity.\n    Please verify this for your usecase.\n\n    Args:\n      atoms: Structure to add fault to\n      pos: Position on fault plane\n      shift: Vector to shift by\n      plane: Normal to fault plane\n\n    Returns:\n      Structure with a stacking fault added\n    \"\"\"\n    pos = to_vec3(pos)\n    shift = to_vec3(shift)\n    plane = to_vec3(plane)\n    plane /= numpy.linalg.norm(plane)\n\n    coords = atoms.coords(frame='local')  # type: ignore\n\n    perp_dist = numpy.dot(coords - pos, plane)\n    atoms = atoms.with_columns(perp_dist=polars.Series(perp_dist)) \\\n        .with_columns(branch=polars.col('perp_dist') &gt; 0.)\n\n    d = numpy.dot(shift, plane)\n    if -d &gt; 1e-8:\n        logging.info(\"Removing atoms.\")\n        old_len = len(atoms)\n        atoms = atoms.filter(\n            (polars.col('perp_dist') &lt; 0) | (polars.col('perp_dist') &gt;= -d)\n        )\n        logging.info(f\"Removed {old_len - len(atoms)} atoms\")\n    if d &gt; 1e-8:\n        logging.info(\"Duplicating atoms.\")\n        duplicate = atoms.filter(\n            (polars.col('perp_dist') &gt;= -d) &amp; (polars.col('perp_dist') &lt; 0)\n        ).with_columns(~polars.col('branch'))\n        logging.info(f\"Duplicated {len(duplicate)} atoms\")\n\n        atoms = atoms.with_atoms(Atoms.concat((atoms, duplicate)))\n\n    coords = atoms.coords(frame='local')\n    branch = atoms['branch'].to_numpy()\n    atoms = atoms.with_coords(coords + shift * branch[:, None], frame='local')\n    return atoms.with_atoms(Atoms(atoms.drop('perp_dist', 'branch')))\n</code></pre>"},{"location":"api/defect/#atomlib.defect.disloc_edge","title":"<code>disloc_edge(atoms, center, b, t, cut='shift', *, poisson=0.25)</code>","text":"<p>Add a Volterra edge dislocation to the structure.</p> <p>The dislocation will pass through <code>center</code>, with line vector <code>t</code> and Burgers vector <code>b</code>. <code>t</code> will be modified such that it is perpendicular to <code>b</code>.</p> <p>The <code>cut</code> parameter defines the cut (discontinuity) plane used to displace the atoms. By default, <code>cut</code> is <code>'shift'</code>, which defines the cut plane to contain <code>b</code>, ensuring no atoms need to be added or removed. Instead, <code>'add'</code> or <code>'rm'</code> may be specified, which defines the cut plane as containing \\(\\mathbf{b} \\times \\mathbf{t}\\). In this mode, atoms will be added or removed in the plane of <code>b</code> to create the dislocation. Alternatively, a vector <code>cut</code> may be supplied. The cut plane will contain this vector.</p> <p>In the coordinate system where <code>t</code> is along \\(z\\), and <code>b</code> is along \\(+x\\), the displacement due to the edge dislocation can be calculated as follows:</p> \\[\\begin{align}    u_x &amp;= \\frac{b}{2\\pi} \\left( \\arctan(x, y) + \\frac{x y}{2(x^2 + y^2)(1-\\nu)} \\right) \\\\    u_y &amp;= -\\frac{b}{4(1-\\nu)} \\left( (1-2\\nu) \\ln(x^2 + y^2) + \\frac{x^2 - y^2}{x^2 + y^2} \\right) \\end{align}\\] <p>Where \\(x\\) and \\(y\\) are distances from the dislocation center. This creates a discontinuity along the \\(-x\\) axis. This coordinate system is rotated to support branches along an arbitrary axis.</p> <p>The dislocation is defined by the FS/RH convention: Performing one loop of positive sense relative to the tangent vector displaces the real crystal one <code>b</code> relative to a reference crystal.</p> <p>Parameters:</p> Name Type Description Default <code>atoms</code> <code>HasAtomsT</code> <p>Structure to add edge dislocation to</p> required <code>center</code> <code>VecLike</code> <p>Position on dislocation line</p> required <code>b</code> <code>VecLike</code> <p>Burgers vector of dislocation (FS/RH convention)</p> required <code>t</code> <code>VecLike</code> <p>Tangent vector of dislocation</p> required <code>cut</code> <code>Union[CutType, VecLike]</code> <p>Cut plane to create dislocation on</p> <code>'shift'</code> <code>poisson</code> <code>float</code> <p>Poisson ratio of material</p> <code>0.25</code> <p>Returns:</p> Type Description <code>HasAtomsT</code> <p>Structure with an edge dislocation added</p> Source code in <code>atomlib/defect.py</code> <pre><code>def disloc_edge(atoms: HasAtomsT, center: VecLike, b: VecLike, t: VecLike, cut: t.Union[CutType, VecLike] = 'shift',\n                *, poisson: float = 0.25) -&gt; HasAtomsT:\n    r\"\"\"\n    Add a Volterra edge dislocation to the structure.\n\n    The dislocation will pass through `center`, with line vector `t` and Burgers vector `b`.\n    `t` will be modified such that it is perpendicular to `b`.\n\n    The `cut` parameter defines the cut (discontinuity) plane used to displace the atoms.\n    By default, `cut` is `'shift'`, which defines the cut plane to contain `b`, ensuring no atoms\n    need to be added or removed.\n    Instead, `'add'` or `'rm'` may be specified, which defines the cut plane as containing\n    $\\mathbf{b} \\times \\mathbf{t}$. In this mode, atoms will be added or removed\n    in the plane of `b` to create the dislocation. Alternatively, a vector `cut`\n    may be supplied. The cut plane will contain this vector.\n\n    In the coordinate system where `t` is along $z$, and `b` is along $+x$, the displacement\n    due to the edge dislocation can be calculated as follows:\n\n    $$\\begin{align}\n       u_x &amp;= \\frac{b}{2\\pi} \\left( \\arctan(x, y) + \\frac{x y}{2(x^2 + y^2)(1-\\nu)} \\right) \\\\\n       u_y &amp;= -\\frac{b}{4(1-\\nu)} \\left( (1-2\\nu) \\ln(x^2 + y^2) + \\frac{x^2 - y^2}{x^2 + y^2} \\right)\n    \\end{align}$$\n\n    Where $x$ and $y$ are distances from the dislocation center. This creates a discontinuity along\n    the $-x$ axis. This coordinate system is rotated to support branches along an arbitrary axis.\n\n    The dislocation is defined by the FS/RH convention: Performing one loop of positive sense\n    relative to the tangent vector displaces the real crystal one `b` relative to a reference\n    crystal.\n\n    Args:\n      atoms: Structure to add edge dislocation to\n      center: Position on dislocation line\n      b: Burgers vector of dislocation (FS/RH convention)\n      t: Tangent vector of dislocation\n      cut: Cut plane to create dislocation on\n      poisson: Poisson ratio of material\n\n    Returns:\n      Structure with an edge dislocation added\n    \"\"\"\n\n    center = to_vec3(center)\n    b_vec = to_vec3(b)\n    #b_mag = norm(b_vec)\n\n    # get component of t perpendicular to b, normalize\n    t = to_vec3(t)\n    t = perp(t, b)\n    if norm(t) &lt; 1e-10:\n        raise ValueError(\"`b` and `t` must be different.\")\n    t /= norm(t)\n\n    if isinstance(cut, str):\n        cut = cast(CutType, cut.lower())\n        if cut == 'shift':\n            plane_v = b_vec.copy()\n        elif cut == 'add':\n            # FS/RH convention: t x b points to extra half plane\n            plane_v = numpy.cross(t, b_vec)\n        elif cut == 'rm':\n            plane_v = -numpy.cross(t, b_vec)\n        else:\n            raise ValueError(f\"Unknown cut plane type `{cut}`. Expected 'shift', 'add', 'rm', or a vector.\")\n        plane_v /= norm(plane_v)\n    else:\n        plane_v = to_vec3(cut)\n        plane_v = plane_v / norm(plane_v)\n        if numpy.linalg.norm(numpy.cross(plane_v, t)) &lt; 1e-10:\n            raise ValueError('`cut` and `t` must be different.')\n\n    # translate center to 0., and align t to [0, 0, 1], plane to +y\n    transform = AffineTransform3D.translate(center).inverse().compose(\n        LinearTransform3D.align_to(t, [0., 0., 1.], plane_v, [-1., 0., 0.])\n    )\n    frame = atoms.get_atoms('local').transform(transform)\n    b_vec = transform.transform_vec(b_vec)\n\n    d = numpy.dot(b_vec, [0., 1., 0.])\n    if -d &gt; 1e-8:\n        logging.info(\"Removing atoms.\")\n        old_len = len(frame)\n        frame = frame.filter(~(\n            (polars.col('coords').arr.get(0) &lt; 0)\n            &amp; (polars.col('coords').arr.get(1) &gt;= d/2.)\n            &amp; (polars.col('coords').arr.get(1) &lt;= -d/2.)\n        ))\n        logging.info(f\"Removed {old_len - len(frame)} atoms\")\n    if d &gt; 1e-8:\n        logging.info(\"Duplicating atoms.\")\n        duplicate = frame.filter(\n            (polars.col('coords').arr.get(0) &lt; 0)\n            &amp; (polars.col('coords').arr.get(1) &gt;= -d/2.)\n            &amp; (polars.col('coords').arr.get(1) &lt;= d/2.)\n        )\n        logging.info(f\"Duplicated {len(duplicate)} atoms\")\n\n        frame = Atoms.concat((frame, duplicate))\n        #atoms = atoms._replace_atoms(frame)\n        branch = numpy.ones(len(frame), dtype=float)\n        if len(duplicate) &gt; 0:\n            branch[-len(duplicate):] *= -1  # flip branch of duplicated atoms\n    else:\n        branch = numpy.ones(len(frame), dtype=float)\n\n    pts = frame.coords()\n\n    x, y, _ = split_arr(pts, axis=-1)\n    r2 = x**2 + y**2\n\n    # displacement parallel and perpendicular to b\n    d_para = branch * numpy.arctan2(y, x) + x*y/(2*(1-poisson)*r2)\n    d_perp = -(1-2*poisson)/(4*(1-poisson)) * numpy.log(r2) + (y**2 - x**2)/(4*(1-poisson)*r2)\n\n    disps = numpy.stack([\n        d_para * b_vec[0] + d_perp * b_vec[1],\n        d_perp * b_vec[0] + d_para * b_vec[1],\n        numpy.zeros_like(x)\n    ], axis=-1) / (2*numpy.pi)\n\n    return atoms.with_atoms(frame.with_coords(pts + disps).transform(transform.inverse()), 'local')\n</code></pre>"},{"location":"api/defect/#atomlib.defect.disloc_screw","title":"<code>disloc_screw(atoms, center, b, cut=None, sign=True)</code>","text":"<p>Add a Volterra screw dislocation to the structure.</p> <p>The dislocation will pass through <code>center</code>, with Burgers vector <code>b</code>.</p> <p>The <code>cut</code> parameter defines the cut (discontinuity) plane used to displace the atoms. By default, <code>cut</code> is chosen automtically, but it may also be specified as a vector which points from the dislocation core towards the cut plane (not normal to the cut plane!)</p> <p>The screw dislocation in an isotropic medium has a particularily simple form, given by:</p> \\[    \\mathbf{u} = \\frac{\\mathbf{b}}{2\\pi} \\arctan(x, y) \\] <p>for a dislocation along \\(+z\\) with cut plane along \\(-x\\). To support arbitrary cut planes, \\(x\\) and \\(y\\) are replaced by the components of \\(r\\) parallel and perpendicular to the cut plane, evaluated in the plane of <code>b</code>.</p> <p>The dislocation is defined by the FS/RH convention: Performing one loop of positive sense relative to the tangent vector displaces the real crystal one <code>b</code> relative to a reference crystal.</p> <p>Parameters:</p> Name Type Description Default <code>atoms</code> <code>HasAtomsT</code> <p>Structure to add screw dislocation to</p> required <code>center</code> <code>VecLike</code> <p>Position on dislocation line</p> required <code>b</code> <code>VecLike</code> <p>Burgers vector of dislocation (FS/RH convention)</p> required <code>cut</code> <code>Optional[VecLike]</code> <p>Cut plane to create dislocation on</p> <code>None</code> <code>sign</code> <code>bool</code> <p>Sign of screw dislocation (True means positive)</p> <code>True</code> <p>Returns:</p> Type Description <code>HasAtomsT</code> <p>Structure with a screw dislocation added</p> Source code in <code>atomlib/defect.py</code> <pre><code>def disloc_screw(atoms: HasAtomsT, center: VecLike, b: VecLike, cut: t.Optional[VecLike] = None,\n                 sign: bool = True) -&gt; HasAtomsT:\n    r\"\"\"\n    Add a Volterra screw dislocation to the structure.\n\n    The dislocation will pass through `center`, with Burgers vector `b`.\n\n    The `cut` parameter defines the cut (discontinuity) plane used to displace the atoms.\n    By default, `cut` is chosen automtically, but it may also be specified as a vector\n    which points from the dislocation core towards the cut plane (not normal to the cut plane!)\n\n    The screw dislocation in an isotropic medium has a particularily simple form, given by:\n\n    $$\n       \\mathbf{u} = \\frac{\\mathbf{b}}{2\\pi} \\arctan(x, y)\n    $$\n\n    for a dislocation along $+z$ with cut plane along $-x$. To support arbitrary cut planes,\n    $x$ and $y$ are replaced by the components of $r$ parallel and perpendicular to the cut plane,\n    evaluated in the plane of `b`.\n\n    The dislocation is defined by the FS/RH convention: Performing one loop of positive sense\n    relative to the tangent vector displaces the real crystal one `b` relative to a reference\n    crystal.\n\n    Args:\n      atoms: Structure to add screw dislocation to\n      center: Position on dislocation line\n      b: Burgers vector of dislocation (FS/RH convention)\n      cut: Cut plane to create dislocation on\n      sign: Sign of screw dislocation (True means positive)\n\n    Returns:\n      Structure with a screw dislocation added\n    \"\"\"\n\n    center = to_vec3(center)\n    b_vec = to_vec3(b)\n    t = b_vec / float(numpy.linalg.norm(b_vec))\n    t = -t if not sign else t\n    if cut is None:\n        if numpy.linalg.norm(numpy.cross(t, [1., 1., 1.])) &lt; numpy.pi/4:\n            # near 111, choose x as cut plane direction\n            cut = to_vec3([1., 0., 0.])\n        else:\n            # otherwise find plane by rotating around 111\n            cut = cast(NDArray[numpy.float_], LinearTransform3D.rotate([1., 1., 1.], 2*numpy.pi/3).transform(t))\n    else:\n        cut = to_vec3(cut)\n        cut /= norm(cut)\n        if numpy.allclose(cut, t, atol=1e-2):\n            raise ValueError(\"`t` and `cut` must be different.\")\n\n    print(f\"Cut plane direction: {cut}\")\n\n    frame = atoms.get_atoms('local')\n    pts = frame.coords() - center\n\n    # components perpendicular to t\n    cut_perp = -perp(cut, t)\n    pts_perp = perp(pts, t)\n\n    # signed angle around dislocation\n    theta = numpy.arctan2(dot(t, numpy.cross(cut_perp, pts_perp)), dot(cut_perp, pts_perp))\n    # FS/RH convention\n    disp = b_vec * (theta / (2*numpy.pi))\n\n    return atoms.with_atoms(frame.with_coords(pts + center + disp), 'local')\n</code></pre>"},{"location":"api/defect/#atomlib.defect.disloc_loop_z","title":"<code>disloc_loop_z(atoms, center, b, loop_r, *, poisson=0.25)</code>","text":"<p>Add a circular dislocation loop to the structure, assuming an elastically isotropic material.</p> <p>The loop will have radius <code>loop_r</code>, be centered at <code>center</code>, and oriented along the z-axis.</p> <p>The dislocation's sign is defined such that travelling upwards through the loop results in a displacement of <code>b</code>. <code>poisson</code> is the material's poisson ratio, which affects the shape of dislocations with an edge component.</p> <p>Adding the loop creates (or removes) a volume of \\(\\mathbf{b} \\cdot \\mathbf{n}A\\), where \\(\\mathbf{n}A\\) is the loop's normal times its area. Consequently, this function adds or remove atoms to effect this volume change.</p> <p>Parameters:</p> Name Type Description Default <code>atoms</code> <code>HasAtomsT</code> <p>Structure to add dislocation loop to</p> required <code>center</code> <code>VecLike</code> <p>Center of dislocation loop</p> required <code>b</code> <code>VecLike</code> <p>Burgers vector of dislocation (defined so travelling upwards leads to a plastic displacment of <code>b</code>).</p> required <code>loop_r</code> <code>float</code> <p>Radius of dislocation loop</p> required <code>poisson</code> <code>float</code> <p>Poisson ratio of material</p> <code>0.25</code> <p>Returns:</p> Type Description <code>HasAtomsT</code> <p>Structure with a dislocation loop added</p> Source code in <code>atomlib/defect.py</code> <pre><code>def disloc_loop_z(atoms: HasAtomsT, center: VecLike, b: VecLike,\n                  loop_r: float, *, poisson: float = 0.25) -&gt; HasAtomsT:\n    r\"\"\"\n    Add a circular dislocation loop to the structure, assuming an elastically isotropic material.\n\n    The loop will have radius `loop_r`, be centered at `center`, and oriented along the z-axis.\n\n    The dislocation's sign is defined such that travelling upwards through the loop results in a displacement of `b`.\n    `poisson` is the material's poisson ratio, which affects the shape of dislocations with an edge component.\n\n    Adding the loop creates (or removes) a volume of $\\mathbf{b} \\cdot \\mathbf{n}A$, where $\\mathbf{n}A$ is the loop's\n    normal times its area. Consequently, this function adds or remove atoms to effect this volume change.\n\n    Args:\n      atoms: Structure to add dislocation loop to\n      center: Center of dislocation loop\n      b: Burgers vector of dislocation (defined so travelling upwards leads to a plastic displacment of `b`).\n      loop_r: Radius of dislocation loop\n      poisson: Poisson ratio of material\n\n    Returns:\n      Structure with a dislocation loop added\n    \"\"\"\n\n    center = to_vec3(center)\n    b_vec = to_vec3(b)\n\n    atoms = atoms.transform_atoms(AffineTransform3D.translate(center).inverse())\n    frame = atoms.get_atoms('local')\n    branch = None\n\n    d = numpy.dot(b_vec, [0, 0, 1])\n    if -d &gt; 1e-8:\n        logging.info(\"Non-conservative dislocation. Removing atoms.\")\n        frame = frame.filter(~(\n            (frame.x()**2 + frame.y()**2 &lt; loop_r**2)\n            &amp; frame.z().is_between(d/2., -d/2., closed='both')\n        ))\n\n    if d &gt; 1e-8:\n        logging.info(\"Non-conservative dislocation. Duplicating atoms.\")\n        duplicate = frame.filter(\n            (frame.x()**2 + frame.y()**2 &lt; loop_r**2)\n            &amp; frame.z().is_between(-d/2., d/2., closed='both')\n        )\n        logging.info(f\"Adding {len(duplicate)} atoms\")\n\n        frame = Atoms.concat((frame, duplicate))\n        #atoms = atoms._replace_atoms(frame)\n        branch = numpy.sign(frame['z'].to_numpy())\n        if len(duplicate) &gt; 0:\n            branch[-len(duplicate):] *= -1  # flip branch of duplicated atoms\n\n    pts = frame.coords()\n    disps = _loop_disp_z(pts, b_vec, loop_r, poisson=poisson, branch=branch)\n\n    return atoms.with_atoms(frame.with_coords(pts + disps + center), 'local')\n</code></pre>"},{"location":"api/defect/#atomlib.defect.disloc_square_z","title":"<code>disloc_square_z(atoms, center, b, loop_r, *, poisson=0.25)</code>","text":"<p>Add a square dislocation loop to the structure, assuming an elastically isotropic material.</p> <p>The dislocation's sign is defined such that traveling upwards through the loop results in a displacement of <code>b</code>. <code>poisson</code> is the material's poisson ratio, which affects the shape of dislocations with an edge component.</p> <p>Adding the loop creates (or removes) a volume of \\(\\mathbf{b} \\cdot \\mathbf{n}A\\), where \\(\\mathbf{n}A\\) is the loop's normal times its area. Consequently, this function adds or remove atoms to effect this volume change.</p> <p>Parameters:</p> Name Type Description Default <code>atoms</code> <code>HasAtomsT</code> <p>Structure to add dislocation loop to</p> required <code>center</code> <code>VecLike</code> <p>Center of dislocation loop</p> required <code>b</code> <code>VecLike</code> <p>Burgers vector of dislocation (defined so travelling upwards leads to a plastic displacment of <code>b</code>).</p> required <code>loop_r</code> <code>float</code> <p>Radius (side length/2) of dislocation loop</p> required <code>poisson</code> <code>float</code> <p>Poisson ratio of material</p> <code>0.25</code> <p>Returns:</p> Type Description <code>HasAtomsT</code> <p>Structure with a dislocation loop added</p> Source code in <code>atomlib/defect.py</code> <pre><code>def disloc_square_z(atoms: HasAtomsT, center: VecLike, b: VecLike,\n                    loop_r: float, *, poisson: float = 0.25) -&gt; HasAtomsT:\n    r\"\"\"\n    Add a square dislocation loop to the structure, assuming an elastically isotropic material.\n\n    The dislocation's sign is defined such that traveling upwards through the loop results in a displacement of `b`.\n    `poisson` is the material's poisson ratio, which affects the shape of dislocations with an edge component.\n\n    Adding the loop creates (or removes) a volume of $\\mathbf{b} \\cdot \\mathbf{n}A$, where $\\mathbf{n}A$ is the loop's\n    normal times its area. Consequently, this function adds or remove atoms to effect this volume change.\n\n    Args:\n      atoms: Structure to add dislocation loop to\n      center: Center of dislocation loop\n      b: Burgers vector of dislocation (defined so travelling upwards leads to a plastic displacment of `b`).\n      loop_r: Radius (side length/2) of dislocation loop\n      poisson: Poisson ratio of material\n\n    Returns:\n      Structure with a dislocation loop added\n    \"\"\"\n    poly = loop_r * numpy.array([(1, 1), (-1, 1), (-1, -1), (1, -1)])\n    return disloc_poly_z(atoms, b, poly, center, poisson=poisson)\n</code></pre>"},{"location":"api/defect/#atomlib.defect.disloc_poly_z","title":"<code>disloc_poly_z(atoms, b, poly, center=None, *, poisson=0.25)</code>","text":"<p>Add a dislocation loop defined by the polygon <code>poly</code>, assuming an elastically isotropic material.</p> <p><code>poly</code> should be a 2d polygon (shape <code>(N, 2)</code>). It will be placed at <code>center</code>, in the plane <code>z=center[2]</code>. For CCW winding order, traveling upwards through the plane of the loop results in a displacement of <code>b</code>. <code>poisson</code> is the material's poisson ratio, which affects the shape of dislocations with an edge component.</p> <p>Adding the loop creates (or removes) a volume of \\(\\mathbf{b} \\cdot \\mathbf{n}A\\), where \\(\\mathbf{n}A\\) is the loop's normal times its area. Consequently, this function adds or remove atoms to effect this volume change.</p> <p>Follows the solution in Hirth, J. P. &amp; Lothe, J. (1982). Theory of Dislocations. ISBN 0-89464-617-6 </p> <p>Parameters:</p> Name Type Description Default <code>atoms</code> <code>HasAtomsT</code> <p>Structure to add dislocation loop to</p> required <code>b</code> <code>VecLike</code> <p>Burgers vector of dislocation (defined so travelling upwards leads to a plastic displacment of <code>b</code>).</p> required <code>poly</code> <code>ArrayLike</code> <p>2D polygon defining dislocation line. It is placed in the plane <code>z=center[2]</code>.</p> required <code>center</code> <code>Optional[VecLike]</code> <p>Center of dislocation loop (defaults to zero, applying no displacement to the gven polygon).</p> <code>None</code> <code>poisson</code> <code>float</code> <p>Poisson ratio of material</p> <code>0.25</code> <p>Returns:</p> Type Description <code>HasAtomsT</code> <p>Structure with a dislocation loop added</p> Source code in <code>atomlib/defect.py</code> <pre><code>def disloc_poly_z(atoms: HasAtomsT, b: VecLike, poly: ArrayLike, center: t.Optional[VecLike] = None,\n                  *, poisson: float = 0.25) -&gt; HasAtomsT:\n    r\"\"\"\n    Add a dislocation loop defined by the polygon `poly`, assuming an elastically isotropic material.\n\n    `poly` should be a 2d polygon (shape `(N, 2)`). It will be placed at `center`, in the plane `z=center[2]`.\n    For CCW winding order, traveling upwards through the plane of the loop results in a displacement of `b`.\n    `poisson` is the material's poisson ratio, which affects the shape of dislocations with an edge component.\n\n    Adding the loop creates (or removes) a volume of $\\mathbf{b} \\cdot \\mathbf{n}A$, where $\\mathbf{n}A$ is the loop's\n    normal times its area. Consequently, this function adds or remove atoms to effect this volume change.\n\n    Follows the solution in [Hirth, J. P. &amp; Lothe, J. (1982). Theory of Dislocations. ISBN 0-89464-617-6\n    ](https://www.google.com/books/edition/Theory_of_Dislocations/TAjwAAAAMAAJ)\n\n    Args:\n      atoms: Structure to add dislocation loop to\n      b: Burgers vector of dislocation (defined so travelling upwards leads to a plastic displacment of `b`).\n      poly: 2D polygon defining dislocation line. It is placed in the plane `z=center[2]`.\n      center: Center of dislocation loop (defaults to zero, applying no displacement to the gven polygon).\n      poisson: Poisson ratio of material\n\n    Returns:\n      Structure with a dislocation loop added\n    \"\"\"\n    center = to_vec3(center if center is not None else [0., 0., 0.])\n    b_vec = to_vec3(b)\n\n    poly = numpy.atleast_2d(poly)\n    if poly.ndim != 2 or poly.shape[-1] != 2:\n        raise ValueError(f\"Expected a 2d polygon. Instead got shape {poly.shape}\")\n\n    frame = atoms.get_atoms('local')\n    coords: NDArray[numpy.float_] = frame.coords() - center\n\n    branch = None\n    d = numpy.dot(b_vec, [0, 0, 1])\n    if abs(d) &gt; 1e-8:\n        logging.info(\"Non-conservative dislocation.\")\n        windings = polygon_winding(poly, coords[..., :2])\n\n        z = coords[..., 2]\n        remove = (z &gt;= windings * d/2.) &amp; (z &lt;= -windings * d/2.)\n        duplicate = (z &gt;= -windings * d/2.) &amp; (z &lt;= windings * d/2.)\n\n        n_remove = numpy.sum(remove, dtype=int)\n        if n_remove:\n            logging.info(f\"Removing {n_remove} atoms\")\n            frame = frame.filter(polars.Series(~remove))\n            duplicate = duplicate[~remove]\n\n        n_duplicate = numpy.sum(duplicate, dtype=int)\n        if n_duplicate:\n            logging.info(f\"Duplicating {n_duplicate} atoms\")\n            frame = Atoms.concat((frame, frame.filter(polars.Series(duplicate))))\n\n            branch = numpy.ones(len(frame))\n            branch[-n_duplicate:] = -1  # flip branch of duplicated atoms\n\n        coords = frame.coords() - center\n\n    disp = _poly_disp_z(coords, b_vec, poly, poisson=poisson, branch=branch)\n\n    return atoms.with_atoms(frame.with_coords(coords + disp + center), 'local')\n</code></pre>"},{"location":"api/elem/","title":"<code>atomlib.elem</code>","text":""},{"location":"api/elem/#atomlib.elem.ELEMENTS","title":"<code>ELEMENTS = {'h': 1, 'he': 2, 'li': 3, 'be': 4, 'b': 5, 'c': 6, 'n': 7, 'o': 8, 'f': 9, 'ne': 10, 'na': 11, 'mg': 12, 'al': 13, 'si': 14, 'p': 15, 's': 16, 'cl': 17, 'ar': 18, 'k': 19, 'ca': 20, 'sc': 21, 'ti': 22, 'v': 23, 'cr': 24, 'mn': 25, 'fe': 26, 'co': 27, 'ni': 28, 'cu': 29, 'zn': 30, 'ga': 31, 'ge': 32, 'as': 33, 'se': 34, 'br': 35, 'kr': 36, 'rb': 37, 'sr': 38, 'y': 39, 'zr': 40, 'nb': 41, 'mo': 42, 'tc': 43, 'ru': 44, 'rh': 45, 'pd': 46, 'ag': 47, 'cd': 48, 'in': 49, 'sn': 50, 'sb': 51, 'te': 52, 'i': 53, 'xe': 54, 'cs': 55, 'ba': 56, 'la': 57, 'ce': 58, 'pr': 59, 'nd': 60, 'pm': 61, 'sm': 62, 'eu': 63, 'gd': 64, 'tb': 65, 'dy': 66, 'ho': 67, 'er': 68, 'tm': 69, 'yb': 70, 'lu': 71, 'hf': 72, 'ta': 73, 'w': 74, 're': 75, 'os': 76, 'ir': 77, 'pt': 78, 'au': 79, 'hg': 80, 'tl': 81, 'pb': 82, 'bi': 83, 'po': 84, 'at': 85, 'rn': 86, 'fr': 87, 'ra': 88, 'ac': 89, 'th': 90, 'pa': 91, 'u': 92, 'np': 93, 'pu': 94, 'am': 95, 'cm': 96, 'bk': 97, 'cf': 98, 'es': 99, 'fm': 100, 'md': 101, 'no': 102, 'lr': 103, 'rf': 104, 'db': 105, 'sg': 106, 'bh': 107, 'hs': 108, 'mt': 109, 'ds': 110, 'rg': 111, 'cn': 112, 'nh': 113, 'fl': 114, 'mc': 115, 'lv': 116, 'ts': 117, 'og': 118}</code>  <code>module-attribute</code>","text":""},{"location":"api/elem/#atomlib.elem.ELEMENT_SYMBOLS","title":"<code>ELEMENT_SYMBOLS = ['H', 'He', 'Li', 'Be', 'B', 'C', 'N', 'O', 'F', 'Ne', 'Na', 'Mg', 'Al', 'Si', 'P', 'S', 'Cl', 'Ar', 'K', 'Ca', 'Sc', 'Ti', 'V', 'Cr', 'Mn', 'Fe', 'Co', 'Ni', 'Cu', 'Zn', 'Ga', 'Ge', 'As', 'Se', 'Br', 'Kr', 'Rb', 'Sr', 'Y', 'Zr', 'Nb', 'Mo', 'Tc', 'Ru', 'Rh', 'Pd', 'Ag', 'Cd', 'In', 'Sn', 'Sb', 'Te', 'I', 'Xe', 'Cs', 'Ba', 'La', 'Ce', 'Pr', 'Nd', 'Pm', 'Sm', 'Eu', 'Gd', 'Tb', 'Dy', 'Ho', 'Er', 'Tm', 'Yb', 'Lu', 'Hf', 'Ta', 'W', 'Re', 'Os', 'Ir', 'Pt', 'Au', 'Hg', 'Tl', 'Pb', 'Bi', 'Po', 'At', 'Rn', 'Fr', 'Ra', 'Ac', 'Th', 'Pa', 'U', 'Np', 'Pu', 'Am', 'Cm', 'Bk', 'Cf', 'Es', 'Fm', 'Md', 'No', 'Lr', 'Rf', 'Db', 'Sg', 'Bh', 'Hs', 'Mt', 'Ds', 'Rg', 'Cn', 'Nh', 'Fl', 'Mc', 'Lv', 'Ts', 'Og']</code>  <code>module-attribute</code>","text":""},{"location":"api/elem/#atomlib.elem.DATA_PATH","title":"<code>DATA_PATH = files('atomlib.data')</code>  <code>module-attribute</code>","text":""},{"location":"api/elem/#atomlib.elem.get_elem","title":"<code>get_elem(sym)</code>","text":"Source code in <code>atomlib/elem.py</code> <pre><code>def get_elem(sym: t.Union[int, str, polars.Series]):\n    if isinstance(sym, int):\n        if not 0 &lt; sym &lt; len(ELEMENTS):\n            raise ValueError(f\"Invalid atomic number {sym}\")\n        return sym\n\n    if isinstance(sym, polars.Series):\n        elem = sym.str.extract(_SYM_RE, 0).str.to_lowercase() \\\n            .replace(ELEMENTS, return_dtype=polars.UInt8, default=255) \\\n            .alias('elem')\n\n        if (invalid := sym.filter(sym.is_not_null() &amp; (elem &gt; 118)).to_list()):\n            raise ValueError(f\"Invalid element symbol(s) '{', '.join(map(str, invalid))}'\")\n\n        return elem\n\n    sym_s = re.search(_SYM_RE, str(sym))\n    try:\n        return ELEMENTS[sym_s[0].lower()]  # type: ignore\n    except (KeyError, IndexError):\n        raise ValueError(f\"Invalid element symbol '{sym}'\")\n</code></pre>"},{"location":"api/elem/#atomlib.elem.get_elems","title":"<code>get_elems(sym)</code>","text":"Source code in <code>atomlib/elem.py</code> <pre><code>def get_elems(sym: str) -&gt; t.List[int]:\n    if len(sym) &gt; 0:\n        sym = sym[0].upper() + sym[1:]\n    segments = [\n        match[0] for match in re.finditer(r'[A-Z][a-z]?', str(sym))\n    ]\n    if len(segments) == 0:\n        raise ValueError(f\"Invalid compound '{sym}'\")\n\n    elems = [ELEMENTS.get(seg.lower()) for seg in segments]\n    for (seg, v) in zip(segments, elems):\n        if v is None:\n            raise ValueError(f\"Unknown element '{seg}' in '{sym}'. Compounds are case-sensitive.\")\n    return t.cast(t.List[int], elems)\n</code></pre>"},{"location":"api/elem/#atomlib.elem.get_sym","title":"<code>get_sym(elem)</code>","text":"Source code in <code>atomlib/elem.py</code> <pre><code>def get_sym(elem: t.Union[int, polars.Series]):\n    if isinstance(elem, polars.Series):\n        try:\n            return elem.map_elements(_get_sym, return_dtype=polars.Utf8, skip_nulls=True) \\\n                    .alias('symbol')\n        except PolarsPanicError:\n            # attempt to recreate the error in Python\n            _ = [_get_sym(t.cast(int, e)) for e in elem.to_list() if e is not None]\n            raise\n\n    return _get_sym(t.cast(int, elem))\n</code></pre>"},{"location":"api/elem/#atomlib.elem.get_mass","title":"<code>get_mass(elem)</code>","text":"<p>Get the standard atomic mass for the given element.</p> <p>Follows the <code>2021 table of the IUPAC Commission on Isotopic Abundances and Atomic Weights &lt;https://doi.org/10.1515/pac-2019-0603&gt;</code>_.</p> Source code in <code>atomlib/elem.py</code> <pre><code>def get_mass(elem: t.Union[int, t.Sequence[int], numpy.ndarray, polars.Series]):\n    \"\"\"\n    Get the standard atomic mass for the given element.\n\n    Follows the `2021 table of the IUPAC Commission on Isotopic Abundances and Atomic Weights &lt;https://doi.org/10.1515/pac-2019-0603&gt;`_.\n    \"\"\"\n    global _ELEMENT_MASSES\n\n    if _ELEMENT_MASSES is None:\n        with _open_binary_data('masses.npy') as f:\n            _ELEMENT_MASSES = numpy.load(f, allow_pickle=False)\n\n    if isinstance(elem, polars.Series):\n        return polars.Series(values=_ELEMENT_MASSES)[elem-1]\n\n    if isinstance(elem, (int, numpy.ndarray)):\n        return _ELEMENT_MASSES[elem-1]  # type: ignore\n    return _ELEMENT_MASSES[[e-1 for e in elem]]  # type: ignore\n</code></pre>"},{"location":"api/elem/#atomlib.elem.get_ionic_radius","title":"<code>get_ionic_radius(elem, charge)</code>","text":"<p>Get crystal ionic radius in angstroms for <code>elem</code> in charge state <code>charge</code>.</p> <p>Follows <code>R.D. Shannon, Acta Cryst. A32 (1976) &lt;https://doi.org/10.1107/S0567739476001551&gt;</code>.</p> Source code in <code>atomlib/elem.py</code> <pre><code>def get_ionic_radius(elem: int, charge: int) -&gt; float:\n    \"\"\"\n    Get crystal ionic radius in angstroms for ``elem`` in charge state ``charge``.\n\n    Follows `R.D. Shannon, Acta Cryst. A32 (1976) &lt;https://doi.org/10.1107/S0567739476001551&gt;`.\n    \"\"\"\n    global _ION_RADII\n\n    import json\n\n    if _ION_RADII is None:\n        with _open_text_data('ion_radii.json') as f:\n            _ION_RADII = json.load(f)\n        assert _ION_RADII is not None\n\n    s = f\"{get_sym(elem)}{charge:+d}\"\n\n    try:\n        return _ION_RADII[s]\n    except KeyError:\n        raise ValueError(f\"Unknown radius for ion '{s}'\") from None\n</code></pre>"},{"location":"api/elem/#atomlib.elem.get_radius","title":"<code>get_radius(elem)</code>","text":"<p>Get the neutral atomic radius for the given element(s), in angstroms.</p> <p>Follows the calculated values in <code>E. Clementi et. al, J. Chem. Phys. 47 (1967) &lt;https://doi.org/10.1063/1.1712084&gt;</code>_.</p> Source code in <code>atomlib/elem.py</code> <pre><code>def get_radius(elem: t.Union[int, t.Sequence[int], numpy.ndarray, polars.Series]):\n    \"\"\"\n    Get the neutral atomic radius for the given element(s), in angstroms.\n\n    Follows the calculated values in `E. Clementi et. al, J. Chem. Phys. 47 (1967) &lt;https://doi.org/10.1063/1.1712084&gt;`_.\n    \"\"\"\n    global _ELEMENT_RADII\n\n    if _ELEMENT_RADII is None:\n        with _open_binary_data('radii.npy') as f:\n            _ELEMENT_RADII = numpy.load(f, allow_pickle=False)\n\n    if isinstance(elem, polars.Series):\n        return polars.Series(values=_ELEMENT_RADII)[elem-1]\n\n    if isinstance(elem, (int, numpy.ndarray)):\n        return _ELEMENT_RADII[elem-1]  # type: ignore\n    return _ELEMENT_RADII[[e-1 for e in elem]]  # type: ignore\n</code></pre>"},{"location":"api/expr/","title":"<code>atomlib.expr</code>","text":""},{"location":"api/expr/#atomlib.expr.WSPACE_RE","title":"<code>WSPACE_RE = re.compile('\\\\s+')</code>  <code>module-attribute</code>","text":""},{"location":"api/expr/#atomlib.expr.NUMERIC_OPS","title":"<code>NUMERIC_OPS: t.Sequence[Op[SupportsNum]] = [BinaryOrUnaryOp(['-'], sub, False, 5), BinaryOp(['+'], operator.add, 5), BinaryOp(['*'], operator.mul, 6), BinaryOp(['/'], operator.truediv, 6), BinaryOp(['//'], operator.floordiv, 6), BinaryOp(['^', '**'], operator.pow, 7)]</code>  <code>module-attribute</code>","text":""},{"location":"api/expr/#atomlib.expr.NUMERIC_PARSER","title":"<code>NUMERIC_PARSER = Parser(NUMERIC_OPS, parse_numeric)</code>  <code>module-attribute</code>","text":""},{"location":"api/expr/#atomlib.expr.BOOLEAN_OPS","title":"<code>BOOLEAN_OPS: t.Sequence[Op[SupportsBool]] = [BinaryOp(['=', '=='], operator.eq, 3), BinaryOp(['!=', '&lt;&gt;'], operator.ne, 3), BinaryOp(['|', '||'], operator.or_, 4), BinaryOp(['&amp;', '&amp;&amp;'], operator.and_, 5), BinaryOp(['^'], operator.xor, 6), UnaryOp(['!', '~'], operator.invert)]</code>  <code>module-attribute</code>","text":""},{"location":"api/expr/#atomlib.expr.BOOLEAN_PARSER","title":"<code>BOOLEAN_PARSER = Parser(BOOLEAN_OPS, parse_boolean)</code>  <code>module-attribute</code>","text":"<p>Parser for boolean expressions ([1 || false &amp;&amp; true])</p>"},{"location":"api/expr/#atomlib.expr.VECTOR_OPS","title":"<code>VECTOR_OPS: t.Sequence[Op[numpy.ndarray]] = [*t.cast(Op[numpy.ndarray], op) for op in NUMERIC_OPS, NaryOp([','], call=stack, precedence=3)]</code>  <code>module-attribute</code>","text":""},{"location":"api/expr/#atomlib.expr.VECTOR_PARSER","title":"<code>VECTOR_PARSER = Parser(VECTOR_OPS, lambda v: numpy.array(parse_numeric(v)))</code>  <code>module-attribute</code>","text":""},{"location":"api/expr/#atomlib.expr.VariadicCallable","title":"<code>VariadicCallable</code>","text":"<p>             Bases: <code>Protocol</code>, <code>Generic[V]</code></p> Source code in <code>atomlib/expr.py</code> <pre><code>class VariadicCallable(t.Protocol, t.Generic[V]):\n    def __call__(self, *args: V) -&gt; V:\n        ...\n</code></pre>"},{"location":"api/expr/#atomlib.expr.Op","title":"<code>Op</code>  <code>dataclass</code>","text":"<p>             Bases: <code>ABC</code>, <code>Generic[V]</code></p> Source code in <code>atomlib/expr.py</code> <pre><code>@dataclass\nclass Op(ABC, t.Generic[V]):\n    aliases: t.List[str]\n    call: t.Callable = field(repr=False)\n\n    @property\n    @abstractmethod\n    def requires_whitespace(self) -&gt; bool:\n        ...\n</code></pre>"},{"location":"api/expr/#atomlib.expr.Op.aliases","title":"<code>aliases: t.List[str]</code>  <code>instance-attribute</code>","text":""},{"location":"api/expr/#atomlib.expr.Op.call","title":"<code>call: t.Callable = field(repr=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/expr/#atomlib.expr.Op.requires_whitespace","title":"<code>requires_whitespace: bool</code>  <code>abstractmethod</code> <code>property</code>","text":""},{"location":"api/expr/#atomlib.expr.NaryOp","title":"<code>NaryOp</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Op[V]</code></p> Source code in <code>atomlib/expr.py</code> <pre><code>@dataclass\nclass NaryOp(Op[V]):\n    call: VariadicCallable[V] = field(repr=False)  # type: ignore\n    precedence: int = 5\n    requires_whitespace: bool = False  # type: ignore\n\n    def __call__(self, *args: V) -&gt; V:\n        return self.call(*args)\n\n    def precedes(self, other: t.Union[BinaryOp, NaryOp, int]) -&gt; bool:\n        if isinstance(other, (BinaryOp, NaryOp)):\n            other = other.precedence\n\n        # default to lower precedence for Nary\n        return self.precedence &gt; other\n</code></pre>"},{"location":"api/expr/#atomlib.expr.NaryOp.aliases","title":"<code>aliases: t.List[str]</code>  <code>instance-attribute</code>","text":""},{"location":"api/expr/#atomlib.expr.NaryOp.call","title":"<code>call: VariadicCallable[V] = field(repr=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/expr/#atomlib.expr.NaryOp.precedence","title":"<code>precedence: int = 5</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/expr/#atomlib.expr.NaryOp.requires_whitespace","title":"<code>requires_whitespace: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/expr/#atomlib.expr.NaryOp.precedes","title":"<code>precedes(other)</code>","text":"Source code in <code>atomlib/expr.py</code> <pre><code>def precedes(self, other: t.Union[BinaryOp, NaryOp, int]) -&gt; bool:\n    if isinstance(other, (BinaryOp, NaryOp)):\n        other = other.precedence\n\n    # default to lower precedence for Nary\n    return self.precedence &gt; other\n</code></pre>"},{"location":"api/expr/#atomlib.expr.BinaryOp","title":"<code>BinaryOp</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Op[V]</code></p> Source code in <code>atomlib/expr.py</code> <pre><code>@dataclass\nclass BinaryOp(Op[V]):\n    call: t.Callable[[V, V], V] = field(repr=False)  # type: ignore\n    precedence: int = 5\n    right_assoc: bool = False\n    requires_whitespace: bool = False  # type: ignore\n\n    def __call__(self, lhs: V, rhs: V) -&gt; V:\n        return self.call(lhs, rhs)\n\n    def precedes(self, other: t.Union[BinaryOp, NaryOp, int]) -&gt; bool:\n        \"\"\"Returns true if self is higher precedence than other.\n        Handles a tie using the associativity of self.\n        \"\"\"\n        if isinstance(other, (BinaryOp, NaryOp)):\n            other = other.precedence\n\n        if self.precedence == other:\n            return self.right_assoc\n        return self.precedence &gt; other\n</code></pre>"},{"location":"api/expr/#atomlib.expr.BinaryOp.aliases","title":"<code>aliases: t.List[str]</code>  <code>instance-attribute</code>","text":""},{"location":"api/expr/#atomlib.expr.BinaryOp.call","title":"<code>call: t.Callable[[V, V], V] = field(repr=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/expr/#atomlib.expr.BinaryOp.precedence","title":"<code>precedence: int = 5</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/expr/#atomlib.expr.BinaryOp.right_assoc","title":"<code>right_assoc: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/expr/#atomlib.expr.BinaryOp.requires_whitespace","title":"<code>requires_whitespace: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/expr/#atomlib.expr.BinaryOp.precedes","title":"<code>precedes(other)</code>","text":"<p>Returns true if self is higher precedence than other. Handles a tie using the associativity of self.</p> Source code in <code>atomlib/expr.py</code> <pre><code>def precedes(self, other: t.Union[BinaryOp, NaryOp, int]) -&gt; bool:\n    \"\"\"Returns true if self is higher precedence than other.\n    Handles a tie using the associativity of self.\n    \"\"\"\n    if isinstance(other, (BinaryOp, NaryOp)):\n        other = other.precedence\n\n    if self.precedence == other:\n        return self.right_assoc\n    return self.precedence &gt; other\n</code></pre>"},{"location":"api/expr/#atomlib.expr.UnaryOp","title":"<code>UnaryOp</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Op[V]</code></p> Source code in <code>atomlib/expr.py</code> <pre><code>@dataclass\nclass UnaryOp(Op[V]):\n    call: t.Callable[[V], V] = field(repr=False)  # type: ignore\n    requires_whitespace: bool = False  # type: ignore\n\n    def __call__(self, inner: V) -&gt; V:\n        return self.call(inner)\n</code></pre>"},{"location":"api/expr/#atomlib.expr.UnaryOp.aliases","title":"<code>aliases: t.List[str]</code>  <code>instance-attribute</code>","text":""},{"location":"api/expr/#atomlib.expr.UnaryOp.call","title":"<code>call: t.Callable[[V], V] = field(repr=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/expr/#atomlib.expr.UnaryOp.requires_whitespace","title":"<code>requires_whitespace: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/expr/#atomlib.expr.BinaryOrUnaryOp","title":"<code>BinaryOrUnaryOp</code>  <code>dataclass</code>","text":"<p>             Bases: <code>BinaryOp[V]</code>, <code>UnaryOp[V]</code></p> Source code in <code>atomlib/expr.py</code> <pre><code>@dataclass\nclass BinaryOrUnaryOp(BinaryOp[V], UnaryOp[V]):\n    call: t.Callable[[V, t.Optional[V]], V] = field(repr=False)  # type: ignore\n\n    def __call__(self, lhs: V, rhs: t.Optional[V] = None) -&gt; V:\n        return self.call(lhs, rhs)\n</code></pre>"},{"location":"api/expr/#atomlib.expr.BinaryOrUnaryOp.aliases","title":"<code>aliases: t.List[str]</code>  <code>instance-attribute</code>","text":""},{"location":"api/expr/#atomlib.expr.BinaryOrUnaryOp.requires_whitespace","title":"<code>requires_whitespace: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/expr/#atomlib.expr.BinaryOrUnaryOp.precedence","title":"<code>precedence: int = 5</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/expr/#atomlib.expr.BinaryOrUnaryOp.right_assoc","title":"<code>right_assoc: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/expr/#atomlib.expr.BinaryOrUnaryOp.call","title":"<code>call: t.Callable[[V, t.Optional[V]], V] = field(repr=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/expr/#atomlib.expr.BinaryOrUnaryOp.precedes","title":"<code>precedes(other)</code>","text":"<p>Returns true if self is higher precedence than other. Handles a tie using the associativity of self.</p> Source code in <code>atomlib/expr.py</code> <pre><code>def precedes(self, other: t.Union[BinaryOp, NaryOp, int]) -&gt; bool:\n    \"\"\"Returns true if self is higher precedence than other.\n    Handles a tie using the associativity of self.\n    \"\"\"\n    if isinstance(other, (BinaryOp, NaryOp)):\n        other = other.precedence\n\n    if self.precedence == other:\n        return self.right_assoc\n    return self.precedence &gt; other\n</code></pre>"},{"location":"api/expr/#atomlib.expr.Token","title":"<code>Token</code>  <code>dataclass</code>","text":"<p>             Bases: <code>ABC</code>, <code>Generic[T_co, V]</code></p> Source code in <code>atomlib/expr.py</code> <pre><code>@dataclass\nclass Token(ABC, t.Generic[T_co, V]):\n    raw: str\n    line: int\n    span: t.Tuple[int, int]\n\n    def __str__(self):\n        return self.raw\n</code></pre>"},{"location":"api/expr/#atomlib.expr.Token.raw","title":"<code>raw: str</code>  <code>instance-attribute</code>","text":""},{"location":"api/expr/#atomlib.expr.Token.line","title":"<code>line: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/expr/#atomlib.expr.Token.span","title":"<code>span: t.Tuple[int, int]</code>  <code>instance-attribute</code>","text":""},{"location":"api/expr/#atomlib.expr.OpToken","title":"<code>OpToken</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Token[T_co, V]</code></p> Source code in <code>atomlib/expr.py</code> <pre><code>@dataclass\nclass OpToken(Token[T_co, V]):\n    op: Op[V]\n</code></pre>"},{"location":"api/expr/#atomlib.expr.OpToken.raw","title":"<code>raw: str</code>  <code>instance-attribute</code>","text":""},{"location":"api/expr/#atomlib.expr.OpToken.line","title":"<code>line: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/expr/#atomlib.expr.OpToken.span","title":"<code>span: t.Tuple[int, int]</code>  <code>instance-attribute</code>","text":""},{"location":"api/expr/#atomlib.expr.OpToken.op","title":"<code>op: Op[V]</code>  <code>instance-attribute</code>","text":""},{"location":"api/expr/#atomlib.expr.GroupOpenToken","title":"<code>GroupOpenToken</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Token</code></p> Source code in <code>atomlib/expr.py</code> <pre><code>@dataclass\nclass GroupOpenToken(Token):\n    ...\n</code></pre>"},{"location":"api/expr/#atomlib.expr.GroupOpenToken.raw","title":"<code>raw: str</code>  <code>instance-attribute</code>","text":""},{"location":"api/expr/#atomlib.expr.GroupOpenToken.line","title":"<code>line: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/expr/#atomlib.expr.GroupOpenToken.span","title":"<code>span: t.Tuple[int, int]</code>  <code>instance-attribute</code>","text":""},{"location":"api/expr/#atomlib.expr.GroupCloseToken","title":"<code>GroupCloseToken</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Token</code></p> Source code in <code>atomlib/expr.py</code> <pre><code>@dataclass\nclass GroupCloseToken(Token):\n    ...\n</code></pre>"},{"location":"api/expr/#atomlib.expr.GroupCloseToken.raw","title":"<code>raw: str</code>  <code>instance-attribute</code>","text":""},{"location":"api/expr/#atomlib.expr.GroupCloseToken.line","title":"<code>line: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/expr/#atomlib.expr.GroupCloseToken.span","title":"<code>span: t.Tuple[int, int]</code>  <code>instance-attribute</code>","text":""},{"location":"api/expr/#atomlib.expr.WhitespaceToken","title":"<code>WhitespaceToken</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Token</code></p> Source code in <code>atomlib/expr.py</code> <pre><code>class WhitespaceToken(Token):\n    ...\n</code></pre>"},{"location":"api/expr/#atomlib.expr.ValueToken","title":"<code>ValueToken</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Token[T_co, V]</code></p> Source code in <code>atomlib/expr.py</code> <pre><code>@dataclass\nclass ValueToken(Token[T_co, V]):\n    val: T_co\n</code></pre>"},{"location":"api/expr/#atomlib.expr.ValueToken.raw","title":"<code>raw: str</code>  <code>instance-attribute</code>","text":""},{"location":"api/expr/#atomlib.expr.ValueToken.line","title":"<code>line: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/expr/#atomlib.expr.ValueToken.span","title":"<code>span: t.Tuple[int, int]</code>  <code>instance-attribute</code>","text":""},{"location":"api/expr/#atomlib.expr.ValueToken.val","title":"<code>val: T_co</code>  <code>instance-attribute</code>","text":""},{"location":"api/expr/#atomlib.expr.Expr","title":"<code>Expr</code>","text":"<p>             Bases: <code>ABC</code>, <code>Generic[T_co, V]</code></p> Source code in <code>atomlib/expr.py</code> <pre><code>class Expr(ABC, t.Generic[T_co, V]):\n    @abstractmethod\n    def eval(self, map_f: t.Callable[[T_co], V]) -&gt; V:\n        ...\n\n    @abstractmethod\n    def format(self,\n               format_scalar: t.Callable[[ValueToken[T_co, V]], str] = str,\n               format_op: t.Callable[[OpToken[T_co, V]], str] = str) -&gt; str:\n        ...\n\n    def __str__(self) -&gt; str:\n        return self.format()\n\n    def __repr__(self) -&gt; str:\n        ...\n</code></pre>"},{"location":"api/expr/#atomlib.expr.Expr.eval","title":"<code>eval(map_f)</code>  <code>abstractmethod</code>","text":"Source code in <code>atomlib/expr.py</code> <pre><code>@abstractmethod\ndef eval(self, map_f: t.Callable[[T_co], V]) -&gt; V:\n    ...\n</code></pre>"},{"location":"api/expr/#atomlib.expr.Expr.format","title":"<code>format(format_scalar=str, format_op=str)</code>  <code>abstractmethod</code>","text":"Source code in <code>atomlib/expr.py</code> <pre><code>@abstractmethod\ndef format(self,\n           format_scalar: t.Callable[[ValueToken[T_co, V]], str] = str,\n           format_op: t.Callable[[OpToken[T_co, V]], str] = str) -&gt; str:\n    ...\n</code></pre>"},{"location":"api/expr/#atomlib.expr.UnaryExpr","title":"<code>UnaryExpr</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Expr[T_co, V]</code></p> Source code in <code>atomlib/expr.py</code> <pre><code>@dataclass\nclass UnaryExpr(Expr[T_co, V]):\n    op_token: OpToken[T_co, V]\n    op: UnaryOp[V] = field(init=False)\n    inner: Expr[T_co, V]\n    lspace: str = \"\"\n\n    def __post_init__(self):\n        if not isinstance(self.op_token.op, UnaryOp):\n            raise TypeError()\n        self.op = self.op_token.op\n\n    def eval(self, map_f: t.Callable[[T_co], V]) -&gt; V:\n        return self.op.call(self.inner.eval(map_f))\n\n    def format(self,\n               format_scalar: t.Callable[[ValueToken[T_co, V]], str] = str,\n               format_op: t.Callable[[OpToken[T_co, V]], str] = str) -&gt; str:\n        return f\"{self.lspace}{format_op(self.op_token)}{self.inner.format(format_scalar, format_op)}\"\n</code></pre>"},{"location":"api/expr/#atomlib.expr.UnaryExpr.op_token","title":"<code>op_token: OpToken[T_co, V]</code>  <code>instance-attribute</code>","text":""},{"location":"api/expr/#atomlib.expr.UnaryExpr.op","title":"<code>op: UnaryOp[V] = field(init=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/expr/#atomlib.expr.UnaryExpr.inner","title":"<code>inner: Expr[T_co, V]</code>  <code>instance-attribute</code>","text":""},{"location":"api/expr/#atomlib.expr.UnaryExpr.lspace","title":"<code>lspace: str = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/expr/#atomlib.expr.UnaryExpr.eval","title":"<code>eval(map_f)</code>","text":"Source code in <code>atomlib/expr.py</code> <pre><code>def eval(self, map_f: t.Callable[[T_co], V]) -&gt; V:\n    return self.op.call(self.inner.eval(map_f))\n</code></pre>"},{"location":"api/expr/#atomlib.expr.UnaryExpr.format","title":"<code>format(format_scalar=str, format_op=str)</code>","text":"Source code in <code>atomlib/expr.py</code> <pre><code>def format(self,\n           format_scalar: t.Callable[[ValueToken[T_co, V]], str] = str,\n           format_op: t.Callable[[OpToken[T_co, V]], str] = str) -&gt; str:\n    return f\"{self.lspace}{format_op(self.op_token)}{self.inner.format(format_scalar, format_op)}\"\n</code></pre>"},{"location":"api/expr/#atomlib.expr.BinaryExpr","title":"<code>BinaryExpr</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Expr[T_co, V]</code></p> Source code in <code>atomlib/expr.py</code> <pre><code>@dataclass\nclass BinaryExpr(Expr[T_co, V]):\n    op_token: OpToken[T_co, V]\n    op: BinaryOp[V] = field(init=False)\n    lhs: Expr[T_co, V]\n    rhs: Expr[T_co, V]\n\n    def __post_init__(self):\n        if not isinstance(self.op_token.op, BinaryOp):\n            raise TypeError()\n        self.op = self.op_token.op\n\n    def eval(self, map_f: t.Callable[[T_co], V]) -&gt; V:\n        return self.op.call(self.lhs.eval(map_f), self.rhs.eval(map_f))\n\n    def format(self,\n               format_scalar: t.Callable[[ValueToken[T_co, V]], str] = str,\n               format_op: t.Callable[[OpToken[T_co, V]], str] = str) -&gt; str:\n        return f\"{self.lhs.format(format_scalar, format_op)}{format_op(self.op_token)}{self.rhs.format(format_scalar, format_op)}\"\n</code></pre>"},{"location":"api/expr/#atomlib.expr.BinaryExpr.op_token","title":"<code>op_token: OpToken[T_co, V]</code>  <code>instance-attribute</code>","text":""},{"location":"api/expr/#atomlib.expr.BinaryExpr.op","title":"<code>op: BinaryOp[V] = field(init=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/expr/#atomlib.expr.BinaryExpr.lhs","title":"<code>lhs: Expr[T_co, V]</code>  <code>instance-attribute</code>","text":""},{"location":"api/expr/#atomlib.expr.BinaryExpr.rhs","title":"<code>rhs: Expr[T_co, V]</code>  <code>instance-attribute</code>","text":""},{"location":"api/expr/#atomlib.expr.BinaryExpr.eval","title":"<code>eval(map_f)</code>","text":"Source code in <code>atomlib/expr.py</code> <pre><code>def eval(self, map_f: t.Callable[[T_co], V]) -&gt; V:\n    return self.op.call(self.lhs.eval(map_f), self.rhs.eval(map_f))\n</code></pre>"},{"location":"api/expr/#atomlib.expr.BinaryExpr.format","title":"<code>format(format_scalar=str, format_op=str)</code>","text":"Source code in <code>atomlib/expr.py</code> <pre><code>def format(self,\n           format_scalar: t.Callable[[ValueToken[T_co, V]], str] = str,\n           format_op: t.Callable[[OpToken[T_co, V]], str] = str) -&gt; str:\n    return f\"{self.lhs.format(format_scalar, format_op)}{format_op(self.op_token)}{self.rhs.format(format_scalar, format_op)}\"\n</code></pre>"},{"location":"api/expr/#atomlib.expr.NaryExpr","title":"<code>NaryExpr</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Expr[T_co, V]</code></p> Source code in <code>atomlib/expr.py</code> <pre><code>@dataclass\nclass NaryExpr(Expr[T_co, V]):\n    op_tokens: t.Sequence[OpToken[T_co, V]]\n    op: NaryOp[V] = field(init=False)\n    args: t.Sequence[Expr[T_co, V]]\n    rspace: str = \"\"\n\n    def __post_init__(self):\n        op = next(token.op for token in self.op_tokens)\n        if not all(token.op == op for token in self.op_tokens[1:]):\n            raise ValueError(\"All `op`s must be identical inside a NaryExpr\")\n        if not isinstance(op, NaryOp):\n            raise TypeError()\n        self.op = op\n\n        assert len(self.op_tokens) == len(self.args) - 1\n\n    def eval(self, map_f: t.Callable[[T_co], V]) -&gt; V:\n        return self.op.call(*map(lambda expr: expr.eval(map_f), self.args))\n\n    def format(self,\n               format_scalar: t.Callable[[ValueToken[T_co, V]], str] = str,\n               format_op: t.Callable[[OpToken[T_co, V]], str] = str) -&gt; str:\n        return \"\".join(interleave(\n            map(lambda expr: expr.format(format_scalar, format_op), self.args),\n            map(format_op, self.op_tokens)\n        )) + self.rspace\n</code></pre>"},{"location":"api/expr/#atomlib.expr.NaryExpr.op_tokens","title":"<code>op_tokens: t.Sequence[OpToken[T_co, V]]</code>  <code>instance-attribute</code>","text":""},{"location":"api/expr/#atomlib.expr.NaryExpr.op","title":"<code>op: NaryOp[V] = field(init=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/expr/#atomlib.expr.NaryExpr.args","title":"<code>args: t.Sequence[Expr[T_co, V]]</code>  <code>instance-attribute</code>","text":""},{"location":"api/expr/#atomlib.expr.NaryExpr.rspace","title":"<code>rspace: str = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/expr/#atomlib.expr.NaryExpr.eval","title":"<code>eval(map_f)</code>","text":"Source code in <code>atomlib/expr.py</code> <pre><code>def eval(self, map_f: t.Callable[[T_co], V]) -&gt; V:\n    return self.op.call(*map(lambda expr: expr.eval(map_f), self.args))\n</code></pre>"},{"location":"api/expr/#atomlib.expr.NaryExpr.format","title":"<code>format(format_scalar=str, format_op=str)</code>","text":"Source code in <code>atomlib/expr.py</code> <pre><code>def format(self,\n           format_scalar: t.Callable[[ValueToken[T_co, V]], str] = str,\n           format_op: t.Callable[[OpToken[T_co, V]], str] = str) -&gt; str:\n    return \"\".join(interleave(\n        map(lambda expr: expr.format(format_scalar, format_op), self.args),\n        map(format_op, self.op_tokens)\n    )) + self.rspace\n</code></pre>"},{"location":"api/expr/#atomlib.expr.GroupExpr","title":"<code>GroupExpr</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Expr[T_co, V]</code></p> Source code in <code>atomlib/expr.py</code> <pre><code>@dataclass\nclass GroupExpr(Expr[T_co, V]):\n    open: GroupOpenToken\n    inner: Expr[T_co, V]\n    close: GroupCloseToken\n    lspace: str = \"\"\n    rspace: str = \"\"\n\n    def eval(self, map_f: t.Callable[[T_co], V]) -&gt; V:\n        return self.inner.eval(map_f)\n\n    def format(self,\n               format_scalar: t.Callable[[ValueToken[T_co, V]], str] = str,\n               format_op: t.Callable[[OpToken[T_co, V]], str] = str) -&gt; str:\n        return f\"{self.lspace}{self.open}{self.inner.format(format_scalar, format_op)}{self.close}{self.rspace}\"\n</code></pre>"},{"location":"api/expr/#atomlib.expr.GroupExpr.open","title":"<code>open: GroupOpenToken</code>  <code>instance-attribute</code>","text":""},{"location":"api/expr/#atomlib.expr.GroupExpr.inner","title":"<code>inner: Expr[T_co, V]</code>  <code>instance-attribute</code>","text":""},{"location":"api/expr/#atomlib.expr.GroupExpr.close","title":"<code>close: GroupCloseToken</code>  <code>instance-attribute</code>","text":""},{"location":"api/expr/#atomlib.expr.GroupExpr.lspace","title":"<code>lspace: str = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/expr/#atomlib.expr.GroupExpr.rspace","title":"<code>rspace: str = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/expr/#atomlib.expr.GroupExpr.eval","title":"<code>eval(map_f)</code>","text":"Source code in <code>atomlib/expr.py</code> <pre><code>def eval(self, map_f: t.Callable[[T_co], V]) -&gt; V:\n    return self.inner.eval(map_f)\n</code></pre>"},{"location":"api/expr/#atomlib.expr.GroupExpr.format","title":"<code>format(format_scalar=str, format_op=str)</code>","text":"Source code in <code>atomlib/expr.py</code> <pre><code>def format(self,\n           format_scalar: t.Callable[[ValueToken[T_co, V]], str] = str,\n           format_op: t.Callable[[OpToken[T_co, V]], str] = str) -&gt; str:\n    return f\"{self.lspace}{self.open}{self.inner.format(format_scalar, format_op)}{self.close}{self.rspace}\"\n</code></pre>"},{"location":"api/expr/#atomlib.expr.ValueExpr","title":"<code>ValueExpr</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Expr[T_co, V]</code></p> Source code in <code>atomlib/expr.py</code> <pre><code>@dataclass\nclass ValueExpr(Expr[T_co, V]):\n    token: ValueToken[T_co, V]\n    lspace: str = \"\"\n    rspace: str = \"\"\n\n    def eval(self, map_f: t.Callable[[T_co], V]) -&gt; V:\n        return map_f(self.token.val)\n\n    def format(self,\n               format_scalar: t.Callable[[ValueToken[T_co, V]], str] = str,\n               format_op: t.Callable[[OpToken[T_co, V]], str] = str) -&gt; str:\n        return f\"{self.lspace}{format_scalar(self.token)}{self.rspace}\"\n</code></pre>"},{"location":"api/expr/#atomlib.expr.ValueExpr.token","title":"<code>token: ValueToken[T_co, V]</code>  <code>instance-attribute</code>","text":""},{"location":"api/expr/#atomlib.expr.ValueExpr.lspace","title":"<code>lspace: str = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/expr/#atomlib.expr.ValueExpr.rspace","title":"<code>rspace: str = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/expr/#atomlib.expr.ValueExpr.eval","title":"<code>eval(map_f)</code>","text":"Source code in <code>atomlib/expr.py</code> <pre><code>def eval(self, map_f: t.Callable[[T_co], V]) -&gt; V:\n    return map_f(self.token.val)\n</code></pre>"},{"location":"api/expr/#atomlib.expr.ValueExpr.format","title":"<code>format(format_scalar=str, format_op=str)</code>","text":"Source code in <code>atomlib/expr.py</code> <pre><code>def format(self,\n           format_scalar: t.Callable[[ValueToken[T_co, V]], str] = str,\n           format_op: t.Callable[[OpToken[T_co, V]], str] = str) -&gt; str:\n    return f\"{self.lspace}{format_scalar(self.token)}{self.rspace}\"\n</code></pre>"},{"location":"api/expr/#atomlib.expr.Parser","title":"<code>Parser</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Generic[T_co, V]</code></p> Source code in <code>atomlib/expr.py</code> <pre><code>@dataclass(init=False)\nclass Parser(t.Generic[T_co, V]):\n    parse_scalar: t.Callable[[str], T_co]\n    ops: t.Dict[str, Op[V]]\n    group_open: t.Dict[str, int]\n    group_close: t.Dict[str, int]\n\n    token_re: re.Pattern = field(init=False)\n    \"\"\"Regex matching operators, brackets, and whitespace\"\"\"\n\n    @t.overload\n    def __init__(self: Parser[str, V], ops: t.Sequence[Op[V]],\n                 parse_scalar: t.Optional[t.Callable[[str], str]] = None,\n                 groups: t.Optional[t.Sequence[t.Tuple[str, str]]] = None):\n        ...\n\n    @t.overload\n    def __init__(self: Parser[T_co, V], ops: t.Sequence[Op[V]],\n                 parse_scalar: t.Callable[[str], T_co],\n                 groups: t.Optional[t.Sequence[t.Tuple[str, str]]] = None):\n        ...\n\n    def __init__(self, ops: t.Sequence[Op[V]],\n                 parse_scalar: t.Optional[t.Callable[[str], t.Union[str, T_co]]] = None,\n                 groups: t.Optional[t.Sequence[t.Tuple[str, str]]] = None):\n        self.parse_scalar = t.cast(t.Callable[[str], T_co], parse_scalar or (lambda s: s))\n\n        if groups is None:\n            groups = [('(', ')'), ('[', ']')]\n\n        match_dict: t.Dict[str, t.Optional[Op[V]]] = {}\n\n        self.group_open = {}\n        self.group_close = {}\n        for (i, (group_open, group_close)) in enumerate(groups):\n            if group_open in match_dict:\n                raise ValueError(f\"Group open token '{group_open}' already defined\")\n            if group_close in match_dict:\n                raise ValueError(f\"Group close token '{group_close}' already defined\")\n            self.group_open[group_open] = i\n            self.group_close[group_close] = i\n            match_dict[group_open] = None\n            match_dict[group_close] = None\n\n        nary_precedences = set()\n        for op in ops:\n            if isinstance(op, NaryOp):\n                if op.precedence in nary_precedences:\n                    raise ValueError(\"N-ary operators must have distinct precedences. \"\n                                     f\"Precedence {op.precedence} conflicts with {op!r}\")\n                nary_precedences.add(op.precedence)\n            for alias in op.aliases:\n                if alias in match_dict:\n                    raise ValueError(f\"Alias '{alias}' already defined\")\n                match_dict[alias] = op\n\n        match_list = list(match_dict.items())\n        match_list.sort(key=lambda a: -len(a[0]))  #longer operators match first\n        self.ops = {k: v for (k, v) in match_list if v is not None}\n\n        def op_to_regex(tup: t.Tuple[str, t.Optional[Op[V]]]):\n            alias, op = tup\n            s = re.escape(alias)  #escape operator for use in regex\n            if op is not None and op.requires_whitespace:\n                #assert operator must be surrounded by whitespace\n                s = r\"(?&lt;=\\s){}(?=\\s)\".format(s)\n            return s\n\n        op_alternation = \"|\".join(map(op_to_regex, match_list))\n        self.token_re = re.compile(f\"(\\\\s+|{op_alternation})\")\n\n    def parse(self, reader: TextIOBase) -&gt; Expr[T_co, V]:\n        state = ParseState(self, reader)\n        expr = state.parse_expr()\n        if not state.empty():\n            raise ValueError(f\"At {state.line}:{state.char}, expected binary operator or end of expression, instead got token {state.peek()}\")\n        return expr\n</code></pre>"},{"location":"api/expr/#atomlib.expr.Parser.parse_scalar","title":"<code>parse_scalar: t.Callable[[str], T_co] = t.cast(t.Callable[[str], T_co], parse_scalar or lambda s: s)</code>  <code>instance-attribute</code>","text":""},{"location":"api/expr/#atomlib.expr.Parser.group_open","title":"<code>group_open: t.Dict[str, int] = {}</code>  <code>instance-attribute</code>","text":""},{"location":"api/expr/#atomlib.expr.Parser.group_close","title":"<code>group_close: t.Dict[str, int] = {}</code>  <code>instance-attribute</code>","text":""},{"location":"api/expr/#atomlib.expr.Parser.ops","title":"<code>ops: t.Dict[str, Op[V]] = {k: vfor (k, v) in match_list if v is not None}</code>  <code>instance-attribute</code>","text":""},{"location":"api/expr/#atomlib.expr.Parser.token_re","title":"<code>token_re: re.Pattern = re.compile(f'(\\s+|{op_alternation})')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Regex matching operators, brackets, and whitespace</p>"},{"location":"api/expr/#atomlib.expr.Parser.parse","title":"<code>parse(reader)</code>","text":"Source code in <code>atomlib/expr.py</code> <pre><code>def parse(self, reader: TextIOBase) -&gt; Expr[T_co, V]:\n    state = ParseState(self, reader)\n    expr = state.parse_expr()\n    if not state.empty():\n        raise ValueError(f\"At {state.line}:{state.char}, expected binary operator or end of expression, instead got token {state.peek()}\")\n    return expr\n</code></pre>"},{"location":"api/expr/#atomlib.expr.ParseState","title":"<code>ParseState</code>","text":"<p>             Bases: <code>Generic[T_co, V]</code></p> Source code in <code>atomlib/expr.py</code> <pre><code>class ParseState(t.Generic[T_co, V]):\n    def __init__(self, parser: Parser[T_co, V], reader: TextIOBase):\n        self.parser: Parser[T_co, V] = parser\n        self._reader = reader\n        self._buf: t.Optional[str] = None\n        self._peek: t.List[Token[T_co, V]] = []\n        self.line = 0\n        self.char = 1\n\n    def empty(self) -&gt; bool:\n        return self.peek() is None\n\n    def _get_buf(self) -&gt; t.Optional[str]:\n        if self._buf is not None:\n            return self._buf\n        try:\n            self._buf = next(self._reader)\n            self.line += 1\n            self.char = 1\n        except StopIteration:\n            pass\n        return self._buf\n\n    def _refill_peek(self):\n        if len(self._peek) &gt; 0:\n            return\n        try:\n            buf = next(self._reader)\n            self.line += 1\n            self.char = 1\n        except StopIteration:\n            return None\n        if buf is None or len(buf) == 0:  # type: ignore\n            return None\n\n        split = self.parser.token_re.split(buf)\n        for s in split:\n            if len(s) == 0:\n                continue\n            span = (self.char, self.char + len(s))\n            self.char += len(s)\n            self._peek.append(self.make_token(s, self.line, span))\n\n        self._peek.reverse()\n\n    def peek(self) -&gt; t.Optional[Token[T_co, V]]:\n        self._refill_peek()\n        return self._peek[-1] if len(self._peek) &gt; 0 else None\n\n    def collect_wspace(self) -&gt; str:\n        wspace = \"\"\n        while True:\n            token = self.peek()\n            if not isinstance(token, WhitespaceToken):\n                break\n            wspace += token.raw\n            self.next()\n        return wspace\n\n    def make_token(self, s: str, line: int, span: t.Tuple[int, int]) -&gt; Token[T_co, V]:\n        if s in self.parser.group_open:\n            return GroupOpenToken(s, line, span)\n        if s in self.parser.group_close:\n            return GroupCloseToken(s, line, span)\n        if s in self.parser.ops:\n            return OpToken(s, line, span, self.parser.ops[s])\n        if WSPACE_RE.fullmatch(s):\n            return WhitespaceToken(s, line, span)\n\n        try:\n            return ValueToken(s, line, span, self.parser.parse_scalar(s))\n        except (ValueError, TypeError):\n            raise ValueError(f\"Syntax error at {line}:{span[0]}: Unexpected token '{s}'\") from None\n\n    def next(self) -&gt; t.Optional[Token[T_co, V]]:\n        token = self.peek()\n        if token is not None:\n            self._peek.pop()\n        return token\n\n    def parse_expr(self) -&gt; Expr[T_co, V]:\n        \"\"\"\n            EXPR := PRIMARY, [ BINARY ]\n        \"\"\"\n        logging.debug(\"parse_expr()\")\n        lhs = self.parse_primary()\n        return self.parse_nary(lhs)\n\n    def parse_nary(self, lhs: Expr[T_co, V], level: t.Optional[int] = None) -&gt; Expr[T_co, V]:\n        \"\"\"\n            NARY := { BINARY_OP | NARY_OP, ( PRIMARY, ? higher precedence NARY ? ) }\n        \"\"\"\n        logging.debug(f\"parse_nary({lhs}, level={level})\")\n        token = self.peek()\n        logging.debug(f\"token: '{token!r}'\")\n\n        while token is not None:\n            if not isinstance(token, OpToken) or \\\n               not isinstance(token.op, (NaryOp, BinaryOp)):\n                break\n\n            if level is not None and not token.op.precedes(level):\n                # next op has lower precedence, it needs to be parsed at a higher level\n                break\n\n            self.next()\n            rhs = self.parse_primary()\n            logging.debug(f\"rhs: '{rhs}'\")\n\n            inner = self.peek()\n            if not inner is None and isinstance(inner, OpToken):\n                inner_op = inner.op\n                if isinstance(inner_op, (NaryOp, BinaryOp)) and \\\n                    inner_op.precedes(token.op):\n                    #rhs is actually lhs of an inner expression\n                    rhs = self.parse_nary(rhs, token.op.precedence)\n\n            # append rhs to lhs and loop\n            if isinstance(token.op, NaryOp):\n                if isinstance(lhs, NaryExpr) and token.op == lhs.op:\n                    # append to existing n-ary node\n                    lhs = NaryExpr(list(lhs.op_tokens) + [token], list(lhs.args) + [rhs])\n                else:\n                    # make new n-ary expression\n                    lhs = NaryExpr([token], [lhs, rhs])\n            else:\n                # or make binary expression\n                lhs = BinaryExpr(token, lhs, rhs)\n\n            token = self.peek()\n\n        return lhs\n\n    def parse_primary(self) -&gt; Expr[T_co, V]:\n        \"\"\"\n            PRIMARY := GROUP_OPEN, EXPR, GROUP_CLOSE | UNARY_OP, PRIMARY | SCALAR\n        \"\"\"\n\n        logging.debug(\"parse_primary()\")\n        lspace = self.collect_wspace()\n        token = self.peek()\n        logging.debug(f\"token: '{token!r}'\")\n        if token is None:\n            raise ValueError(\"Unexpected EOF while parsing expression\")\n\n        if isinstance(token, GroupOpenToken):\n            self.next()\n            inner = self.parse_expr()\n            close = self.next()\n            rspace = self.collect_wspace()\n            if close is None:\n                raise ValueError(f\"Unclosed delimeter '{token.raw}' opened at {token.line}:{token.span[0]}\")\n            if not isinstance(close, GroupCloseToken):\n                raise ValueError(f\"At {close.line}:{close.span[0]}: Expected operator or group close, instead got '{close.raw}'\")\n            if self.parser.group_open[token.raw] != self.parser.group_close[close.raw]:\n                raise ValueError(f\"At {token.line}:{token.span[0]}-{close.span[1]}: Mismatched delimeters: '{token.raw}' closed with '{close.raw}'\")\n            return GroupExpr(token, inner, close, lspace, rspace)\n\n        if isinstance(token, GroupCloseToken):\n            raise ValueError(f\"At {token.line}:{token.span[0]}: Unexpected delimeter '{token.raw.strip()}'\")\n\n        if isinstance(token, OpToken):\n            self.next()\n            if not isinstance(token.op, UnaryOp):\n                raise ValueError(f\"At {token.line}:{token.span[0]}: Unexpected operator '{token.raw}'. Expected a value or prefix operator.\")\n            inner = self.parse_primary()\n            return UnaryExpr(token, inner, lspace)\n\n        if isinstance(token, ValueToken):\n            self.next()\n            rspace = self.collect_wspace()\n            return ValueExpr(token, lspace, rspace)\n\n        raise TypeError(f\"Unknown token type '{type(token)}'\")\n</code></pre>"},{"location":"api/expr/#atomlib.expr.ParseState.parser","title":"<code>parser: Parser[T_co, V] = parser</code>  <code>instance-attribute</code>","text":""},{"location":"api/expr/#atomlib.expr.ParseState.line","title":"<code>line = 0</code>  <code>instance-attribute</code>","text":""},{"location":"api/expr/#atomlib.expr.ParseState.char","title":"<code>char = 1</code>  <code>instance-attribute</code>","text":""},{"location":"api/expr/#atomlib.expr.ParseState.empty","title":"<code>empty()</code>","text":"Source code in <code>atomlib/expr.py</code> <pre><code>def empty(self) -&gt; bool:\n    return self.peek() is None\n</code></pre>"},{"location":"api/expr/#atomlib.expr.ParseState.peek","title":"<code>peek()</code>","text":"Source code in <code>atomlib/expr.py</code> <pre><code>def peek(self) -&gt; t.Optional[Token[T_co, V]]:\n    self._refill_peek()\n    return self._peek[-1] if len(self._peek) &gt; 0 else None\n</code></pre>"},{"location":"api/expr/#atomlib.expr.ParseState.collect_wspace","title":"<code>collect_wspace()</code>","text":"Source code in <code>atomlib/expr.py</code> <pre><code>def collect_wspace(self) -&gt; str:\n    wspace = \"\"\n    while True:\n        token = self.peek()\n        if not isinstance(token, WhitespaceToken):\n            break\n        wspace += token.raw\n        self.next()\n    return wspace\n</code></pre>"},{"location":"api/expr/#atomlib.expr.ParseState.make_token","title":"<code>make_token(s, line, span)</code>","text":"Source code in <code>atomlib/expr.py</code> <pre><code>def make_token(self, s: str, line: int, span: t.Tuple[int, int]) -&gt; Token[T_co, V]:\n    if s in self.parser.group_open:\n        return GroupOpenToken(s, line, span)\n    if s in self.parser.group_close:\n        return GroupCloseToken(s, line, span)\n    if s in self.parser.ops:\n        return OpToken(s, line, span, self.parser.ops[s])\n    if WSPACE_RE.fullmatch(s):\n        return WhitespaceToken(s, line, span)\n\n    try:\n        return ValueToken(s, line, span, self.parser.parse_scalar(s))\n    except (ValueError, TypeError):\n        raise ValueError(f\"Syntax error at {line}:{span[0]}: Unexpected token '{s}'\") from None\n</code></pre>"},{"location":"api/expr/#atomlib.expr.ParseState.next","title":"<code>next()</code>","text":"Source code in <code>atomlib/expr.py</code> <pre><code>def next(self) -&gt; t.Optional[Token[T_co, V]]:\n    token = self.peek()\n    if token is not None:\n        self._peek.pop()\n    return token\n</code></pre>"},{"location":"api/expr/#atomlib.expr.ParseState.parse_expr","title":"<code>parse_expr()</code>","text":"<p>EXPR := PRIMARY, [ BINARY ]</p> Source code in <code>atomlib/expr.py</code> <pre><code>def parse_expr(self) -&gt; Expr[T_co, V]:\n    \"\"\"\n        EXPR := PRIMARY, [ BINARY ]\n    \"\"\"\n    logging.debug(\"parse_expr()\")\n    lhs = self.parse_primary()\n    return self.parse_nary(lhs)\n</code></pre>"},{"location":"api/expr/#atomlib.expr.ParseState.parse_nary","title":"<code>parse_nary(lhs, level=None)</code>","text":"<p>NARY := { BINARY_OP | NARY_OP, ( PRIMARY, ? higher precedence NARY ? ) }</p> Source code in <code>atomlib/expr.py</code> <pre><code>def parse_nary(self, lhs: Expr[T_co, V], level: t.Optional[int] = None) -&gt; Expr[T_co, V]:\n    \"\"\"\n        NARY := { BINARY_OP | NARY_OP, ( PRIMARY, ? higher precedence NARY ? ) }\n    \"\"\"\n    logging.debug(f\"parse_nary({lhs}, level={level})\")\n    token = self.peek()\n    logging.debug(f\"token: '{token!r}'\")\n\n    while token is not None:\n        if not isinstance(token, OpToken) or \\\n           not isinstance(token.op, (NaryOp, BinaryOp)):\n            break\n\n        if level is not None and not token.op.precedes(level):\n            # next op has lower precedence, it needs to be parsed at a higher level\n            break\n\n        self.next()\n        rhs = self.parse_primary()\n        logging.debug(f\"rhs: '{rhs}'\")\n\n        inner = self.peek()\n        if not inner is None and isinstance(inner, OpToken):\n            inner_op = inner.op\n            if isinstance(inner_op, (NaryOp, BinaryOp)) and \\\n                inner_op.precedes(token.op):\n                #rhs is actually lhs of an inner expression\n                rhs = self.parse_nary(rhs, token.op.precedence)\n\n        # append rhs to lhs and loop\n        if isinstance(token.op, NaryOp):\n            if isinstance(lhs, NaryExpr) and token.op == lhs.op:\n                # append to existing n-ary node\n                lhs = NaryExpr(list(lhs.op_tokens) + [token], list(lhs.args) + [rhs])\n            else:\n                # make new n-ary expression\n                lhs = NaryExpr([token], [lhs, rhs])\n        else:\n            # or make binary expression\n            lhs = BinaryExpr(token, lhs, rhs)\n\n        token = self.peek()\n\n    return lhs\n</code></pre>"},{"location":"api/expr/#atomlib.expr.ParseState.parse_primary","title":"<code>parse_primary()</code>","text":"<p>PRIMARY := GROUP_OPEN, EXPR, GROUP_CLOSE | UNARY_OP, PRIMARY | SCALAR</p> Source code in <code>atomlib/expr.py</code> <pre><code>def parse_primary(self) -&gt; Expr[T_co, V]:\n    \"\"\"\n        PRIMARY := GROUP_OPEN, EXPR, GROUP_CLOSE | UNARY_OP, PRIMARY | SCALAR\n    \"\"\"\n\n    logging.debug(\"parse_primary()\")\n    lspace = self.collect_wspace()\n    token = self.peek()\n    logging.debug(f\"token: '{token!r}'\")\n    if token is None:\n        raise ValueError(\"Unexpected EOF while parsing expression\")\n\n    if isinstance(token, GroupOpenToken):\n        self.next()\n        inner = self.parse_expr()\n        close = self.next()\n        rspace = self.collect_wspace()\n        if close is None:\n            raise ValueError(f\"Unclosed delimeter '{token.raw}' opened at {token.line}:{token.span[0]}\")\n        if not isinstance(close, GroupCloseToken):\n            raise ValueError(f\"At {close.line}:{close.span[0]}: Expected operator or group close, instead got '{close.raw}'\")\n        if self.parser.group_open[token.raw] != self.parser.group_close[close.raw]:\n            raise ValueError(f\"At {token.line}:{token.span[0]}-{close.span[1]}: Mismatched delimeters: '{token.raw}' closed with '{close.raw}'\")\n        return GroupExpr(token, inner, close, lspace, rspace)\n\n    if isinstance(token, GroupCloseToken):\n        raise ValueError(f\"At {token.line}:{token.span[0]}: Unexpected delimeter '{token.raw.strip()}'\")\n\n    if isinstance(token, OpToken):\n        self.next()\n        if not isinstance(token.op, UnaryOp):\n            raise ValueError(f\"At {token.line}:{token.span[0]}: Unexpected operator '{token.raw}'. Expected a value or prefix operator.\")\n        inner = self.parse_primary()\n        return UnaryExpr(token, inner, lspace)\n\n    if isinstance(token, ValueToken):\n        self.next()\n        rspace = self.collect_wspace()\n        return ValueExpr(token, lspace, rspace)\n\n    raise TypeError(f\"Unknown token type '{type(token)}'\")\n</code></pre>"},{"location":"api/expr/#atomlib.expr.SupportsBool","title":"<code>SupportsBool</code>","text":"<p>             Bases: <code>Protocol</code></p> Source code in <code>atomlib/expr.py</code> <pre><code>class SupportsBool(t.Protocol):\n    def __and__(self: SupportsBoolSelf, other: SupportsBoolSelf) -&gt; SupportsBoolSelf:\n        ...\n\n    def __or__(self: SupportsBoolSelf, other: SupportsBoolSelf) -&gt; SupportsBoolSelf:\n        ...\n\n    def __xor__(self: SupportsBoolSelf, other: SupportsBoolSelf) -&gt; SupportsBoolSelf:\n        ...\n\n    def __invert__(self: SupportsBoolSelf) -&gt; SupportsBoolSelf:\n        ...\n</code></pre>"},{"location":"api/expr/#atomlib.expr.SupportsNum","title":"<code>SupportsNum</code>","text":"<p>             Bases: <code>Protocol</code></p> Source code in <code>atomlib/expr.py</code> <pre><code>class SupportsNum(t.Protocol):\n    def __add__(self: SupportsNumSelf, other: SupportsNumSelf) -&gt; SupportsNumSelf:\n        ...\n\n    def __sub__(self: SupportsNumSelf, other: SupportsNumSelf) -&gt; SupportsNumSelf:\n        ...\n\n    def __mul__(self: SupportsNumSelf, other: SupportsNumSelf) -&gt; SupportsNumSelf:\n        ...\n\n    def __truediv__(self: SupportsNumSelf, other: SupportsNumSelf) -&gt; SupportsNumSelf:\n        ...\n\n    def __floordiv__(self: SupportsNumSelf, other: SupportsNumSelf) -&gt; SupportsNumSelf:\n        ...\n\n    def __mod__(self: SupportsNumSelf, other: SupportsNumSelf) -&gt; SupportsNumSelf:\n        ...\n\n    def __pow__(self: SupportsNumSelf, other: SupportsNumSelf) -&gt; SupportsNumSelf:\n        ...\n\n    def __neg__(self: SupportsNumSelf) -&gt; SupportsNumSelf:\n        ...\n\n    def __pos__(self: SupportsNumSelf) -&gt; SupportsNumSelf:\n        ...\n</code></pre>"},{"location":"api/expr/#atomlib.expr.interleave","title":"<code>interleave(l1, l2)</code>","text":"Source code in <code>atomlib/expr.py</code> <pre><code>def interleave(l1: t.Iterable[T_co], l2: t.Iterable[T_co]) -&gt; t.Iterator[T_co]:\n    for (v1, v2) in zip_longest(l1, l2):\n        yield v1\n        if v2 is not None:\n            yield v2\n</code></pre>"},{"location":"api/expr/#atomlib.expr.parse_numeric","title":"<code>parse_numeric(s)</code>","text":"Source code in <code>atomlib/expr.py</code> <pre><code>def parse_numeric(s: str) -&gt; t.Union[int, float]:\n    try:\n        return int(s)\n    except ValueError:\n        pass\n    return float(s)\n</code></pre>"},{"location":"api/expr/#atomlib.expr.sub","title":"<code>sub(lhs, rhs=None)</code>","text":"Source code in <code>atomlib/expr.py</code> <pre><code>def sub(lhs: SupportsNum, rhs: t.Optional[SupportsNum] = None):\n    if rhs is None:\n        return -lhs\n    return lhs-rhs\n</code></pre>"},{"location":"api/expr/#atomlib.expr.add","title":"<code>add(lhs, rhs=None)</code>","text":"Source code in <code>atomlib/expr.py</code> <pre><code>def add(lhs: SupportsNum, rhs: t.Optional[SupportsNum] = None):\n    if rhs is None:\n        return +lhs\n    return lhs+rhs\n</code></pre>"},{"location":"api/expr/#atomlib.expr.parse_boolean","title":"<code>parse_boolean(s)</code>","text":"Source code in <code>atomlib/expr.py</code> <pre><code>def parse_boolean(s: str) -&gt; bool:\n    if s.lower() in (\"0\", \"false\", \"f\"):\n        return False\n    elif s.lower() in (\"1\", \"true\", \"t\"):\n        return True\n    raise ValueError(f\"Can't parse '{s}' as boolean\")\n</code></pre>"},{"location":"api/expr/#atomlib.expr.stack","title":"<code>stack(*vs)</code>","text":"Source code in <code>atomlib/expr.py</code> <pre><code>def stack(*vs: numpy.ndarray) -&gt; numpy.ndarray:\n    return numpy.stack(vs, axis=0)\n</code></pre>"},{"location":"api/make/","title":"<code>atomlib.make</code>","text":""},{"location":"api/make/#atomlib.make.CellType","title":"<code>CellType = t.Literal['conv', 'prim', 'ortho']</code>  <code>module-attribute</code>","text":""},{"location":"api/make/#atomlib.make.fcc","title":"<code>fcc(elem, a, *, cell='conv', additional=None)</code>","text":"<p>Make a FCC lattice of the specified element, with the given cell. If <code>cell='conv'</code> (the default), return the conventional cell, four atoms with cubic cell symmetry. If <code>cell='prim'</code>, return the primitive cell, a single atom with rhombohedral cell symmetry. If <code>cell='ortho'</code>, return an orthogonal cell, two atoms in a cell of size <code>[a/sqrt(2), a/sqrt(2), a]</code>.</p> <p>If <code>additional</code> is specified, those atoms will be added to the lattice (in fractional coordinates).</p> <p>Parameters:</p> Name Type Description Default <code>elem</code> <code>ElemLike</code> <p>Element to add (e.g. <code>'Al'</code> or <code>13</code>)</p> required <code>a</code> <code>Num</code> <p>Lattice parameter (Angstrom)</p> required <code>cell</code> <code>CellType</code> <p>Cell type to return ('conv', 'prim', or 'ortho')</p> <code>'conv'</code> <code>additional</code> <code>Optional[IntoAtoms]</code> <p>Additional atoms to add to the structure.</p> <code>None</code> <p>Returns:</p> Type Description <code>AtomCell</code> <p>Periodic FCC unit cell</p> Source code in <code>atomlib/make/__init__.py</code> <pre><code>def fcc(elem: ElemLike, a: Num, *, cell: CellType = 'conv', additional: t.Optional[IntoAtoms] = None) -&gt; AtomCell:\n    \"\"\"\n    Make a FCC lattice of the specified element, with the given cell.\n    If `cell='conv'` (the default), return the conventional cell, four atoms with cubic cell symmetry.\n    If `cell='prim'`, return the primitive cell, a single atom with rhombohedral cell symmetry.\n    If `cell='ortho'`, return an orthogonal cell, two atoms in a cell of size `[a/sqrt(2), a/sqrt(2), a]`.\n\n    If `additional` is specified, those atoms will be added to the lattice (in fractional coordinates).\n\n    Args:\n      elem: Element to add (e.g. `'Al'` or `13`)\n      a: Lattice parameter (Angstrom)\n      cell: Cell type to return ('conv', 'prim', or 'ortho')\n      additional: Additional atoms to add to the structure.\n\n    Returns:\n      Periodic FCC unit cell\n    \"\"\"\n\n    elems = [get_elem(elem)]\n    cell = t.cast(CellType, str(cell).lower())\n\n    if cell == 'prim':\n        xs = ys = zs = [0.]\n        ortho = LinearTransform3D(a / 2. * numpy.array([\n            [0., 1., 1.],\n            [1., 0., 1.],\n            [1., 1., 0.],\n        ]))\n    elif cell == 'ortho':\n        elems *= 2\n        xs = ys = zs = [0., 0.5]\n        b = a / numpy.sqrt(2)\n        ortho = LinearTransform3D.scale(b, b, a)\n    elif cell == 'conv':\n        elems *= 4\n        xs = [0., 0., 0.5, 0.5]\n        ys = [0., 0.5, 0., 0.5]\n        zs = [0., 0.5, 0.5, 0.]\n        ortho = LinearTransform3D.scale(all=a)\n    else:\n        raise ValueError(f\"Unknown cell type '{cell}'. Expected 'conv', 'prim', or 'ortho'.\")\n\n    frame = Atoms(dict(x=xs, y=ys, z=zs, elem=elems))\n    if additional is not None:\n        frame = Atoms.concat((frame, additional), how='vertical')\n\n    return AtomCell.from_ortho(frame, ortho, frame='cell_frac')\n</code></pre>"},{"location":"api/make/#atomlib.make.wurtzite","title":"<code>wurtzite(elems, a, c=None, d=None, *, cell='conv')</code>","text":"<p>Create a wurzite lattice of the specified two elements, with the given cell. <code>a</code> and <code>c</code> are the hexagonal cell parameters. <code>d</code> is the fractional distance between the two sublattices.</p> <p>If <code>cell='prim'</code> or <code>cell='conv'</code> (the default), return a hexagonal unit cell. If <code>cell='ortho'</code>, return an orthogonal unit cell constructed from the hexagonal unit cell as \\(\\hat{\\mathbf{a}} = \\mathbf{a}\\), \\(\\hat{\\mathbf{b}} = \\mathbf{a} + 2 \\mathbf{b}\\), \\(\\hat{\\mathbf{c}} = \\mathbf{c}\\).</p> <p>Parameters:</p> Name Type Description Default <code>elems</code> <code>Union[str, Sequence[ElemLike]]</code> <p>Elements to add (e.g. <code>'AlN'</code> or <code>('Al', 'N')</code>)</p> required <code>a</code> <code>Num</code> <p>Lattice parameter (Angstrom)</p> required <code>c</code> <code>Optional[Num]</code> <p>Vertical lattice parameter (Angstrom)</p> <code>None</code> <code>d</code> <code>Optional[Num]</code> <p>Vertical distance between the two sublattices (fractional)</p> <code>None</code> <code>cell</code> <code>CellType</code> <p>Cell type to return ('conv', 'prim', or 'ortho')</p> <code>'conv'</code> <p>Returns:</p> Type Description <code>AtomCell</code> <p>Periodic wurtzite unit cell</p> Source code in <code>atomlib/make/__init__.py</code> <pre><code>def wurtzite(elems: t.Union[str, t.Sequence[ElemLike]], a: Num, c: t.Optional[Num] = None,\n             d: t.Optional[Num] = None, *, cell: CellType = 'conv') -&gt; AtomCell:\n    r\"\"\"\n    Create a wurzite lattice of the specified two elements, with the given cell.\n    `a` and `c` are the hexagonal cell parameters. `d` is the fractional distance\n    between the two sublattices.\n\n    If `cell='prim'` or `cell='conv'` (the default), return a hexagonal unit cell.\n    If `cell='ortho'`, return an orthogonal unit cell constructed from the hexagonal unit cell as\n    $\\hat{\\mathbf{a}} = \\mathbf{a}$, $\\hat{\\mathbf{b}} = \\mathbf{a} + 2 \\mathbf{b}$, $\\hat{\\mathbf{c}} = \\mathbf{c}$.\n\n    Args:\n      elems: Elements to add (e.g. `'AlN'` or `('Al', 'N')`)\n      a: Lattice parameter (Angstrom)\n      c: Vertical lattice parameter (Angstrom)\n      d: Vertical distance between the two sublattices (fractional)\n      cell: Cell type to return ('conv', 'prim', or 'ortho')\n\n    Returns:\n      Periodic wurtzite unit cell\n    \"\"\"\n    if isinstance(elems, str):\n        elems = get_elems(elems)\n    else:\n        elems = list(map(get_elem, elems))\n\n    if len(elems) != 2:\n        raise ValueError(\"Expected two elements.\")\n\n    # default to ideal c/a\n    c_a = float(numpy.sqrt(8. / 3.) if c is None else c / a)\n\n    d = 0.25 + 1 / (3 * c_a**2) if d is None else d\n    if not 0 &lt; d &lt; 0.5:\n        raise ValueError(f\"Invalid 'd' parameter: {d}\")\n\n    cell = t.cast(CellType, str(cell).lower())\n    if cell not in ('prim', 'conv', 'ortho'):\n        raise ValueError(f\"Unknown cell type '{cell}'. Expected 'conv', 'prim', or 'ortho'.\")\n\n    ortho = cell_to_ortho(\n        a * numpy.array([1., 1., c_a]), \n        numpy.pi * numpy.array([1/2., 1/2., 2/3.])\n    )\n    xs = [2/3, 2/3, 1/3, 1/3]\n    ys = [1/3, 1/3, 2/3, 2/3]\n    #zs = [1. - d, 0., 0.5 - d, 0.5]\n    zs = [0.5, 0.5 + d, 0., d]\n    elems *= 2\n\n    frame = Atoms(dict(x=xs, y=ys, z=zs, elem=elems))\n    atoms = AtomCell.from_ortho(frame, ortho, frame='cell_frac')\n    if cell == 'ortho':\n        return _ortho_hexagonal(atoms)\n    return atoms\n</code></pre>"},{"location":"api/make/#atomlib.make.graphite","title":"<code>graphite(elem=None, a=None, c=None, *, cell='conv')</code>","text":"Source code in <code>atomlib/make/__init__.py</code> <pre><code>def graphite(elem: t.Union[str, ElemLike, None] = None, a: t.Optional[Num] = None,\n             c: t.Optional[Num] = None, *, cell: CellType = 'conv'):\n    if elem is None:\n        elem = 6\n    else:\n        elem = get_elem(elem)\n        if elem != 6 and a is None or c is None:\n            raise ValueError(\"'a' and 'c' must be specified for non-graphite elements.\")\n\n    if a is None:\n        a = 2.47\n    if c is None:\n        c = 8.69\n\n    cell = t.cast(CellType, str(cell).lower())\n    if cell not in ('prim', 'conv', 'ortho'):\n        raise ValueError(f\"Unknown cell type '{cell}'. Expected 'conv', 'prim', or 'ortho'.\")\n\n    ortho = cell_to_ortho(\n        numpy.array([a, a, c]), \n        numpy.pi * numpy.array([1/2., 1/2., 2/3.])\n    )\n    xs = [0., 2/3, 0., 1/3]\n    ys = [0., 1/3, 0., 2/3]\n    zs = [0., 0., 1/2, 1/2]\n    elems = [elem] * 4\n\n    frame = Atoms(dict(x=xs, y=ys, z=zs, elem=elems))\n    atoms = AtomCell.from_ortho(frame, ortho, frame='cell_frac')\n\n    if cell == 'ortho':\n        return _ortho_hexagonal(atoms)\n    return atoms\n</code></pre>"},{"location":"api/make/#atomlib.make.rocksalt","title":"<code>rocksalt(elems, a, *, cell='conv')</code>","text":"<p>Create a rock salt FCC structure AB. Returns the same cell types as <code>fcc</code>.</p> <p>Parameters:</p> Name Type Description Default <code>elems</code> <code>Union[str, Sequence[ElemLike]]</code> <p>Elements to add (e.g. <code>'NaCl'</code> or <code>('Na', 'Cl')</code>)</p> required <code>a</code> <code>Num</code> <p>Lattice parameter (Angstrom)</p> required <code>cell</code> <code>CellType</code> <p>Cell type to return ('conv', 'prim', or 'ortho'). Returns     the same cell types as <code>fcc</code>.</p> <code>'conv'</code> <p>Returns:</p> Type Description <code>AtomCell</code> <p>Periodic rocksalt unit cell</p> Source code in <code>atomlib/make/__init__.py</code> <pre><code>def rocksalt(elems: t.Union[str, t.Sequence[ElemLike]], a: Num, *,\n             cell: CellType = 'conv') -&gt; AtomCell:\n    \"\"\"\n    Create a rock salt FCC structure AB. Returns the same cell types as `fcc`.\n\n    Args:\n      elems: Elements to add (e.g. `'NaCl'` or `('Na', 'Cl')`)\n      a: Lattice parameter (Angstrom)\n      cell: Cell type to return ('conv', 'prim', or 'ortho'). Returns\n            the same cell types as `fcc`.\n\n    Returns:\n      Periodic rocksalt unit cell\n    \"\"\"\n    if isinstance(elems, str):\n        elems = get_elems(elems)\n    else:\n        elems = list(map(get_elem, elems))\n\n    if len(elems) != 2:\n        raise ValueError(\"Expected two elements.\")\n\n    if cell == 'prim':\n        additional: t.Dict[str, t.Any] = {\n            'x': [-0.5],\n            'y': [0.5],\n            'z': [0.5],\n            'elem': [elems[1]],\n        }\n    elif cell == 'ortho':\n        additional: t.Dict[str, t.Any] = {\n            'x': [0.5, 0.0],\n            'y': [0.5, 0.0],\n            'z': [0.0, 0.5],\n            'elem': [elems[1]] * 2,\n        }\n    elif cell == 'conv':\n        additional: t.Dict[str, t.Any] = {\n            'x': [0.5, 0.0, 0.0, 0.5],\n            'y': [0.0, 0.5, 0.0, 0.5],\n            'z': [0.0, 0.0, 0.5, 0.5],\n            'elem': [elems[1]] * 4,\n        }\n    else:\n        raise ValueError(f\"Unknown cell type '{cell}'. Expected 'conv', 'prim', or 'ortho'.\")\n\n    return fcc(elems[0], a, cell=cell, additional=additional)\n</code></pre>"},{"location":"api/make/#atomlib.make.zincblende","title":"<code>zincblende(elems, a, *, cell='conv')</code>","text":"<p>Create a zinc-blende FCC structure AB.</p> <p>Parameters:</p> Name Type Description Default <code>elems</code> <code>Union[str, Sequence[ElemLike]]</code> <p>Elements to add (e.g. <code>'ZnS'</code> or <code>('Zn', 'S')</code>)</p> required <code>a</code> <code>Num</code> <p>Lattice parameter (Angstrom)</p> required <code>cell</code> <code>CellType</code> <p>Cell type to return ('conv', 'prim', or 'ortho'). Returns     the same cell types as <code>fcc</code>.</p> <code>'conv'</code> <p>Returns:</p> Type Description <code>AtomCell</code> <p>Periodic zinc-blende unit cell</p> Source code in <code>atomlib/make/__init__.py</code> <pre><code>def zincblende(elems: t.Union[str, t.Sequence[ElemLike]], a: Num, *,\n               cell: CellType = 'conv') -&gt; AtomCell:\n    \"\"\"\n    Create a zinc-blende FCC structure AB.\n\n    Args:\n      elems: Elements to add (e.g. `'ZnS'` or `('Zn', 'S')`)\n      a: Lattice parameter (Angstrom)\n      cell: Cell type to return ('conv', 'prim', or 'ortho'). Returns\n            the same cell types as `fcc`.\n\n    Returns:\n      Periodic zinc-blende unit cell\n    \"\"\"\n    if isinstance(elems, str):\n        elems = get_elems(elems)\n    else:\n        elems = list(map(get_elem, elems))\n\n    if len(elems) != 2:\n        raise ValueError(\"Expected two elements.\")\n\n    if cell == 'prim':\n        d = [0.25]\n        additional: t.Dict[str, t.Any] = {\n            'x': d,\n            'y': d,\n            'z': d,\n            'elem': [elems[1]],\n        }\n    elif cell == 'ortho':\n        additional: t.Dict[str, t.Any] = {\n            'x': [0.5, 0.0],\n            'y': [0.0, 0.5],\n            'z': [0.25, 0.75],\n            'elem': [elems[1]] * 2,\n        }\n    elif cell == 'conv':\n        additional: t.Dict[str, t.Any] = {\n            'x': [0.25, 0.25, 0.75, 0.75],\n            'y': [0.25, 0.75, 0.25, 0.75],\n            'z': [0.25, 0.75, 0.75, 0.25],\n            'elem': [elems[1]] * 4,\n        }\n    else:\n        raise ValueError(f\"Unknown cell type '{cell}'. Expected 'conv', 'prim', or 'ortho'.\")\n\n    return fcc(elems[0], a, cell=cell, additional=additional)\n</code></pre>"},{"location":"api/make/#atomlib.make.diamond","title":"<code>diamond(elem=None, a=None, *, cell='conv')</code>","text":"<p>Create a diamond cubic FCC structure. <code>elem</code> and <code>a</code> can be left unspecified to return a diamond structure. Otherwise, both must be specified.</p> <p>Parameters:</p> Name Type Description Default <code>elem</code> <code>Optional[ElemLike]</code> <p>Element to add (e.g. <code>'C'</code>)</p> <code>None</code> <code>a</code> <code>Optional[Num]</code> <p>Lattice parameter (Angstrom)</p> <code>None</code> <code>cell</code> <code>CellType</code> <p>Cell type to return ('conv', 'prim', or 'ortho'). Returns     the same cell types as <code>fcc</code>.</p> <code>'conv'</code> <p>Returns:</p> Type Description <code>AtomCell</code> <p>Periodic diamond cubic unit cell</p> Source code in <code>atomlib/make/__init__.py</code> <pre><code>def diamond(elem: t.Optional[ElemLike] = None, a: t.Optional[Num] = None, *,\n            cell: CellType = 'conv') -&gt; AtomCell:\n    \"\"\"\n    Create a diamond cubic FCC structure. `elem` and `a` can be left\n    unspecified to return a diamond structure. Otherwise, both\n    must be specified.\n\n    Args:\n      elem: Element to add (e.g. `'C'`)\n      a: Lattice parameter (Angstrom)\n      cell: Cell type to return ('conv', 'prim', or 'ortho'). Returns\n            the same cell types as `fcc`.\n\n    Returns:\n      Periodic diamond cubic unit cell\n    \"\"\"\n    if elem is None:\n        elems = (6, 6)\n    else:\n        elem = get_elem(elem)\n        elems = (elem, elem)\n\n    if a is None:\n        if elems == (6, 6):\n            # diamond lattice parameter\n            a = 3.567\n        else:\n            raise ValueError(\"Must specify lattice parameter 'a'.\")\n\n    return zincblende(elems, a, cell=cell)\n</code></pre>"},{"location":"api/make/#atomlib.make.fluorite","title":"<code>fluorite(elems, a, *, cell='conv')</code>","text":"<p>Create a fluorite FCC structure \\(\\mathrm{AB_2}\\). Returns the same cell types as <code>fcc</code>.</p> <p>Parameters:</p> Name Type Description Default <code>elems</code> <code>Union[str, Sequence[ElemLike]]</code> <p>Elements to add (e.g. <code>'CaF'</code> or <code>('Ca', 'F')</code>)</p> required <code>a</code> <code>Num</code> <p>Lattice parameter (Angstrom)</p> required <code>cell</code> <code>CellType</code> <p>Cell type to return ('conv', 'prim', or 'ortho'). Returns     the same cell types as <code>fcc</code>.</p> <code>'conv'</code> <p>Returns:</p> Type Description <code>AtomCell</code> <p>Periodic fluorite unit cell</p> Source code in <code>atomlib/make/__init__.py</code> <pre><code>def fluorite(elems: t.Union[str, t.Sequence[ElemLike]], a: Num, *,\n             cell: CellType = 'conv') -&gt; AtomCell:\n    \"\"\"\n    Create a fluorite FCC structure $\\\\mathrm{AB_2}$. Returns the same cell types as `fcc`.\n\n    Args:\n      elems: Elements to add (e.g. `'CaF'` or `('Ca', 'F')`)\n      a: Lattice parameter (Angstrom)\n      cell: Cell type to return ('conv', 'prim', or 'ortho'). Returns\n            the same cell types as `fcc`.\n\n    Returns:\n      Periodic fluorite unit cell\n    \"\"\"\n\n    if isinstance(elems, str):\n        elems = get_elems(elems)\n    else:\n        elems = list(map(get_elem, elems))\n\n    if len(elems) != 2:\n        raise ValueError(\"Expected two elements.\")\n\n    if cell == 'prim':\n        d = [0.25, 0.75]\n        additional: t.Dict[str, t.Any] = {\n            'x': d, 'y': d, 'z': d,\n            'elem': [elems[1]] * 2,\n        }\n    elif cell == 'ortho':\n        additional: t.Dict[str, t.Any] = {\n            'x': [0.5, 0.5, 0.0, 0.0],\n            'y': [0.0, 0.0, 0.5, 0.5],\n            'z': [0.25, 0.75, 0.25, 0.75],\n            'elem': [elems[1]] * 4,\n        }\n    elif cell == 'conv':\n        additional: t.Dict[str, t.Any] = {\n            'x': [0.25] * 4 + [0.75] * 4,\n            'y': [0.25, 0.25, 0.75, 0.75, 0.25, 0.25, 0.75, 0.75],\n            'z': [0.25, 0.75, 0.25, 0.75, 0.25, 0.75, 0.25, 0.75],\n            'elem': [elems[1]] * 8,\n        }\n    else:\n        raise ValueError(f\"Unknown cell type '{cell}'. Expected 'conv', 'prim', or 'ortho'.\")\n\n    return fcc(elems[0], a, cell=cell, additional=additional)\n</code></pre>"},{"location":"api/make/#atomlib.make.cesium_chloride","title":"<code>cesium_chloride(elems='CsCl', a=None, *, d=None, cell='conv')</code>","text":"<p>Create a cesium chloride structure \\(\\mathrm{AB}\\). CsCl is simple cubic, so all cell types are the same.</p> <p>Only one of <code>a</code> (lattice parameter) or <code>d</code> (bond distance) needs to be specified.</p> <p>Parameters:</p> Name Type Description Default <code>elems</code> <code>Union[str, Sequence[ElemLike]]</code> <p>Elements to add (e.g. <code>'CsCl'</code> or <code>('Cs', 'Cl')</code>)</p> <code>'CsCl'</code> <code>a</code> <code>Optional[Num]</code> <p>Lattice parameter (Angstrom)</p> <code>None</code> <code>d</code> <code>Optional[Num]</code> <p>Nearest-neighbor bond distance (Angstrom)</p> <code>None</code> <code>cell</code> <code>CellType</code> <p>Cell type to return ('conv', 'prim', or 'ortho').     All are identical for this structure</p> <code>'conv'</code> <p>Returns:</p> Type Description <code>AtomCell</code> <p>Periodic cesium chloride unit cell</p> Source code in <code>atomlib/make/__init__.py</code> <pre><code>def cesium_chloride(elems: t.Union[str, t.Sequence[ElemLike]] = 'CsCl', a: t.Optional[Num] = None, *,\n                    d: t.Optional[Num] = None, cell: CellType = 'conv') -&gt; AtomCell:\n    \"\"\"\n    Create a cesium chloride structure $\\\\mathrm{AB}$.\n    CsCl is simple cubic, so all cell types are the same.\n\n    Only one of `a` (lattice parameter) or `d` (bond distance) needs to be specified.\n\n    Args:\n      elems: Elements to add (e.g. `'CsCl'` or `('Cs', 'Cl')`)\n      a: Lattice parameter (Angstrom)\n      d: Nearest-neighbor bond distance (Angstrom)\n      cell: Cell type to return ('conv', 'prim', or 'ortho').\n            All are identical for this structure\n\n    Returns:\n      Periodic cesium chloride unit cell\n    \"\"\"\n    if isinstance(elems, str):\n        elems = get_elems(elems)\n    else:\n        elems = list(map(get_elem, elems))\n\n    if len(elems) != 2:\n        raise ValueError(\"Expected two elements.\")\n\n    if a is not None and d is not None:\n        raise ValueError(\"Both 'a' and 'd' cannot be specified.\")\n\n    if a is None:\n        if d is not None:\n            a_ = d * 2/numpy.sqrt(3)\n        elif elems == [55, 17]:\n            # CsCl lattice parameter\n            a_ = 4.123\n        else:\n            raise ValueError(\"Must specify either 'a' or 'd' lattice parameter\")\n    else:\n        a_ = a\n\n    ortho = cell_to_ortho([a_] * 3)\n\n    frame = Atoms(dict(x=[0., 0.5], y=[0., 0.5], z=[0., 0.5], elem=elems))\n    return AtomCell.from_ortho(frame, ortho, frame='cell_frac')\n</code></pre>"},{"location":"api/make/#atomlib.make.perovskite","title":"<code>perovskite(elems, cell_size, *, cell='conv')</code>","text":"<p>Create a perovskite structure \\(\\mathrm{ABX_3}\\).</p> <p><code>A</code> is placed at the origin and <code>B</code> is placed at the cell center. <code>cell_size</code> determines whether a cubic, tetragonal, or orthorhombic structure is created. For instance, <code>cell_size=3.</code> returns a cubic structure, while <code>cell_size=[3., 5.]</code> returns a tetragonal structure <code>a=3</code>, <code>c=5</code>.</p> <p>All cell types are the same for perovskite, so the <code>cell</code> parameter has no effect.</p> <p>Parameters:</p> Name Type Description Default <code>elems</code> <code>Union[str, Sequence[ElemLike]]</code> <p>Elements to add (e.g. <code>'CaTiO'</code> or <code>('Ca', 'Ti', 'O')</code>)</p> required <code>cell_size</code> <code>VecLike</code> <p>Lattice parameters (e.g. <code>3.0</code> (cubic), <code>[3.0, 5.0]</code>          (tetragonal), or <code>[3.0, 4.0, 5.0]</code> (orthorhombic)).</p> required <code>cell</code> <code>CellType</code> <p>Cell type to return ('conv', 'prim', or 'ortho').     All are identical for this structure</p> <code>'conv'</code> <p>Returns:</p> Type Description <code>AtomCell</code> <p>Periodic perovskite unit cell.</p> Source code in <code>atomlib/make/__init__.py</code> <pre><code>def perovskite(elems: t.Union[str, t.Sequence[ElemLike]], cell_size: VecLike, *,\n               cell: CellType = 'conv') -&gt; AtomCell:\n    \"\"\"\n    Create a perovskite structure $\\\\mathrm{ABX_3}$.\n\n    `A` is placed at the origin and `B` is placed at the cell center.\n    `cell_size` determines whether a cubic, tetragonal, or orthorhombic\n    structure is created. For instance, `cell_size=3.` returns a cubic\n    structure, while `cell_size=[3., 5.]` returns a tetragonal structure\n    `a=3`, `c=5`.\n\n    All cell types are the same for perovskite, so the `cell` parameter\n    has no effect.\n\n    Args:\n      elems: Elements to add (e.g. `'CaTiO'` or `('Ca', 'Ti', 'O')`)\n      cell_size: Lattice parameters (e.g. `3.0` (cubic), `[3.0, 5.0]`\n                 (tetragonal), or `[3.0, 4.0, 5.0]` (orthorhombic)).\n      cell: Cell type to return ('conv', 'prim', or 'ortho').\n            All are identical for this structure\n\n    Returns:\n      Periodic perovskite unit cell.\n    \"\"\"\n    if isinstance(elems, str):\n        elems = get_elems(elems)\n    else:\n        elems = list(map(get_elem, elems))\n\n    if len(elems) != 3:\n        raise ValueError(\"Expected three elements.\")\n\n    cell_size = numpy.atleast_1d(cell_size)\n    if cell_size.squeeze().ndim &gt; 1:\n        raise ValueError(\"Expected a 1D vector\")\n    if len(cell_size) == 2:\n        # tetragonal shortcut\n        cell_size = numpy.array([cell_size[0], cell_size[0], cell_size[1]])\n\n    if cell not in ('prim', 'ortho', 'conv'):\n        raise ValueError(f\"Unknown cell type '{cell}'. Expected 'conv', 'prim', or 'ortho'.\")\n\n    xs = [0., 0.5, 0., 0.5, 0.5]\n    ys = [0., 0.5, 0.5, 0., 0.5]\n    zs = [0., 0.5, 0.5, 0.5, 0.]\n    elems = [elems[0], elems[1], *([elems[2]] * 3)]\n\n    atoms = Atoms(dict(x=xs, y=ys, z=zs, elem=elems))\n    return AtomCell(atoms, Cell.from_unit_cell(cell_size), frame='cell_frac')\n</code></pre>"},{"location":"api/make/#atomlib.make.random","title":"<code>random(cell, elem, density, seed=None, **extra_cols)</code>","text":"<p>Make a random arrangement of atoms inside <code>cell</code> (<code>Cell</code> or cell_size vector).</p> <p>Parameters:</p> Name Type Description Default <code>elem</code> <code>ElemLike</code> <p>Element to add (e.g. <code>'C'</code> or <code>6</code>)</p> required <code>density</code> <code>float</code> <p>Mean mass density to target (g/cm^3)</p> required <code>seed</code> <code>Optional[object]</code> <p>Deterministic random seed to add (any object)</p> <code>None</code> <code>extra_cols</code> <code>Any</code> <p>Extra parameters to add to each atom</p> <code>{}</code> <p>Returns:</p> Type Description <code>AtomCell</code> <p>A random arrangement of atoms</p> Source code in <code>atomlib/make/__init__.py</code> <pre><code>def random(cell: t.Union[Cell, VecLike], elem: ElemLike, density: float,\n           seed: t.Optional[object] = None, **extra_cols: t.Any) -&gt; AtomCell:\n    \"\"\"\n    Make a random arrangement of atoms inside `cell`\n    ([`Cell`][atomlib.cell.Cell] or cell_size vector).\n\n    Args:\n      elem: Element to add (e.g. `'C'` or `6`)\n      density: Mean mass density to target (g/cm^3)\n      seed: Deterministic random seed to add (any object)\n      extra_cols: Extra parameters to add to each atom\n\n    Returns:\n      A random arrangement of atoms\n    \"\"\"\n    if not isinstance(cell, Cell):\n        cell = Cell.from_unit_cell(cell, pbc=[True, True, True])\n\n    elem = get_elem(elem)\n    mass = get_mass(elem)\n\n    # g/cm^3 / g/mol * 6.022e23/mol * 1e-24 cm^3/angstrom^3\n    number_density = density / mass * 0.60221408\n    n = int(numpy.round(numpy.prod(cell.box_size) * number_density).astype(int))\n\n    rng = numpy.random.RandomState(proc_seed(seed, 'make.random'))\n    pos = rng.uniform(0., 1., size=(3, n))\n\n    return AtomCell(Atoms({\n        'x': pos[0], 'y': pos[1], 'z': pos[2],\n        'elem': [elem] * n,\n        **{k: [v] * n for (k, v) in extra_cols.items()}\n    }), cell=cell, frame='cell_box')\n</code></pre>"},{"location":"api/make/#atomlib.make.slab","title":"<code>slab(atoms, zone=(0.0, 0.0, 1.0), horz=(1.0, 0.0, 0.0), *, max_n=50, tol=0.001)</code>","text":"<p>Create an periodic orthogonal slab of the periodic cell <code>atoms</code>.</p> <p><code>zone</code> in the original crystal will point along the +z-axis, and <code>horz</code> (minus the <code>zone</code> component) wil point along the +x-axis.</p> <p>Finds a periodic orthogonal slab with less than <code>tol</code> amount of strain, and no more than <code>max_n</code> cells on one side.</p> <p>Parameters:</p> Name Type Description Default <code>atoms</code> <code>HasAtomCellT</code> <p>Input structure</p> required <code>zone</code> <code>VecLike</code> <p>Zone to align with the +z-axis</p> <code>(0.0, 0.0, 1.0)</code> <code>horz</code> <code>VecLike</code> <p>Zone to align with the +x-axis</p> <code>(1.0, 0.0, 0.0)</code> <code>max_n</code> <code>int</code> <p>Maximum number of unit cells to search</p> <code>50</code> <code>tol</code> <code>float</code> <p>Maximum strain tolerance</p> <code>0.001</code> <p>Returns:</p> Type Description <code>HasAtomCellT</code> <p>A periodic, orthogonal cell</p> Source code in <code>atomlib/make/__init__.py</code> <pre><code>def slab(atoms: HasAtomCellT, zone: VecLike = (0., 0., 1.), horz: VecLike = (1., 0., 0.), *,\n         max_n: int = 50, tol: float = 0.001) -&gt; HasAtomCellT:\n    \"\"\"\n    Create an periodic orthogonal slab of the periodic cell `atoms`.\n\n    `zone` in the original crystal will point along the +z-axis,\n    and `horz` (minus the `zone` component) wil point along the +x-axis.\n\n    Finds a periodic orthogonal slab with less than `tol` amount of strain,\n    and no more than `max_n` cells on one side.\n\n    Args:\n      atoms: Input structure\n      zone: Zone to align with the +z-axis\n      horz: Zone to align with the +x-axis\n      max_n: Maximum number of unit cells to search\n      tol: Maximum strain tolerance\n\n    Returns:\n      A periodic, orthogonal cell\n    \"\"\"\n\n    # align `zone` with the z-axis, and `horz` with the x-axis\n    zone = reduce_vec(to_vec3(zone))  # ensure `zone` is a lattice vector\n    # TODO should this go from 'local' or 'ortho'?\n    cell_transform = atoms.get_transform('local', 'cell_frac').to_linear()\n    align_transform = LinearTransform3D.align(cell_transform @ zone, cell_transform @ horz)\n    transform = (align_transform @ cell_transform)\n    z = transform @ zone\n    numpy.testing.assert_allclose(z / numpy.linalg.norm(z), [0., 0., 1.], atol=1e-6)\n\n    # generate lattice points\n    lattice_coords = numpy.stack(numpy.meshgrid(*[numpy.arange(-max_n, max_n)]*3), axis=-1).reshape(-1, 3)\n    realspace_coords = transform @ lattice_coords\n    realspace_norm = numpy.linalg.norm(realspace_coords, axis=-1)\n\n    # sort coordinates from smallest to largest (TODO this method is slow)\n    sorting = realspace_norm.argsort()[1:]\n    realspace_norm = realspace_norm[sorting]\n    lattice_coords = lattice_coords[sorting]\n    realspace_coords = realspace_coords[sorting]\n    tols = realspace_norm * tol\n\n    # find lattice points which are acceptablly close to orthogonal\n    (x_close, y_close, z_close) = split_arr(numpy.abs(realspace_coords) &lt; tols[:, None], axis=-1)\n\n    try:\n        x_i = numpy.argwhere(z_close &amp; ~x_close &amp; y_close)[0, 0],\n        y_i = numpy.argwhere(z_close &amp; ~y_close &amp; x_close)[0, 0],\n\n        logging.info(f\"x: {lattice_coords[x_i]} transforms to {realspace_coords[x_i]}\")\n        logging.info(f\"y: {lattice_coords[y_i]} transforms to {realspace_coords[y_i]}\")\n        logging.info(f\"z: {zone} transforms to {z}\")\n    except IndexError:\n        raise ValueError(\"Couldn't find a viable surface along zone {zone}\") from None\n\n    # orient vectors correctly\n    x = realspace_coords[x_i] * numpy.sign(realspace_coords[x_i][0])\n    y = realspace_coords[y_i] * numpy.sign(realspace_coords[y_i][1])\n\n    # repeat original lattice to cover orthogonal lattice\n    pts = transform.inverse() @ BBox3D.from_pts([numpy.zeros(3), x, y, z]).corners()\n    raw_atoms = atoms._repeat_to_contain(pts).get_atoms('local').transform(align_transform)\n    cell = Cell.from_ortho(LinearTransform3D(numpy.stack([x, y, z], axis=0)))\n\n    # strain cell to orthogonal (with atoms in the ``cell`` frame)\n    raw_atoms = raw_atoms.transform(cell.get_transform('cell', 'local'))\n    cell = cell.strain_orthogonal()\n    return atoms.with_cell(cell).with_atoms(raw_atoms, 'cell').crop_to_box()\n</code></pre>"},{"location":"api/make/#atomlib.make.stacking_sequence","title":"<code>stacking_sequence(layer, sequence, shift_vector=(1, 0, 0), *, n_layers=3)</code>","text":"<p>Create an arbitrary stacking sequence from a single layer <code>layer</code>.</p> <p>Parameters:</p> Name Type Description Default <code>layer</code> <code>AtomCell</code> <p>Layer to stack into a stacking sequence. Will be stacked along the c axis.</p> required <code>sequence</code> <code>str</code> <p>Stacking sequence. Each layer should be \"A\", \"B\", or \"C\" (in the common case         where there are three layers). Example: <code>\"ABCABC\"</code>.</p> required <code>shift_vector</code> <code>VecLike</code> <p>Shift to apply, in fractional coordinates. The shift between each layer             will be <code>shift_vector/n_layers</code>. Typically an integer value, to             preserve periodicity. Defaults to <code>[100]</code>.</p> <code>(1, 0, 0)</code> <code>n_layers</code> <code>int</code> <p>Number of layers which corresponds to a shift of a complete lattice vector.         Defaults to <code>3</code>, the case for FCC and HCP.</p> <code>3</code> <p>Returns:</p> Type Description <code>AtomCell</code> <p>An <code>AtomCell</code> containing the stacked structure.</p> Source code in <code>atomlib/make/__init__.py</code> <pre><code>def stacking_sequence(layer: AtomCell, sequence: str, shift_vector: VecLike = (1, 0, 0), *,\n                      n_layers: int = 3) -&gt; AtomCell:\n    \"\"\"\n    Create an arbitrary stacking sequence from a single layer `layer`.\n\n    Args:\n      layer: Layer to stack into a stacking sequence. Will be stacked along the c axis.\n      sequence: Stacking sequence. Each layer should be \"A\", \"B\", or \"C\" (in the common case\n                where there are three layers). Example: `\"ABCABC\"`.\n      shift_vector: Shift to apply, in fractional coordinates. The shift between each layer\n                    will be `shift_vector/n_layers`. Typically an integer value, to\n                    preserve periodicity. Defaults to `[100]`.\n      n_layers: Number of layers which corresponds to a shift of a complete lattice vector.\n                Defaults to `3`, the case for FCC and HCP.\n\n    Returns:\n     An [`AtomCell`][atomlib.atomcell.AtomCell] containing the stacked structure.\n    \"\"\"\n\n    layers = string.ascii_uppercase[:n_layers]\n\n    # TODO generalize this to arbitrary number of layers\n    sequence = sequence.upper()\n    if any(s not in layers for s in sequence):\n        raise ValueError(f\"Invalid sequence '{sequence}'. Expected values in '{layers}'\")\n\n    # c vector to shift along\n    c_vec = layer.to_ortho().transform_vec([0, 0, 1])\n    # new cell is original cell tiled by the number of layers\n    cell = layer.get_cell().repeat([1, 1, len(sequence)])\n\n    # convert shift_vector to local coordinates\n    shift_vector = layer.get_cell().get_transform('local', 'cell_frac').transform_vec(shift_vector)\n\n    atoms = layer.get_atoms('local')\n    return AtomCell(Atoms.concat(\n        # translate by the shift vector and translate to the correct layer\n        atoms.transform(AffineTransform3D.translate(shift_vector * (layers.find(c)) / n_layers + i*c_vec))\n        for (i, c) in enumerate(sequence)\n    ), cell).wrap()\n</code></pre>"},{"location":"api/mixins/","title":"<code>atomlib.mixins</code>","text":""},{"location":"api/mixins/#atomlib.mixins.AtomsIOMixin","title":"<code>AtomsIOMixin</code>","text":"<p>             Bases: <code>_HasAtoms</code>, <code>ABC</code></p> Source code in <code>atomlib/mixins.py</code> <pre><code>class AtomsIOMixin(_HasAtoms, abc.ABC):\n    @t.overload\n    @classmethod\n    def read(cls: t.Type[HasAtomsT], path: FileOrPath, ty: FileType) -&gt; HasAtomsT:\n        ...\n\n    @t.overload\n    @classmethod\n    def read(cls: t.Type[HasAtomsT], path: t.Union[str, Path, t.TextIO], ty: t.Literal[None] = None) -&gt; HasAtomsT:\n        ...\n\n    @classmethod\n    def read(cls: t.Type[HasAtomsT], path: FileOrPath, ty: t.Optional[FileType] = None) -&gt; HasAtomsT:\n        \"\"\"\n        Read a structure from a file.\n\n        Supported types can be found in the [io][atomlib.io] module.\n        If no `ty` is specified, it is inferred from the file's extension.\n        \"\"\"\n        from .io import read\n        return _cast_atoms(read(path, ty), cls)  # type: ignore\n\n    @classmethod\n    def read_cif(cls: t.Type[HasAtomsT], f: t.Union[FileOrPath, CIF, CIFDataBlock], block: t.Union[int, str, None] = None) -&gt; HasAtomsT:\n        \"\"\"\n        Read a structure from a CIF file.\n\n        If `block` is specified, read data from the given block of the CIF file (index or name).\n        \"\"\"\n        from .io import read_cif\n        return _cast_atoms(read_cif(f, block), cls)\n\n    @classmethod\n    def read_xyz(cls: t.Type[HasAtomsT], f: t.Union[FileOrPath, XYZ]) -&gt; HasAtomsT:\n        \"\"\"Read a structure from an XYZ file.\"\"\"\n        from .io import read_xyz\n        return _cast_atoms(read_xyz(f), cls)\n\n    @classmethod\n    def read_xsf(cls: t.Type[HasAtomsT], f: t.Union[FileOrPath, XSF]) -&gt; HasAtomsT:\n        \"\"\"Read a structure from an XSF file.\"\"\"\n        from .io import read_xsf\n        return _cast_atoms(read_xsf(f), cls)\n\n    @classmethod\n    def read_cfg(cls: t.Type[HasAtomsT], f: t.Union[FileOrPath, CFG]) -&gt; HasAtomsT:\n        \"\"\"Read a structure from a CFG file.\"\"\"\n        from .io import read_cfg\n        return _cast_atoms(read_cfg(f), cls)\n\n    @classmethod\n    def read_lmp(cls: t.Type[HasAtomsT], f: t.Union[FileOrPath, LMP], type_map: t.Optional[t.Dict[int, t.Union[str, int]]] = None) -&gt; HasAtomsT:\n        \"\"\"Read a structure from a LAAMPS data file.\"\"\"\n        from .io import read_lmp\n        return _cast_atoms(read_lmp(f, type_map=type_map), cls)\n\n    def write_cif(self, f: FileOrPath):\n        from .io import write_cif\n        write_cif(self, f)\n\n    def write_xyz(self, f: FileOrPath, fmt: XYZFormat = 'exyz'):\n        from .io import write_xyz\n        write_xyz(self, f, fmt)\n\n    def write_xsf(self, f: FileOrPath):\n        from .io import write_xsf\n        write_xsf(self, f)\n\n    def write_cfg(self, f: FileOrPath):\n        from .io import write_cfg\n        write_cfg(self, f)\n\n    def write_lmp(self, f: FileOrPath):\n        from .io import write_lmp\n        write_lmp(self, f)\n\n    @t.overload\n    def write(self, path: FileOrPath, ty: FileType):\n        ...\n\n    @t.overload\n    def write(self, path: t.Union[str, Path, t.TextIO], ty: t.Literal[None] = None):\n        ...\n\n    def write(self, path: FileOrPath, ty: t.Optional[FileType] = None):\n        \"\"\"\n        Write this structure to a file.\n\n        A file type may be specified using `ty`.\n        If no `ty` is specified, it is inferred from the path's extension.\n        \"\"\"\n        from .io import write\n        write(self, path, ty)  # type: ignore\n</code></pre>"},{"location":"api/mixins/#atomlib.mixins.AtomsIOMixin.read","title":"<code>read(path, ty=None)</code>  <code>classmethod</code>","text":"<p>Read a structure from a file.</p> <p>Supported types can be found in the io module. If no <code>ty</code> is specified, it is inferred from the file's extension.</p> Source code in <code>atomlib/mixins.py</code> <pre><code>@classmethod\ndef read(cls: t.Type[HasAtomsT], path: FileOrPath, ty: t.Optional[FileType] = None) -&gt; HasAtomsT:\n    \"\"\"\n    Read a structure from a file.\n\n    Supported types can be found in the [io][atomlib.io] module.\n    If no `ty` is specified, it is inferred from the file's extension.\n    \"\"\"\n    from .io import read\n    return _cast_atoms(read(path, ty), cls)  # type: ignore\n</code></pre>"},{"location":"api/mixins/#atomlib.mixins.AtomsIOMixin.read_cif","title":"<code>read_cif(f, block=None)</code>  <code>classmethod</code>","text":"<p>Read a structure from a CIF file.</p> <p>If <code>block</code> is specified, read data from the given block of the CIF file (index or name).</p> Source code in <code>atomlib/mixins.py</code> <pre><code>@classmethod\ndef read_cif(cls: t.Type[HasAtomsT], f: t.Union[FileOrPath, CIF, CIFDataBlock], block: t.Union[int, str, None] = None) -&gt; HasAtomsT:\n    \"\"\"\n    Read a structure from a CIF file.\n\n    If `block` is specified, read data from the given block of the CIF file (index or name).\n    \"\"\"\n    from .io import read_cif\n    return _cast_atoms(read_cif(f, block), cls)\n</code></pre>"},{"location":"api/mixins/#atomlib.mixins.AtomsIOMixin.read_xyz","title":"<code>read_xyz(f)</code>  <code>classmethod</code>","text":"<p>Read a structure from an XYZ file.</p> Source code in <code>atomlib/mixins.py</code> <pre><code>@classmethod\ndef read_xyz(cls: t.Type[HasAtomsT], f: t.Union[FileOrPath, XYZ]) -&gt; HasAtomsT:\n    \"\"\"Read a structure from an XYZ file.\"\"\"\n    from .io import read_xyz\n    return _cast_atoms(read_xyz(f), cls)\n</code></pre>"},{"location":"api/mixins/#atomlib.mixins.AtomsIOMixin.read_xsf","title":"<code>read_xsf(f)</code>  <code>classmethod</code>","text":"<p>Read a structure from an XSF file.</p> Source code in <code>atomlib/mixins.py</code> <pre><code>@classmethod\ndef read_xsf(cls: t.Type[HasAtomsT], f: t.Union[FileOrPath, XSF]) -&gt; HasAtomsT:\n    \"\"\"Read a structure from an XSF file.\"\"\"\n    from .io import read_xsf\n    return _cast_atoms(read_xsf(f), cls)\n</code></pre>"},{"location":"api/mixins/#atomlib.mixins.AtomsIOMixin.read_cfg","title":"<code>read_cfg(f)</code>  <code>classmethod</code>","text":"<p>Read a structure from a CFG file.</p> Source code in <code>atomlib/mixins.py</code> <pre><code>@classmethod\ndef read_cfg(cls: t.Type[HasAtomsT], f: t.Union[FileOrPath, CFG]) -&gt; HasAtomsT:\n    \"\"\"Read a structure from a CFG file.\"\"\"\n    from .io import read_cfg\n    return _cast_atoms(read_cfg(f), cls)\n</code></pre>"},{"location":"api/mixins/#atomlib.mixins.AtomsIOMixin.read_lmp","title":"<code>read_lmp(f, type_map=None)</code>  <code>classmethod</code>","text":"<p>Read a structure from a LAAMPS data file.</p> Source code in <code>atomlib/mixins.py</code> <pre><code>@classmethod\ndef read_lmp(cls: t.Type[HasAtomsT], f: t.Union[FileOrPath, LMP], type_map: t.Optional[t.Dict[int, t.Union[str, int]]] = None) -&gt; HasAtomsT:\n    \"\"\"Read a structure from a LAAMPS data file.\"\"\"\n    from .io import read_lmp\n    return _cast_atoms(read_lmp(f, type_map=type_map), cls)\n</code></pre>"},{"location":"api/mixins/#atomlib.mixins.AtomsIOMixin.write_cif","title":"<code>write_cif(f)</code>","text":"Source code in <code>atomlib/mixins.py</code> <pre><code>def write_cif(self, f: FileOrPath):\n    from .io import write_cif\n    write_cif(self, f)\n</code></pre>"},{"location":"api/mixins/#atomlib.mixins.AtomsIOMixin.write_xyz","title":"<code>write_xyz(f, fmt='exyz')</code>","text":"Source code in <code>atomlib/mixins.py</code> <pre><code>def write_xyz(self, f: FileOrPath, fmt: XYZFormat = 'exyz'):\n    from .io import write_xyz\n    write_xyz(self, f, fmt)\n</code></pre>"},{"location":"api/mixins/#atomlib.mixins.AtomsIOMixin.write_xsf","title":"<code>write_xsf(f)</code>","text":"Source code in <code>atomlib/mixins.py</code> <pre><code>def write_xsf(self, f: FileOrPath):\n    from .io import write_xsf\n    write_xsf(self, f)\n</code></pre>"},{"location":"api/mixins/#atomlib.mixins.AtomsIOMixin.write_cfg","title":"<code>write_cfg(f)</code>","text":"Source code in <code>atomlib/mixins.py</code> <pre><code>def write_cfg(self, f: FileOrPath):\n    from .io import write_cfg\n    write_cfg(self, f)\n</code></pre>"},{"location":"api/mixins/#atomlib.mixins.AtomsIOMixin.write_lmp","title":"<code>write_lmp(f)</code>","text":"Source code in <code>atomlib/mixins.py</code> <pre><code>def write_lmp(self, f: FileOrPath):\n    from .io import write_lmp\n    write_lmp(self, f)\n</code></pre>"},{"location":"api/mixins/#atomlib.mixins.AtomsIOMixin.write","title":"<code>write(path, ty=None)</code>","text":"<p>Write this structure to a file.</p> <p>A file type may be specified using <code>ty</code>. If no <code>ty</code> is specified, it is inferred from the path's extension.</p> Source code in <code>atomlib/mixins.py</code> <pre><code>def write(self, path: FileOrPath, ty: t.Optional[FileType] = None):\n    \"\"\"\n    Write this structure to a file.\n\n    A file type may be specified using `ty`.\n    If no `ty` is specified, it is inferred from the path's extension.\n    \"\"\"\n    from .io import write\n    write(self, path, ty)  # type: ignore\n</code></pre>"},{"location":"api/mixins/#atomlib.mixins.AtomCellIOMixin","title":"<code>AtomCellIOMixin</code>","text":"<p>             Bases: <code>_HasAtomCell</code>, <code>AtomsIOMixin</code></p> Source code in <code>atomlib/mixins.py</code> <pre><code>class AtomCellIOMixin(_HasAtomCell, AtomsIOMixin):\n    def write_mslice(self, f: BinaryFileOrPath, template: t.Optional[MSliceFile] = None, *,\n                 slice_thickness: t.Optional[float] = None,  # angstrom\n                 scan_points: t.Optional[ArrayLike] = None,\n                 scan_extent: t.Optional[ArrayLike] = None,\n                 noise_sigma: t.Optional[float] = None,  # angstrom\n                 conv_angle: t.Optional[float] = None,  # mrad\n                 energy: t.Optional[float] = None,  # keV\n                 defocus: t.Optional[float] = None,  # angstrom\n                 tilt: t.Optional[t.Tuple[float, float]] = None,  # (mrad, mrad)\n                 tds: t.Optional[bool] = None,\n                 n_cells: t.Optional[ArrayLike] = None):\n        \"\"\"\n        Write a structure to an mslice file.\n\n        `template` may be a file, path, or ElementTree containing an existing mslice file.\n        Its structure will be modified to make the final output. If not specified, a default\n        template will be used.\n\n        Additional options modify simulation properties. If an option is not specified, the\n        template's properties are used.\n        \"\"\"\n        from .io import write_mslice\n        return write_mslice(self, f, template, slice_thickness=slice_thickness,\n                            scan_points=scan_points, scan_extent=scan_extent,\n                            conv_angle=conv_angle, energy=energy, defocus=defocus,\n                            noise_sigma=noise_sigma, tilt=tilt, tds=tds, n_cells=n_cells)\n\n    def write_qe(self, f: FileOrPath, pseudo: t.Optional[t.Mapping[str, str]] = None):\n        from .io import write_qe\n        write_qe(self, f, pseudo)\n</code></pre>"},{"location":"api/mixins/#atomlib.mixins.AtomCellIOMixin.read","title":"<code>read(path, ty=None)</code>  <code>classmethod</code>","text":"<p>Read a structure from a file.</p> <p>Supported types can be found in the io module. If no <code>ty</code> is specified, it is inferred from the file's extension.</p> Source code in <code>atomlib/mixins.py</code> <pre><code>@classmethod\ndef read(cls: t.Type[HasAtomsT], path: FileOrPath, ty: t.Optional[FileType] = None) -&gt; HasAtomsT:\n    \"\"\"\n    Read a structure from a file.\n\n    Supported types can be found in the [io][atomlib.io] module.\n    If no `ty` is specified, it is inferred from the file's extension.\n    \"\"\"\n    from .io import read\n    return _cast_atoms(read(path, ty), cls)  # type: ignore\n</code></pre>"},{"location":"api/mixins/#atomlib.mixins.AtomCellIOMixin.read_cif","title":"<code>read_cif(f, block=None)</code>  <code>classmethod</code>","text":"<p>Read a structure from a CIF file.</p> <p>If <code>block</code> is specified, read data from the given block of the CIF file (index or name).</p> Source code in <code>atomlib/mixins.py</code> <pre><code>@classmethod\ndef read_cif(cls: t.Type[HasAtomsT], f: t.Union[FileOrPath, CIF, CIFDataBlock], block: t.Union[int, str, None] = None) -&gt; HasAtomsT:\n    \"\"\"\n    Read a structure from a CIF file.\n\n    If `block` is specified, read data from the given block of the CIF file (index or name).\n    \"\"\"\n    from .io import read_cif\n    return _cast_atoms(read_cif(f, block), cls)\n</code></pre>"},{"location":"api/mixins/#atomlib.mixins.AtomCellIOMixin.read_xyz","title":"<code>read_xyz(f)</code>  <code>classmethod</code>","text":"<p>Read a structure from an XYZ file.</p> Source code in <code>atomlib/mixins.py</code> <pre><code>@classmethod\ndef read_xyz(cls: t.Type[HasAtomsT], f: t.Union[FileOrPath, XYZ]) -&gt; HasAtomsT:\n    \"\"\"Read a structure from an XYZ file.\"\"\"\n    from .io import read_xyz\n    return _cast_atoms(read_xyz(f), cls)\n</code></pre>"},{"location":"api/mixins/#atomlib.mixins.AtomCellIOMixin.read_xsf","title":"<code>read_xsf(f)</code>  <code>classmethod</code>","text":"<p>Read a structure from an XSF file.</p> Source code in <code>atomlib/mixins.py</code> <pre><code>@classmethod\ndef read_xsf(cls: t.Type[HasAtomsT], f: t.Union[FileOrPath, XSF]) -&gt; HasAtomsT:\n    \"\"\"Read a structure from an XSF file.\"\"\"\n    from .io import read_xsf\n    return _cast_atoms(read_xsf(f), cls)\n</code></pre>"},{"location":"api/mixins/#atomlib.mixins.AtomCellIOMixin.read_cfg","title":"<code>read_cfg(f)</code>  <code>classmethod</code>","text":"<p>Read a structure from a CFG file.</p> Source code in <code>atomlib/mixins.py</code> <pre><code>@classmethod\ndef read_cfg(cls: t.Type[HasAtomsT], f: t.Union[FileOrPath, CFG]) -&gt; HasAtomsT:\n    \"\"\"Read a structure from a CFG file.\"\"\"\n    from .io import read_cfg\n    return _cast_atoms(read_cfg(f), cls)\n</code></pre>"},{"location":"api/mixins/#atomlib.mixins.AtomCellIOMixin.read_lmp","title":"<code>read_lmp(f, type_map=None)</code>  <code>classmethod</code>","text":"<p>Read a structure from a LAAMPS data file.</p> Source code in <code>atomlib/mixins.py</code> <pre><code>@classmethod\ndef read_lmp(cls: t.Type[HasAtomsT], f: t.Union[FileOrPath, LMP], type_map: t.Optional[t.Dict[int, t.Union[str, int]]] = None) -&gt; HasAtomsT:\n    \"\"\"Read a structure from a LAAMPS data file.\"\"\"\n    from .io import read_lmp\n    return _cast_atoms(read_lmp(f, type_map=type_map), cls)\n</code></pre>"},{"location":"api/mixins/#atomlib.mixins.AtomCellIOMixin.write_cif","title":"<code>write_cif(f)</code>","text":"Source code in <code>atomlib/mixins.py</code> <pre><code>def write_cif(self, f: FileOrPath):\n    from .io import write_cif\n    write_cif(self, f)\n</code></pre>"},{"location":"api/mixins/#atomlib.mixins.AtomCellIOMixin.write_xyz","title":"<code>write_xyz(f, fmt='exyz')</code>","text":"Source code in <code>atomlib/mixins.py</code> <pre><code>def write_xyz(self, f: FileOrPath, fmt: XYZFormat = 'exyz'):\n    from .io import write_xyz\n    write_xyz(self, f, fmt)\n</code></pre>"},{"location":"api/mixins/#atomlib.mixins.AtomCellIOMixin.write_xsf","title":"<code>write_xsf(f)</code>","text":"Source code in <code>atomlib/mixins.py</code> <pre><code>def write_xsf(self, f: FileOrPath):\n    from .io import write_xsf\n    write_xsf(self, f)\n</code></pre>"},{"location":"api/mixins/#atomlib.mixins.AtomCellIOMixin.write_cfg","title":"<code>write_cfg(f)</code>","text":"Source code in <code>atomlib/mixins.py</code> <pre><code>def write_cfg(self, f: FileOrPath):\n    from .io import write_cfg\n    write_cfg(self, f)\n</code></pre>"},{"location":"api/mixins/#atomlib.mixins.AtomCellIOMixin.write_lmp","title":"<code>write_lmp(f)</code>","text":"Source code in <code>atomlib/mixins.py</code> <pre><code>def write_lmp(self, f: FileOrPath):\n    from .io import write_lmp\n    write_lmp(self, f)\n</code></pre>"},{"location":"api/mixins/#atomlib.mixins.AtomCellIOMixin.write","title":"<code>write(path, ty=None)</code>","text":"<p>Write this structure to a file.</p> <p>A file type may be specified using <code>ty</code>. If no <code>ty</code> is specified, it is inferred from the path's extension.</p> Source code in <code>atomlib/mixins.py</code> <pre><code>def write(self, path: FileOrPath, ty: t.Optional[FileType] = None):\n    \"\"\"\n    Write this structure to a file.\n\n    A file type may be specified using `ty`.\n    If no `ty` is specified, it is inferred from the path's extension.\n    \"\"\"\n    from .io import write\n    write(self, path, ty)  # type: ignore\n</code></pre>"},{"location":"api/mixins/#atomlib.mixins.AtomCellIOMixin.write_mslice","title":"<code>write_mslice(f, template=None, *, slice_thickness=None, scan_points=None, scan_extent=None, noise_sigma=None, conv_angle=None, energy=None, defocus=None, tilt=None, tds=None, n_cells=None)</code>","text":"<p>Write a structure to an mslice file.</p> <p><code>template</code> may be a file, path, or ElementTree containing an existing mslice file. Its structure will be modified to make the final output. If not specified, a default template will be used.</p> <p>Additional options modify simulation properties. If an option is not specified, the template's properties are used.</p> Source code in <code>atomlib/mixins.py</code> <pre><code>def write_mslice(self, f: BinaryFileOrPath, template: t.Optional[MSliceFile] = None, *,\n             slice_thickness: t.Optional[float] = None,  # angstrom\n             scan_points: t.Optional[ArrayLike] = None,\n             scan_extent: t.Optional[ArrayLike] = None,\n             noise_sigma: t.Optional[float] = None,  # angstrom\n             conv_angle: t.Optional[float] = None,  # mrad\n             energy: t.Optional[float] = None,  # keV\n             defocus: t.Optional[float] = None,  # angstrom\n             tilt: t.Optional[t.Tuple[float, float]] = None,  # (mrad, mrad)\n             tds: t.Optional[bool] = None,\n             n_cells: t.Optional[ArrayLike] = None):\n    \"\"\"\n    Write a structure to an mslice file.\n\n    `template` may be a file, path, or ElementTree containing an existing mslice file.\n    Its structure will be modified to make the final output. If not specified, a default\n    template will be used.\n\n    Additional options modify simulation properties. If an option is not specified, the\n    template's properties are used.\n    \"\"\"\n    from .io import write_mslice\n    return write_mslice(self, f, template, slice_thickness=slice_thickness,\n                        scan_points=scan_points, scan_extent=scan_extent,\n                        conv_angle=conv_angle, energy=energy, defocus=defocus,\n                        noise_sigma=noise_sigma, tilt=tilt, tds=tds, n_cells=n_cells)\n</code></pre>"},{"location":"api/mixins/#atomlib.mixins.AtomCellIOMixin.write_qe","title":"<code>write_qe(f, pseudo=None)</code>","text":"Source code in <code>atomlib/mixins.py</code> <pre><code>def write_qe(self, f: FileOrPath, pseudo: t.Optional[t.Mapping[str, str]] = None):\n    from .io import write_qe\n    write_qe(self, f, pseudo)\n</code></pre>"},{"location":"api/testing/","title":"<code>atomlib.testing</code>","text":""},{"location":"api/testing/#atomlib.testing.CallableT","title":"<code>CallableT = t.TypeVar('CallableT', bound=t.Callable)</code>  <code>module-attribute</code>","text":""},{"location":"api/testing/#atomlib.testing.OUTPUT_PATH","title":"<code>OUTPUT_PATH = Path(__file__).parents[2] / 'tests/baseline_files'</code>  <code>module-attribute</code>","text":""},{"location":"api/testing/#atomlib.testing.INPUT_PATH","title":"<code>INPUT_PATH = Path(__file__).parents[2] / 'tests/input_files'</code>  <code>module-attribute</code>","text":""},{"location":"api/testing/#atomlib.testing.assert_files_equal","title":"<code>assert_files_equal(expected_path, actual_path)</code>","text":"Source code in <code>atomlib/testing/__init__.py</code> <pre><code>def assert_files_equal(expected_path: t.Union[str, Path], actual_path: t.Union[str, Path]):\n    with open(OUTPUT_PATH / expected_path, 'r') as f:\n        expected = re.sub('\\r\\n', '\\n', f.read())\n    with open(actual_path, 'r') as f:\n        actual = re.sub('\\r\\n', '\\n', f.read())\n\n    assert expected == actual\n</code></pre>"},{"location":"api/testing/#atomlib.testing.check_equals_file","title":"<code>check_equals_file(name, *, skip_lines=0)</code>","text":"Source code in <code>atomlib/testing/__init__.py</code> <pre><code>def check_equals_file(name: t.Union[str, Path], *, skip_lines: int = 0) -&gt; t.Callable[[t.Callable[..., t.Any]], t.Callable[..., None]]:\n    def decorator(f: t.Callable[..., str]):\n        @pytest.mark.expected_filename(name)\n        def wrapper(expected_contents_text: str, *args, **kwargs):  # type: ignore\n            buf = StringIO()\n            f(buf, *args, **kwargs)\n            if skip_lines &gt; 0:\n                lhs = \"\".join(buf.getvalue().splitlines(True)[skip_lines:])\n                rhs = \"\".join(expected_contents_text.splitlines(True)[skip_lines:])\n                assert lhs == rhs\n            else:\n                assert buf.getvalue() == expected_contents_text\n\n        return _wrap_pytest(wrapper, f, lambda params: [inspect.Parameter('expected_contents_text', inspect.Parameter.POSITIONAL_OR_KEYWORD), *params[1:]])\n\n    return decorator\n</code></pre>"},{"location":"api/testing/#atomlib.testing.check_equals_binary_file","title":"<code>check_equals_binary_file(name)</code>","text":"Source code in <code>atomlib/testing/__init__.py</code> <pre><code>def check_equals_binary_file(name: t.Union[str, Path]) -&gt; t.Callable[[t.Callable[..., t.Any]], t.Callable[..., None]]:\n    def decorator(f: t.Callable[..., str]):\n        @pytest.mark.expected_filename(name)\n        def wrapper(expected_contents_binary: bytes, *args, **kwargs):  # type: ignore\n            buf = BytesIO()\n            f(buf, *args, **kwargs)\n            assert buf.getvalue() == expected_contents_binary\n\n        return _wrap_pytest(wrapper, f, lambda params: [inspect.Parameter('expected_contents_binary', inspect.Parameter.POSITIONAL_OR_KEYWORD), *params[1:]])\n\n    return decorator\n</code></pre>"},{"location":"api/testing/#atomlib.testing.assert_structure_equal","title":"<code>assert_structure_equal(expected_path, actual)</code>","text":"Source code in <code>atomlib/testing/__init__.py</code> <pre><code>def assert_structure_equal(expected_path: t.Union[str, Path], actual: t.Union[str, Path, AtomsIOMixin]):\n    from atomlib.io import read\n\n    expected = read(OUTPUT_PATH / expected_path)\n\n    try:\n        if isinstance(actual, (str, Path)):\n            actual = t.cast('AtomsIOMixin', read(actual))\n    except Exception:\n        print(\"Failed to load structure under test.\")\n        raise\n\n    try:\n        if hasattr(actual, 'assert_equal'):\n            actual.assert_equal(expected)  # type: ignore\n        else:\n            assert actual == expected\n    except AssertionError:\n        try:\n            actual_path = Path(expected_path).with_stem(Path(expected_path).stem + '_actual').name\n            print(f\"Saving result structure to '{actual_path}'\")\n            actual.write(OUTPUT_PATH / actual_path)\n        except Exception:\n            print(\"Failed to save result structure.\")\n        raise\n</code></pre>"},{"location":"api/testing/#atomlib.testing.check_equals_structure","title":"<code>check_equals_structure(name)</code>","text":"<p>Test that the wrapped function returns the same structure as contained in <code>name</code>.</p> Source code in <code>atomlib/testing/__init__.py</code> <pre><code>def check_equals_structure(name: t.Union[str, Path]) -&gt; t.Callable[[t.Callable[..., AtomsIOMixin]], t.Callable[..., None]]:\n    \"\"\"Test that the wrapped function returns the same structure as contained in `name`.\"\"\"\n    def decorator(f: t.Callable[..., 'AtomsIOMixin']):\n        @pytest.mark.expected_filename(name)\n        def wrapper(expected_structure: 'HasAtoms', *args, **kwargs):  # type: ignore\n            result = f(*args, **kwargs)\n            try:\n                if hasattr(result, 'assert_equal'):\n                    result.assert_equal(expected_structure)  # type: ignore\n                else:\n                    assert result == expected_structure\n            except AssertionError:\n                try:\n                    actual_path = Path(name).with_stem(Path(name).stem + '_actual').name\n                    print(f\"Saving result structure to '{actual_path}'\")\n                    result.write(OUTPUT_PATH / actual_path)\n                except Exception:\n                    print(\"Failed to save result structure.\")\n                raise\n\n        return _wrap_pytest(wrapper, f, lambda params: [inspect.Parameter('expected_structure', inspect.Parameter.POSITIONAL_OR_KEYWORD), *params])\n\n    return decorator\n</code></pre>"},{"location":"api/testing/#atomlib.testing.check_parse_structure","title":"<code>check_parse_structure(name)</code>","text":"<p>Test that <code>name</code> parses to the same structure as given in the function body.</p> Source code in <code>atomlib/testing/__init__.py</code> <pre><code>def check_parse_structure(name: t.Union[str, Path]) -&gt; t.Callable[[t.Callable[..., HasAtoms]], t.Callable[..., None]]:\n    \"\"\"Test that `name` parses to the same structure as given in the function body.\"\"\"\n    def decorator(f: t.Callable[..., 'HasAtoms']):\n        def wrapper(*args, **kwargs):  # type: ignore\n            expected = f(*args, **kwargs)\n\n            from atomlib.io import read\n            result = read(INPUT_PATH / name)\n\n            if hasattr(result, 'assert_equal'):\n                result.assert_equal(expected)  # type: ignore\n            else:\n                assert result == expected\n\n        return _wrap_pytest(wrapper, f)\n    return decorator\n</code></pre>"},{"location":"api/testing/#atomlib.testing.check_figure_draw","title":"<code>check_figure_draw(name, savefig_kwarg=None)</code>","text":"<p>Test that the wrapped function draws an identical figure to <code>name</code> in <code>baseline_images</code>.</p> Source code in <code>atomlib/testing/__init__.py</code> <pre><code>def check_figure_draw(name: t.Union[str, Path, t.Sequence[t.Union[str, Path]]],\n                      savefig_kwarg=None) -&gt; t.Callable[[t.Callable[..., None]], t.Callable[..., None]]:\n    \"\"\"Test that the wrapped function draws an identical figure to `name` in `baseline_images`.\"\"\"\n\n    if isinstance(name, (str, Path)):\n        names = (str(name),)\n    else:\n        names = tuple(map(str, name))\n\n    def decorator(f: t.Callable[..., None]):\n        from matplotlib.testing.decorators import image_comparison\n        return image_comparison(list(names), savefig_kwarg=savefig_kwarg)(f)\n\n    return decorator\n</code></pre>"},{"location":"api/transform/","title":"<code>atomlib.transform</code>","text":""},{"location":"api/transform/#atomlib.transform.IntoTransform3D","title":"<code>IntoTransform3D = t.Union['Transform3D', t.Callable[[NDArray[numpy.floating]], numpy.ndarray], numpy.ndarray]</code>  <code>module-attribute</code>","text":"<p>Type which is coercable into a <code>Transform3D</code>.</p> <p>Includes transformations, numpy arrays (3x3 or 4x4), and functions (which should take a Nx3 ndarray and return an ndarray of the same shape).</p>"},{"location":"api/transform/#atomlib.transform.Transform3D","title":"<code>Transform3D</code>","text":"<p>             Bases: <code>ABC</code></p> <p>Arbitrary 3D transformation. Superclass of all 3D transformation types.</p> <p>Transformations can be composed: <code>t3 = t1 @ t2</code>, or applied to points: <code>transformed = transform @ points</code> using the <code>@</code> operator.</p> <p>Alternatively, points can be transformed using functional notation: <code>transformed = transform(points)</code>.</p> Source code in <code>atomlib/transform.py</code> <pre><code>class Transform3D(ABC):\n    \"\"\"\n    Arbitrary 3D transformation. Superclass of all 3D transformation types.\n\n    Transformations can be composed: `t3 = t1 @ t2`, or applied\n    to points: `transformed = transform @ points` using the `@`\n    operator.\n\n    Alternatively, points can be transformed using functional notation:\n    `transformed = transform(points)`.\n    \"\"\"\n\n    @staticmethod\n    @abstractmethod\n    def identity() -&gt; Transform3D:\n        \"\"\"Return an identity transformation.\"\"\"\n        ...\n\n    @staticmethod\n    def make(data: IntoTransform3D) -&gt; Transform3D:\n        \"\"\"Make a transformation from a function or numpy array (3x3 or 4x4).\"\"\"\n        if isinstance(data, Transform3D):\n            return data\n        if not isinstance(data, numpy.ndarray) and hasattr(data, '__call__'):\n            return FuncTransform3D(data)\n        data = numpy.array(data)\n        if data.shape == (3, 3):\n            return LinearTransform3D(data)\n        if data.shape == (4, 4):\n            return AffineTransform3D(data)\n        raise ValueError(f\"Transform3D of invalid shape {data.shape}\")\n\n    @abstractmethod\n    def compose(self, other: Transform3D) -&gt; Transform3D:\n        \"\"\"Compose this transformation with another.\"\"\"\n        ...\n\n    @t.overload\n    @abstractmethod\n    def transform(self, points: BBox3D) -&gt; BBox3D:\n        ...\n\n    @t.overload\n    @abstractmethod\n    def transform(self, points: ArrayLike) -&gt; NDArray[numpy.floating]:\n        ...\n\n    @abstractmethod\n    def transform(self, points: Pts3DLike) -&gt; t.Union[BBox3D, NDArray[numpy.floating]]:\n        \"\"\"Transform points according to the given transformation.\"\"\"\n        ...\n\n    __call__ = transform\n\n    def transform_vec(self, vecs: ArrayLike) -&gt; NDArray[numpy.floating]:\n        \"\"\"Transform vector quantities. This excludes translation, as would be expected when transforming vectors.\"\"\"\n        a = numpy.atleast_1d(vecs)\n        return self.transform(a) - self.transform(numpy.zeros_like(a))\n\n    @t.overload\n    def __matmul__(self, other: Transform3D) -&gt; Transform3D:\n        ...\n\n    @t.overload\n    def __matmul__(self, other: BBox3D) -&gt; BBox3D:\n        ...\n\n    @t.overload\n    def __matmul__(self, other: ArrayLike) -&gt; NDArray[numpy.floating]:\n        ...\n\n    def __matmul__(self, other: t.Union[Transform3D, Pts3DLike]) -&gt; t.Union[Transform3D, BBox3D, NDArray[numpy.floating]]:\n        \"\"\"Compose this transformation, or apply it to a given set of points.\"\"\"\n        if isinstance(other, Transform3D):\n            return other.compose(self)\n        return self.transform(other)\n\n    def __rmatmul__(self, other: t.Any):\n        raise ValueError(\"Transform must be applied to points, not the other way around.\")\n</code></pre>"},{"location":"api/transform/#atomlib.transform.Transform3D.identity","title":"<code>identity()</code>  <code>abstractmethod</code> <code>staticmethod</code>","text":"<p>Return an identity transformation.</p> Source code in <code>atomlib/transform.py</code> <pre><code>@staticmethod\n@abstractmethod\ndef identity() -&gt; Transform3D:\n    \"\"\"Return an identity transformation.\"\"\"\n    ...\n</code></pre>"},{"location":"api/transform/#atomlib.transform.Transform3D.make","title":"<code>make(data)</code>  <code>staticmethod</code>","text":"<p>Make a transformation from a function or numpy array (3x3 or 4x4).</p> Source code in <code>atomlib/transform.py</code> <pre><code>@staticmethod\ndef make(data: IntoTransform3D) -&gt; Transform3D:\n    \"\"\"Make a transformation from a function or numpy array (3x3 or 4x4).\"\"\"\n    if isinstance(data, Transform3D):\n        return data\n    if not isinstance(data, numpy.ndarray) and hasattr(data, '__call__'):\n        return FuncTransform3D(data)\n    data = numpy.array(data)\n    if data.shape == (3, 3):\n        return LinearTransform3D(data)\n    if data.shape == (4, 4):\n        return AffineTransform3D(data)\n    raise ValueError(f\"Transform3D of invalid shape {data.shape}\")\n</code></pre>"},{"location":"api/transform/#atomlib.transform.Transform3D.compose","title":"<code>compose(other)</code>  <code>abstractmethod</code>","text":"<p>Compose this transformation with another.</p> Source code in <code>atomlib/transform.py</code> <pre><code>@abstractmethod\ndef compose(self, other: Transform3D) -&gt; Transform3D:\n    \"\"\"Compose this transformation with another.\"\"\"\n    ...\n</code></pre>"},{"location":"api/transform/#atomlib.transform.Transform3D.transform","title":"<code>transform(points)</code>  <code>abstractmethod</code>","text":"<p>Transform points according to the given transformation.</p> Source code in <code>atomlib/transform.py</code> <pre><code>@abstractmethod\ndef transform(self, points: Pts3DLike) -&gt; t.Union[BBox3D, NDArray[numpy.floating]]:\n    \"\"\"Transform points according to the given transformation.\"\"\"\n    ...\n</code></pre>"},{"location":"api/transform/#atomlib.transform.Transform3D.transform_vec","title":"<code>transform_vec(vecs)</code>","text":"<p>Transform vector quantities. This excludes translation, as would be expected when transforming vectors.</p> Source code in <code>atomlib/transform.py</code> <pre><code>def transform_vec(self, vecs: ArrayLike) -&gt; NDArray[numpy.floating]:\n    \"\"\"Transform vector quantities. This excludes translation, as would be expected when transforming vectors.\"\"\"\n    a = numpy.atleast_1d(vecs)\n    return self.transform(a) - self.transform(numpy.zeros_like(a))\n</code></pre>"},{"location":"api/transform/#atomlib.transform.FuncTransform3D","title":"<code>FuncTransform3D</code>","text":"<p>             Bases: <code>Transform3D</code></p> <p>Transformation which applies a function to the given points.</p> Source code in <code>atomlib/transform.py</code> <pre><code>class FuncTransform3D(Transform3D):\n    \"\"\"Transformation which applies a function to the given points.\"\"\"\n\n    def __init__(self, f: t.Callable[[numpy.ndarray], numpy.ndarray]):\n        self.f: t.Callable[[numpy.ndarray], numpy.ndarray] = f\n        \"\"\"Wrapped function\"\"\"\n\n    @staticmethod\n    def identity() -&gt; FuncTransform3D:\n        \"\"\"Return an identity transformation.\"\"\"\n        return FuncTransform3D(lambda pts: pts)\n\n    @t.overload\n    def transform(self, points: BBox3D) -&gt; BBox3D:\n        ...\n\n    @t.overload\n    def transform(self, points: ArrayLike) -&gt; NDArray[numpy.floating]:\n        ...\n\n    def transform(self, points: Pts3DLike) -&gt; t.Union[BBox3D, NDArray[numpy.floating]]:\n        \"\"\"Transform points according to the given transformation.\"\"\"\n        if isinstance(points, BBox3D):\n            return points.from_pts(self.transform(points.corners()))\n\n        return self.f(numpy.atleast_1d(points))\n\n    def compose(self, other: Transform3D) -&gt; FuncTransform3D:\n        \"\"\"Compose this transformation with another.\"\"\"\n        return FuncTransform3D(lambda pts: other.transform(self.f(pts)))\n\n    def _rcompose(self, after: Transform3D) -&gt; FuncTransform3D:\n        return FuncTransform3D(lambda pts: self.f(after.transform(pts)))\n\n    __call__ = transform\n</code></pre>"},{"location":"api/transform/#atomlib.transform.FuncTransform3D.f","title":"<code>f: t.Callable[[numpy.ndarray], numpy.ndarray] = f</code>  <code>instance-attribute</code>","text":"<p>Wrapped function</p>"},{"location":"api/transform/#atomlib.transform.FuncTransform3D.make","title":"<code>make(data)</code>  <code>staticmethod</code>","text":"<p>Make a transformation from a function or numpy array (3x3 or 4x4).</p> Source code in <code>atomlib/transform.py</code> <pre><code>@staticmethod\ndef make(data: IntoTransform3D) -&gt; Transform3D:\n    \"\"\"Make a transformation from a function or numpy array (3x3 or 4x4).\"\"\"\n    if isinstance(data, Transform3D):\n        return data\n    if not isinstance(data, numpy.ndarray) and hasattr(data, '__call__'):\n        return FuncTransform3D(data)\n    data = numpy.array(data)\n    if data.shape == (3, 3):\n        return LinearTransform3D(data)\n    if data.shape == (4, 4):\n        return AffineTransform3D(data)\n    raise ValueError(f\"Transform3D of invalid shape {data.shape}\")\n</code></pre>"},{"location":"api/transform/#atomlib.transform.FuncTransform3D.transform_vec","title":"<code>transform_vec(vecs)</code>","text":"<p>Transform vector quantities. This excludes translation, as would be expected when transforming vectors.</p> Source code in <code>atomlib/transform.py</code> <pre><code>def transform_vec(self, vecs: ArrayLike) -&gt; NDArray[numpy.floating]:\n    \"\"\"Transform vector quantities. This excludes translation, as would be expected when transforming vectors.\"\"\"\n    a = numpy.atleast_1d(vecs)\n    return self.transform(a) - self.transform(numpy.zeros_like(a))\n</code></pre>"},{"location":"api/transform/#atomlib.transform.FuncTransform3D.identity","title":"<code>identity()</code>  <code>staticmethod</code>","text":"<p>Return an identity transformation.</p> Source code in <code>atomlib/transform.py</code> <pre><code>@staticmethod\ndef identity() -&gt; FuncTransform3D:\n    \"\"\"Return an identity transformation.\"\"\"\n    return FuncTransform3D(lambda pts: pts)\n</code></pre>"},{"location":"api/transform/#atomlib.transform.FuncTransform3D.transform","title":"<code>transform(points)</code>","text":"<p>Transform points according to the given transformation.</p> Source code in <code>atomlib/transform.py</code> <pre><code>def transform(self, points: Pts3DLike) -&gt; t.Union[BBox3D, NDArray[numpy.floating]]:\n    \"\"\"Transform points according to the given transformation.\"\"\"\n    if isinstance(points, BBox3D):\n        return points.from_pts(self.transform(points.corners()))\n\n    return self.f(numpy.atleast_1d(points))\n</code></pre>"},{"location":"api/transform/#atomlib.transform.FuncTransform3D.compose","title":"<code>compose(other)</code>","text":"<p>Compose this transformation with another.</p> Source code in <code>atomlib/transform.py</code> <pre><code>def compose(self, other: Transform3D) -&gt; FuncTransform3D:\n    \"\"\"Compose this transformation with another.\"\"\"\n    return FuncTransform3D(lambda pts: other.transform(self.f(pts)))\n</code></pre>"},{"location":"api/transform/#atomlib.transform.AffineTransform3D","title":"<code>AffineTransform3D</code>","text":"<p>             Bases: <code>Transform3D</code></p> Source code in <code>atomlib/transform.py</code> <pre><code>class AffineTransform3D(Transform3D):\n    __array_ufunc__ = None\n\n    def __init__(self, array: t.Optional[ArrayLike] = None):\n        if array is None:\n            array = numpy.eye(4)\n        self.inner = numpy.broadcast_to(array, (4, 4))\n\n    @property\n    def __array_interface__(self):\n        return self.inner.__array_interface__\n\n    def __repr__(self) -&gt; str:\n        return f\"AffineTransform3D(\\n{self.inner!r}\\n)\"\n\n    @staticmethod\n    def identity() -&gt; AffineTransform3D:\n        \"\"\"Return an identity transformation.\"\"\"\n        return AffineTransform3D()\n\n    def round_near_zero(self: Affine3DSelf) -&gt; Affine3DSelf:\n        \"\"\"Round near-zero matrix elements in self.\"\"\"\n        return type(self)(\n            numpy.where(numpy.abs(self.inner) &lt; 1e-15, 0., self.inner)\n        )\n\n    @staticmethod\n    def from_linear(linear: LinearTransform3D) -&gt; AffineTransform3D:\n        \"\"\"Make an affine transformation from a linear transformation.\"\"\"\n        dtype = linear.inner.dtype\n        return AffineTransform3D(numpy.block([\n            [linear.inner, numpy.zeros((3, 1), dtype=dtype)],\n            [numpy.zeros((1, 3), dtype=dtype), numpy.ones((), dtype=dtype)]\n        ]))  # type: ignore\n\n    def to_linear(self) -&gt; LinearTransform3D:\n        \"\"\"Return the linear part of an affine transformation.\"\"\"\n        return LinearTransform3D(self.inner[:3, :3])\n\n    def to_translation(self) -&gt; AffineTransform3D:\n        \"\"\"Extract the translation component of `self`, and return it.\"\"\"\n        return AffineTransform3D.translate(self.translation())\n\n    def det(self) -&gt; float:\n        \"\"\"Return the determinant of an affine transformation.\"\"\"\n        return numpy.linalg.det(self.inner[:3, :3])\n\n    def translation(self) -&gt; numpy.ndarray:\n        \"\"\"Extract the translation component of `self`, and return it as a vector.\"\"\"\n        return self.inner[:3, -1]\n\n    def inverse(self) -&gt; AffineTransform3D:\n        \"\"\"Return the inverse of an affine transformation.\"\"\"\n        linear_inv = LinearTransform3D(self.inner[:3, :3]).inverse()\n        # first undo translation, then undo linear transformation\n        return linear_inv @ AffineTransform3D.translate(*-self.translation())\n\n    @t.overload\n    @classmethod\n    def translate(cls, x: VecLike, /) -&gt; AffineTransform3D:\n        ...\n\n    @t.overload\n    @classmethod\n    def translate(cls, x: Num = 0., y: Num = 0., z: Num = 0.) -&gt; AffineTransform3D:\n        ...\n\n    @opt_classmethod\n    def translate(self, x: t.Union[Num, VecLike] = 0., y: Num = 0., z: Num = 0.) -&gt; AffineTransform3D:\n        \"\"\"\n        Create or append an affine translation.\n\n        Can be called as a classmethod or instance method.\n        \"\"\"\n        if isinstance(x, t.Sized) and len(x) &gt; 1:\n            try:\n                (x, y, z) = to_vec3(x)\n            except ValueError:\n                raise ValueError(\"translate() must be called with a sequence or three numbers.\")\n\n        if isinstance(self, LinearTransform3D):\n            self = AffineTransform3D.from_linear(self)\n\n        a = self.inner.copy()\n        a[:3, -1] += [x, y, z]\n        return AffineTransform3D(a)\n\n    @t.overload\n    @classmethod\n    def scale(cls, x: VecLike, /) -&gt; AffineTransform3D:\n        ...\n\n    @t.overload\n    @classmethod\n    def scale(cls, x: Num = 1., y: Num = 1., z: Num = 1., *,\n              all: Num = 1.) -&gt; AffineTransform3D:\n        ...\n\n    @opt_classmethod\n    def scale(self, x: t.Union[Num, VecLike] = 1., y: Num = 1., z: Num = 1., *,\n              all: Num = 1.) -&gt; AffineTransform3D:\n        \"\"\"\n        Create or append a scaling transformation.\n\n        Can be called as a classmethod or instance method.\n        \"\"\"\n        return self.compose(LinearTransform3D.scale(x, y, z, all=all))\n\n    @opt_classmethod\n    def rotate(self, v: VecLike, theta: Num) -&gt; AffineTransform3D:\n        \"\"\"\n        Create or append a rotation transformation of `theta`\n        radians CCW around the given vector `v`.\n\n        Can be called as a classmethod or instance method.\n        \"\"\"\n        return self.compose(LinearTransform3D.rotate(v, theta))\n\n    @opt_classmethod\n    def rotate_euler(self, x: Num = 0., y: Num = 0., z: Num = 0.) -&gt; AffineTransform3D:\n        \"\"\"\n        Create or append a Euler rotation transformation.\n        Rotation is performed on the x axis first, then y axis and z axis.\n        Values are specified in radians.\n\n        Can be called as a classmethod or instance method.\n        \"\"\"\n        return self.compose(LinearTransform3D.rotate_euler(x, y, z))\n\n    @t.overload\n    @classmethod\n    def mirror(cls, a: VecLike, /) -&gt; AffineTransform3D:\n        ...\n\n    @t.overload\n    @classmethod\n    def mirror(cls, a: Num, b: Num, c: Num) -&gt; AffineTransform3D:\n        ...\n\n    @opt_classmethod\n    def mirror(self, a: t.Union[Num, VecLike],\n               b: t.Optional[Num] = None,\n               c: t.Optional[Num] = None) -&gt; AffineTransform3D:\n        \"\"\"\n        Create or append a mirror transformation across the given plane.\n\n        Can be called as a classmethod or instance method.\n        \"\"\"\n        return self.compose(LinearTransform3D.mirror(a, b, c))\n\n    @opt_classmethod\n    def strain(self, strain: float, v: VecLike = (0, 0, 1), poisson: float = 0.) -&gt; AffineTransform3D:\n        \"\"\"\n        Apply a strain of ``strain`` in direction ``v``, assuming an elastically isotropic material.\n\n        Strain is applied relative to the origin.\n\n        With ``poisson=0`` (default), a uniaxial strain is applied.\n        With ``poisson=-1``, hydrostatic strain is applied.\n        Otherwise, a uniaxial stress is applied for a material with Poisson ratio `poisson`,\n        which results in shrinkage perpendicular to the direction strain is applied.\n\n        Can be called as a classmethod or instance method.\n        \"\"\"\n        return self.compose(LinearTransform3D.strain(strain, v, poisson))\n\n    def align_standard(self) -&gt; AffineTransform3D:\n        \"\"\"\n        Align `self` so `v1` is in the x-axis and `v2` is in the xy-plane.\n\n        This is equivalent to a $QR$ decomposition which keeps only the\n        right-triangular matrix $R$.\n\n        For an affine transformation, this rotates the transformation\n        around the global origin (including any transformation).\n        \"\"\"\n        if self.det() &lt;= 0:\n            raise ValueError(\"align_standard() requires a right-handed transformation\")\n\n        translation = self.translation()\n\n        import scipy.linalg\n        q, r = t.cast(t.Tuple[numpy.ndarray, numpy.ndarray], scipy.linalg.qr(self.to_linear().inner))\n        # qr unique up to the sign of the digonal\n        # we choose the case where r is positive definite\n        q = q * numpy.sign(r.diagonal())\n        r = r * numpy.sign(r.diagonal())[:, None]\n        assert numpy.linalg.det(r) &gt; 0\n        # we need to remove the rotation from the translation component as well\n        # q is orthogonal, so q^-1 = q.T\n        return LinearTransform3D(r).translate(q.T @ translation).round_near_zero()\n\n    @t.overload\n    def transform(self, points: BBox3D) -&gt; BBox3D:\n        ...\n\n    @t.overload\n    def transform(self, points: ArrayLike) -&gt; NDArray[numpy.floating]:\n        ...\n\n    def transform(self, points: Pts3DLike) -&gt; t.Union[BBox3D, NDArray[numpy.floating]]:\n        \"\"\"Transform points according to the given transformation.\"\"\"\n        if isinstance(points, BBox3D):\n            return points.from_pts(self.transform(points.corners()))\n\n        points = numpy.atleast_1d(points)\n        pts = numpy.concatenate((points, numpy.broadcast_to(1., (*points.shape[:-1], 1))), axis=-1)\n        # carefully handle inf and nan. this is probably slow\n        isnan = numpy.bitwise_or.reduce(numpy.isnan(pts), axis=-1)\n        with numpy.errstate(invalid='ignore'):\n            prod = self.inner * pts[..., None, :]\n        prod[numpy.isnan(prod)] = 0.\n        prod[isnan, :] = numpy.nan\n        return prod.sum(axis=-1)[..., :3]\n\n    __call__ = transform\n\n    def transform_vec(self, vecs: ArrayLike) -&gt; NDArray[numpy.floating]:\n        return self.to_linear().transform(vecs)\n\n    @t.overload\n    def compose(self, other: AffineTransform3D) -&gt; AffineTransform3D:\n        ...\n\n    @t.overload\n    def compose(self, other: Transform3DT) -&gt; Transform3DT:\n        ...\n\n    def compose(self, other: Transform3D) -&gt; Transform3D:\n        \"\"\"Compose this transformation with another.\"\"\"\n        if not isinstance(other, Transform3D):\n            raise TypeError(f\"Expected a Transform3D, got {type(other)}\")\n        if isinstance(other, LinearTransform3D):\n            return self.compose(AffineTransform3D.from_linear(other))\n        if isinstance(other, AffineTransform3D):\n            return AffineTransform3D(other.inner @ self.inner)\n        elif hasattr(other, '_rcompose'):\n            return other._rcompose(self)  # type: ignore\n        else:\n            raise NotImplementedError()\n\n    @t.overload\n    def conjugate(self, transform: AffineTransform3D) -&gt; AffineTransform3D:\n        ...\n\n    @t.overload\n    def conjugate(self, transform: Transform3DT) -&gt; Transform3DT:\n        ...\n\n    def conjugate(self, transform: Transform3D) -&gt; Transform3D:\n        \"\"\"\n        Apply ``transform`` in the coordinate frame of ``self``.\n\n        Equivalent to an (inverse) conjugation in group theory, or :math:`T^-1 A T`\n        \"\"\"\n        return self.inverse() @ transform @ self\n\n    @t.overload\n    def __matmul__(self, other: AffineTransform3D) -&gt; AffineTransform3D:\n        ...\n\n    @t.overload\n    def __matmul__(self, other: Transform3D) -&gt; Transform3D:\n        ...\n\n    @t.overload\n    def __matmul__(self, other: BBox3D) -&gt; BBox3D:\n        ...\n\n    @t.overload\n    def __matmul__(self, other: ArrayLike) -&gt; NDArray[numpy.floating]:\n        ...\n\n    def __matmul__(self, other: t.Union[Transform3D, ArrayLike, BBox3D]):  # type: ignore (spurious)\n        \"\"\"Compose this transformation, or apply it to a given set of points.\"\"\"\n        if isinstance(other, Transform3D):\n            return other.compose(self)\n        return self.transform(other)\n</code></pre>"},{"location":"api/transform/#atomlib.transform.AffineTransform3D.inner","title":"<code>inner = numpy.broadcast_to(array, (4, 4))</code>  <code>instance-attribute</code>","text":""},{"location":"api/transform/#atomlib.transform.AffineTransform3D.make","title":"<code>make(data)</code>  <code>staticmethod</code>","text":"<p>Make a transformation from a function or numpy array (3x3 or 4x4).</p> Source code in <code>atomlib/transform.py</code> <pre><code>@staticmethod\ndef make(data: IntoTransform3D) -&gt; Transform3D:\n    \"\"\"Make a transformation from a function or numpy array (3x3 or 4x4).\"\"\"\n    if isinstance(data, Transform3D):\n        return data\n    if not isinstance(data, numpy.ndarray) and hasattr(data, '__call__'):\n        return FuncTransform3D(data)\n    data = numpy.array(data)\n    if data.shape == (3, 3):\n        return LinearTransform3D(data)\n    if data.shape == (4, 4):\n        return AffineTransform3D(data)\n    raise ValueError(f\"Transform3D of invalid shape {data.shape}\")\n</code></pre>"},{"location":"api/transform/#atomlib.transform.AffineTransform3D.identity","title":"<code>identity()</code>  <code>staticmethod</code>","text":"<p>Return an identity transformation.</p> Source code in <code>atomlib/transform.py</code> <pre><code>@staticmethod\ndef identity() -&gt; AffineTransform3D:\n    \"\"\"Return an identity transformation.\"\"\"\n    return AffineTransform3D()\n</code></pre>"},{"location":"api/transform/#atomlib.transform.AffineTransform3D.round_near_zero","title":"<code>round_near_zero()</code>","text":"<p>Round near-zero matrix elements in self.</p> Source code in <code>atomlib/transform.py</code> <pre><code>def round_near_zero(self: Affine3DSelf) -&gt; Affine3DSelf:\n    \"\"\"Round near-zero matrix elements in self.\"\"\"\n    return type(self)(\n        numpy.where(numpy.abs(self.inner) &lt; 1e-15, 0., self.inner)\n    )\n</code></pre>"},{"location":"api/transform/#atomlib.transform.AffineTransform3D.from_linear","title":"<code>from_linear(linear)</code>  <code>staticmethod</code>","text":"<p>Make an affine transformation from a linear transformation.</p> Source code in <code>atomlib/transform.py</code> <pre><code>@staticmethod\ndef from_linear(linear: LinearTransform3D) -&gt; AffineTransform3D:\n    \"\"\"Make an affine transformation from a linear transformation.\"\"\"\n    dtype = linear.inner.dtype\n    return AffineTransform3D(numpy.block([\n        [linear.inner, numpy.zeros((3, 1), dtype=dtype)],\n        [numpy.zeros((1, 3), dtype=dtype), numpy.ones((), dtype=dtype)]\n    ]))  # type: ignore\n</code></pre>"},{"location":"api/transform/#atomlib.transform.AffineTransform3D.to_linear","title":"<code>to_linear()</code>","text":"<p>Return the linear part of an affine transformation.</p> Source code in <code>atomlib/transform.py</code> <pre><code>def to_linear(self) -&gt; LinearTransform3D:\n    \"\"\"Return the linear part of an affine transformation.\"\"\"\n    return LinearTransform3D(self.inner[:3, :3])\n</code></pre>"},{"location":"api/transform/#atomlib.transform.AffineTransform3D.to_translation","title":"<code>to_translation()</code>","text":"<p>Extract the translation component of <code>self</code>, and return it.</p> Source code in <code>atomlib/transform.py</code> <pre><code>def to_translation(self) -&gt; AffineTransform3D:\n    \"\"\"Extract the translation component of `self`, and return it.\"\"\"\n    return AffineTransform3D.translate(self.translation())\n</code></pre>"},{"location":"api/transform/#atomlib.transform.AffineTransform3D.det","title":"<code>det()</code>","text":"<p>Return the determinant of an affine transformation.</p> Source code in <code>atomlib/transform.py</code> <pre><code>def det(self) -&gt; float:\n    \"\"\"Return the determinant of an affine transformation.\"\"\"\n    return numpy.linalg.det(self.inner[:3, :3])\n</code></pre>"},{"location":"api/transform/#atomlib.transform.AffineTransform3D.translation","title":"<code>translation()</code>","text":"<p>Extract the translation component of <code>self</code>, and return it as a vector.</p> Source code in <code>atomlib/transform.py</code> <pre><code>def translation(self) -&gt; numpy.ndarray:\n    \"\"\"Extract the translation component of `self`, and return it as a vector.\"\"\"\n    return self.inner[:3, -1]\n</code></pre>"},{"location":"api/transform/#atomlib.transform.AffineTransform3D.inverse","title":"<code>inverse()</code>","text":"<p>Return the inverse of an affine transformation.</p> Source code in <code>atomlib/transform.py</code> <pre><code>def inverse(self) -&gt; AffineTransform3D:\n    \"\"\"Return the inverse of an affine transformation.\"\"\"\n    linear_inv = LinearTransform3D(self.inner[:3, :3]).inverse()\n    # first undo translation, then undo linear transformation\n    return linear_inv @ AffineTransform3D.translate(*-self.translation())\n</code></pre>"},{"location":"api/transform/#atomlib.transform.AffineTransform3D.translate","title":"<code>translate(x=0.0, y=0.0, z=0.0)</code>","text":"<p>Create or append an affine translation.</p> <p>Can be called as a classmethod or instance method.</p> Source code in <code>atomlib/transform.py</code> <pre><code>@opt_classmethod\ndef translate(self, x: t.Union[Num, VecLike] = 0., y: Num = 0., z: Num = 0.) -&gt; AffineTransform3D:\n    \"\"\"\n    Create or append an affine translation.\n\n    Can be called as a classmethod or instance method.\n    \"\"\"\n    if isinstance(x, t.Sized) and len(x) &gt; 1:\n        try:\n            (x, y, z) = to_vec3(x)\n        except ValueError:\n            raise ValueError(\"translate() must be called with a sequence or three numbers.\")\n\n    if isinstance(self, LinearTransform3D):\n        self = AffineTransform3D.from_linear(self)\n\n    a = self.inner.copy()\n    a[:3, -1] += [x, y, z]\n    return AffineTransform3D(a)\n</code></pre>"},{"location":"api/transform/#atomlib.transform.AffineTransform3D.scale","title":"<code>scale(x=1.0, y=1.0, z=1.0, *, all=1.0)</code>","text":"<p>Create or append a scaling transformation.</p> <p>Can be called as a classmethod or instance method.</p> Source code in <code>atomlib/transform.py</code> <pre><code>@opt_classmethod\ndef scale(self, x: t.Union[Num, VecLike] = 1., y: Num = 1., z: Num = 1., *,\n          all: Num = 1.) -&gt; AffineTransform3D:\n    \"\"\"\n    Create or append a scaling transformation.\n\n    Can be called as a classmethod or instance method.\n    \"\"\"\n    return self.compose(LinearTransform3D.scale(x, y, z, all=all))\n</code></pre>"},{"location":"api/transform/#atomlib.transform.AffineTransform3D.rotate","title":"<code>rotate(v, theta)</code>","text":"<p>Create or append a rotation transformation of <code>theta</code> radians CCW around the given vector <code>v</code>.</p> <p>Can be called as a classmethod or instance method.</p> Source code in <code>atomlib/transform.py</code> <pre><code>@opt_classmethod\ndef rotate(self, v: VecLike, theta: Num) -&gt; AffineTransform3D:\n    \"\"\"\n    Create or append a rotation transformation of `theta`\n    radians CCW around the given vector `v`.\n\n    Can be called as a classmethod or instance method.\n    \"\"\"\n    return self.compose(LinearTransform3D.rotate(v, theta))\n</code></pre>"},{"location":"api/transform/#atomlib.transform.AffineTransform3D.rotate_euler","title":"<code>rotate_euler(x=0.0, y=0.0, z=0.0)</code>","text":"<p>Create or append a Euler rotation transformation. Rotation is performed on the x axis first, then y axis and z axis. Values are specified in radians.</p> <p>Can be called as a classmethod or instance method.</p> Source code in <code>atomlib/transform.py</code> <pre><code>@opt_classmethod\ndef rotate_euler(self, x: Num = 0., y: Num = 0., z: Num = 0.) -&gt; AffineTransform3D:\n    \"\"\"\n    Create or append a Euler rotation transformation.\n    Rotation is performed on the x axis first, then y axis and z axis.\n    Values are specified in radians.\n\n    Can be called as a classmethod or instance method.\n    \"\"\"\n    return self.compose(LinearTransform3D.rotate_euler(x, y, z))\n</code></pre>"},{"location":"api/transform/#atomlib.transform.AffineTransform3D.mirror","title":"<code>mirror(a, b=None, c=None)</code>","text":"<p>Create or append a mirror transformation across the given plane.</p> <p>Can be called as a classmethod or instance method.</p> Source code in <code>atomlib/transform.py</code> <pre><code>@opt_classmethod\ndef mirror(self, a: t.Union[Num, VecLike],\n           b: t.Optional[Num] = None,\n           c: t.Optional[Num] = None) -&gt; AffineTransform3D:\n    \"\"\"\n    Create or append a mirror transformation across the given plane.\n\n    Can be called as a classmethod or instance method.\n    \"\"\"\n    return self.compose(LinearTransform3D.mirror(a, b, c))\n</code></pre>"},{"location":"api/transform/#atomlib.transform.AffineTransform3D.strain","title":"<code>strain(strain, v=(0, 0, 1), poisson=0.0)</code>","text":"<p>Apply a strain of <code>strain</code> in direction <code>v</code>, assuming an elastically isotropic material.</p> <p>Strain is applied relative to the origin.</p> <p>With <code>poisson=0</code> (default), a uniaxial strain is applied. With <code>poisson=-1</code>, hydrostatic strain is applied. Otherwise, a uniaxial stress is applied for a material with Poisson ratio <code>poisson</code>, which results in shrinkage perpendicular to the direction strain is applied.</p> <p>Can be called as a classmethod or instance method.</p> Source code in <code>atomlib/transform.py</code> <pre><code>@opt_classmethod\ndef strain(self, strain: float, v: VecLike = (0, 0, 1), poisson: float = 0.) -&gt; AffineTransform3D:\n    \"\"\"\n    Apply a strain of ``strain`` in direction ``v``, assuming an elastically isotropic material.\n\n    Strain is applied relative to the origin.\n\n    With ``poisson=0`` (default), a uniaxial strain is applied.\n    With ``poisson=-1``, hydrostatic strain is applied.\n    Otherwise, a uniaxial stress is applied for a material with Poisson ratio `poisson`,\n    which results in shrinkage perpendicular to the direction strain is applied.\n\n    Can be called as a classmethod or instance method.\n    \"\"\"\n    return self.compose(LinearTransform3D.strain(strain, v, poisson))\n</code></pre>"},{"location":"api/transform/#atomlib.transform.AffineTransform3D.align_standard","title":"<code>align_standard()</code>","text":"<p>Align <code>self</code> so <code>v1</code> is in the x-axis and <code>v2</code> is in the xy-plane.</p> <p>This is equivalent to a \\(QR\\) decomposition which keeps only the right-triangular matrix \\(R\\).</p> <p>For an affine transformation, this rotates the transformation around the global origin (including any transformation).</p> Source code in <code>atomlib/transform.py</code> <pre><code>def align_standard(self) -&gt; AffineTransform3D:\n    \"\"\"\n    Align `self` so `v1` is in the x-axis and `v2` is in the xy-plane.\n\n    This is equivalent to a $QR$ decomposition which keeps only the\n    right-triangular matrix $R$.\n\n    For an affine transformation, this rotates the transformation\n    around the global origin (including any transformation).\n    \"\"\"\n    if self.det() &lt;= 0:\n        raise ValueError(\"align_standard() requires a right-handed transformation\")\n\n    translation = self.translation()\n\n    import scipy.linalg\n    q, r = t.cast(t.Tuple[numpy.ndarray, numpy.ndarray], scipy.linalg.qr(self.to_linear().inner))\n    # qr unique up to the sign of the digonal\n    # we choose the case where r is positive definite\n    q = q * numpy.sign(r.diagonal())\n    r = r * numpy.sign(r.diagonal())[:, None]\n    assert numpy.linalg.det(r) &gt; 0\n    # we need to remove the rotation from the translation component as well\n    # q is orthogonal, so q^-1 = q.T\n    return LinearTransform3D(r).translate(q.T @ translation).round_near_zero()\n</code></pre>"},{"location":"api/transform/#atomlib.transform.AffineTransform3D.transform","title":"<code>transform(points)</code>","text":"<p>Transform points according to the given transformation.</p> Source code in <code>atomlib/transform.py</code> <pre><code>def transform(self, points: Pts3DLike) -&gt; t.Union[BBox3D, NDArray[numpy.floating]]:\n    \"\"\"Transform points according to the given transformation.\"\"\"\n    if isinstance(points, BBox3D):\n        return points.from_pts(self.transform(points.corners()))\n\n    points = numpy.atleast_1d(points)\n    pts = numpy.concatenate((points, numpy.broadcast_to(1., (*points.shape[:-1], 1))), axis=-1)\n    # carefully handle inf and nan. this is probably slow\n    isnan = numpy.bitwise_or.reduce(numpy.isnan(pts), axis=-1)\n    with numpy.errstate(invalid='ignore'):\n        prod = self.inner * pts[..., None, :]\n    prod[numpy.isnan(prod)] = 0.\n    prod[isnan, :] = numpy.nan\n    return prod.sum(axis=-1)[..., :3]\n</code></pre>"},{"location":"api/transform/#atomlib.transform.AffineTransform3D.transform_vec","title":"<code>transform_vec(vecs)</code>","text":"Source code in <code>atomlib/transform.py</code> <pre><code>def transform_vec(self, vecs: ArrayLike) -&gt; NDArray[numpy.floating]:\n    return self.to_linear().transform(vecs)\n</code></pre>"},{"location":"api/transform/#atomlib.transform.AffineTransform3D.compose","title":"<code>compose(other)</code>","text":"<p>Compose this transformation with another.</p> Source code in <code>atomlib/transform.py</code> <pre><code>def compose(self, other: Transform3D) -&gt; Transform3D:\n    \"\"\"Compose this transformation with another.\"\"\"\n    if not isinstance(other, Transform3D):\n        raise TypeError(f\"Expected a Transform3D, got {type(other)}\")\n    if isinstance(other, LinearTransform3D):\n        return self.compose(AffineTransform3D.from_linear(other))\n    if isinstance(other, AffineTransform3D):\n        return AffineTransform3D(other.inner @ self.inner)\n    elif hasattr(other, '_rcompose'):\n        return other._rcompose(self)  # type: ignore\n    else:\n        raise NotImplementedError()\n</code></pre>"},{"location":"api/transform/#atomlib.transform.AffineTransform3D.conjugate","title":"<code>conjugate(transform)</code>","text":"<p>Apply <code>transform</code> in the coordinate frame of <code>self</code>.</p> <p>Equivalent to an (inverse) conjugation in group theory, or :math:<code>T^-1 A T</code></p> Source code in <code>atomlib/transform.py</code> <pre><code>def conjugate(self, transform: Transform3D) -&gt; Transform3D:\n    \"\"\"\n    Apply ``transform`` in the coordinate frame of ``self``.\n\n    Equivalent to an (inverse) conjugation in group theory, or :math:`T^-1 A T`\n    \"\"\"\n    return self.inverse() @ transform @ self\n</code></pre>"},{"location":"api/transform/#atomlib.transform.LinearTransform3D","title":"<code>LinearTransform3D</code>","text":"<p>             Bases: <code>AffineTransform3D</code></p> Source code in <code>atomlib/transform.py</code> <pre><code>class LinearTransform3D(AffineTransform3D):\n    def __init__(self, array: t.Optional[ArrayLike] = None):\n        if array is None:\n            array = numpy.eye(3, dtype=numpy.float_)\n        self.inner = numpy.broadcast_to(array, (3, 3))\n\n    @property\n    def T(self):\n        return LinearTransform3D(self.inner.T)\n\n    def __repr__(self) -&gt; str:\n        return f\"LinearTransform3D(\\n{self.inner!r}\\n)\"\n\n    def translation(self):\n        \"\"\"Extract the translation component of `self`, and return it as a vector.\"\"\"\n        return numpy.zeros(3, dtype=self.inner.dtype)\n\n    @staticmethod\n    def identity() -&gt; LinearTransform3D:\n        \"\"\"Return an identity transformation.\"\"\"\n        return LinearTransform3D()\n\n    def det(self) -&gt; float:\n        \"\"\"Return the determinant of an affine transformation.\"\"\"\n        return numpy.linalg.det(self.inner)\n\n    def inverse(self) -&gt; LinearTransform3D:\n        \"\"\"Return the inverse of an affine transformation.\"\"\"\n        return LinearTransform3D(numpy.linalg.inv(self.inner))\n\n    def to_linear(self) -&gt; LinearTransform3D:\n        \"\"\"Return the linear part of an affine transformation.\"\"\"\n        return self\n\n    def is_diagonal(self, tol: float = 1e-10) -&gt; bool:\n        \"\"\"\n        Return whether this transformation is diagonal (i.e. axis-aligned scaling only).\n        \"\"\"\n        d = self.inner.shape[0]\n        p, q = self.inner.strides\n        offdiag = numpy.lib.stride_tricks.as_strided(self.inner[:, 1:], (d-1, d), (p+q, q))\n        return bool((numpy.abs(offdiag) &lt; tol).all())\n\n    def is_normal(self, rtol: float = 1e-5, atol: float = 1e-8) -&gt; bool:\n        \"\"\"Returns `True` if `self` is a normal matrix.\"\"\"\n        return bool(numpy.allclose(\n            self.inner.T @ self.inner, self.inner @ self.inner.T,\n            rtol=rtol, atol=atol\n        ))\n\n    def is_orthogonal(self, tol: float = 1e-8) -&gt; bool:\n        \"\"\"\n        Returns `True` if `self` is an orthogonal matrix (i.e. a pure rotation or roto-reflection).\n        \"\"\"\n        return numpy.allclose(self.inner @ self.inner.T, numpy.eye(3), atol=tol)\n\n    def is_scaled_orthogonal(self, tol: float = 1e-8) -&gt; bool:\n        \"\"\"\n        Returns `True` if `self` is a scaled orthogonal matrix (composed of orthogonal\n        basis vectors, i.e. a scaling + a rotation or roto-reflection)\n        \"\"\"\n        return is_diagonal(self.inner @ self.inner.T, tol=tol)\n\n    @t.overload\n    @classmethod\n    def mirror(cls, a: VecLike, /) -&gt; LinearTransform3D:\n        ...\n\n    @t.overload\n    @classmethod\n    def mirror(cls, a: Num, b: Num, c: Num) -&gt; LinearTransform3D:\n        ...\n\n    @opt_classmethod\n    def mirror(self, a: t.Union[Num, VecLike],\n               b: t.Optional[Num] = None,\n               c: t.Optional[Num] = None) -&gt; LinearTransform3D:\n        \"\"\"\n        Create or append a mirror transformation across the given plane.\n\n        Can be called as a classmethod or instance method.\n        \"\"\"\n        if isinstance(a, t.Sized):\n            v = numpy.array(numpy.broadcast_to(a, 3), dtype=numpy.float_)\n            if b is not None or c is not None:\n                raise ValueError(\"mirror() must be passed a sequence or three numbers.\")\n        else:\n            v = numpy.array([a, b, c], dtype=numpy.float_)\n        v /= numpy.linalg.norm(v)\n        mirror = numpy.eye(3) - 2 * numpy.outer(v, v)\n        return LinearTransform3D(mirror @ self.inner)\n\n    @opt_classmethod\n    def strain(self, strain: float, v: VecLike = (0, 0, 1), poisson: float = 0.) -&gt; LinearTransform3D:\n        \"\"\"\n        Apply a strain of ``strain`` in direction ``v``, assuming an elastically isotropic material.\n\n        Strain is applied relative to the origin.\n\n        With ``poisson=0`` (default), a uniaxial strain is applied.\n        With ``poisson=-1``, hydrostatic strain is applied.\n        Otherwise, a uniaxial stress is applied for a material with Poisson ratio `poisson`,\n        which results in shrinkage perpendicular to the direction strain is applied.\n\n        Can be called as a classmethod or instance method.\n        \"\"\"\n        shrink = (1 + strain) ** -poisson\n        return self.compose(LinearTransform3D.align(v).conjugate(\n                            LinearTransform3D.scale([shrink, shrink, 1. + strain])))\n\n    @opt_classmethod\n    def rotate(self, v: VecLike, theta: Num) -&gt; LinearTransform3D:\n        \"\"\"\n        Create or append a rotation transformation of `theta`\n        radians CCW around the given vector `v`.\n\n        Can be called as a classmethod or instance method.\n        \"\"\"\n        theta = float(theta)\n        v = numpy.array(numpy.broadcast_to(v, (3,)), dtype=numpy.float_)\n        l = numpy.linalg.norm(v)\n        if numpy.isclose(l, 0.):\n            if numpy.isclose(theta, 0.):\n                # null rotation\n                return self\n            raise ValueError(\"rotate() about the zero vector is undefined.\")\n        v /= l\n\n        # Rodrigues rotation formula\n        w = numpy.array([[  0., -v[2],  v[1]],\n                         [ v[2],   0., -v[0]],\n                         [-v[1], v[0],   0.]], dtype=numpy.float_)\n        # I + sin(t) W + (1 - cos(t)) W^2 = I + sin(t) W + 2*sin^2(t/2) W^2\n        a = numpy.eye(3) + numpy.sin(theta) * w + 2 * (numpy.sin(theta / 2)**2) * w @ w\n        return LinearTransform3D(a @ self.inner)\n\n    @opt_classmethod\n    def rotate_euler(self, x: Num = 0., y: Num = 0., z: Num = 0.) -&gt; LinearTransform3D:\n        \"\"\"\n        Create or append a Euler rotation transformation.\n        Rotation is performed on the x axis first, then y axis and z axis.\n        Values are specified in radians.\n\n        Can be called as a classmethod or instance method.\n        \"\"\"\n        angles = numpy.array([x, y, z], dtype=numpy.float_)\n        c, s = numpy.cos(angles), numpy.sin(angles)\n        a = numpy.array([\n            [c[1]*c[2], s[0]*s[1]*c[2] - c[0]*s[2], c[0]*s[1]*c[2] + s[0]*s[2]],\n            [c[1]*s[2], s[0]*s[1]*s[2] + c[0]*c[2], c[0]*s[1]*s[2] - s[0]*c[2]],\n            [-s[1],     s[0]*c[1],                  c[0]*c[1]],\n        ], dtype=numpy.float_)\n        return LinearTransform3D(a @ self.inner)\n\n    @opt_classmethod\n    def align(self, v1: VecLike, horz: t.Optional[VecLike] = None) -&gt; LinearTransform3D:\n        \"\"\"\n        Create a transformation which transforms `v1` to align with [0, 0, 1].\n        If `horz` is specified, it will be aligned in the direction of [1, 0, 0].\n\n        Can be called as a classmethod or instance method.\n        \"\"\"\n        v1 = numpy.broadcast_to(v1, 3)\n        v1 = v1 / numpy.linalg.norm(v1)\n        if horz is None:\n            if numpy.isclose(v1[0], 1.):\n                # zone is [1., 0., 0.], choose a different direction\n                horz = numpy.array([0., 1., 0.])\n            else:\n                horz = numpy.array([1., 0., 0.])\n        else:\n            horz = numpy.broadcast_to(horz, 3)\n\n        return self.align_to(v1, [0., 0., 1.], horz, [1., 0., 0.])\n\n    @t.overload\n    def align_to(self, v1: VecLike, v2: VecLike, p1: t.Literal[None] = None, p2: t.Literal[None] = None) -&gt; LinearTransform3D:\n        ...\n\n    @t.overload\n    def align_to(self, v1: VecLike, v2: VecLike, p1: VecLike, p2: VecLike) -&gt; LinearTransform3D:\n        ...\n\n    @opt_classmethod\n    def align_to(self, v1: VecLike, v2: VecLike,\n                 p1: t.Optional[VecLike] = None, p2: t.Optional[VecLike] = None) -&gt; LinearTransform3D:\n        \"\"\"\n        Create a transformation which transforms `v1` to align with `v2`.\n        If specified, additionally ensure that `p1` aligns with `p2` in the plane of `v2`.\n\n        Can be called as a classmethod or instance method.\n        \"\"\"\n        v1 = numpy.broadcast_to(v1, 3)\n        v1 = v1 / numpy.linalg.norm(v1)\n        v2 = numpy.broadcast_to(v2, 3)\n        v2 = v2 / numpy.linalg.norm(v2)\n\n        v3 = numpy.cross(v1, v2)\n        # rotate along v1 x v2 (geodesic rotation)\n        theta = numpy.arctan2(numpy.linalg.norm(v3), numpy.dot(v1, v2))\n        if numpy.isclose(numpy.linalg.norm(v3), 0.):\n            # any non-v1/v2 vector works. We choose the unit vector with largest cross product\n            v3 = numpy.zeros_like(v3)\n            v3[numpy.argmin(numpy.abs(v1))] = 1.\n\n        aligned = self.rotate(v3, theta)\n\n        if p1 is None and p2 is None:\n            return aligned.round_near_zero()\n        if p1 is None:\n            raise ValueError(\"If `p2` is specified, `p1` must also be specified.\")\n        if p2 is None:\n            raise ValueError(\"If `p1` is specified, `p2` must also be specified.\")\n\n        p1_align = aligned.transform(numpy.broadcast_to(p1, 3))\n        p2 = numpy.broadcast_to(p2, 3)\n        # components perpendicular to v2\n        p2_perp = perp(p2, v2)\n        p1_perp = perp(p1_align, v2)\n        # now rotate along v2\n        theta = numpy.arctan2(numpy.dot(v2, numpy.cross(p1_perp, p2_perp)), numpy.dot(p1_perp, p2_perp))\n        #theta = numpy.arctan2(numpy.linalg.norm(numpy.cross(p1_perp, p2_perp)), numpy.dot(p1_perp, p2_perp))\n        return aligned.rotate(v2, theta).round_near_zero()\n\n    def align_standard(self) -&gt; LinearTransform3D:\n        \"\"\"\n        Align `self` so `v1` is in the x-axis and `v2` is in the xy-plane.\n\n        This is equivalent to a $QR$ decomposition which keeps only the\n        right-triangular matrix $R$.\n        \"\"\"\n        if self.det() &lt;= 0:\n            raise ValueError(\"align_standard() requires a right-handed transformation\")\n\n        import scipy.linalg\n        _q, r = t.cast(t.Tuple[numpy.ndarray, numpy.ndarray], scipy.linalg.qr(self.inner))\n        # qr unique up to the sign of the digonal\n        # we choose the case where r is positive definite\n        r = r * numpy.sign(r.diagonal())[:, None]\n        assert numpy.linalg.det(r) &gt; 0  # check our work\n        return LinearTransform3D(r).round_near_zero()\n\n    def _orthogonal_axes(self, max_denom: int = 1000) -&gt; NDArray[numpy.int_]:\n        \"\"\"\n        Given a linear transformation A, compute an optimal linear\n        combination of basis vectors to form an orthogonal basis.\n\n        More formally, returns a small integer matrix M such that A@M is normal.\n        \"\"\"\n        import scipy.linalg\n\n        inv = self.inverse().inner\n        r, _q = scipy.linalg.rq(inv)\n        # rq unique up to the sign of the digonal\n        r = r * numpy.sign(r.diagonal())\n\n        int_r = numpy.array([reduce_vec(v, max_denom) for v in r.T]).T\n        return int_r\n\n    @t.overload\n    @classmethod\n    def scale(cls, x: VecLike, /) -&gt; LinearTransform3D:\n        ...\n\n    @t.overload\n    @classmethod\n    def scale(cls, x: Num = 1., y: Num = 1., z: Num = 1., *,\n              all: Num = 1.) -&gt; LinearTransform3D:\n        ...\n\n    @opt_classmethod\n    def scale(self, x: t.Union[Num, VecLike] = 1., y: Num = 1., z: Num = 1., *,\n              all: Num = 1.) -&gt; LinearTransform3D:\n        \"\"\"\n        Create or append a scaling transformation.\n\n        Can be called as a classmethod or instance method.\n        \"\"\"\n        if isinstance(x, t.Sized):\n            v = numpy.broadcast_to(x, 3)\n            if y != 1. or z != 1.:\n                raise ValueError(\"scale() must be passed a sequence or three numbers.\")\n        else:\n            v = numpy.array([x, y, z])\n\n        a = numpy.zeros((3, 3), dtype=self.inner.dtype)\n        a[numpy.diag_indices(3)] = all * v\n        return LinearTransform3D(a @ self.inner)\n\n    def conjugate(self, transform: Transform3DT) -&gt; Transform3DT:  # type: ignore (spurious)\n        \"\"\"\n        Apply `transform` in the coordinate frame of `self`.\n\n        Equivalent to an (inverse) conjugation in group theory, or $T^{-1} A T$\n        \"\"\"\n        return self.inverse() @ self.compose(transform)\n\n    def compose(self, other: Transform3DT) -&gt; Transform3DT:  # type: ignore (spurious)\n        \"\"\"Compose this transformation with another.\"\"\"\n        if isinstance(other, LinearTransform3D):\n            return other.__class__(other.inner @ self.inner)\n        if isinstance(other, AffineTransform3D):\n            return AffineTransform3D.from_linear(self).compose(other)\n        if not isinstance(other, Transform3D):\n            raise TypeError(f\"Expected a Transform3D, got {type(other)}\")\n        elif hasattr(other, '_rcompose'):\n            return other._rcompose(self)  # type: ignore\n        raise NotImplementedError()\n\n    @t.overload\n    def transform(self, points: BBox3D) -&gt; BBox3D:\n        ...\n\n    @t.overload\n    def transform(self, points: ArrayLike) -&gt; NDArray[numpy.floating]:\n        ...\n\n    def transform(self, points: Pts3DLike) -&gt; t.Union[BBox3D, NDArray[numpy.floating]]:\n        \"\"\"Transform points according to the given transformation.\"\"\"\n        if isinstance(points, BBox3D):\n            return points.from_pts(self.transform(points.corners()))\n\n        points = numpy.atleast_1d(points)\n        if points.shape[-1] != 3:\n            raise ValueError(f\"{self.__class__} works on 3d points only.\")\n\n        # carefully handle inf and nan. this is probably slow\n        isnan = numpy.bitwise_or.reduce(numpy.isnan(points), axis=-1)\n        with numpy.errstate(invalid='ignore'):\n            prod = self.inner * points[..., None, :]\n        prod[numpy.isnan(prod)] = 0.\n        prod[isnan, :] = numpy.nan\n        return prod.sum(axis=-1)\n\n    @t.overload\n    def __matmul__(self, other: Transform3DT) -&gt; Transform3DT:\n        ...\n\n    @t.overload\n    def __matmul__(self, other: BBox3D) -&gt; BBox3D:\n        ...\n\n    @t.overload\n    def __matmul__(self, other: ArrayLike) -&gt; NDArray[numpy.floating]:\n        ...\n\n    def __matmul__(self, other: t.Union[Transform3DT, ArrayLike, BBox3D]) -&gt; t.Union[Transform3DT, NDArray[numpy.floating], BBox3D]:\n        \"\"\"Compose this transformation, or apply it to a given set of points.\"\"\"\n        if isinstance(other, Transform3D):\n            return other.compose(self)\n        return self.transform(other)\n</code></pre>"},{"location":"api/transform/#atomlib.transform.LinearTransform3D.inner","title":"<code>inner = numpy.broadcast_to(array, (3, 3))</code>  <code>instance-attribute</code>","text":""},{"location":"api/transform/#atomlib.transform.LinearTransform3D.make","title":"<code>make(data)</code>  <code>staticmethod</code>","text":"<p>Make a transformation from a function or numpy array (3x3 or 4x4).</p> Source code in <code>atomlib/transform.py</code> <pre><code>@staticmethod\ndef make(data: IntoTransform3D) -&gt; Transform3D:\n    \"\"\"Make a transformation from a function or numpy array (3x3 or 4x4).\"\"\"\n    if isinstance(data, Transform3D):\n        return data\n    if not isinstance(data, numpy.ndarray) and hasattr(data, '__call__'):\n        return FuncTransform3D(data)\n    data = numpy.array(data)\n    if data.shape == (3, 3):\n        return LinearTransform3D(data)\n    if data.shape == (4, 4):\n        return AffineTransform3D(data)\n    raise ValueError(f\"Transform3D of invalid shape {data.shape}\")\n</code></pre>"},{"location":"api/transform/#atomlib.transform.LinearTransform3D.transform_vec","title":"<code>transform_vec(vecs)</code>","text":"Source code in <code>atomlib/transform.py</code> <pre><code>def transform_vec(self, vecs: ArrayLike) -&gt; NDArray[numpy.floating]:\n    return self.to_linear().transform(vecs)\n</code></pre>"},{"location":"api/transform/#atomlib.transform.LinearTransform3D.round_near_zero","title":"<code>round_near_zero()</code>","text":"<p>Round near-zero matrix elements in self.</p> Source code in <code>atomlib/transform.py</code> <pre><code>def round_near_zero(self: Affine3DSelf) -&gt; Affine3DSelf:\n    \"\"\"Round near-zero matrix elements in self.\"\"\"\n    return type(self)(\n        numpy.where(numpy.abs(self.inner) &lt; 1e-15, 0., self.inner)\n    )\n</code></pre>"},{"location":"api/transform/#atomlib.transform.LinearTransform3D.from_linear","title":"<code>from_linear(linear)</code>  <code>staticmethod</code>","text":"<p>Make an affine transformation from a linear transformation.</p> Source code in <code>atomlib/transform.py</code> <pre><code>@staticmethod\ndef from_linear(linear: LinearTransform3D) -&gt; AffineTransform3D:\n    \"\"\"Make an affine transformation from a linear transformation.\"\"\"\n    dtype = linear.inner.dtype\n    return AffineTransform3D(numpy.block([\n        [linear.inner, numpy.zeros((3, 1), dtype=dtype)],\n        [numpy.zeros((1, 3), dtype=dtype), numpy.ones((), dtype=dtype)]\n    ]))  # type: ignore\n</code></pre>"},{"location":"api/transform/#atomlib.transform.LinearTransform3D.to_translation","title":"<code>to_translation()</code>","text":"<p>Extract the translation component of <code>self</code>, and return it.</p> Source code in <code>atomlib/transform.py</code> <pre><code>def to_translation(self) -&gt; AffineTransform3D:\n    \"\"\"Extract the translation component of `self`, and return it.\"\"\"\n    return AffineTransform3D.translate(self.translation())\n</code></pre>"},{"location":"api/transform/#atomlib.transform.LinearTransform3D.translate","title":"<code>translate(x=0.0, y=0.0, z=0.0)</code>","text":"<p>Create or append an affine translation.</p> <p>Can be called as a classmethod or instance method.</p> Source code in <code>atomlib/transform.py</code> <pre><code>@opt_classmethod\ndef translate(self, x: t.Union[Num, VecLike] = 0., y: Num = 0., z: Num = 0.) -&gt; AffineTransform3D:\n    \"\"\"\n    Create or append an affine translation.\n\n    Can be called as a classmethod or instance method.\n    \"\"\"\n    if isinstance(x, t.Sized) and len(x) &gt; 1:\n        try:\n            (x, y, z) = to_vec3(x)\n        except ValueError:\n            raise ValueError(\"translate() must be called with a sequence or three numbers.\")\n\n    if isinstance(self, LinearTransform3D):\n        self = AffineTransform3D.from_linear(self)\n\n    a = self.inner.copy()\n    a[:3, -1] += [x, y, z]\n    return AffineTransform3D(a)\n</code></pre>"},{"location":"api/transform/#atomlib.transform.LinearTransform3D.translation","title":"<code>translation()</code>","text":"<p>Extract the translation component of <code>self</code>, and return it as a vector.</p> Source code in <code>atomlib/transform.py</code> <pre><code>def translation(self):\n    \"\"\"Extract the translation component of `self`, and return it as a vector.\"\"\"\n    return numpy.zeros(3, dtype=self.inner.dtype)\n</code></pre>"},{"location":"api/transform/#atomlib.transform.LinearTransform3D.identity","title":"<code>identity()</code>  <code>staticmethod</code>","text":"<p>Return an identity transformation.</p> Source code in <code>atomlib/transform.py</code> <pre><code>@staticmethod\ndef identity() -&gt; LinearTransform3D:\n    \"\"\"Return an identity transformation.\"\"\"\n    return LinearTransform3D()\n</code></pre>"},{"location":"api/transform/#atomlib.transform.LinearTransform3D.det","title":"<code>det()</code>","text":"<p>Return the determinant of an affine transformation.</p> Source code in <code>atomlib/transform.py</code> <pre><code>def det(self) -&gt; float:\n    \"\"\"Return the determinant of an affine transformation.\"\"\"\n    return numpy.linalg.det(self.inner)\n</code></pre>"},{"location":"api/transform/#atomlib.transform.LinearTransform3D.inverse","title":"<code>inverse()</code>","text":"<p>Return the inverse of an affine transformation.</p> Source code in <code>atomlib/transform.py</code> <pre><code>def inverse(self) -&gt; LinearTransform3D:\n    \"\"\"Return the inverse of an affine transformation.\"\"\"\n    return LinearTransform3D(numpy.linalg.inv(self.inner))\n</code></pre>"},{"location":"api/transform/#atomlib.transform.LinearTransform3D.to_linear","title":"<code>to_linear()</code>","text":"<p>Return the linear part of an affine transformation.</p> Source code in <code>atomlib/transform.py</code> <pre><code>def to_linear(self) -&gt; LinearTransform3D:\n    \"\"\"Return the linear part of an affine transformation.\"\"\"\n    return self\n</code></pre>"},{"location":"api/transform/#atomlib.transform.LinearTransform3D.is_diagonal","title":"<code>is_diagonal(tol=1e-10)</code>","text":"<p>Return whether this transformation is diagonal (i.e. axis-aligned scaling only).</p> Source code in <code>atomlib/transform.py</code> <pre><code>def is_diagonal(self, tol: float = 1e-10) -&gt; bool:\n    \"\"\"\n    Return whether this transformation is diagonal (i.e. axis-aligned scaling only).\n    \"\"\"\n    d = self.inner.shape[0]\n    p, q = self.inner.strides\n    offdiag = numpy.lib.stride_tricks.as_strided(self.inner[:, 1:], (d-1, d), (p+q, q))\n    return bool((numpy.abs(offdiag) &lt; tol).all())\n</code></pre>"},{"location":"api/transform/#atomlib.transform.LinearTransform3D.is_normal","title":"<code>is_normal(rtol=1e-05, atol=1e-08)</code>","text":"<p>Returns <code>True</code> if <code>self</code> is a normal matrix.</p> Source code in <code>atomlib/transform.py</code> <pre><code>def is_normal(self, rtol: float = 1e-5, atol: float = 1e-8) -&gt; bool:\n    \"\"\"Returns `True` if `self` is a normal matrix.\"\"\"\n    return bool(numpy.allclose(\n        self.inner.T @ self.inner, self.inner @ self.inner.T,\n        rtol=rtol, atol=atol\n    ))\n</code></pre>"},{"location":"api/transform/#atomlib.transform.LinearTransform3D.is_orthogonal","title":"<code>is_orthogonal(tol=1e-08)</code>","text":"<p>Returns <code>True</code> if <code>self</code> is an orthogonal matrix (i.e. a pure rotation or roto-reflection).</p> Source code in <code>atomlib/transform.py</code> <pre><code>def is_orthogonal(self, tol: float = 1e-8) -&gt; bool:\n    \"\"\"\n    Returns `True` if `self` is an orthogonal matrix (i.e. a pure rotation or roto-reflection).\n    \"\"\"\n    return numpy.allclose(self.inner @ self.inner.T, numpy.eye(3), atol=tol)\n</code></pre>"},{"location":"api/transform/#atomlib.transform.LinearTransform3D.is_scaled_orthogonal","title":"<code>is_scaled_orthogonal(tol=1e-08)</code>","text":"<p>Returns <code>True</code> if <code>self</code> is a scaled orthogonal matrix (composed of orthogonal basis vectors, i.e. a scaling + a rotation or roto-reflection)</p> Source code in <code>atomlib/transform.py</code> <pre><code>def is_scaled_orthogonal(self, tol: float = 1e-8) -&gt; bool:\n    \"\"\"\n    Returns `True` if `self` is a scaled orthogonal matrix (composed of orthogonal\n    basis vectors, i.e. a scaling + a rotation or roto-reflection)\n    \"\"\"\n    return is_diagonal(self.inner @ self.inner.T, tol=tol)\n</code></pre>"},{"location":"api/transform/#atomlib.transform.LinearTransform3D.mirror","title":"<code>mirror(a, b=None, c=None)</code>","text":"<p>Create or append a mirror transformation across the given plane.</p> <p>Can be called as a classmethod or instance method.</p> Source code in <code>atomlib/transform.py</code> <pre><code>@opt_classmethod\ndef mirror(self, a: t.Union[Num, VecLike],\n           b: t.Optional[Num] = None,\n           c: t.Optional[Num] = None) -&gt; LinearTransform3D:\n    \"\"\"\n    Create or append a mirror transformation across the given plane.\n\n    Can be called as a classmethod or instance method.\n    \"\"\"\n    if isinstance(a, t.Sized):\n        v = numpy.array(numpy.broadcast_to(a, 3), dtype=numpy.float_)\n        if b is not None or c is not None:\n            raise ValueError(\"mirror() must be passed a sequence or three numbers.\")\n    else:\n        v = numpy.array([a, b, c], dtype=numpy.float_)\n    v /= numpy.linalg.norm(v)\n    mirror = numpy.eye(3) - 2 * numpy.outer(v, v)\n    return LinearTransform3D(mirror @ self.inner)\n</code></pre>"},{"location":"api/transform/#atomlib.transform.LinearTransform3D.strain","title":"<code>strain(strain, v=(0, 0, 1), poisson=0.0)</code>","text":"<p>Apply a strain of <code>strain</code> in direction <code>v</code>, assuming an elastically isotropic material.</p> <p>Strain is applied relative to the origin.</p> <p>With <code>poisson=0</code> (default), a uniaxial strain is applied. With <code>poisson=-1</code>, hydrostatic strain is applied. Otherwise, a uniaxial stress is applied for a material with Poisson ratio <code>poisson</code>, which results in shrinkage perpendicular to the direction strain is applied.</p> <p>Can be called as a classmethod or instance method.</p> Source code in <code>atomlib/transform.py</code> <pre><code>@opt_classmethod\ndef strain(self, strain: float, v: VecLike = (0, 0, 1), poisson: float = 0.) -&gt; LinearTransform3D:\n    \"\"\"\n    Apply a strain of ``strain`` in direction ``v``, assuming an elastically isotropic material.\n\n    Strain is applied relative to the origin.\n\n    With ``poisson=0`` (default), a uniaxial strain is applied.\n    With ``poisson=-1``, hydrostatic strain is applied.\n    Otherwise, a uniaxial stress is applied for a material with Poisson ratio `poisson`,\n    which results in shrinkage perpendicular to the direction strain is applied.\n\n    Can be called as a classmethod or instance method.\n    \"\"\"\n    shrink = (1 + strain) ** -poisson\n    return self.compose(LinearTransform3D.align(v).conjugate(\n                        LinearTransform3D.scale([shrink, shrink, 1. + strain])))\n</code></pre>"},{"location":"api/transform/#atomlib.transform.LinearTransform3D.rotate","title":"<code>rotate(v, theta)</code>","text":"<p>Create or append a rotation transformation of <code>theta</code> radians CCW around the given vector <code>v</code>.</p> <p>Can be called as a classmethod or instance method.</p> Source code in <code>atomlib/transform.py</code> <pre><code>@opt_classmethod\ndef rotate(self, v: VecLike, theta: Num) -&gt; LinearTransform3D:\n    \"\"\"\n    Create or append a rotation transformation of `theta`\n    radians CCW around the given vector `v`.\n\n    Can be called as a classmethod or instance method.\n    \"\"\"\n    theta = float(theta)\n    v = numpy.array(numpy.broadcast_to(v, (3,)), dtype=numpy.float_)\n    l = numpy.linalg.norm(v)\n    if numpy.isclose(l, 0.):\n        if numpy.isclose(theta, 0.):\n            # null rotation\n            return self\n        raise ValueError(\"rotate() about the zero vector is undefined.\")\n    v /= l\n\n    # Rodrigues rotation formula\n    w = numpy.array([[  0., -v[2],  v[1]],\n                     [ v[2],   0., -v[0]],\n                     [-v[1], v[0],   0.]], dtype=numpy.float_)\n    # I + sin(t) W + (1 - cos(t)) W^2 = I + sin(t) W + 2*sin^2(t/2) W^2\n    a = numpy.eye(3) + numpy.sin(theta) * w + 2 * (numpy.sin(theta / 2)**2) * w @ w\n    return LinearTransform3D(a @ self.inner)\n</code></pre>"},{"location":"api/transform/#atomlib.transform.LinearTransform3D.rotate_euler","title":"<code>rotate_euler(x=0.0, y=0.0, z=0.0)</code>","text":"<p>Create or append a Euler rotation transformation. Rotation is performed on the x axis first, then y axis and z axis. Values are specified in radians.</p> <p>Can be called as a classmethod or instance method.</p> Source code in <code>atomlib/transform.py</code> <pre><code>@opt_classmethod\ndef rotate_euler(self, x: Num = 0., y: Num = 0., z: Num = 0.) -&gt; LinearTransform3D:\n    \"\"\"\n    Create or append a Euler rotation transformation.\n    Rotation is performed on the x axis first, then y axis and z axis.\n    Values are specified in radians.\n\n    Can be called as a classmethod or instance method.\n    \"\"\"\n    angles = numpy.array([x, y, z], dtype=numpy.float_)\n    c, s = numpy.cos(angles), numpy.sin(angles)\n    a = numpy.array([\n        [c[1]*c[2], s[0]*s[1]*c[2] - c[0]*s[2], c[0]*s[1]*c[2] + s[0]*s[2]],\n        [c[1]*s[2], s[0]*s[1]*s[2] + c[0]*c[2], c[0]*s[1]*s[2] - s[0]*c[2]],\n        [-s[1],     s[0]*c[1],                  c[0]*c[1]],\n    ], dtype=numpy.float_)\n    return LinearTransform3D(a @ self.inner)\n</code></pre>"},{"location":"api/transform/#atomlib.transform.LinearTransform3D.align","title":"<code>align(v1, horz=None)</code>","text":"<p>Create a transformation which transforms <code>v1</code> to align with [0, 0, 1]. If <code>horz</code> is specified, it will be aligned in the direction of [1, 0, 0].</p> <p>Can be called as a classmethod or instance method.</p> Source code in <code>atomlib/transform.py</code> <pre><code>@opt_classmethod\ndef align(self, v1: VecLike, horz: t.Optional[VecLike] = None) -&gt; LinearTransform3D:\n    \"\"\"\n    Create a transformation which transforms `v1` to align with [0, 0, 1].\n    If `horz` is specified, it will be aligned in the direction of [1, 0, 0].\n\n    Can be called as a classmethod or instance method.\n    \"\"\"\n    v1 = numpy.broadcast_to(v1, 3)\n    v1 = v1 / numpy.linalg.norm(v1)\n    if horz is None:\n        if numpy.isclose(v1[0], 1.):\n            # zone is [1., 0., 0.], choose a different direction\n            horz = numpy.array([0., 1., 0.])\n        else:\n            horz = numpy.array([1., 0., 0.])\n    else:\n        horz = numpy.broadcast_to(horz, 3)\n\n    return self.align_to(v1, [0., 0., 1.], horz, [1., 0., 0.])\n</code></pre>"},{"location":"api/transform/#atomlib.transform.LinearTransform3D.align_to","title":"<code>align_to(v1, v2, p1=None, p2=None)</code>","text":"<p>Create a transformation which transforms <code>v1</code> to align with <code>v2</code>. If specified, additionally ensure that <code>p1</code> aligns with <code>p2</code> in the plane of <code>v2</code>.</p> <p>Can be called as a classmethod or instance method.</p> Source code in <code>atomlib/transform.py</code> <pre><code>@opt_classmethod\ndef align_to(self, v1: VecLike, v2: VecLike,\n             p1: t.Optional[VecLike] = None, p2: t.Optional[VecLike] = None) -&gt; LinearTransform3D:\n    \"\"\"\n    Create a transformation which transforms `v1` to align with `v2`.\n    If specified, additionally ensure that `p1` aligns with `p2` in the plane of `v2`.\n\n    Can be called as a classmethod or instance method.\n    \"\"\"\n    v1 = numpy.broadcast_to(v1, 3)\n    v1 = v1 / numpy.linalg.norm(v1)\n    v2 = numpy.broadcast_to(v2, 3)\n    v2 = v2 / numpy.linalg.norm(v2)\n\n    v3 = numpy.cross(v1, v2)\n    # rotate along v1 x v2 (geodesic rotation)\n    theta = numpy.arctan2(numpy.linalg.norm(v3), numpy.dot(v1, v2))\n    if numpy.isclose(numpy.linalg.norm(v3), 0.):\n        # any non-v1/v2 vector works. We choose the unit vector with largest cross product\n        v3 = numpy.zeros_like(v3)\n        v3[numpy.argmin(numpy.abs(v1))] = 1.\n\n    aligned = self.rotate(v3, theta)\n\n    if p1 is None and p2 is None:\n        return aligned.round_near_zero()\n    if p1 is None:\n        raise ValueError(\"If `p2` is specified, `p1` must also be specified.\")\n    if p2 is None:\n        raise ValueError(\"If `p1` is specified, `p2` must also be specified.\")\n\n    p1_align = aligned.transform(numpy.broadcast_to(p1, 3))\n    p2 = numpy.broadcast_to(p2, 3)\n    # components perpendicular to v2\n    p2_perp = perp(p2, v2)\n    p1_perp = perp(p1_align, v2)\n    # now rotate along v2\n    theta = numpy.arctan2(numpy.dot(v2, numpy.cross(p1_perp, p2_perp)), numpy.dot(p1_perp, p2_perp))\n    #theta = numpy.arctan2(numpy.linalg.norm(numpy.cross(p1_perp, p2_perp)), numpy.dot(p1_perp, p2_perp))\n    return aligned.rotate(v2, theta).round_near_zero()\n</code></pre>"},{"location":"api/transform/#atomlib.transform.LinearTransform3D.align_standard","title":"<code>align_standard()</code>","text":"<p>Align <code>self</code> so <code>v1</code> is in the x-axis and <code>v2</code> is in the xy-plane.</p> <p>This is equivalent to a \\(QR\\) decomposition which keeps only the right-triangular matrix \\(R\\).</p> Source code in <code>atomlib/transform.py</code> <pre><code>def align_standard(self) -&gt; LinearTransform3D:\n    \"\"\"\n    Align `self` so `v1` is in the x-axis and `v2` is in the xy-plane.\n\n    This is equivalent to a $QR$ decomposition which keeps only the\n    right-triangular matrix $R$.\n    \"\"\"\n    if self.det() &lt;= 0:\n        raise ValueError(\"align_standard() requires a right-handed transformation\")\n\n    import scipy.linalg\n    _q, r = t.cast(t.Tuple[numpy.ndarray, numpy.ndarray], scipy.linalg.qr(self.inner))\n    # qr unique up to the sign of the digonal\n    # we choose the case where r is positive definite\n    r = r * numpy.sign(r.diagonal())[:, None]\n    assert numpy.linalg.det(r) &gt; 0  # check our work\n    return LinearTransform3D(r).round_near_zero()\n</code></pre>"},{"location":"api/transform/#atomlib.transform.LinearTransform3D.scale","title":"<code>scale(x=1.0, y=1.0, z=1.0, *, all=1.0)</code>","text":"<p>Create or append a scaling transformation.</p> <p>Can be called as a classmethod or instance method.</p> Source code in <code>atomlib/transform.py</code> <pre><code>@opt_classmethod\ndef scale(self, x: t.Union[Num, VecLike] = 1., y: Num = 1., z: Num = 1., *,\n          all: Num = 1.) -&gt; LinearTransform3D:\n    \"\"\"\n    Create or append a scaling transformation.\n\n    Can be called as a classmethod or instance method.\n    \"\"\"\n    if isinstance(x, t.Sized):\n        v = numpy.broadcast_to(x, 3)\n        if y != 1. or z != 1.:\n            raise ValueError(\"scale() must be passed a sequence or three numbers.\")\n    else:\n        v = numpy.array([x, y, z])\n\n    a = numpy.zeros((3, 3), dtype=self.inner.dtype)\n    a[numpy.diag_indices(3)] = all * v\n    return LinearTransform3D(a @ self.inner)\n</code></pre>"},{"location":"api/transform/#atomlib.transform.LinearTransform3D.conjugate","title":"<code>conjugate(transform)</code>","text":"<p>Apply <code>transform</code> in the coordinate frame of <code>self</code>.</p> <p>Equivalent to an (inverse) conjugation in group theory, or \\(T^{-1} A T\\)</p> Source code in <code>atomlib/transform.py</code> <pre><code>def conjugate(self, transform: Transform3DT) -&gt; Transform3DT:  # type: ignore (spurious)\n    \"\"\"\n    Apply `transform` in the coordinate frame of `self`.\n\n    Equivalent to an (inverse) conjugation in group theory, or $T^{-1} A T$\n    \"\"\"\n    return self.inverse() @ self.compose(transform)\n</code></pre>"},{"location":"api/transform/#atomlib.transform.LinearTransform3D.compose","title":"<code>compose(other)</code>","text":"<p>Compose this transformation with another.</p> Source code in <code>atomlib/transform.py</code> <pre><code>def compose(self, other: Transform3DT) -&gt; Transform3DT:  # type: ignore (spurious)\n    \"\"\"Compose this transformation with another.\"\"\"\n    if isinstance(other, LinearTransform3D):\n        return other.__class__(other.inner @ self.inner)\n    if isinstance(other, AffineTransform3D):\n        return AffineTransform3D.from_linear(self).compose(other)\n    if not isinstance(other, Transform3D):\n        raise TypeError(f\"Expected a Transform3D, got {type(other)}\")\n    elif hasattr(other, '_rcompose'):\n        return other._rcompose(self)  # type: ignore\n    raise NotImplementedError()\n</code></pre>"},{"location":"api/transform/#atomlib.transform.LinearTransform3D.transform","title":"<code>transform(points)</code>","text":"<p>Transform points according to the given transformation.</p> Source code in <code>atomlib/transform.py</code> <pre><code>def transform(self, points: Pts3DLike) -&gt; t.Union[BBox3D, NDArray[numpy.floating]]:\n    \"\"\"Transform points according to the given transformation.\"\"\"\n    if isinstance(points, BBox3D):\n        return points.from_pts(self.transform(points.corners()))\n\n    points = numpy.atleast_1d(points)\n    if points.shape[-1] != 3:\n        raise ValueError(f\"{self.__class__} works on 3d points only.\")\n\n    # carefully handle inf and nan. this is probably slow\n    isnan = numpy.bitwise_or.reduce(numpy.isnan(points), axis=-1)\n    with numpy.errstate(invalid='ignore'):\n        prod = self.inner * points[..., None, :]\n    prod[numpy.isnan(prod)] = 0.\n    prod[isnan, :] = numpy.nan\n    return prod.sum(axis=-1)\n</code></pre>"},{"location":"api/types/","title":"<code>atomlib.types</code>","text":""},{"location":"api/types/#atomlib.types.ParamSpec","title":"<code>ParamSpec = typing_extensions.ParamSpec</code>  <code>module-attribute</code>","text":"<p>Re-export of <code>typing.ParamSpec</code></p>"},{"location":"api/types/#atomlib.types.Concatenate","title":"<code>Concatenate = typing_extensions.Concatenate</code>  <code>module-attribute</code>","text":"<p>Re-export of <code>typing.Concatenate</code></p>"},{"location":"api/types/#atomlib.types.TypeAlias","title":"<code>TypeAlias = typing_extensions.TypeAlias</code>  <code>module-attribute</code>","text":"<p>Re-export of <code>typing.TypeAlias</code></p>"},{"location":"api/types/#atomlib.types.Vec3","title":"<code>Vec3 = NDArray[numpy.floating[t.Any]]</code>  <code>module-attribute</code>","text":"<p>3D float vector, of shape (3,).</p>"},{"location":"api/types/#atomlib.types.VecLike","title":"<code>VecLike = ArrayLike</code>  <code>module-attribute</code>","text":"<p>3d vector-like</p>"},{"location":"api/types/#atomlib.types.Pts3DLike","title":"<code>Pts3DLike = t.Union['BBox3D', ArrayLike]</code>  <code>module-attribute</code>","text":"<p>Sequence of 3d points-like</p>"},{"location":"api/types/#atomlib.types.Num","title":"<code>Num = t.Union[float, int]</code>  <code>module-attribute</code>","text":"<p>Scalar numeric type</p>"},{"location":"api/types/#atomlib.types.ElemLike","title":"<code>ElemLike = t.Union[str, int]</code>  <code>module-attribute</code>","text":"<p>Element-like</p>"},{"location":"api/types/#atomlib.types.ScalarT","title":"<code>ScalarT = t.TypeVar('ScalarT', bound=numpy.generic)</code>  <code>module-attribute</code>","text":"<p><code>numpy.generic</code>-bound type variable</p>"},{"location":"api/types/#atomlib.types.to_vec3","title":"<code>to_vec3(v, dtype=None)</code>","text":"<p>Broadcast and coerce <code>v</code> to a <code>Vec3</code> of type <code>dtype</code>.</p> Source code in <code>atomlib/types.py</code> <pre><code>def to_vec3(v: VecLike, dtype: t.Optional[t.Type[numpy.generic]] = None) -&gt; NDArray[numpy.generic]:\n    \"\"\"\n    Broadcast and coerce `v` to a [`Vec3`][atomlib.types.Vec3] of type `dtype`.\n    \"\"\"\n\n    try:\n        v = numpy.broadcast_to(v, (3,)).astype(dtype or numpy.float_)\n    except (ValueError, TypeError):\n        raise TypeError(\"Expected a vector of 3 elements.\") from None\n    return v\n</code></pre>"},{"location":"api/util/","title":"<code>atomlib.util</code>","text":""},{"location":"api/util/#atomlib.util.FileOrPath","title":"<code>FileOrPath = t.Union[str, Path, TextIOBase, t.TextIO]</code>  <code>module-attribute</code>","text":"<p>Open text file or path to a file. Use with open_file.</p>"},{"location":"api/util/#atomlib.util.BinaryFileOrPath","title":"<code>BinaryFileOrPath = t.Union[str, Path, t.TextIO, t.BinaryIO, IOBase]</code>  <code>module-attribute</code>","text":"<p>Open binary file or path to a file. Use with open_file_binary.</p>"},{"location":"api/util/#atomlib.util.opt_classmethod","title":"<code>opt_classmethod</code>","text":"<p>             Bases: <code>classmethod</code>, <code>Generic[T, P, U_co]</code></p> <p>Decorates a method that may be called either on an instance or the class. If called on the class, a default instance will be constructed before calling the wrapped function.</p> Source code in <code>atomlib/util.py</code> <pre><code>class opt_classmethod(classmethod, t.Generic[T, P, U_co]):\n    \"\"\"\n    Decorates a method that may be called either on an instance or the class.\n    If called on the class, a default instance will be constructed before\n    calling the wrapped function.\n    \"\"\"\n\n    __func__: t.Callable[Concatenate[T, P], U_co]  # type: ignore\n    def __init__(self, f: t.Callable[Concatenate[T, P], U_co]):\n        super().__init__(f)\n\n    def __get__(self, obj: t.Optional[T], ty: t.Optional[t.Type[T]] = None) -&gt; t.Callable[P, U_co]:  # type: ignore\n        if obj is None:\n            if ty is None:\n                raise RuntimeError()  # pragma: no cover\n            obj = ty()\n        return t.cast(\n            t.Callable[P, U_co],\n            super().__get__(obj, obj)  # type: ignore\n        )\n</code></pre>"},{"location":"api/util/#atomlib.util.CheckedJoinError","title":"<code>CheckedJoinError</code>","text":"<p>             Bases: <code>Exception</code></p> Source code in <code>atomlib/util.py</code> <pre><code>class CheckedJoinError(Exception):\n    def __init__(self, missing_keys: t.Sequence[t.Any]):\n        self.missing_keys: t.Tuple[t.Any, ...] = tuple(missing_keys)\n        super().__init__()\n\n    def __str__(self) -&gt; str:\n        return f\"Missing match for key(s): '{', '.join(map(repr, self.missing_keys))}'\"\n</code></pre>"},{"location":"api/util/#atomlib.util.CheckedJoinError.missing_keys","title":"<code>missing_keys: t.Tuple[t.Any, ...] = tuple(missing_keys)</code>  <code>instance-attribute</code>","text":""},{"location":"api/util/#atomlib.util.map_some","title":"<code>map_some(f, val)</code>","text":"<p>Map <code>f</code> over <code>val</code> if not <code>None</code>.</p> Source code in <code>atomlib/util.py</code> <pre><code>def map_some(f: t.Callable[[T], U], val: t.Optional[T]) -&gt; t.Optional[U]:\n    \"\"\"\n    Map `f` over `val` if not `None`.\n    \"\"\"\n    return None if val is None else f(val)\n</code></pre>"},{"location":"api/util/#atomlib.util.open_file","title":"<code>open_file(f, mode='r', newline=None, encoding='utf-8')</code>","text":"<p>Open the given file for text I/O.</p> <p>If given a path-like, opens it with the specified settings. Otherwise, make an effort to reconfigure the encoding, and check that it is readable/writable as specified.</p> Source code in <code>atomlib/util.py</code> <pre><code>def open_file(f: FileOrPath,\n              mode: t.Union[t.Literal['r'], t.Literal['w']] = 'r',\n              newline: t.Optional[str] = None,\n              encoding: t.Optional[str] = 'utf-8') -&gt; AbstractContextManager[TextIOBase]:\n    \"\"\"\n    Open the given file for text I/O.\n\n    If given a path-like, opens it with the specified settings.\n    Otherwise, make an effort to reconfigure the encoding, and\n    check that it is readable/writable as specified.\n    \"\"\"\n    if not isinstance(f, (IOBase, t.BinaryIO, t.TextIO)):\n        return open(f, mode, newline=newline, encoding=encoding)\n\n    if isinstance(f, TextIOWrapper):\n        f.reconfigure(newline=newline, encoding=encoding)\n    elif isinstance(f, t.TextIO):\n        f = TextIOWrapper(f.buffer, newline=newline, encoding=encoding)\n    elif isinstance(f, (BufferedIOBase, t.BinaryIO)):\n        f = TextIOWrapper(t.cast(t.BinaryIO, f), newline=newline, encoding=encoding)\n\n    _validate_file(f, mode)\n    return nullcontext(f)  # don't close a f we didn't open\n</code></pre>"},{"location":"api/util/#atomlib.util.open_file_binary","title":"<code>open_file_binary(f, mode='r')</code>","text":"<p>Open the given file for binary I/O.</p> <p>If given a path-like, opens it with the specified settings. If given text I/O, reconfigure to binary. Make sure stream is readable/writable, as specified.</p> Source code in <code>atomlib/util.py</code> <pre><code>def open_file_binary(f: BinaryFileOrPath,\n                     mode: t.Union[t.Literal['r'], t.Literal['w']] = 'r') -&gt; AbstractContextManager[IOBase]:\n    \"\"\"\n    Open the given file for binary I/O.\n\n    If given a path-like, opens it with the specified settings. If given text I/O,\n    reconfigure to binary. Make sure stream is readable/writable, as specified.\n    \"\"\"\n    if not isinstance(f, (IOBase, t.BinaryIO, t.TextIO)):\n        return t.cast(IOBase, open(f, mode + 'b'))\n\n    if isinstance(f, (TextIOWrapper, t.TextIO)):\n        try:\n            f = f.buffer\n        except AttributeError:\n            raise ValueError(\"Error: Couldn't get raw buffer from text file.\")\n    elif isinstance(f, StringIO):\n        if mode == 'w':\n            raise ValueError(\"Can't write binary stream to StringIO.\")\n        return BytesIO(f.getvalue().encode('utf-8'))\n    elif isinstance(f, TextIOBase):\n        raise ValueError(f\"Error: Couldn't get binary stream from text stream of type '{type(f)}'.\")\n\n    _validate_file(f, mode)\n    return nullcontext(t.cast(IOBase, f))  # don't close a file we didn't open\n</code></pre>"},{"location":"api/util/#atomlib.util.localtime","title":"<code>localtime()</code>","text":"<p>Return the current time in a timezone-aware datetime object.</p> Source code in <code>atomlib/util.py</code> <pre><code>def localtime() -&gt; datetime.datetime:\n    \"\"\"Return the current time in a timezone-aware [datetime][datetime.datetime] object.\"\"\"\n    ltime = time.localtime()\n    tz = datetime.timezone(datetime.timedelta(seconds=ltime.tm_gmtoff), ltime.tm_zone)\n    return datetime.datetime.now(tz)\n</code></pre>"},{"location":"api/util/#atomlib.util.proc_seed","title":"<code>proc_seed(seed, entropy)</code>","text":"<p>Process a random seed, which can be any object (or <code>None</code> for a random seed). Return it in a form which can be passed to numpy.random.default_rng.</p> <p>Uses a SHA-256 sum under the hood.</p> <p><code>entropy</code> should be a routine-specific object, to ensure that separate random routines called using the same seed return uncorrelated results.</p> Source code in <code>atomlib/util.py</code> <pre><code>def proc_seed(seed: t.Optional[object], entropy: object) -&gt; t.Optional[NDArray[numpy.uint32]]:\n    \"\"\"\n    Process a random seed, which can be any object (or `None` for a random seed).\n    Return it in a form which can be passed to [numpy.random.default_rng][].\n\n    Uses a SHA-256 sum under the hood.\n\n    `entropy` should be a routine-specific object, to ensure that separate random\n    routines called using the same seed return uncorrelated results.\n    \"\"\"\n    if seed is None:\n        return None\n    # hash our seed and our extra entropy\n    state = sha256()\n    state.update(str(seed).encode('utf-8'))\n    state.update(json.dumps(entropy).encode('utf-8'))\n    return numpy.frombuffer(state.digest(), dtype=numpy.uint32)\n</code></pre>"},{"location":"api/util/#atomlib.util.checked_left_join","title":"<code>checked_left_join(lhs, rhs, on=None, *, left_on=None, right_on=None)</code>","text":"Source code in <code>atomlib/util.py</code> <pre><code>def checked_left_join(lhs: polars.DataFrame, rhs: polars.DataFrame, on: t.Optional[str] = None, *,\n                      left_on: t.Optional[str] = None, right_on: t.Optional[str] = None) -&gt; polars.DataFrame:\n    df = lhs.join(rhs, how='inner', on=on, left_on=left_on, right_on=right_on, validate='m:1')\n\n    if len(df) &lt; len(lhs):\n        missing_rows = lhs.join(rhs, how='anti', on=on, left_on=left_on, right_on=right_on)\n        col = t.cast(str, left_on or on)\n        missing = missing_rows.select(polars.col(col).unique()).to_series()\n        raise CheckedJoinError(tuple(missing))\n\n    return df\n</code></pre>"},{"location":"api/vec/","title":"<code>atomlib.vec</code>","text":"<p>Helper functions for spatial vectors.</p>"},{"location":"api/vec/#atomlib.vec.WindingRule","title":"<code>WindingRule = t.Literal['nonzero', 'evenodd', 'positive', 'negative']</code>  <code>module-attribute</code>","text":""},{"location":"api/vec/#atomlib.vec.to_vec3","title":"<code>to_vec3(v, dtype=None)</code>","text":"<p>Broadcast and coerce <code>v</code> to a <code>Vec3</code> of type <code>dtype</code>.</p> Source code in <code>atomlib/types.py</code> <pre><code>def to_vec3(v: VecLike, dtype: t.Optional[t.Type[numpy.generic]] = None) -&gt; NDArray[numpy.generic]:\n    \"\"\"\n    Broadcast and coerce `v` to a [`Vec3`][atomlib.types.Vec3] of type `dtype`.\n    \"\"\"\n\n    try:\n        v = numpy.broadcast_to(v, (3,)).astype(dtype or numpy.float_)\n    except (ValueError, TypeError):\n        raise TypeError(\"Expected a vector of 3 elements.\") from None\n    return v\n</code></pre>"},{"location":"api/vec/#atomlib.vec.dot","title":"<code>dot(v1, v2, axis=-1, keepdims=True)</code>","text":"Source code in <code>atomlib/vec.py</code> <pre><code>def dot(v1: ArrayLike, v2: ArrayLike, axis: int = -1, keepdims: bool = True) -&gt; NDArray[numpy.floating]:\n    return numpy.add.reduce(numpy.atleast_1d(v1) * numpy.atleast_1d(v2), axis=axis, keepdims=keepdims)\n</code></pre>"},{"location":"api/vec/#atomlib.vec.norm","title":"<code>norm(v)</code>","text":"Source code in <code>atomlib/vec.py</code> <pre><code>def norm(v: ArrayLike) -&gt; numpy.floating:\n    return numpy.linalg.norm(v)\n</code></pre>"},{"location":"api/vec/#atomlib.vec.perp","title":"<code>perp(v1, v2)</code>","text":"<p>Return the component of <code>v1</code> perpendicular to <code>v2</code>.</p> Source code in <code>atomlib/vec.py</code> <pre><code>def perp(v1: ArrayLike, v2: ArrayLike) -&gt; NDArray[numpy.floating]:\n    \"\"\"Return the component of ``v1`` perpendicular to ``v2``.\"\"\"\n    v1 = numpy.atleast_1d(v1)\n    v2 = numpy.atleast_1d(v2)\n    v2 /= norm(v2)\n    return v1 - v2 * dot(v1, v2)\n</code></pre>"},{"location":"api/vec/#atomlib.vec.para","title":"<code>para(v1, v2)</code>","text":"<p>Return the component of <code>v1</code> parallel to <code>v2</code>.</p> Source code in <code>atomlib/vec.py</code> <pre><code>def para(v1: ArrayLike, v2: ArrayLike) -&gt; NDArray[numpy.floating]:\n    \"\"\"Return the component of ``v1`` parallel to ``v2``.\"\"\"\n    v1 = numpy.atleast_1d(v1)\n    v2 = numpy.atleast_1d(v2)\n    v2 /= norm(v2)\n    return v2 * dot(v1, v2)\n</code></pre>"},{"location":"api/vec/#atomlib.vec.is_diagonal","title":"<code>is_diagonal(matrix, tol=1e-10)</code>","text":"Source code in <code>atomlib/vec.py</code> <pre><code>def is_diagonal(matrix: numpy.ndarray, tol: float = 1e-10) -&gt; bool:\n    d = matrix.shape[0]\n    assert matrix.shape == (d, d)\n    p, q = matrix.strides\n    offdiag = numpy.lib.stride_tricks.as_strided(matrix[:, 1:], (d-1, d), (p+q, q))\n    return bool((numpy.abs(offdiag) &lt; tol).all())\n</code></pre>"},{"location":"api/vec/#atomlib.vec.split_arr","title":"<code>split_arr(a, axis=0)</code>","text":"Source code in <code>atomlib/vec.py</code> <pre><code>def split_arr(a: NDArray[ScalarT], axis: int = 0) -&gt; t.Iterator[NDArray[ScalarT]]:\n    return (numpy.squeeze(sub_a, axis) for sub_a in numpy.split(a, a.shape[axis], axis))\n</code></pre>"},{"location":"api/vec/#atomlib.vec.polygon_solid_angle","title":"<code>polygon_solid_angle(poly, pts=None, winding=None)</code>","text":"<p>Return the signed solid angle of the polygon <code>poly</code> in the xy plane, as viewed from <code>pts</code>.</p> <p><code>poly</code>: ndarray of shape (..., N, 2) <code>pts</code>: ndarray of shape (..., 3)</p> <p>Returns a ndarray of shape <code>broadcast(poly.shape[:-2], pts.shape[:-1])</code></p> Source code in <code>atomlib/vec.py</code> <pre><code>def polygon_solid_angle(poly: ArrayLike, pts: t.Optional[ArrayLike] = None,\n                        winding: t.Optional[ArrayLike] = None) -&gt; NDArray[numpy.float_]:\n    \"\"\"\n    Return the signed solid angle of the polygon ``poly`` in the xy plane, as viewed from ``pts``.\n\n    ``poly``: ndarray of shape (..., N, 2)\n    ``pts``: ndarray of shape (..., 3)\n\n    Returns a ndarray of shape ``broadcast(poly.shape[:-2], pts.shape[:-1])``\n    \"\"\"\n    poly = numpy.atleast_2d(poly).astype(numpy.float_)\n    pts = (numpy.array([0., 0., 0.]) if pts is None else numpy.atleast_1d(pts)).astype(numpy.float_)\n\n    if poly.shape[-1] == 3:\n        raise ValueError(\"Only 2d polygons are supported.\")\n    if poly.shape[-1] != 2:\n        raise ValueError(\"`poly` must be a list of 2d points.\")\n    if winding is None:\n        # calculate winding\n        winding = polygon_winding(poly)\n    else:\n        winding = numpy.asarray(winding, dtype=int)\n    # extend to 3d\n    poly = numpy.concatenate((poly, numpy.zeros_like(poly, shape=(*poly.shape[:-1], 1))), axis=-1)\n\n    if pts.shape[-1] != 3:\n        raise ValueError(\"`pts` must be a list of 3d points.\")\n\n    poly = poly - pts[..., None, :]\n    # normalize polygon points to unit sphere\n    numpy.divide(poly, numpy.linalg.norm(poly, axis=-1, keepdims=True), out=poly)\n\n    def _dot(v1: NDArray[numpy.float_], v2: NDArray[numpy.float_]) -&gt; NDArray[numpy.float_]:\n        return numpy.add.reduce(v1 * v2, axis=-1)\n\n    # next and previous points in polygon\n    poly_n = numpy.roll(poly, -1, axis=-2)\n    poly_p = numpy.roll(poly, 1, axis=-2)\n\n    # spherical angle is 2*pi - sum(atan2(-|v1v2v3|, v1 dot v2 * v2 dot v3 - v1 dot v3))\n    angles = numpy.arctan2(_dot(poly_p, numpy.cross(poly, poly_n)), _dot(poly_p, poly) * _dot(poly, poly_n) - _dot(poly_p, poly_n))\n    angle = numpy.sum(angles, axis=-1)\n\n    # when winding is nonzero, we have to offset the calculated angle by the angle created by winding.\n    numpy.mod(angle, 4*numpy.pi*winding, out=angle, where=(winding != 0))\n    return angle - 2*numpy.pi*winding\n</code></pre>"},{"location":"api/vec/#atomlib.vec.polygon_winding","title":"<code>polygon_winding(poly, pt=None)</code>","text":"<p>Return the winding number of the given 2d polygon <code>poly</code> around the point <code>pt</code>. If <code>pt</code> is not specified, return the polygon's total winding number (turning number).</p> <p>Vectorized. CCW winding is defined as positive.</p> Source code in <code>atomlib/vec.py</code> <pre><code>def polygon_winding(poly: ArrayLike, pt: t.Optional[ArrayLike] = None) -&gt; NDArray[numpy.int_]:\n    \"\"\"\n    Return the winding number of the given 2d polygon ``poly`` around the point ``pt``.\n    If ``pt`` is not specified, return the polygon's total winding number (turning number).\n\n    Vectorized. CCW winding is defined as positive.\n    \"\"\"\n    poly = numpy.atleast_2d(poly)\n    if poly.dtype == object:\n        raise ValueError(\"Ragged arrays not supported.\")\n    poly = poly.astype(numpy.float_)\n\n    if pt is None:\n        # return polygon's total winding number (turning number)\n        poly_next = numpy.roll(poly, -1, axis=-2)\n        # equivalent to the turning number of velocity vectors (difference vectors)\n        poly = poly_next - poly\n        # about the origin\n        pt = numpy.array([0., 0.])\n\n        # remove points at the origin (duplicate points)\n        zero_pts = (numpy.isclose(poly[..., 0], 0., atol=1e-10) &amp; \n                    numpy.isclose(poly[..., 1], 0., atol=1e-10))\n        poly = poly[~zero_pts]\n\n    pt = numpy.atleast_1d(pt)[..., None, :].astype(numpy.float_)\n\n    # shift the polygon's origin to `pt`.\n    poly = poly - pt\n    poly_next = numpy.roll(poly, -1, axis=-2)\n    (x, y) = split_arr(poly, axis=-1)\n    (xn, yn) = split_arr(poly_next, axis=-1)\n\n    # |p1 cross (p2 - p1)| -&gt; (p2 - p1) to right or left of origin\n    x_pos = x*(yn - y) - y*(xn - x)  # type: ignore\n    # count up crossings and down crossings\n    up_crossing = (y &lt;= 0) &amp; (yn &gt; 0) &amp; (x_pos &gt; 0)\n    down_crossing = (y &gt; 0) &amp; (yn &lt;= 0) &amp; (x_pos &lt; 0)\n\n    # reduce and return\n    return numpy.sum(up_crossing, axis=-1) - numpy.sum(down_crossing, axis=-1)\n</code></pre>"},{"location":"api/vec/#atomlib.vec.in_polygon","title":"<code>in_polygon(poly, pt=None, *, rule='evenodd')</code>","text":"<p>Return whether <code>pt</code> is in <code>poly</code>, under the given winding rule. In the one-argument form, return a closure which tests <code>poly</code> for the given point.</p> Source code in <code>atomlib/vec.py</code> <pre><code>def in_polygon(poly: numpy.ndarray, pt: t.Optional[numpy.ndarray] = None, *,\n               rule: WindingRule = 'evenodd') -&gt; t.Union[NDArray[numpy.bool_], t.Callable[[numpy.ndarray], NDArray[numpy.bool_]]]:\n    \"\"\"\n    Return whether `pt` is in `poly`, under the given winding rule.\n    In the one-argument form, return a closure which tests `poly` for the given point.\n    \"\"\"\n    if pt is None:\n        return lambda pt: in_polygon(poly, pt, rule=rule)\n    winding = polygon_winding(poly, pt)\n\n    rule = t.cast(WindingRule, rule.lower())\n    if rule == 'nonzero':\n        return winding.astype(numpy.bool_)\n    elif rule == 'evenodd':\n        return (winding &amp; 1) &gt; 0\n    elif rule == 'positive':\n        return winding &gt; 0\n    elif rule == 'negative':\n        return winding &lt; 0\n    raise ValueError(f\"Unknown winding rule '{rule}'. Expected one of \"\n                     \"'nonzero', 'evenodd', 'positive', or 'negative'.\")\n</code></pre>"},{"location":"api/vec/#atomlib.vec.reduce_vec","title":"<code>reduce_vec(arr, max_denom=10000)</code>","text":"<p>Reduce a crystallographic vector (int or float) to lowest common terms. Example: reduce_vec([3, 3, 3]) = [1, 1, 1] reduce_vec([0.25, 0.25, 0.25]) = [1, 1, 1]</p> Source code in <code>atomlib/vec.py</code> <pre><code>def reduce_vec(arr: ArrayLike, max_denom: int = 10000) -&gt; NDArray[numpy.int_]:\n    \"\"\"\n    Reduce a crystallographic vector (int or float) to lowest common terms.\n    Example: reduce_vec([3, 3, 3]) = [1, 1, 1]\n    reduce_vec([0.25, 0.25, 0.25]) = [1, 1, 1]\n    \"\"\"\n    a = numpy.atleast_1d(arr)\n    if not numpy.issubdtype(a.dtype, numpy.floating):\n        return a // numpy.gcd.reduce(a, axis=-1, keepdims=True)\n\n    a = a / numpy.max(numpy.abs(a))\n\n    n = numpy.empty(shape=a.shape, dtype=numpy.int64)\n    d = numpy.empty(shape=a.shape, dtype=numpy.int64)\n    with numpy.nditer([a, n, d], ['refs_ok'], [['readonly'], ['writeonly'], ['writeonly']]) as it:  # type: ignore\n        for (v, n_, d_) in it:\n            (n_[()], d_[()]) = Fraction(float(v)).limit_denominator(max_denom).as_integer_ratio()\n\n    # reduce to common denominator\n    factors = numpy.lcm.reduce(d, axis=-1, keepdims=True) // d\n    n *= factors\n    # and then reduce numerators\n    return n // numpy.gcd.reduce(n, axis=-1, keepdims=True)\n</code></pre>"},{"location":"api/vec/#atomlib.vec.miller_4_to_3_vec","title":"<code>miller_4_to_3_vec(a, reduce=True, max_denom=10000)</code>","text":"<p>Convert a vector in 4-axis Miller-Bravais notation to 3-axis Miller notation.</p> Source code in <code>atomlib/vec.py</code> <pre><code>def miller_4_to_3_vec(a: NDArray[numpy.number], reduce: bool = True, max_denom: int = 10000) -&gt; NDArray[numpy.number]:\n    \"\"\"Convert a vector in 4-axis Miller-Bravais notation to 3-axis Miller notation.\"\"\"\n    a = numpy.atleast_1d(a)\n    assert a.shape[-1] == 4\n    U, V, T, W = numpy.split(a, 4, axis=-1)\n    assert numpy.allclose(-T, U + V, equal_nan=True)\n    out = numpy.concatenate((2*U + V, 2*V + U, W), axis=-1)\n    return reduce_vec(out, max_denom) if reduce else out\n</code></pre>"},{"location":"api/vec/#atomlib.vec.miller_3_to_4_vec","title":"<code>miller_3_to_4_vec(a, reduce=True, max_denom=10000)</code>","text":"<p>Convert a vector in 3-axis Miller notation to 4-axis Miller-Bravais notation.</p> Source code in <code>atomlib/vec.py</code> <pre><code>def miller_3_to_4_vec(a: NDArray[numpy.number], reduce: bool = True, max_denom: int = 10000) -&gt; NDArray[numpy.number]:\n    \"\"\"Convert a vector in 3-axis Miller notation to 4-axis Miller-Bravais notation.\"\"\"\n    a = numpy.atleast_1d(a)\n    assert a.shape[-1] == 3\n    u, v, w = numpy.split(a, 3, axis=-1)\n    U = 2*u - v\n    V = 2*v - u\n    W = 3*w\n    out = numpy.concatenate((U, V, -(U + V), W), axis=-1)\n    return reduce_vec(out, max_denom) if reduce else out\n</code></pre>"},{"location":"api/vec/#atomlib.vec.miller_4_to_3_plane","title":"<code>miller_4_to_3_plane(a, reduce=True, max_denom=10000)</code>","text":"<p>Convert a plane in 4-axis Miller-Bravais notation to 3-axis Miller notation.</p> Source code in <code>atomlib/vec.py</code> <pre><code>def miller_4_to_3_plane(a: NDArray[numpy.number], reduce: bool = True, max_denom: int = 10000) -&gt; NDArray[numpy.number]:\n    \"\"\"Convert a plane in 4-axis Miller-Bravais notation to 3-axis Miller notation.\"\"\"\n    a = numpy.atleast_1d(a)\n    assert a.shape[-1] == 4\n    h, k, i, l = numpy.split(a, 4, axis=-1)\n    assert numpy.allclose(-i, h + k, equal_nan=True)\n    out = numpy.concatenate((h, k, l), axis=-1)\n    return reduce_vec(out, max_denom) if reduce else out\n</code></pre>"},{"location":"api/vec/#atomlib.vec.miller_3_to_4_plane","title":"<code>miller_3_to_4_plane(a, reduce=True, max_denom=10000)</code>","text":"<p>Convert a plane in 3-axis Miller notation to 4-axis Miller-Bravais notation.</p> Source code in <code>atomlib/vec.py</code> <pre><code>def miller_3_to_4_plane(a: NDArray[numpy.number], reduce: bool = True, max_denom: int = 10000) -&gt; NDArray[numpy.number]:\n    \"\"\"Convert a plane in 3-axis Miller notation to 4-axis Miller-Bravais notation.\"\"\"\n    a = numpy.atleast_1d(a)\n    assert a.shape[-1] == 3\n    h, k, l = numpy.split(a, 3, axis=-1)\n    out = numpy.concatenate((h, k, -(h + k), l), axis=-1)  # type: ignore\n    return reduce_vec(out, max_denom) if reduce else out\n</code></pre>"},{"location":"api/visualize/","title":"<code>atomlib.visualize</code>","text":"<p>Visualization of atomic structures. Useful for debugging.</p>"},{"location":"api/visualize/#atomlib.visualize.BackendName","title":"<code>BackendName = t.Literal['mpl', 'ase']</code>  <code>module-attribute</code>","text":""},{"location":"api/visualize/#atomlib.visualize.AtomStyle","title":"<code>AtomStyle = t.Literal['spacefill', 'ballstick', 'small']</code>  <code>module-attribute</code>","text":""},{"location":"api/visualize/#atomlib.visualize.AtomImage","title":"<code>AtomImage</code>","text":"<p>             Bases: <code>ABC</code></p> Source code in <code>atomlib/visualize/__init__.py</code> <pre><code>class AtomImage(ABC):\n    @abstractmethod\n    def save(self, f: FileOrPath):\n        ...\n</code></pre>"},{"location":"api/visualize/#atomlib.visualize.AtomImage.save","title":"<code>save(f)</code>  <code>abstractmethod</code>","text":"Source code in <code>atomlib/visualize/__init__.py</code> <pre><code>@abstractmethod\ndef save(self, f: FileOrPath):\n    ...\n</code></pre>"},{"location":"api/visualize/#atomlib.visualize.AtomImageMpl","title":"<code>AtomImageMpl</code>","text":"<p>             Bases: <code>Figure</code>, <code>AtomImage</code></p> Source code in <code>atomlib/visualize/__init__.py</code> <pre><code>class AtomImageMpl(Figure, AtomImage):\n    def __new__(cls, fig: Figure):\n        fig.__class__ = cls\n        return fig\n\n    def __init__(self, fig: Figure):\n        ...\n\n    def save(self, f: FileOrPath):\n        return self.savefig(f)  # type: ignore\n</code></pre>"},{"location":"api/visualize/#atomlib.visualize.AtomImageMpl.save","title":"<code>save(f)</code>","text":"Source code in <code>atomlib/visualize/__init__.py</code> <pre><code>def save(self, f: FileOrPath):\n    return self.savefig(f)  # type: ignore\n</code></pre>"},{"location":"api/visualize/#atomlib.visualize.show_atoms_3d","title":"<code>show_atoms_3d(atoms, *, zone=None, plane=None, backend='mpl', style='small', **kwargs)</code>","text":"Source code in <code>atomlib/visualize/__init__.py</code> <pre><code>def show_atoms_3d(atoms: HasAtoms, *,\n                  zone: t.Optional[VecLike] = None,\n                  plane: t.Optional[VecLike] = None,\n                  backend: BackendName = 'mpl',\n                  style: AtomStyle = 'small', **kwargs: t.Any) -&gt; AtomImage:\n    backend = t.cast(BackendName, backend.lower())\n    if backend == 'mpl':\n        return show_atoms_mpl_3d(atoms, zone=zone, plane=plane, style=style, **kwargs)\n    elif backend == 'ase':\n        raise NotImplementedError()\n\n    raise ValueError(f\"Unknown backend '{backend}'\")\n</code></pre>"},{"location":"api/visualize/#atomlib.visualize.show_atoms_2d","title":"<code>show_atoms_2d(atoms, *, zone=None, plane=None, horz=None, backend='mpl', style='small', **kwargs)</code>","text":"Source code in <code>atomlib/visualize/__init__.py</code> <pre><code>def show_atoms_2d(atoms: HasAtoms, *,\n                  zone: t.Optional[VecLike] = None,\n                  plane: t.Optional[VecLike] = None,\n                  horz: t.Optional[VecLike] = None,\n                  backend: BackendName = 'mpl',\n                  style: AtomStyle = 'small', **kwargs: t.Any) -&gt; AtomImage:\n    backend = t.cast(BackendName, backend.lower())\n    if backend == 'mpl':\n        return show_atoms_mpl_2d(atoms, zone=zone, plane=plane, horz=horz, style=style, **kwargs)\n    elif backend == 'ase':\n        raise NotImplementedError()\n\n    raise ValueError(f\"Unknown backend '{backend}'\")\n</code></pre>"},{"location":"api/visualize/#atomlib.visualize.get_elem_color","title":"<code>get_elem_color(elem)</code>","text":"Source code in <code>atomlib/visualize/__init__.py</code> <pre><code>def get_elem_color(elem: int) -&gt; t.List[int]:\n    # grey fallback\n    return _ELEM_MAP.get(elem, [80, 80, 80])\n</code></pre>"},{"location":"api/visualize/#atomlib.visualize.get_zone","title":"<code>get_zone(atoms, zone=None, plane=None, default=None)</code>","text":"Source code in <code>atomlib/visualize/__init__.py</code> <pre><code>def get_zone(atoms: HasAtoms, zone: t.Optional[VecLike] = None,\n             plane: t.Optional[VecLike] = None,\n             default: t.Optional[VecLike] = None) -&gt; NDArray[numpy.float_]:\n    if zone is not None and plane is not None:\n        raise ValueError(\"'zone' and 'plane' can't both be specified.\")\n    if plane is not None:\n        if isinstance(atoms, AtomCell) and not atoms.is_orthogonal():\n            # convert plane into zone\n            raise NotImplementedError()\n        zone = plane\n    if zone is not None:\n        return numpy.broadcast_to(zone, 3)\n    if default is not None:\n        return numpy.broadcast_to(default, 3)\n    return numpy.array([0., 0., 1.])\n</code></pre>"},{"location":"api/visualize/#atomlib.visualize.get_plot_radii","title":"<code>get_plot_radii(atoms, min_r=1.0, style='small')</code>","text":"Source code in <code>atomlib/visualize/__init__.py</code> <pre><code>def get_plot_radii(atoms: HasAtoms, min_r: t.Optional[float] = 1.0, style: AtomStyle = 'small') -&gt; NDArray[numpy.float_]:\n    radii = get_radius(atoms['elem']).to_numpy()\n    if style == 'small':\n        radii = radii * 0.6\n    elif style == 'ballstick':\n        radii = radii * 0.5\n    elif style == 'spacefill':\n        radii = radii * 1.0\n    else:\n        raise ValueError(f\"Unknown atom style '{style}'. Expected 'spacefill', 'ballstick', or 'small'.\")\n    if min_r is not None:\n        return numpy.maximum(min_r, radii)\n    return radii\n</code></pre>"},{"location":"api/visualize/#atomlib.visualize.get_azim_elev","title":"<code>get_azim_elev(zone)</code>","text":"Source code in <code>atomlib/visualize/__init__.py</code> <pre><code>def get_azim_elev(zone: VecLike) -&gt; t.Tuple[float, float]:\n    (a, b, c) = -to_vec3(zone)  # look down zone\n    l = numpy.sqrt(a**2 + b**2)\n    # todo: aren't these just arctan2s?\n    return (numpy.angle(a + b*1.j, deg=True), numpy.angle(l + c*1.j, deg=True))  # type: ignore\n</code></pre>"},{"location":"api/visualize/#atomlib.visualize.show_atoms_mpl_3d","title":"<code>show_atoms_mpl_3d(atoms, *, fig=None, zone=None, plane=None, min_r=1.0, style='small')</code>","text":"Source code in <code>atomlib/visualize/__init__.py</code> <pre><code>def show_atoms_mpl_3d(atoms: HasAtoms, *, fig: t.Optional[Figure] = None,\n                      zone: t.Optional[VecLike] = None,\n                      plane: t.Optional[VecLike] = None,\n                      min_r: t.Optional[float] = 1.0,\n                      style: AtomStyle = 'small') -&gt; AtomImageMpl:\n    fig = AtomImageMpl(fig or pyplot.figure())  # type: ignore\n\n    zone = get_zone(atoms, zone, plane, [1., 2., 4.])\n    (azim, elev) = get_azim_elev(zone)\n\n    rect = (0., 0., 1., 1.)\n    ax: Axes3D = fig.add_axes(rect, axes_class=Axes3D, proj_type='ortho', azim=azim, elev=elev)  # type: ignore\n    ax.grid(False)\n\n    bbox = atoms.bbox().pad(0.2)\n    ax.set_xlim3d(bbox.x)  # type: ignore\n    ax.set_ylim3d(bbox.y)  # type: ignore\n    ax.set_zlim3d(bbox.z)  # type: ignore\n    ax.set_box_aspect(bbox.size)\n\n    ax.set_xlabel('X')\n    ax.set_ylabel('Y')\n    ax.set_zlabel('Z')\n\n    frame = atoms.get_atoms('local')\n    #radii = get_plot_radii(atoms, min_r=min_r, style=style)\n    coords = frame.coords()\n    elem_colors = numpy.array(list(map(get_elem_color, frame['elem']))) / 255.\n    s = 100\n\n    if isinstance(atoms, HasCell):\n        # plot cell corners\n        corners = atoms.corners('global')\n        faces = [\n            numpy.array([\n                corners[(val*2**axis + v1*2**((axis+1) % 3) + v2*2**((axis+2) % 3))]\n                for (v1, v2) in [(0, 0), (0, 1), (1, 1), (1, 0), (0, 0)]\n            ])\n            for axis in (0, 1, 2)\n            for val in (0, 1)\n        ]\n        for face in faces:\n            ax.plot3D(*split_arr(face, axis=-1), '.-k', alpha=1, markersize=8)\n\n    ax.scatter(coords[:, 0], coords[:, 1], coords[:, 2], c=elem_colors, alpha=1, s=s)  # type: ignore\n\n    return t.cast(AtomImageMpl, fig)\n</code></pre>"},{"location":"api/visualize/#atomlib.visualize.show_atoms_mpl_2d","title":"<code>show_atoms_mpl_2d(atoms, *, fig=None, zone=None, plane=None, horz=None, min_r=1.0, style='small')</code>","text":"Source code in <code>atomlib/visualize/__init__.py</code> <pre><code>def show_atoms_mpl_2d(atoms: HasAtoms, *, fig: t.Optional[Figure] = None,\n                      zone: t.Optional[VecLike] = None,\n                      plane: t.Optional[VecLike] = None,\n                      horz: t.Optional[VecLike] = None,\n                      min_r: t.Optional[float] = 1.0,\n                      style: AtomStyle = 'small') -&gt; AtomImageMpl:\n    zone = get_zone(atoms, zone, plane, [0., 0., 1.])\n    fig = AtomImageMpl(fig or pyplot.figure())  # type: ignore\n\n    rect = (0.05, 0.05, 0.95, 0.95)\n    ax: Axes = fig.add_axes(rect)\n    ax.set_aspect('equal')\n\n    frame = atoms.get_atoms('local')\n    coords = frame.coords()\n    elem_colors = numpy.array(list(map(get_elem_color, frame['elem']))) / 255.\n    radii = get_plot_radii(frame, min_r=min_r, style=style)\n\n    # look down zone\n    transform = LinearTransform3D.align_to(zone, [0, 0, -1], horz, [1, 0, 0] if horz is not None else None)\n    bbox_2d = transform @ atoms.bbox()\n    coords = transform @ coords\n    # sort by z-order\n    sort = numpy.argsort(coords[..., 2])\n    coords = coords[sort]\n    elem_colors = elem_colors[sort]\n    radii = radii[sort]\n\n    ax.set_xbound(*bbox_2d.x)\n    ax.set_ybound(*bbox_2d.y)\n\n    # old plotting method\n    # ax.scatter(coords[:, 0], coords[:, 1], c=elem_colors, alpha=1., s=s)\n\n    ax.add_collection(EllipseCollection(\n        radii, radii, numpy.zeros_like(radii), units='xy', facecolors=elem_colors, ec='black',\n        offsets=coords[..., :2], offset_transform=ax.transData,\n    ))  # type: ignore (bad api typing)\n\n    return t.cast(AtomImageMpl, fig)\n</code></pre>"},{"location":"api/io/","title":"<code>atomlib.io</code>","text":""},{"location":"api/io/#atomlib.io.FileType","title":"<code>FileType = t.Literal['cif', 'xyz', 'xsf', 'cfg', 'lmp', 'mslice', 'qe']</code>  <code>module-attribute</code>","text":""},{"location":"api/io/#atomlib.io.ReadFunc","title":"<code>ReadFunc = t.Callable[[FileOrPath], HasAtoms]</code>  <code>module-attribute</code>","text":""},{"location":"api/io/#atomlib.io.WriteFunc","title":"<code>WriteFunc = t.Callable[[HasAtoms, FileOrPath], None]</code>  <code>module-attribute</code>","text":""},{"location":"api/io/#atomlib.io.CIF","title":"<code>CIF</code>  <code>dataclass</code>","text":"Source code in <code>atomlib/io/cif.py</code> <pre><code>@dataclass\nclass CIF:\n    data_blocks: t.Tuple[CIFDataBlock, ...]\n\n    def __post_init__(self):\n        # ensure that all data_blocks after the first have a name\n        for data_block in self.data_blocks[1:]:\n            if data_block.name is None:\n                data_block.name = \"\"\n\n    @staticmethod\n    def from_file(file: FileOrPath) -&gt; CIF:\n        return CIF(tuple(CIFDataBlock.from_file(file)))\n\n    def __len__(self) -&gt; int:\n        return self.data_blocks.__len__()\n\n    def get_block(self, block: t.Union[int, str]) -&gt; CIFDataBlock:\n        try:\n            if isinstance(block, int):\n                return self.data_blocks[block]\n            return next(b for b in self.data_blocks if b.name == block)\n        except (IndexError, StopIteration):\n            raise ValueError(f\"Couldn't find block '{block}' in CIF file. File has {len(self)} blocks.\")\n\n    def write(self, file: FileOrPath):\n        with open_file(file, 'w') as f:\n            print(f\"# generated by atomlib\", file=f, end=None)\n            for data_block in self.data_blocks:\n                print(file=f)\n                data_block._write(f)\n</code></pre>"},{"location":"api/io/#atomlib.io.CIF.data_blocks","title":"<code>data_blocks: t.Tuple[CIFDataBlock, ...]</code>  <code>instance-attribute</code>","text":""},{"location":"api/io/#atomlib.io.CIF.from_file","title":"<code>from_file(file)</code>  <code>staticmethod</code>","text":"Source code in <code>atomlib/io/cif.py</code> <pre><code>@staticmethod\ndef from_file(file: FileOrPath) -&gt; CIF:\n    return CIF(tuple(CIFDataBlock.from_file(file)))\n</code></pre>"},{"location":"api/io/#atomlib.io.CIF.get_block","title":"<code>get_block(block)</code>","text":"Source code in <code>atomlib/io/cif.py</code> <pre><code>def get_block(self, block: t.Union[int, str]) -&gt; CIFDataBlock:\n    try:\n        if isinstance(block, int):\n            return self.data_blocks[block]\n        return next(b for b in self.data_blocks if b.name == block)\n    except (IndexError, StopIteration):\n        raise ValueError(f\"Couldn't find block '{block}' in CIF file. File has {len(self)} blocks.\")\n</code></pre>"},{"location":"api/io/#atomlib.io.CIF.write","title":"<code>write(file)</code>","text":"Source code in <code>atomlib/io/cif.py</code> <pre><code>def write(self, file: FileOrPath):\n    with open_file(file, 'w') as f:\n        print(f\"# generated by atomlib\", file=f, end=None)\n        for data_block in self.data_blocks:\n            print(file=f)\n            data_block._write(f)\n</code></pre>"},{"location":"api/io/#atomlib.io.XYZ","title":"<code>XYZ</code>  <code>dataclass</code>","text":"Source code in <code>atomlib/io/xyz.py</code> <pre><code>@dataclass\nclass XYZ:\n    atoms: polars.DataFrame\n    comment: t.Optional[str] = None\n    params: t.Dict[str, str] = field(default_factory=dict)\n\n    @staticmethod\n    def from_atoms(atoms: HasAtoms) -&gt; XYZ:\n        params = {}\n        if isinstance(atoms, HasAtomCell):\n            coords = atoms.get_cell().to_ortho().to_linear().inner.ravel()\n            lattice_str = \" \".join((f\"{c:.8f}\" for c in coords))\n            params['Lattice'] = lattice_str\n\n            pbc_str = \" \".join(str(int(v)) for v in atoms.get_cell().pbc)\n            params['pbc'] = pbc_str\n\n        return XYZ(\n            atoms.get_atoms('local')._get_frame(),\n            params=params\n        )\n\n    @staticmethod\n    def from_file(file: FileOrPath) -&gt; XYZ:\n        logging.info(f\"Loading XYZ {file.name if hasattr(file, 'name') else file!r}...\")  # type: ignore\n\n        with open_file(file, 'r') as f:\n            try:\n                # TODO be more gracious about whitespace here\n                length = int(f.readline())\n            except ValueError:\n                raise ValueError(f\"Error parsing XYZ file: Invalid length\") from None\n            except IOError as e:\n                raise IOError(f\"Error parsing XYZ file: {e}\") from None\n\n            comment = f.readline().rstrip('\\n')\n            # TODO handle if there's not a gap here\n\n            try:\n                params = ExtXYZParser(comment).parse()\n            except ValueError:\n                params = None\n\n            schema = _get_columns_from_params(params)\n\n            df = parse_whitespace_separated(f, schema, start_line=1)\n\n            # map atomic numbers -&gt; symbols (on columns which are Int8)\n            df = df.with_columns(\n                get_sym(df.select(polars.col('symbol').cast(polars.Int8, strict=False)).to_series())\n                    .fill_null(df['symbol']).alias('symbol')\n            )\n            # ensure all symbols are recognizable (this will raise ValueError if not)\n            get_elem(df['symbol'])\n\n            if length &lt; len(df):\n                warnings.warn(f\"Warning: truncating structure of length {len(df)} \"\n                            f\"to match declared length of {length}\")\n                df = df[:length]\n            elif length &gt; len(df):\n                warnings.warn(f\"Warning: structure length {len(df)} doesn't match \"\n                            f\"declared length {length}.\\nData could be corrupted.\")\n\n            try:\n                params = ExtXYZParser(comment).parse()\n                return XYZ(df, comment, params)\n            except ValueError:\n                pass\n\n            return XYZ(df, comment)\n\n    def write(self, file: FileOrPath, fmt: XYZFormat = 'exyz'):\n        with open_file(file, 'w', newline='\\r\\n') as f:\n\n            f.write(f\"{len(self.atoms)}\\n\")\n            if len(self.params) &gt; 0 and fmt == 'exyz':\n                f.write(\" \".join(_param_strings(self.params)))\n            else:\n                f.write(self.comment or \"\")\n            f.write(\"\\n\")\n\n            # not my best work\n            col_space = (3, 12, 12, 12)\n            f.writelines(\n                \"\".join(\n                    f\"{val:&lt; {space}.8f}\" if isinstance(val, float) else f\"{val:&lt;{space}}\" for (val, space) in zip(_flatten(row), col_space)\n                ).strip() + '\\n' for row in self.atoms.select(('symbol', 'coords')).rows()\n            )\n\n    def cell_matrix(self) -&gt; t.Optional[NDArray[numpy.float_]]:\n        if (s := self.params.get('Lattice')) is None:\n            return None\n\n        try:\n            items = list(map(float, s.split()))\n            if not len(items) == 9:\n                raise ValueError(\"Invalid length\")\n            return numpy.array(items, dtype=numpy.float_).reshape((3, 3)).T\n        except ValueError:\n            warnings.warn(f\"Warning: Invalid format for key 'Lattice=\\\"{s}\\\"'\")\n        return None\n\n    def pbc(self) -&gt; t.Optional[NDArray[numpy.bool_]]:\n        if (s := self.params.get('pbc')) is None:\n            return None\n\n        val_map = {'0': False, 'f': False, '1': True, 't': True}\n        try:\n            items = [val_map[v.lower()] for v in s.split()]\n            if not len(items) == 3:\n                raise ValueError(\"Invalid length\")\n            return numpy.array(items, dtype=numpy.bool_)\n        except ValueError:\n            warnings.warn(f\"Warning: Invalid format for key 'pbc=\\\"{s}\\\"'\")\n        return None\n</code></pre>"},{"location":"api/io/#atomlib.io.XYZ.atoms","title":"<code>atoms: polars.DataFrame</code>  <code>instance-attribute</code>","text":""},{"location":"api/io/#atomlib.io.XYZ.comment","title":"<code>comment: t.Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/io/#atomlib.io.XYZ.params","title":"<code>params: t.Dict[str, str] = field(default_factory=dict)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/io/#atomlib.io.XYZ.from_atoms","title":"<code>from_atoms(atoms)</code>  <code>staticmethod</code>","text":"Source code in <code>atomlib/io/xyz.py</code> <pre><code>@staticmethod\ndef from_atoms(atoms: HasAtoms) -&gt; XYZ:\n    params = {}\n    if isinstance(atoms, HasAtomCell):\n        coords = atoms.get_cell().to_ortho().to_linear().inner.ravel()\n        lattice_str = \" \".join((f\"{c:.8f}\" for c in coords))\n        params['Lattice'] = lattice_str\n\n        pbc_str = \" \".join(str(int(v)) for v in atoms.get_cell().pbc)\n        params['pbc'] = pbc_str\n\n    return XYZ(\n        atoms.get_atoms('local')._get_frame(),\n        params=params\n    )\n</code></pre>"},{"location":"api/io/#atomlib.io.XYZ.from_file","title":"<code>from_file(file)</code>  <code>staticmethod</code>","text":"Source code in <code>atomlib/io/xyz.py</code> <pre><code>@staticmethod\ndef from_file(file: FileOrPath) -&gt; XYZ:\n    logging.info(f\"Loading XYZ {file.name if hasattr(file, 'name') else file!r}...\")  # type: ignore\n\n    with open_file(file, 'r') as f:\n        try:\n            # TODO be more gracious about whitespace here\n            length = int(f.readline())\n        except ValueError:\n            raise ValueError(f\"Error parsing XYZ file: Invalid length\") from None\n        except IOError as e:\n            raise IOError(f\"Error parsing XYZ file: {e}\") from None\n\n        comment = f.readline().rstrip('\\n')\n        # TODO handle if there's not a gap here\n\n        try:\n            params = ExtXYZParser(comment).parse()\n        except ValueError:\n            params = None\n\n        schema = _get_columns_from_params(params)\n\n        df = parse_whitespace_separated(f, schema, start_line=1)\n\n        # map atomic numbers -&gt; symbols (on columns which are Int8)\n        df = df.with_columns(\n            get_sym(df.select(polars.col('symbol').cast(polars.Int8, strict=False)).to_series())\n                .fill_null(df['symbol']).alias('symbol')\n        )\n        # ensure all symbols are recognizable (this will raise ValueError if not)\n        get_elem(df['symbol'])\n\n        if length &lt; len(df):\n            warnings.warn(f\"Warning: truncating structure of length {len(df)} \"\n                        f\"to match declared length of {length}\")\n            df = df[:length]\n        elif length &gt; len(df):\n            warnings.warn(f\"Warning: structure length {len(df)} doesn't match \"\n                        f\"declared length {length}.\\nData could be corrupted.\")\n\n        try:\n            params = ExtXYZParser(comment).parse()\n            return XYZ(df, comment, params)\n        except ValueError:\n            pass\n\n        return XYZ(df, comment)\n</code></pre>"},{"location":"api/io/#atomlib.io.XYZ.write","title":"<code>write(file, fmt='exyz')</code>","text":"Source code in <code>atomlib/io/xyz.py</code> <pre><code>def write(self, file: FileOrPath, fmt: XYZFormat = 'exyz'):\n    with open_file(file, 'w', newline='\\r\\n') as f:\n\n        f.write(f\"{len(self.atoms)}\\n\")\n        if len(self.params) &gt; 0 and fmt == 'exyz':\n            f.write(\" \".join(_param_strings(self.params)))\n        else:\n            f.write(self.comment or \"\")\n        f.write(\"\\n\")\n\n        # not my best work\n        col_space = (3, 12, 12, 12)\n        f.writelines(\n            \"\".join(\n                f\"{val:&lt; {space}.8f}\" if isinstance(val, float) else f\"{val:&lt;{space}}\" for (val, space) in zip(_flatten(row), col_space)\n            ).strip() + '\\n' for row in self.atoms.select(('symbol', 'coords')).rows()\n        )\n</code></pre>"},{"location":"api/io/#atomlib.io.XYZ.cell_matrix","title":"<code>cell_matrix()</code>","text":"Source code in <code>atomlib/io/xyz.py</code> <pre><code>def cell_matrix(self) -&gt; t.Optional[NDArray[numpy.float_]]:\n    if (s := self.params.get('Lattice')) is None:\n        return None\n\n    try:\n        items = list(map(float, s.split()))\n        if not len(items) == 9:\n            raise ValueError(\"Invalid length\")\n        return numpy.array(items, dtype=numpy.float_).reshape((3, 3)).T\n    except ValueError:\n        warnings.warn(f\"Warning: Invalid format for key 'Lattice=\\\"{s}\\\"'\")\n    return None\n</code></pre>"},{"location":"api/io/#atomlib.io.XYZ.pbc","title":"<code>pbc()</code>","text":"Source code in <code>atomlib/io/xyz.py</code> <pre><code>def pbc(self) -&gt; t.Optional[NDArray[numpy.bool_]]:\n    if (s := self.params.get('pbc')) is None:\n        return None\n\n    val_map = {'0': False, 'f': False, '1': True, 't': True}\n    try:\n        items = [val_map[v.lower()] for v in s.split()]\n        if not len(items) == 3:\n            raise ValueError(\"Invalid length\")\n        return numpy.array(items, dtype=numpy.bool_)\n    except ValueError:\n        warnings.warn(f\"Warning: Invalid format for key 'pbc=\\\"{s}\\\"'\")\n    return None\n</code></pre>"},{"location":"api/io/#atomlib.io.XSF","title":"<code>XSF</code>  <code>dataclass</code>","text":"Source code in <code>atomlib/io/xsf.py</code> <pre><code>@dataclass\nclass XSF:\n    periodicity: Periodicity = 'crystal'\n    primitive_cell: t.Optional[LinearTransform3D] = None\n    conventional_cell: t.Optional[LinearTransform3D] = None\n\n    prim_coords: t.Optional[polars.DataFrame] = None\n    conv_coords: t.Optional[polars.DataFrame] = None\n    atoms: t.Optional[polars.DataFrame] = None\n\n    def get_atoms(self) -&gt; polars.DataFrame:\n        if self.prim_coords is not None:\n            return self.prim_coords\n        if self.atoms is not None:\n            return self.atoms\n        if self.conv_coords is not None:\n            raise NotImplementedError()  # TODO untransform conv_coords by conventional_cell?\n        raise ValueError(\"No coordinates specified in XSF file.\")\n\n    def get_pbc(self) -&gt; NDArray[numpy.bool_]:\n        return _periodicity_to_pbc(self.periodicity)\n\n    @staticmethod\n    def from_cell(cell: HasAtomCell) -&gt; XSF:\n        ortho = cell.get_transform('local', 'cell_box').to_linear()\n        return XSF(\n            primitive_cell=ortho,\n            conventional_cell=ortho,\n            prim_coords=cell.get_atoms('linear').inner,\n            periodicity=_pbc_to_periodicity(cell.pbc)\n        )\n\n    @staticmethod\n    def from_atoms(atoms: HasAtoms) -&gt; XSF:\n        return XSF(\n            periodicity='molecule',\n            atoms=atoms.get_atoms('local').inner\n        )\n\n    @staticmethod\n    def from_file(file: FileOrPath) -&gt; XSF:\n        logging.info(f\"Loading XSF {file.name if hasattr(file, 'name') else file!r}...\")  # type: ignore\n        with open_file(file) as f:\n            return XSFParser(f).parse()\n\n    def __post_init__(self):\n        if self.prim_coords is None and self.conv_coords is None and self.atoms is None:\n            raise ValueError(\"Error: No coordinates are specified (atoms, primitive, or conventional).\")\n\n        if self.prim_coords is not None and self.conv_coords is not None:\n            logging.warn(\"Warning: Both 'primcoord' and 'convcoord' are specified. 'convcoord' will be ignored.\")\n        elif self.conv_coords is not None and self.conventional_cell is None:\n            raise ValueError(\"If 'convcoord' is specified, 'convvec' must be specified as well.\")\n\n        if self.periodicity == 'molecule':\n            if self.atoms is None:\n                raise ValueError(\"'atoms' must be specified for molecules.\")\n\n    def write(self, path: FileOrPath):\n        with open_file(path, 'w') as f:\n            print(self.periodicity.upper(), file=f)\n            if self.primitive_cell is not None:\n                print('PRIMVEC', file=f)\n                self._write_cell(f, self.primitive_cell)\n            if self.conventional_cell is not None:\n                print('CONVVEC', file=f)\n                self._write_cell(f, self.conventional_cell)\n            print(file=f)\n\n            if self.prim_coords is not None:\n                print(\"PRIMCOORD\", file=f)\n                print(f\"{len(self.prim_coords)} 1\", file=f)\n                self._write_coords(f, self.prim_coords)\n            if self.conv_coords is not None:\n                print(\"CONVCOORD\", file=f)\n                print(f\"{len(self.conv_coords)} 1\", file=f)\n                self._write_coords(f, self.conv_coords)\n            if self.atoms is not None:\n                print(\"ATOMS\", file=f)\n                self._write_coords(f, self.atoms)\n\n    def _write_cell(self, f: TextIOBase, cell: LinearTransform3D):\n        for row in cell.inner.T:\n            for val in row:\n                f.write(f\"{val:12.7f}\")\n            f.write('\\n')\n\n    def _write_coords(self, f: TextIOBase, coords: polars.DataFrame):\n        for (elem, [x, y, z]) in coords.select(['elem', 'coords']).rows():\n            print(f\"{elem:2d} {x:11.6f} {y:11.6f} {z:11.6f}\", file=f)\n        print(file=f)\n</code></pre>"},{"location":"api/io/#atomlib.io.XSF.periodicity","title":"<code>periodicity: Periodicity = 'crystal'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/io/#atomlib.io.XSF.primitive_cell","title":"<code>primitive_cell: t.Optional[LinearTransform3D] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/io/#atomlib.io.XSF.conventional_cell","title":"<code>conventional_cell: t.Optional[LinearTransform3D] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/io/#atomlib.io.XSF.prim_coords","title":"<code>prim_coords: t.Optional[polars.DataFrame] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/io/#atomlib.io.XSF.conv_coords","title":"<code>conv_coords: t.Optional[polars.DataFrame] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/io/#atomlib.io.XSF.atoms","title":"<code>atoms: t.Optional[polars.DataFrame] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/io/#atomlib.io.XSF.get_atoms","title":"<code>get_atoms()</code>","text":"Source code in <code>atomlib/io/xsf.py</code> <pre><code>def get_atoms(self) -&gt; polars.DataFrame:\n    if self.prim_coords is not None:\n        return self.prim_coords\n    if self.atoms is not None:\n        return self.atoms\n    if self.conv_coords is not None:\n        raise NotImplementedError()  # TODO untransform conv_coords by conventional_cell?\n    raise ValueError(\"No coordinates specified in XSF file.\")\n</code></pre>"},{"location":"api/io/#atomlib.io.XSF.get_pbc","title":"<code>get_pbc()</code>","text":"Source code in <code>atomlib/io/xsf.py</code> <pre><code>def get_pbc(self) -&gt; NDArray[numpy.bool_]:\n    return _periodicity_to_pbc(self.periodicity)\n</code></pre>"},{"location":"api/io/#atomlib.io.XSF.from_cell","title":"<code>from_cell(cell)</code>  <code>staticmethod</code>","text":"Source code in <code>atomlib/io/xsf.py</code> <pre><code>@staticmethod\ndef from_cell(cell: HasAtomCell) -&gt; XSF:\n    ortho = cell.get_transform('local', 'cell_box').to_linear()\n    return XSF(\n        primitive_cell=ortho,\n        conventional_cell=ortho,\n        prim_coords=cell.get_atoms('linear').inner,\n        periodicity=_pbc_to_periodicity(cell.pbc)\n    )\n</code></pre>"},{"location":"api/io/#atomlib.io.XSF.from_atoms","title":"<code>from_atoms(atoms)</code>  <code>staticmethod</code>","text":"Source code in <code>atomlib/io/xsf.py</code> <pre><code>@staticmethod\ndef from_atoms(atoms: HasAtoms) -&gt; XSF:\n    return XSF(\n        periodicity='molecule',\n        atoms=atoms.get_atoms('local').inner\n    )\n</code></pre>"},{"location":"api/io/#atomlib.io.XSF.from_file","title":"<code>from_file(file)</code>  <code>staticmethod</code>","text":"Source code in <code>atomlib/io/xsf.py</code> <pre><code>@staticmethod\ndef from_file(file: FileOrPath) -&gt; XSF:\n    logging.info(f\"Loading XSF {file.name if hasattr(file, 'name') else file!r}...\")  # type: ignore\n    with open_file(file) as f:\n        return XSFParser(f).parse()\n</code></pre>"},{"location":"api/io/#atomlib.io.XSF.write","title":"<code>write(path)</code>","text":"Source code in <code>atomlib/io/xsf.py</code> <pre><code>def write(self, path: FileOrPath):\n    with open_file(path, 'w') as f:\n        print(self.periodicity.upper(), file=f)\n        if self.primitive_cell is not None:\n            print('PRIMVEC', file=f)\n            self._write_cell(f, self.primitive_cell)\n        if self.conventional_cell is not None:\n            print('CONVVEC', file=f)\n            self._write_cell(f, self.conventional_cell)\n        print(file=f)\n\n        if self.prim_coords is not None:\n            print(\"PRIMCOORD\", file=f)\n            print(f\"{len(self.prim_coords)} 1\", file=f)\n            self._write_coords(f, self.prim_coords)\n        if self.conv_coords is not None:\n            print(\"CONVCOORD\", file=f)\n            print(f\"{len(self.conv_coords)} 1\", file=f)\n            self._write_coords(f, self.conv_coords)\n        if self.atoms is not None:\n            print(\"ATOMS\", file=f)\n            self._write_coords(f, self.atoms)\n</code></pre>"},{"location":"api/io/#atomlib.io.CFG","title":"<code>CFG</code>  <code>dataclass</code>","text":"Source code in <code>atomlib/io/cfg.py</code> <pre><code>@dataclass\nclass CFG:\n    atoms: polars.DataFrame\n\n    cell: LinearTransform3D\n    transform: t.Optional[LinearTransform3D] = None\n    eta: t.Optional[LinearTransform3D] = None\n\n    length_scale: t.Optional[float] = None\n    length_unit: t.Optional[str] = None\n    rate_scale: t.Optional[float] = None\n    rate_unit: t.Optional[str] = None\n\n    @staticmethod\n    def from_file(file: FileOrPath) -&gt; CFG:\n        with open_file(file, 'r') as f:\n            return CFGParser(f).parse()\n\n    @staticmethod\n    def from_atoms(atoms: HasAtoms) -&gt; CFG:\n        if isinstance(atoms, HasAtomCell):\n            cell = atoms.get_transform('cell_box').inverse().to_linear()\n            atoms = atoms.get_atoms('cell_box')\n        else:\n            cell = LinearTransform3D.identity()\n\n        # ensure we have masses and velocities\n        atoms = atoms.with_mass().with_velocity()\n        return CFG(atoms._get_frame(), cell, length_scale=1.0, length_unit=\"Angstrom\")\n\n    def write(self, file: FileOrPath):\n        with open_file(file, 'w', newline='\\r\\n') as f:\n            f.write(f\"Number of particles = {len(self.atoms)}\\n\")\n\n            if self.length_scale is not None:\n                unit = f\" [{self.length_unit}]\" if self.length_unit is not None else \"\"\n                f.write(f\"\\nA = {self.length_scale:.8}{unit}\\n\\n\")\n\n            cell = self.cell.inner\n            for (i, j) in product(range(3), repeat=2):\n                f.write(f\"H0({i+1},{j+1}) = {cell[j,i]:.8} A\\n\")\n\n            if self.transform is not None:\n                f.write(\"\\n\")\n                transform = self.transform.inner\n                for (i, j) in product(range(3), repeat=2):\n                    f.write(f\"Transform({i+1},{j+1}) = {transform[j,i]:.8}\\n\")\n\n            if self.eta is not None:\n                f.write(\"\\n\")\n                eta = self.eta.inner\n                for i in range(3):\n                    for j in range(i, 3):\n                        f.write(f\"eta({i+1},{j+1}) = {eta[j,i]:.8}\\n\")\n\n            if self.rate_scale is not None:\n                unit = f\" [{self.rate_unit}]\" if self.rate_unit is not None else \"\"\n                f.write(f\"\\nR = {self.rate_scale:.8}{unit}\\n\")\n\n            f.write(\"\\n\")\n            for row in self.atoms.select(('mass', 'symbol', 'coords', 'velocity')).rows():\n                (mass, sym, (x, y, z), (v_x, v_y, v_z)) = row\n                f.write(f\"{mass:.4f} {sym:&gt;2} {x:.8} {y:.8} {z:.8} {v_x:.8} {v_y:.8} {v_z:.8}\\n\")\n</code></pre>"},{"location":"api/io/#atomlib.io.CFG.atoms","title":"<code>atoms: polars.DataFrame</code>  <code>instance-attribute</code>","text":""},{"location":"api/io/#atomlib.io.CFG.cell","title":"<code>cell: LinearTransform3D</code>  <code>instance-attribute</code>","text":""},{"location":"api/io/#atomlib.io.CFG.transform","title":"<code>transform: t.Optional[LinearTransform3D] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/io/#atomlib.io.CFG.eta","title":"<code>eta: t.Optional[LinearTransform3D] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/io/#atomlib.io.CFG.length_scale","title":"<code>length_scale: t.Optional[float] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/io/#atomlib.io.CFG.length_unit","title":"<code>length_unit: t.Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/io/#atomlib.io.CFG.rate_scale","title":"<code>rate_scale: t.Optional[float] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/io/#atomlib.io.CFG.rate_unit","title":"<code>rate_unit: t.Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/io/#atomlib.io.CFG.from_file","title":"<code>from_file(file)</code>  <code>staticmethod</code>","text":"Source code in <code>atomlib/io/cfg.py</code> <pre><code>@staticmethod\ndef from_file(file: FileOrPath) -&gt; CFG:\n    with open_file(file, 'r') as f:\n        return CFGParser(f).parse()\n</code></pre>"},{"location":"api/io/#atomlib.io.CFG.from_atoms","title":"<code>from_atoms(atoms)</code>  <code>staticmethod</code>","text":"Source code in <code>atomlib/io/cfg.py</code> <pre><code>@staticmethod\ndef from_atoms(atoms: HasAtoms) -&gt; CFG:\n    if isinstance(atoms, HasAtomCell):\n        cell = atoms.get_transform('cell_box').inverse().to_linear()\n        atoms = atoms.get_atoms('cell_box')\n    else:\n        cell = LinearTransform3D.identity()\n\n    # ensure we have masses and velocities\n    atoms = atoms.with_mass().with_velocity()\n    return CFG(atoms._get_frame(), cell, length_scale=1.0, length_unit=\"Angstrom\")\n</code></pre>"},{"location":"api/io/#atomlib.io.CFG.write","title":"<code>write(file)</code>","text":"Source code in <code>atomlib/io/cfg.py</code> <pre><code>def write(self, file: FileOrPath):\n    with open_file(file, 'w', newline='\\r\\n') as f:\n        f.write(f\"Number of particles = {len(self.atoms)}\\n\")\n\n        if self.length_scale is not None:\n            unit = f\" [{self.length_unit}]\" if self.length_unit is not None else \"\"\n            f.write(f\"\\nA = {self.length_scale:.8}{unit}\\n\\n\")\n\n        cell = self.cell.inner\n        for (i, j) in product(range(3), repeat=2):\n            f.write(f\"H0({i+1},{j+1}) = {cell[j,i]:.8} A\\n\")\n\n        if self.transform is not None:\n            f.write(\"\\n\")\n            transform = self.transform.inner\n            for (i, j) in product(range(3), repeat=2):\n                f.write(f\"Transform({i+1},{j+1}) = {transform[j,i]:.8}\\n\")\n\n        if self.eta is not None:\n            f.write(\"\\n\")\n            eta = self.eta.inner\n            for i in range(3):\n                for j in range(i, 3):\n                    f.write(f\"eta({i+1},{j+1}) = {eta[j,i]:.8}\\n\")\n\n        if self.rate_scale is not None:\n            unit = f\" [{self.rate_unit}]\" if self.rate_unit is not None else \"\"\n            f.write(f\"\\nR = {self.rate_scale:.8}{unit}\\n\")\n\n        f.write(\"\\n\")\n        for row in self.atoms.select(('mass', 'symbol', 'coords', 'velocity')).rows():\n            (mass, sym, (x, y, z), (v_x, v_y, v_z)) = row\n            f.write(f\"{mass:.4f} {sym:&gt;2} {x:.8} {y:.8} {z:.8} {v_x:.8} {v_y:.8} {v_z:.8}\\n\")\n</code></pre>"},{"location":"api/io/#atomlib.io.LMP","title":"<code>LMP</code>  <code>dataclass</code>","text":"Source code in <code>atomlib/io/lmp.py</code> <pre><code>@dataclass\nclass LMP:\n    comment: t.Optional[str]\n    headers: t.Dict[str, t.Any]\n    sections: t.Tuple[LMPSection, ...]\n\n    def get_cell(self) -&gt; Cell:\n        dims = numpy.array([\n            self.headers.get(f\"{c}lo {c}hi\", (-0.5, 0.5))\n            for c in \"xyz\"\n        ])\n        origin = dims[:, 0]\n        tilts = self.headers.get(\"xy xz yz\", (0., 0., 0.))\n\n        ortho = numpy.diag(dims[:, 1] - dims[:, 0])\n        (ortho[0, 1], ortho[0, 2], ortho[1, 2]) = tilts\n\n        return Cell.from_ortho(LinearTransform3D(ortho).translate(origin))\n\n    def get_atoms(self, type_map: t.Optional[t.Dict[int, t.Union[str, int]]] = None) -&gt; AtomCell:\n        if type_map is not None:\n            try:\n                type_map_df = polars.DataFrame({\n                    'type': polars.Series(type_map.keys(), dtype=polars.Int32),\n                    'elem': polars.Series(list(map(get_elem, type_map.values())), dtype=polars.UInt8),\n                    'symbol': polars.Series([get_sym(v) if isinstance(v, int) else v for v in type_map.values()], dtype=polars.Utf8),\n                })\n            except ValueError as e:\n                raise ValueError(\"Invalid type map\") from e\n        else:\n            type_map_df = None\n\n        cell = self.get_cell()\n\n        def _apply_type_labels(df: polars.DataFrame, section_name: str, labels: t.Optional[polars.DataFrame] = None) -&gt; polars.DataFrame:\n            if labels is not None:\n                #df = df.with_columns(polars.col('type').replace(d, default=polars.col('type').cast(polars.Int32, strict=False), return_dtype=polars.Int32))\n                df = df.with_columns(polars.col('type').replace(labels['symbol'], labels['type'], default=polars.col('type').cast(polars.Int32, strict=False), return_dtype=polars.Int32))\n                if df['type'].is_null().any():\n                    raise ValueError(f\"While parsing section {section_name}: Unknown atom label or invalid atom type\")\n            try:\n                return df.with_columns(polars.col('type').cast(polars.Int32))\n            except polars.ComputeError:\n                raise ValueError(f\"While parsing section {section_name}: Invalid atom type(s)\")\n\n        atoms: t.Optional[polars.DataFrame] = None\n        labels: t.Optional[polars.DataFrame] = None\n        masses: t.Optional[polars.DataFrame] = None\n        velocities = None\n\n        for section in self.sections:\n            start_line = section.start_line + 1\n\n            if section.name == 'Atoms':\n                if section.style not in (None, 'atomic'):\n                    # TODO support other styles\n                    raise ValueError(f\"Only 'atomic' atom_style is supported, instead got '{section.style}'\")\n\n                atoms = parse_whitespace_separated(section.body, {\n                    'i': polars.Int64, 'type': polars.Utf8,\n                    'coords': polars.Array(polars.Float64, 3),\n                }, start_line=start_line)\n                atoms = _apply_type_labels(atoms, 'Atoms', labels)\n            elif section.name == 'Atom Type Labels':\n                labels = parse_whitespace_separated(section.body, {'type': polars.Int32, 'symbol': polars.Utf8}, start_line=start_line)\n            elif section.name == 'Masses':\n                masses = parse_whitespace_separated(section.body, {'type': polars.Utf8, 'mass': polars.Float64}, start_line=start_line)\n                masses = _apply_type_labels(masses, 'Masses', labels)\n            elif section.name == 'Velocities':\n                velocities = parse_whitespace_separated(section.body, {\n                    'i': polars.Int64, 'velocity': polars.Array(polars.Float64, 3),\n                }, start_line=start_line)\n\n        # now all 'type's should be in Int32\n\n        if atoms is None:\n            if self.headers['atoms'] &gt; 0:\n                raise ValueError(\"Missing required section 'Atoms'\")\n            return AtomCell(Atoms.empty(), cell=cell, frame='local')\n\n        # next we need to assign element symbols\n        # first, if type_map is specified, use that:\n        #if type_map_elem is not None and type_map_sym is not None:\n        if type_map_df is not None:\n            try:\n                atoms = checked_left_join(atoms, type_map_df, on='type')\n            except CheckedJoinError as e:\n                raise ValueError(f\"Missing type_map specification for atom type(s): {', '.join(map(repr, e.missing_keys))}\")\n        elif labels is not None:\n            try:\n                labels = labels.with_columns(get_elem(labels['symbol']))\n            except ValueError as e:\n                raise ValueError(\"Failed to auto-detect elements from type labels. Please pass 'type_map' explicitly\") from e\n            try:\n                atoms = checked_left_join(atoms, labels, 'type')\n            except CheckedJoinError as e:\n                raise ValueError(f\"Missing labels for atom type(s): {', '.join(map(repr, e.missing_keys))}\")\n        # otherwise we have no way\n        else:\n            raise ValueError(\"Failed to auto-detect elements from type labels. Please pass 'type_map' explicitly\")\n\n        if velocities is not None:\n            # join velocities\n            try:\n                # TODO use join_asof here?\n                atoms = checked_left_join(atoms, velocities, 'i')\n            except CheckedJoinError as e:\n                raise ValueError(f\"Missing velocities for {len(e.missing_keys)}/{len(atoms)} atoms\")\n\n        if masses is not None:\n            # join masses\n            try:\n                atoms = checked_left_join(atoms, masses, 'type')\n            except CheckedJoinError as e:\n                raise ValueError(f\"Missing masses for atom type(s): {', '.join(map(repr, e.missing_keys))}\")\n\n        return AtomCell(atoms, cell=cell, frame='local')\n\n    @staticmethod\n    def from_atoms(atoms: HasAtoms) -&gt; LMP:\n        if isinstance(atoms, HasAtomCell):\n            # we're basically converting everything to the ortho frame, but including the affine shift\n\n            # transform affine shift into ortho frame\n            origin = atoms.get_transform('ortho', 'local').to_linear().round_near_zero() \\\n                .transform(atoms.get_cell().affine.translation())\n\n            # get the orthogonalization transform only, without affine\n            ortho = atoms.get_transform('ortho', 'cell_box').to_linear().round_near_zero().inner\n\n            # get atoms in ortho frame, and then add the affine shift\n            frame = atoms.get_atoms('ortho').transform_atoms(AffineTransform3D.translate(origin)) \\\n                .round_near_zero().with_type()\n        else:\n            bbox = atoms.bbox_atoms()\n            ortho = numpy.diag(bbox.size)\n            origin = bbox.min\n\n            frame = atoms.get_atoms('local').with_type()\n\n        types = frame.unique(subset='type')\n        types = types.with_mass().sort('type')\n\n        now = localtime()\n        comment = f\"# Generated by atomlib on {now.isoformat(' ', 'seconds')}\"\n\n        headers = {}\n        sections = []\n\n        headers['atoms'] = len(frame)\n        headers['atom types'] = len(types)\n\n        for (s, low, diff) in zip(('x', 'y', 'z'), origin, ortho.diagonal()):\n            headers[f\"{s}lo {s}hi\"] = (low, low + diff)\n\n        headers['xy xz yz'] = (ortho[0, 1], ortho[0, 2], ortho[1, 2])\n\n        body = [\n            f\" {ty:8} {sym:&gt;4}\\n\"\n            for (ty, sym) in types.select('type', 'symbol').rows()\n        ]\n        sections.append(LMPSection(\"Atom Type Labels\", tuple(body)))\n\n        if 'mass' in types:\n            body = [\n                f\" {ty:8} {mass:14.7f}  # {sym}\\n\"\n                for (ty, sym, mass) in types.select(('type', 'symbol', 'mass')).rows()\n            ]\n            sections.append(LMPSection(\"Masses\", tuple(body)))\n\n        body = [\n            f\" {i+1:8} {ty:4} {x:14.7f} {y:14.7f} {z:14.7f}\\n\"\n            for (i, (ty, (x, y, z))) in enumerate(frame.select(('type', 'coords')).rows())\n        ]\n        sections.append(LMPSection(\"Atoms\", tuple(body), 'atomic'))\n\n        if (velocities := frame.velocities()) is not None:\n            body = [\n                f\" {i+1:8} {v_x:14.7f} {v_y:14.7f} {v_z:14.7f}\\n\"\n                for (i, (v_x, v_y, v_z)) in enumerate(velocities)\n            ]\n            sections.append(LMPSection(\"Velocities\", tuple(body)))\n\n        return LMP(comment, headers, tuple(sections))\n\n    @staticmethod\n    def from_file(file: FileOrPath) -&gt; LMP:\n        with open_file(file, 'r') as f:\n            return LMPReader(f).parse()\n\n    def write(self, file: FileOrPath):\n        with open_file(file, 'w') as f:\n            print((self.comment or \"\") + '\\n', file=f)\n\n            # print headers\n            for (name, val) in self.headers.items():\n                val = _HEADER_FMT.get(name, lambda s: f\"{s:8}\")(val)\n                print(f\" {val} {name}\", file=f)\n\n            # print sections\n            for section in self.sections:\n                l = section.name\n                if section.style is not None:\n                    l += f'  # {section.style}'\n                print(f\"\\n{l}\\n\", file=f)\n\n                f.writelines(section.body)\n</code></pre>"},{"location":"api/io/#atomlib.io.LMP.comment","title":"<code>comment: t.Optional[str]</code>  <code>instance-attribute</code>","text":""},{"location":"api/io/#atomlib.io.LMP.headers","title":"<code>headers: t.Dict[str, t.Any]</code>  <code>instance-attribute</code>","text":""},{"location":"api/io/#atomlib.io.LMP.sections","title":"<code>sections: t.Tuple[LMPSection, ...]</code>  <code>instance-attribute</code>","text":""},{"location":"api/io/#atomlib.io.LMP.get_cell","title":"<code>get_cell()</code>","text":"Source code in <code>atomlib/io/lmp.py</code> <pre><code>def get_cell(self) -&gt; Cell:\n    dims = numpy.array([\n        self.headers.get(f\"{c}lo {c}hi\", (-0.5, 0.5))\n        for c in \"xyz\"\n    ])\n    origin = dims[:, 0]\n    tilts = self.headers.get(\"xy xz yz\", (0., 0., 0.))\n\n    ortho = numpy.diag(dims[:, 1] - dims[:, 0])\n    (ortho[0, 1], ortho[0, 2], ortho[1, 2]) = tilts\n\n    return Cell.from_ortho(LinearTransform3D(ortho).translate(origin))\n</code></pre>"},{"location":"api/io/#atomlib.io.LMP.get_atoms","title":"<code>get_atoms(type_map=None)</code>","text":"Source code in <code>atomlib/io/lmp.py</code> <pre><code>def get_atoms(self, type_map: t.Optional[t.Dict[int, t.Union[str, int]]] = None) -&gt; AtomCell:\n    if type_map is not None:\n        try:\n            type_map_df = polars.DataFrame({\n                'type': polars.Series(type_map.keys(), dtype=polars.Int32),\n                'elem': polars.Series(list(map(get_elem, type_map.values())), dtype=polars.UInt8),\n                'symbol': polars.Series([get_sym(v) if isinstance(v, int) else v for v in type_map.values()], dtype=polars.Utf8),\n            })\n        except ValueError as e:\n            raise ValueError(\"Invalid type map\") from e\n    else:\n        type_map_df = None\n\n    cell = self.get_cell()\n\n    def _apply_type_labels(df: polars.DataFrame, section_name: str, labels: t.Optional[polars.DataFrame] = None) -&gt; polars.DataFrame:\n        if labels is not None:\n            #df = df.with_columns(polars.col('type').replace(d, default=polars.col('type').cast(polars.Int32, strict=False), return_dtype=polars.Int32))\n            df = df.with_columns(polars.col('type').replace(labels['symbol'], labels['type'], default=polars.col('type').cast(polars.Int32, strict=False), return_dtype=polars.Int32))\n            if df['type'].is_null().any():\n                raise ValueError(f\"While parsing section {section_name}: Unknown atom label or invalid atom type\")\n        try:\n            return df.with_columns(polars.col('type').cast(polars.Int32))\n        except polars.ComputeError:\n            raise ValueError(f\"While parsing section {section_name}: Invalid atom type(s)\")\n\n    atoms: t.Optional[polars.DataFrame] = None\n    labels: t.Optional[polars.DataFrame] = None\n    masses: t.Optional[polars.DataFrame] = None\n    velocities = None\n\n    for section in self.sections:\n        start_line = section.start_line + 1\n\n        if section.name == 'Atoms':\n            if section.style not in (None, 'atomic'):\n                # TODO support other styles\n                raise ValueError(f\"Only 'atomic' atom_style is supported, instead got '{section.style}'\")\n\n            atoms = parse_whitespace_separated(section.body, {\n                'i': polars.Int64, 'type': polars.Utf8,\n                'coords': polars.Array(polars.Float64, 3),\n            }, start_line=start_line)\n            atoms = _apply_type_labels(atoms, 'Atoms', labels)\n        elif section.name == 'Atom Type Labels':\n            labels = parse_whitespace_separated(section.body, {'type': polars.Int32, 'symbol': polars.Utf8}, start_line=start_line)\n        elif section.name == 'Masses':\n            masses = parse_whitespace_separated(section.body, {'type': polars.Utf8, 'mass': polars.Float64}, start_line=start_line)\n            masses = _apply_type_labels(masses, 'Masses', labels)\n        elif section.name == 'Velocities':\n            velocities = parse_whitespace_separated(section.body, {\n                'i': polars.Int64, 'velocity': polars.Array(polars.Float64, 3),\n            }, start_line=start_line)\n\n    # now all 'type's should be in Int32\n\n    if atoms is None:\n        if self.headers['atoms'] &gt; 0:\n            raise ValueError(\"Missing required section 'Atoms'\")\n        return AtomCell(Atoms.empty(), cell=cell, frame='local')\n\n    # next we need to assign element symbols\n    # first, if type_map is specified, use that:\n    #if type_map_elem is not None and type_map_sym is not None:\n    if type_map_df is not None:\n        try:\n            atoms = checked_left_join(atoms, type_map_df, on='type')\n        except CheckedJoinError as e:\n            raise ValueError(f\"Missing type_map specification for atom type(s): {', '.join(map(repr, e.missing_keys))}\")\n    elif labels is not None:\n        try:\n            labels = labels.with_columns(get_elem(labels['symbol']))\n        except ValueError as e:\n            raise ValueError(\"Failed to auto-detect elements from type labels. Please pass 'type_map' explicitly\") from e\n        try:\n            atoms = checked_left_join(atoms, labels, 'type')\n        except CheckedJoinError as e:\n            raise ValueError(f\"Missing labels for atom type(s): {', '.join(map(repr, e.missing_keys))}\")\n    # otherwise we have no way\n    else:\n        raise ValueError(\"Failed to auto-detect elements from type labels. Please pass 'type_map' explicitly\")\n\n    if velocities is not None:\n        # join velocities\n        try:\n            # TODO use join_asof here?\n            atoms = checked_left_join(atoms, velocities, 'i')\n        except CheckedJoinError as e:\n            raise ValueError(f\"Missing velocities for {len(e.missing_keys)}/{len(atoms)} atoms\")\n\n    if masses is not None:\n        # join masses\n        try:\n            atoms = checked_left_join(atoms, masses, 'type')\n        except CheckedJoinError as e:\n            raise ValueError(f\"Missing masses for atom type(s): {', '.join(map(repr, e.missing_keys))}\")\n\n    return AtomCell(atoms, cell=cell, frame='local')\n</code></pre>"},{"location":"api/io/#atomlib.io.LMP.from_atoms","title":"<code>from_atoms(atoms)</code>  <code>staticmethod</code>","text":"Source code in <code>atomlib/io/lmp.py</code> <pre><code>@staticmethod\ndef from_atoms(atoms: HasAtoms) -&gt; LMP:\n    if isinstance(atoms, HasAtomCell):\n        # we're basically converting everything to the ortho frame, but including the affine shift\n\n        # transform affine shift into ortho frame\n        origin = atoms.get_transform('ortho', 'local').to_linear().round_near_zero() \\\n            .transform(atoms.get_cell().affine.translation())\n\n        # get the orthogonalization transform only, without affine\n        ortho = atoms.get_transform('ortho', 'cell_box').to_linear().round_near_zero().inner\n\n        # get atoms in ortho frame, and then add the affine shift\n        frame = atoms.get_atoms('ortho').transform_atoms(AffineTransform3D.translate(origin)) \\\n            .round_near_zero().with_type()\n    else:\n        bbox = atoms.bbox_atoms()\n        ortho = numpy.diag(bbox.size)\n        origin = bbox.min\n\n        frame = atoms.get_atoms('local').with_type()\n\n    types = frame.unique(subset='type')\n    types = types.with_mass().sort('type')\n\n    now = localtime()\n    comment = f\"# Generated by atomlib on {now.isoformat(' ', 'seconds')}\"\n\n    headers = {}\n    sections = []\n\n    headers['atoms'] = len(frame)\n    headers['atom types'] = len(types)\n\n    for (s, low, diff) in zip(('x', 'y', 'z'), origin, ortho.diagonal()):\n        headers[f\"{s}lo {s}hi\"] = (low, low + diff)\n\n    headers['xy xz yz'] = (ortho[0, 1], ortho[0, 2], ortho[1, 2])\n\n    body = [\n        f\" {ty:8} {sym:&gt;4}\\n\"\n        for (ty, sym) in types.select('type', 'symbol').rows()\n    ]\n    sections.append(LMPSection(\"Atom Type Labels\", tuple(body)))\n\n    if 'mass' in types:\n        body = [\n            f\" {ty:8} {mass:14.7f}  # {sym}\\n\"\n            for (ty, sym, mass) in types.select(('type', 'symbol', 'mass')).rows()\n        ]\n        sections.append(LMPSection(\"Masses\", tuple(body)))\n\n    body = [\n        f\" {i+1:8} {ty:4} {x:14.7f} {y:14.7f} {z:14.7f}\\n\"\n        for (i, (ty, (x, y, z))) in enumerate(frame.select(('type', 'coords')).rows())\n    ]\n    sections.append(LMPSection(\"Atoms\", tuple(body), 'atomic'))\n\n    if (velocities := frame.velocities()) is not None:\n        body = [\n            f\" {i+1:8} {v_x:14.7f} {v_y:14.7f} {v_z:14.7f}\\n\"\n            for (i, (v_x, v_y, v_z)) in enumerate(velocities)\n        ]\n        sections.append(LMPSection(\"Velocities\", tuple(body)))\n\n    return LMP(comment, headers, tuple(sections))\n</code></pre>"},{"location":"api/io/#atomlib.io.LMP.from_file","title":"<code>from_file(file)</code>  <code>staticmethod</code>","text":"Source code in <code>atomlib/io/lmp.py</code> <pre><code>@staticmethod\ndef from_file(file: FileOrPath) -&gt; LMP:\n    with open_file(file, 'r') as f:\n        return LMPReader(f).parse()\n</code></pre>"},{"location":"api/io/#atomlib.io.LMP.write","title":"<code>write(file)</code>","text":"Source code in <code>atomlib/io/lmp.py</code> <pre><code>def write(self, file: FileOrPath):\n    with open_file(file, 'w') as f:\n        print((self.comment or \"\") + '\\n', file=f)\n\n        # print headers\n        for (name, val) in self.headers.items():\n            val = _HEADER_FMT.get(name, lambda s: f\"{s:8}\")(val)\n            print(f\" {val} {name}\", file=f)\n\n        # print sections\n        for section in self.sections:\n            l = section.name\n            if section.style is not None:\n                l += f'  # {section.style}'\n            print(f\"\\n{l}\\n\", file=f)\n\n            f.writelines(section.body)\n</code></pre>"},{"location":"api/io/#atomlib.io.write_mslice","title":"<code>write_mslice(cell, f, template=None, *, slice_thickness=None, scan_points=None, scan_extent=None, noise_sigma=None, conv_angle=None, energy=None, defocus=None, tilt=None, tds=None, n_cells=None)</code>","text":"<p>Write a structure to an mslice file. The structure must be orthogonal and aligned with the local coordinate system. It should be periodic in X and Y.</p> <p><code>template</code> may be a file, path, or ElementTree containing an existing mslice file. Its structure will be modified to make the final output. If not specified, a default template will be used.</p> <p>Additional options modify simulation properties. If an option is not specified, the template's properties are used.</p> Source code in <code>atomlib/io/mslice.py</code> <pre><code>def write_mslice(cell: HasAtomCell, f: BinaryFileOrPath, template: t.Optional[MSliceFile] = None, *,\n                 slice_thickness: t.Optional[float] = None,  # angstrom\n                 scan_points: t.Optional[ArrayLike] = None,\n                 scan_extent: t.Optional[ArrayLike] = None,\n                 noise_sigma: t.Optional[float] = None,  # angstrom\n                 conv_angle: t.Optional[float] = None,  # mrad\n                 energy: t.Optional[float] = None,  # keV\n                 defocus: t.Optional[float] = None,  # angstrom\n                 tilt: t.Optional[t.Tuple[float, float]] = None,  # (mrad, mrad)\n                 tds: t.Optional[bool] = None,\n                 n_cells: t.Optional[ArrayLike] = None):\n    \"\"\"\n    Write a structure to an mslice file. The structure must be orthogonal and aligned\n    with the local coordinate system. It should be periodic in X and Y.\n\n    ``template`` may be a file, path, or ElementTree containing an existing mslice file.\n    Its structure will be modified to make the final output. If not specified, a default\n    template will be used.\n\n    Additional options modify simulation properties. If an option is not specified, the\n    template's properties are used.\n    \"\"\"\n    #if not issubclass(type(cell), HasAtomCell):\n    #    raise TypeError(\"mslice format requires an AtomCell.\")\n\n    if not cell.is_orthogonal_in_local():\n        raise ValueError(\"mslice requires an orthogonal AtomCell.\")\n\n    if not numpy.all(cell.pbc[:2]):\n        warn(\"AtomCell may not be periodic\", UserWarning, stacklevel=2)\n\n    box_size = cell._box_size_in_local()\n\n    # get atoms in local frame (which we verified aligns with the cell's axes)\n    # then scale into fractional coordinates\n    atoms = cell.get_atoms('linear') \\\n        .transform(AffineTransform3D.scale(1/box_size)) \\\n        .with_wobble().with_occupancy()\n\n    out: ElementTree\n    if template is None:\n        out = default_template()\n    elif not isinstance(template, ElementTree):\n        with open_file(template, 'r') as temp:\n            out = et.parse(temp, None)\n    else:\n        out = deepcopy(template)\n\n    # TODO clean up this code\n    db: t.Optional[Element] = out.getroot() if out.getroot().tag == 'database' else out.find(\"./database\", None)\n    if db is None:\n        raise ValueError(\"Couldn't find 'database' tag in template.\")\n\n    struct = db.find(\".//object[@type='STRUCTURE']\", None)\n    if struct is None:\n        raise ValueError(\"Couldn't find STRUCTURE object in template.\")\n\n    params = db.find(\".//object[@type='SIMPARAMETERS']\", None)\n    if params is None:\n        raise ValueError(\"Couldn't find SIMPARAMETERS object in template.\")\n\n    microscope = db.find(\".//object[@type='MICROSCOPE']\", None)\n    if microscope is None:\n        raise ValueError(\"Couldn't find MICROSCOPE object in template.\")\n\n    scan = db.find(\".//object[@type='SCAN']\", None)\n    aberrations = db.findall(\".//object[@type='ABERRATION']\", None)\n\n    def set_attr(struct: Element, name: str, type: str, val: str):\n        node = t.cast(t.Optional[Element], struct.find(f\".//attribute[@name='{name}']\", None))\n        if node is None:\n            node = t.cast(Element, et.Element('attribute', dict(name=name, type=type), None))\n            struct.append(node)\n        else:\n            node.attrib['type'] = type\n        node.text = val  # type: ignore\n\n    def parse_xml_object(obj: Element) -&gt; t.Dict[str, t.Any]:\n        \"\"\"Parse the attributes of a passed XML object.\"\"\"\n        params = {}\n        for attr in obj.iterchildren(None):\n            if attr.tag == 'attribute':\n                params[attr.attrib['name']] = convert_xml_value(attr.text, attr.attrib['type'])\n            elif attr.tag == 'relationship':\n                # todo give this a better API\n                if 'idrefs' in attr.attrib:\n                    params[f\"{attr.attrib['name']}ID\"] = attr.attrib['idrefs']\n        return params\n\n    # TODO how to store atoms in unexploded form\n    (n_a, n_b, n_c) = map(str, (1, 1, 1) if n_cells is None else numpy.asarray(n_cells).astype(int))\n    set_attr(struct, 'repeata', 'int16', n_a)\n    set_attr(struct, 'repeatb', 'int16', n_b)\n    set_attr(struct, 'repeatc', 'int16', n_c)\n\n    (a, b, c) = map(lambda v: f\"{v:.8g}\", box_size)\n    set_attr(struct, 'aparam', 'float', a)\n    set_attr(struct, 'bparam', 'float', b)\n    set_attr(struct, 'cparam', 'float', c)\n\n    if tilt is not None:\n        (tiltx, tilty) = tilt\n        set_attr(struct, 'tiltx', 'float', f\"{tiltx:.4g}\")\n        set_attr(struct, 'tilty', 'float', f\"{tilty:.4g}\")\n\n    if slice_thickness is not None:\n        set_attr(params, 'slicethickness', 'float', f\"{float(slice_thickness):.8g}\")\n    if tds is not None:\n        set_attr(params, 'includetds', 'bool', str(int(bool(tds))))\n    if conv_angle is not None:\n        set_attr(microscope, 'aperture', 'float', f\"{float(conv_angle):.8g}\")\n    if energy is not None:\n        set_attr(microscope, 'kv', 'float', f\"{float(energy):.8g}\")\n    if noise_sigma is not None:\n        if scan is None:\n            raise ValueError(\"New scan specification required for 'noise_sigma'.\")\n        set_attr(scan, 'noise_sigma', 'float', f\"{float(noise_sigma):.8g}\")\n\n    if defocus is not None:\n        for aberration in aberrations:\n            obj = parse_xml_object(aberration)\n            if obj['n'] == 1 and obj['m'] == 0:\n                set_attr(aberration, 'cnma', 'float', f\"{float(defocus):.8g}\")  # A, + is over\n                set_attr(aberration, 'cnmb', 'float', \"0.0\")\n                break\n        else:\n            raise ValueError(\"Couldn't find defocus aberration to modify.\")\n\n    if scan_points is not None:\n        (nx, ny) = numpy.broadcast_to(scan_points, 2,).astype(int)\n        if scan is not None:\n            set_attr(scan, 'nx', 'int16', str(nx))\n            set_attr(scan, 'ny', 'int16', str(ny))\n        else:\n            set_attr(params, 'numscanx', 'int16', str(nx))\n            set_attr(params, 'numscany', 'int16', str(ny))\n\n    if scan_extent is not None:\n        scan_extent = numpy.asarray(scan_extent, dtype=float)\n        try:\n            if scan_extent.ndim &lt; 2:\n                if not scan_extent.shape == (4,):\n                    scan_extent = numpy.broadcast_to(scan_extent, (2,))\n                    scan_extent = numpy.stack(((0., 0.), scan_extent), axis=-1)\n            else:\n                scan_extent = numpy.broadcast_to(scan_extent, (2, 2))\n        except ValueError as e:\n            raise ValueError(f\"Invalid scan_extent '{scan_extent}'. Expected an array of shape (2,), (4,), or (2, 2).\") from e\n\n        if scan is not None:\n            names = ('x_i', 'x_f', 'y_i', 'y_f')\n            elem = scan\n        else:\n            names = ('intx', 'finx', 'inty', 'finy')\n            elem = params\n\n        for (name, val) in zip(names, scan_extent.ravel()):\n            set_attr(elem, name, 'float', f\"{float(val):.8g}\")\n\n    # remove existing atoms\n    for elem in db.findall(\"./object[@type='STRUCTUREATOM']\", None):\n        db.remove(elem)\n\n    # &lt;u^2&gt; -&gt; 1d sigma\n    atoms = atoms.with_wobble((polars.col('wobble') / 3.).sqrt())\n    rows = atoms.select(('elem', 'coords', 'wobble', 'frac_occupancy')).rows()\n    for (i, (elem, (x, y, z), wobble, frac_occupancy)) in enumerate(rows):\n        e = _atom_elem(i, elem, x, y, z, wobble, frac_occupancy)\n        db.append(e)\n\n    et.indent(db, space=\"    \", level=0)  # type: ignore\n\n    with open_file_binary(f, 'w') as f:\n        doctype = b\"\"\"&lt;!DOCTYPE database SYSTEM \"file:///System/Library/DTDs/CoreData.dtd\"&gt;\\n\"\"\"\n        out.write(f, encoding='UTF-8', xml_declaration=True, standalone=True, doctype=doctype)  # type: ignore\n        f.write(b'\\n')\n</code></pre>"},{"location":"api/io/#atomlib.io.write_qe","title":"<code>write_qe(atomcell, f, pseudo=None)</code>","text":"Source code in <code>atomlib/io/qe.py</code> <pre><code>def write_qe(atomcell: HasAtomCell, f: FileOrPath, pseudo: t.Optional[t.Mapping[str, str]] = None):\n    if not isinstance(atomcell, HasAtomCell):\n        raise TypeError(\"'qe' format requires an AtomCell.\")\n\n    atoms = atomcell.wrap().get_atoms('cell_frac').with_mass()\n\n    types = atoms.select(('symbol', 'mass')).unique(subset='symbol').sort('mass')\n    if pseudo is not None:\n        types = types.with_columns(polars.col('symbol').cast(polars.Utf8).map_dict(dict(pseudo), return_dtype=polars.Utf8).alias('pot'))\n    else:\n        types = types.with_columns(polars.col('symbol').apply(lambda sym: f\"{sym}.UPF\").alias('pot'))\n\n    with open_file(f, 'w') as f:\n        print(f\"&amp;SYSTEM ibrav=0 nat={len(atoms)} ntyp={len(types)}\", file=f)\n\n        ortho = atomcell.get_transform('local', 'cell_box').to_linear().inner\n        print(f\"\\nCELL_PARAMETERS angstrom\", file=f)\n        for row in ortho.T:\n            print(f\"  {row[0]:12.8f} {row[1]:12.8f} {row[2]:12.8f}\", file=f)\n\n        print(f\"\\nATOMIC_SPECIES\", file=f)\n        for (symbol, mass, pot) in types.select(('symbol', 'mass', 'pot')).rows():\n            print(f\"{symbol:&gt;4} {mass:10.3f}  {pot}\", file=f)\n\n        print(f\"\\nATOMIC_POSITIONS crystal\", file=f)\n        for (symbol, (x, y, z)) in atoms.select(('symbol', 'coords')).rows():\n            print(f\"{symbol:&gt;4} {x:.8f} {y:.8f} {z:.8f}\", file=f)\n</code></pre>"},{"location":"api/io/#atomlib.io.read_cif","title":"<code>read_cif(f, block=None)</code>","text":"<p>Read a structure from a CIF file.</p> <p>If <code>block</code> is specified, read data from the given block of the CIF file (index or name).</p> Source code in <code>atomlib/io/__init__.py</code> <pre><code>def read_cif(f: t.Union[FileOrPath, CIF, CIFDataBlock], block: t.Union[int, str, None] = None) -&gt; HasAtoms:\n    \"\"\"\n    Read a structure from a CIF file.\n\n    If `block` is specified, read data from the given block of the CIF file (index or name).\n    \"\"\"\n\n    if isinstance(f, (CIF, CIFDataBlock)):\n        cif = f\n    else:\n        cif = CIF.from_file(f)\n\n    if isinstance(cif, CIF):\n        if len(cif) == 0:\n            raise ValueError(\"No data present in CIF file.\")\n        if block is None:\n            if len(cif) &gt; 1:\n                logging.warn(\"Multiple blocks present in CIF file. Defaulting to reading first block.\")\n            cif = cif.data_blocks[0]\n        else:\n            cif = cif.get_block(block)\n\n    logging.debug(\"cif data: %r\", cif.data_dict)\n\n    # TODO: support atom_site_Cartn_[xyz]\n    df = cif.stack_tags('atom_site_fract_x', 'atom_site_fract_y', 'atom_site_fract_z',\n                        'atom_site_type_symbol', 'atom_site_label', 'atom_site_occupancy',\n                        'atom_site_U_iso_or_equiv', 'atom_site_B_iso_or_equiv',\n                        rename=('x', 'y', 'z', 'symbol', 'label', 'frac_occupancy', 'wobble', 'wobble_B'),\n                        required=(True, True, True, False, False, False, False, False))\n    if 'wobble_B' in df.columns:\n        if 'wobble' in df.columns:\n            raise ValueError(\"CIF file specifies both 'atom_site_U_iso_or_equiv' and 'atom_site_B_iso_or_equiv'\")\n        df = df.rename({'wobble_B': 'wobble'}) \\\n            .with_columns(polars.col('wobble') * (3./8. / numpy.pi**2))\n    if 'symbol' not in df.columns:\n        if 'label' not in df.columns:\n            raise ValueError(\"Tag 'atom_site_type_symbol' or 'atom_site_label' missing from CIF file\")\n        # infer symbol from label, insert at beginning\n        df = df.insert_column(0, get_sym(get_elem(df['label'])))\n    atoms = Atoms(df)\n\n    # parse and apply symmetry\n    sym_atoms = []\n    for sym in cif.get_symmetry():\n        sym_atoms.append(atoms.transform(sym))\n\n    #s = '\\n'.join(map(str, sym_atoms))\n    #print(f\"sym_atoms:\\n{s}\")\n    #print(f\"atoms: {atoms!s}\")\n\n    if len(sym_atoms) &gt; 0:\n        atoms = Atoms.concat(sym_atoms)._wrap().deduplicate()\n\n    if (cell_size := cif.cell_size()) is not None:\n        cell_size = to_vec3(cell_size)\n        if (cell_angle := cif.cell_angle()) is not None:\n            # degrees to radians\n            cell_angle = to_vec3(cell_angle) * numpy.pi/180.\n        return AtomCell.from_unit_cell(atoms, cell_size, cell_angle, frame='cell_frac')\n    return Atoms(atoms)\n</code></pre>"},{"location":"api/io/#atomlib.io.write_cif","title":"<code>write_cif(atoms, f)</code>","text":"<p>Write a structure to an XSF file.</p> Source code in <code>atomlib/io/__init__.py</code> <pre><code>def write_cif(atoms: t.Union[HasAtoms, CIF, CIFDataBlock], f: FileOrPath):\n    \"\"\"Write a structure to an XSF file.\"\"\"\n    if isinstance(atoms, (CIF, CIFDataBlock)):\n        cif = atoms\n    elif isinstance(atoms, AtomCell):\n        cif = CIF((CIFDataBlock.from_atomcell(atoms),))\n    else:\n        cif = CIF((CIFDataBlock.from_atoms(atoms),))\n\n    cif.write(f)\n</code></pre>"},{"location":"api/io/#atomlib.io.read_xyz","title":"<code>read_xyz(f)</code>","text":"<p>Read a structure from an XYZ file.</p> Source code in <code>atomlib/io/__init__.py</code> <pre><code>def read_xyz(f: t.Union[FileOrPath, XYZ]) -&gt; HasAtoms:\n    \"\"\"Read a structure from an XYZ file.\"\"\"\n    if isinstance(f, XYZ):\n        xyz = f\n    else:\n        xyz = XYZ.from_file(f)\n\n    atoms = Atoms(xyz.atoms)\n\n    if (cell_matrix := xyz.cell_matrix()) is not None:\n        cell = Cell.from_ortho(LinearTransform3D(cell_matrix), pbc=xyz.pbc())\n        return AtomCell(atoms, cell, frame='local')\n    return Atoms(atoms)\n</code></pre>"},{"location":"api/io/#atomlib.io.write_xyz","title":"<code>write_xyz(atoms, f, fmt='exyz')</code>","text":"Source code in <code>atomlib/io/__init__.py</code> <pre><code>def write_xyz(atoms: t.Union[HasAtoms, XYZ], f: FileOrPath, fmt: XYZFormat = 'exyz'):\n    if not isinstance(atoms, XYZ):\n        atoms = XYZ.from_atoms(atoms)\n    atoms.write(f, fmt)\n</code></pre>"},{"location":"api/io/#atomlib.io.read_xsf","title":"<code>read_xsf(f)</code>","text":"<p>Read a structure from a XSF file.</p> Source code in <code>atomlib/io/__init__.py</code> <pre><code>def read_xsf(f: t.Union[FileOrPath, XSF]) -&gt; HasAtoms:\n    \"\"\"Read a structure from a XSF file.\"\"\"\n    if isinstance(f, XSF):\n        xsf = f\n    else:\n        xsf = XSF.from_file(f)\n\n    atoms = xsf.get_atoms()\n    atoms = atoms.with_columns(get_sym(atoms['elem']))\n\n    if (primitive_cell := xsf.primitive_cell) is not None:\n        cell = Cell.from_ortho(primitive_cell, pbc=xsf.get_pbc())\n        return AtomCell(atoms, cell, frame='local')\n    return Atoms(atoms)\n</code></pre>"},{"location":"api/io/#atomlib.io.write_xsf","title":"<code>write_xsf(atoms, f)</code>","text":"<p>Write a structure to an XSF file.</p> Source code in <code>atomlib/io/__init__.py</code> <pre><code>def write_xsf(atoms: t.Union[HasAtoms, XSF], f: FileOrPath):\n    \"\"\"Write a structure to an XSF file.\"\"\"\n    if isinstance(atoms, XSF):\n        xsf = atoms\n    elif isinstance(atoms, AtomCell):\n        xsf = XSF.from_cell(atoms)\n    else:\n        xsf = XSF.from_atoms(atoms)\n\n    xsf.write(f)\n</code></pre>"},{"location":"api/io/#atomlib.io.read_cfg","title":"<code>read_cfg(f)</code>","text":"<p>Read a structure from an AtomEye CFG file.</p> Source code in <code>atomlib/io/__init__.py</code> <pre><code>def read_cfg(f: t.Union[FileOrPath, CFG]) -&gt; AtomCell:\n    \"\"\"Read a structure from an AtomEye CFG file.\"\"\"\n    if isinstance(f, CFG):\n        cfg = f\n    else:\n        cfg = CFG.from_file(f)\n\n    ortho = cfg.cell\n    if cfg.transform is not None:\n        ortho = cfg.transform @ ortho\n\n    if cfg.length_scale is not None:\n        ortho = ortho.scale(all=cfg.length_scale)\n\n    if cfg.eta is not None:\n        m = numpy.eye(3) + 2. * cfg.eta.inner\n        # matrix sqrt using eigenvals, eigenvecs\n        eigenvals, eigenvecs = numpy.linalg.eigh(m)\n        sqrtm = (eigenvecs * numpy.sqrt(eigenvals)) @ eigenvecs.T\n        ortho = LinearTransform3D(sqrtm) @ ortho\n\n    frame = Atoms(cfg.atoms).transform(ortho, transform_velocities=True)\n    return AtomCell.from_ortho(frame, ortho)\n</code></pre>"},{"location":"api/io/#atomlib.io.write_cfg","title":"<code>write_cfg(atoms, f)</code>","text":"<p>Write a structure to an AtomEye CFG file.</p> Source code in <code>atomlib/io/__init__.py</code> <pre><code>def write_cfg(atoms: t.Union[HasAtoms, CFG], f: FileOrPath):\n    \"\"\"Write a structure to an AtomEye CFG file.\"\"\"\n    if not isinstance(atoms, CFG):\n        atoms = CFG.from_atoms(atoms)\n    atoms.write(f)\n</code></pre>"},{"location":"api/io/#atomlib.io.read_lmp","title":"<code>read_lmp(f, type_map=None)</code>","text":"<p>Read a structure from a LAAMPS data file.</p> Source code in <code>atomlib/io/__init__.py</code> <pre><code>def read_lmp(f: t.Union[FileOrPath, LMP], type_map: t.Optional[t.Dict[int, t.Union[str, int]]] = None) -&gt; AtomCell:\n    \"\"\"Read a structure from a LAAMPS data file.\"\"\"\n    if isinstance(f, LMP):\n        lmp = f\n    else:\n        lmp = LMP.from_file(f)\n\n    return lmp.get_atoms(type_map=type_map)\n</code></pre>"},{"location":"api/io/#atomlib.io.write_lmp","title":"<code>write_lmp(atoms, f)</code>","text":"<p>Write a structure to a LAAMPS data file.</p> Source code in <code>atomlib/io/__init__.py</code> <pre><code>def write_lmp(atoms: t.Union[HasAtoms, LMP], f: FileOrPath):\n    \"\"\"Write a structure to a LAAMPS data file.\"\"\"\n    if not isinstance(atoms, LMP):\n        atoms = LMP.from_atoms(atoms)\n    atoms.write(f)\n</code></pre>"},{"location":"api/io/#atomlib.io.read","title":"<code>read(path, ty=None)</code>","text":"<p>Read a structure from a file.</p> <p>Currently, supported file types are 'cif', 'xyz', and 'xsf'. If no <code>ty</code> is specified, it is inferred from the file's extension.</p> Source code in <code>atomlib/io/__init__.py</code> <pre><code>def read(path: FileOrPath, ty: t.Optional[FileType] = None) -&gt; HasAtoms:\n    \"\"\"\n    Read a structure from a file.\n\n    Currently, supported file types are 'cif', 'xyz', and 'xsf'.\n    If no `ty` is specified, it is inferred from the file's extension.\n    \"\"\"\n    if ty is None:\n        if isinstance(path, (t.IO, IOBase)):\n            try:\n                name = path.name  # type: ignore\n                if name is None:\n                    raise AttributeError()\n                ext = Path(name).suffix\n            except AttributeError:\n                raise TypeError(\"read() must be passed a file-type when reading an already-open file.\") from None\n        else:\n            name = Path(path).name\n            ext = Path(path).suffix\n\n        if len(ext) == 0:\n            raise ValueError(f\"Can't infer extension for file '{name}'\")\n\n        return read(path, t.cast(FileType, ext))\n\n    ty_strip = str(ty).lstrip('.').lower()\n    try:\n        read_fn = _READ_TABLE[t.cast(FileType, ty_strip)]\n    except KeyError:\n        raise ValueError(f\"Unknown file type '{ty}'\") from None\n    if read_fn is None:\n        raise ValueError(f\"Reading is not supported for file type '{ty_strip}'\")\n    return read_fn(path)\n</code></pre>"},{"location":"api/io/#atomlib.io.write","title":"<code>write(atoms, path, ty=None)</code>","text":"<p>Write this structure to a file.</p> <p>A file type may be specified using <code>ty</code>. If no <code>ty</code> is specified, it is inferred from the path's extension.</p> Source code in <code>atomlib/io/__init__.py</code> <pre><code>def write(atoms: HasAtoms, path: FileOrPath, ty: t.Optional[FileType] = None):\n    \"\"\"\n    Write this structure to a file.\n\n    A file type may be specified using `ty`.\n    If no `ty` is specified, it is inferred from the path's extension.\n    \"\"\"\n\n    if ty is None:\n        if isinstance(path, (t.IO, IOBase)):\n            try:\n                name = path.name  # type: ignore\n                if name is None:\n                    raise AttributeError()\n                ext = Path(name).suffix\n            except AttributeError:\n                raise TypeError(\"write() must be passed a file-type when reading an already-open file.\") from None\n        else:\n            name = Path(path).name\n            ext = Path(path).suffix\n\n        if len(ext) == 0:\n            raise ValueError(f\"Can't infer extension for file '{name}'\")\n\n        return write(atoms, path, t.cast(FileType, ext))\n\n    ty_strip = str(ty).lstrip('.').lower()\n    try:\n        write_fn = _WRITE_TABLE[t.cast(FileType, ty_strip)]\n    except KeyError:\n        raise ValueError(f\"Unknown file type '{ty}'\") from None\n    if write_fn is None:\n        raise ValueError(f\"Writing is not supported for file type '{ty_strip}'\")\n\n    return write_fn(atoms, path)\n</code></pre>"},{"location":"api/io/cfg/","title":"<code>atomlib.io.cfg</code>","text":"<p>IO for AtomEye's CFG file format, described here: http://li.mit.edu/Archive/Graphics/A/index.html#standard_CFG</p>"},{"location":"api/io/cfg/#atomlib.io.cfg.TAGS","title":"<code>TAGS: t.FrozenSet[str] = frozenset(map(lambda s: s.lower(), ('Number of particles', 'A', 'R')))</code>  <code>module-attribute</code>","text":""},{"location":"api/io/cfg/#atomlib.io.cfg.ARRAY_TAGS","title":"<code>ARRAY_TAGS: t.FrozenSet[str] = frozenset(map(lambda s: s.lower(), ('H0', 'Transform', 'eta')))</code>  <code>module-attribute</code>","text":""},{"location":"api/io/cfg/#atomlib.io.cfg.CFG","title":"<code>CFG</code>  <code>dataclass</code>","text":"Source code in <code>atomlib/io/cfg.py</code> <pre><code>@dataclass\nclass CFG:\n    atoms: polars.DataFrame\n\n    cell: LinearTransform3D\n    transform: t.Optional[LinearTransform3D] = None\n    eta: t.Optional[LinearTransform3D] = None\n\n    length_scale: t.Optional[float] = None\n    length_unit: t.Optional[str] = None\n    rate_scale: t.Optional[float] = None\n    rate_unit: t.Optional[str] = None\n\n    @staticmethod\n    def from_file(file: FileOrPath) -&gt; CFG:\n        with open_file(file, 'r') as f:\n            return CFGParser(f).parse()\n\n    @staticmethod\n    def from_atoms(atoms: HasAtoms) -&gt; CFG:\n        if isinstance(atoms, HasAtomCell):\n            cell = atoms.get_transform('cell_box').inverse().to_linear()\n            atoms = atoms.get_atoms('cell_box')\n        else:\n            cell = LinearTransform3D.identity()\n\n        # ensure we have masses and velocities\n        atoms = atoms.with_mass().with_velocity()\n        return CFG(atoms._get_frame(), cell, length_scale=1.0, length_unit=\"Angstrom\")\n\n    def write(self, file: FileOrPath):\n        with open_file(file, 'w', newline='\\r\\n') as f:\n            f.write(f\"Number of particles = {len(self.atoms)}\\n\")\n\n            if self.length_scale is not None:\n                unit = f\" [{self.length_unit}]\" if self.length_unit is not None else \"\"\n                f.write(f\"\\nA = {self.length_scale:.8}{unit}\\n\\n\")\n\n            cell = self.cell.inner\n            for (i, j) in product(range(3), repeat=2):\n                f.write(f\"H0({i+1},{j+1}) = {cell[j,i]:.8} A\\n\")\n\n            if self.transform is not None:\n                f.write(\"\\n\")\n                transform = self.transform.inner\n                for (i, j) in product(range(3), repeat=2):\n                    f.write(f\"Transform({i+1},{j+1}) = {transform[j,i]:.8}\\n\")\n\n            if self.eta is not None:\n                f.write(\"\\n\")\n                eta = self.eta.inner\n                for i in range(3):\n                    for j in range(i, 3):\n                        f.write(f\"eta({i+1},{j+1}) = {eta[j,i]:.8}\\n\")\n\n            if self.rate_scale is not None:\n                unit = f\" [{self.rate_unit}]\" if self.rate_unit is not None else \"\"\n                f.write(f\"\\nR = {self.rate_scale:.8}{unit}\\n\")\n\n            f.write(\"\\n\")\n            for row in self.atoms.select(('mass', 'symbol', 'coords', 'velocity')).rows():\n                (mass, sym, (x, y, z), (v_x, v_y, v_z)) = row\n                f.write(f\"{mass:.4f} {sym:&gt;2} {x:.8} {y:.8} {z:.8} {v_x:.8} {v_y:.8} {v_z:.8}\\n\")\n</code></pre>"},{"location":"api/io/cfg/#atomlib.io.cfg.CFG.atoms","title":"<code>atoms: polars.DataFrame</code>  <code>instance-attribute</code>","text":""},{"location":"api/io/cfg/#atomlib.io.cfg.CFG.cell","title":"<code>cell: LinearTransform3D</code>  <code>instance-attribute</code>","text":""},{"location":"api/io/cfg/#atomlib.io.cfg.CFG.transform","title":"<code>transform: t.Optional[LinearTransform3D] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/io/cfg/#atomlib.io.cfg.CFG.eta","title":"<code>eta: t.Optional[LinearTransform3D] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/io/cfg/#atomlib.io.cfg.CFG.length_scale","title":"<code>length_scale: t.Optional[float] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/io/cfg/#atomlib.io.cfg.CFG.length_unit","title":"<code>length_unit: t.Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/io/cfg/#atomlib.io.cfg.CFG.rate_scale","title":"<code>rate_scale: t.Optional[float] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/io/cfg/#atomlib.io.cfg.CFG.rate_unit","title":"<code>rate_unit: t.Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/io/cfg/#atomlib.io.cfg.CFG.from_file","title":"<code>from_file(file)</code>  <code>staticmethod</code>","text":"Source code in <code>atomlib/io/cfg.py</code> <pre><code>@staticmethod\ndef from_file(file: FileOrPath) -&gt; CFG:\n    with open_file(file, 'r') as f:\n        return CFGParser(f).parse()\n</code></pre>"},{"location":"api/io/cfg/#atomlib.io.cfg.CFG.from_atoms","title":"<code>from_atoms(atoms)</code>  <code>staticmethod</code>","text":"Source code in <code>atomlib/io/cfg.py</code> <pre><code>@staticmethod\ndef from_atoms(atoms: HasAtoms) -&gt; CFG:\n    if isinstance(atoms, HasAtomCell):\n        cell = atoms.get_transform('cell_box').inverse().to_linear()\n        atoms = atoms.get_atoms('cell_box')\n    else:\n        cell = LinearTransform3D.identity()\n\n    # ensure we have masses and velocities\n    atoms = atoms.with_mass().with_velocity()\n    return CFG(atoms._get_frame(), cell, length_scale=1.0, length_unit=\"Angstrom\")\n</code></pre>"},{"location":"api/io/cfg/#atomlib.io.cfg.CFG.write","title":"<code>write(file)</code>","text":"Source code in <code>atomlib/io/cfg.py</code> <pre><code>def write(self, file: FileOrPath):\n    with open_file(file, 'w', newline='\\r\\n') as f:\n        f.write(f\"Number of particles = {len(self.atoms)}\\n\")\n\n        if self.length_scale is not None:\n            unit = f\" [{self.length_unit}]\" if self.length_unit is not None else \"\"\n            f.write(f\"\\nA = {self.length_scale:.8}{unit}\\n\\n\")\n\n        cell = self.cell.inner\n        for (i, j) in product(range(3), repeat=2):\n            f.write(f\"H0({i+1},{j+1}) = {cell[j,i]:.8} A\\n\")\n\n        if self.transform is not None:\n            f.write(\"\\n\")\n            transform = self.transform.inner\n            for (i, j) in product(range(3), repeat=2):\n                f.write(f\"Transform({i+1},{j+1}) = {transform[j,i]:.8}\\n\")\n\n        if self.eta is not None:\n            f.write(\"\\n\")\n            eta = self.eta.inner\n            for i in range(3):\n                for j in range(i, 3):\n                    f.write(f\"eta({i+1},{j+1}) = {eta[j,i]:.8}\\n\")\n\n        if self.rate_scale is not None:\n            unit = f\" [{self.rate_unit}]\" if self.rate_unit is not None else \"\"\n            f.write(f\"\\nR = {self.rate_scale:.8}{unit}\\n\")\n\n        f.write(\"\\n\")\n        for row in self.atoms.select(('mass', 'symbol', 'coords', 'velocity')).rows():\n            (mass, sym, (x, y, z), (v_x, v_y, v_z)) = row\n            f.write(f\"{mass:.4f} {sym:&gt;2} {x:.8} {y:.8} {z:.8} {v_x:.8} {v_y:.8} {v_z:.8}\\n\")\n</code></pre>"},{"location":"api/io/cfg/#atomlib.io.cfg.CFGParser","title":"<code>CFGParser</code>","text":"Source code in <code>atomlib/io/cfg.py</code> <pre><code>class CFGParser:\n    def __init__(self, f: TextIOBase):\n        self.buf = LineBuffer(f)\n\n    def parse(self) -&gt; CFG:\n        (n, value_tags, array_tags) = self.parse_tags()\n        atoms = self.parse_atoms(n)\n\n        try:\n            cell = array_tags['h0']\n        except KeyError:\n            raise ValueError(\"CFG file missing required tag 'H0'\") from None\n\n        length = value_tags.get('a')\n        length_scale = map_some(lambda t: t[0], length)\n        length_unit = map_some(lambda t: t[1], length)\n\n        rate = value_tags.get('r')\n        rate_scale = map_some(lambda t: t[0], rate)\n        rate_unit = map_some(lambda t: t[1], rate)\n\n        return CFG(\n            atoms=atoms,\n            cell=LinearTransform3D(cell),\n            transform=map_some(LinearTransform3D, array_tags.get('transform')),\n            eta=map_some(LinearTransform3D, array_tags.get('eta')),\n            length_scale=length_scale,\n            length_unit=length_unit,\n            rate_scale=rate_scale,\n            rate_unit=rate_unit,\n        )\n\n    def parse_tags(self) -&gt; t.Tuple[int, t.Dict[str, t.Tuple[float, t.Optional[str]]], t.Dict[str, numpy.ndarray]]:\n        first = True\n\n        # tag, (value, unit)\n        n: t.Optional[int] = None\n        value_tags: t.Dict[str, t.Tuple[float, t.Optional[str]]] = {}\n        array_tags: t.Dict[str, t.List[t.List[t.Optional[float]]]] = {}\n\n        while (line := self.buf.peek_line()) is not None:\n            line = line.strip()\n            if len(line) == 0 or line.startswith(\"#\"):\n                # skip comments and blank lines\n                self.buf.next_line()\n                continue\n\n            if first:\n                if not line.lower().startswith('number of particles'):\n                    raise ValueError(\"File does not start with Number of particles.\"\n                                    \" Is this an AtomEye CFG file?\")\n\n            try:\n                tag, value = line.split('=')\n            except ValueError:\n                try:\n                    float(line.split(' ', 1)[0])\n                    # started list of atoms\n                    break\n                except ValueError:\n                    raise ValueError(f\"Expected a tag-value pair at line {self.buf.line}: '{line}'\")\n\n            tag = tag.strip()\n            value = value.strip()\n            if first:\n                try:\n                    value = int(value)\n                except ValueError:\n                    raise ValueError(f\"Invalid # of elements '{value}' at line {self.buf.line}\") from None\n                n = value\n                first = False\n                self.buf.next_line()\n                continue\n\n            if tag.lower() in TAGS:\n                try:\n                    value_tags[tag.lower()] = self.parse_value_with_unit(value)\n                except ValueError:\n                    raise ValueError(f\"Invalid value '{value}' at line {self.buf.line}\") from None\n            elif (match := re.match(r'(.+)\\((\\d+),(\\d+)\\)', tag)):\n                try:\n                    (tag, i, j) = (match[1].lower(), int(match[2]), int(match[3]))\n                    if not (0 &lt; i &lt;= 3 and 0 &lt; j &lt;= 3):\n                        raise ValueError(f\"Invalid index ({i},{j}) for tag '{tag}' at line {self.buf.line}\")\n                    if tag not in array_tags:\n                        array_tags[tag] = [[None] * 3, [None] * 3, [None] * 3]\n                    try:\n                        val = self.parse_value_with_unit(value)[0]\n                        array_tags[tag][j-1][i-1] = val\n                        if tag == 'eta':\n                            array_tags[tag][i-1][j-1] = val\n                    except ValueError:\n                        raise ValueError(f\"Invalid value '{value}' at line {self.buf.line}\") from None\n                except ValueError:\n                    raise ValueError(f\"Invalid indexes in tag '{tag}' at line {self.buf.line}\") from None\n                if tag.lower() not in ARRAY_TAGS:\n                    raise ValueError(f\"Unknown array tag '{tag}'\")\n            elif tag.lower() in ARRAY_TAGS:\n                raise ValueError(f\"Missing indexes for tag '{tag}' at line {self.buf.line}\")\n            else:\n                raise ValueError(f\"Unknown tag '{tag}' at line {self.buf.line}\")\n\n            self.buf.next_line()\n\n        if n is None:\n            raise ValueError(\"Empty CFG file\")\n\n        ndarray_tags: t.Dict[str, numpy.ndarray] = {}\n\n        for (tag, value) in array_tags.items():\n            for i in range(3):\n                for j in range(3):\n                    if value[j][i] is None:\n                        raise ValueError(f\"Tag '{tag}' missing value for index ({i+1},{j+1})\")\n            ndarray_tags[tag] = numpy.array(value)\n\n        return (n, value_tags, ndarray_tags)\n\n    def parse_value_with_unit(self, value: str) -&gt; t.Tuple[float, t.Optional[str]]:\n        segments = value.split(maxsplit=1)\n        if len(segments) == 1:\n            return (float(value), None)\n        value, unit = map(lambda s: s.strip(), segments)\n\n        if (match := re.match(r'\\[(.+)\\]', unit)):\n            unit = str(match[1])\n        else:\n            unit = unit.split(maxsplit=1)[0]\n\n        return (float(value), unit)\n\n    def parse_atoms(self, n: int) -&gt; polars.DataFrame:\n        df = parse_whitespace_separated(self.buf, {\n            'mass': polars.Float64, 'symbol': polars.Utf8,\n            'coords': polars.Array(polars.Float64, 3),\n            'velocity': polars.Array(polars.Float64, 3),\n        })\n        df = df.with_columns(get_elem(df['symbol'])).select(\n            'elem', 'symbol', 'coords', 'velocity', 'mass'\n        )\n\n        if n != len(df):\n            raise ValueError(f\"# of atom rows doesn't match declared number ({len(df)} vs. {n})\")\n\n        return df\n</code></pre>"},{"location":"api/io/cfg/#atomlib.io.cfg.CFGParser.buf","title":"<code>buf = LineBuffer(f)</code>  <code>instance-attribute</code>","text":""},{"location":"api/io/cfg/#atomlib.io.cfg.CFGParser.parse","title":"<code>parse()</code>","text":"Source code in <code>atomlib/io/cfg.py</code> <pre><code>def parse(self) -&gt; CFG:\n    (n, value_tags, array_tags) = self.parse_tags()\n    atoms = self.parse_atoms(n)\n\n    try:\n        cell = array_tags['h0']\n    except KeyError:\n        raise ValueError(\"CFG file missing required tag 'H0'\") from None\n\n    length = value_tags.get('a')\n    length_scale = map_some(lambda t: t[0], length)\n    length_unit = map_some(lambda t: t[1], length)\n\n    rate = value_tags.get('r')\n    rate_scale = map_some(lambda t: t[0], rate)\n    rate_unit = map_some(lambda t: t[1], rate)\n\n    return CFG(\n        atoms=atoms,\n        cell=LinearTransform3D(cell),\n        transform=map_some(LinearTransform3D, array_tags.get('transform')),\n        eta=map_some(LinearTransform3D, array_tags.get('eta')),\n        length_scale=length_scale,\n        length_unit=length_unit,\n        rate_scale=rate_scale,\n        rate_unit=rate_unit,\n    )\n</code></pre>"},{"location":"api/io/cfg/#atomlib.io.cfg.CFGParser.parse_tags","title":"<code>parse_tags()</code>","text":"Source code in <code>atomlib/io/cfg.py</code> <pre><code>def parse_tags(self) -&gt; t.Tuple[int, t.Dict[str, t.Tuple[float, t.Optional[str]]], t.Dict[str, numpy.ndarray]]:\n    first = True\n\n    # tag, (value, unit)\n    n: t.Optional[int] = None\n    value_tags: t.Dict[str, t.Tuple[float, t.Optional[str]]] = {}\n    array_tags: t.Dict[str, t.List[t.List[t.Optional[float]]]] = {}\n\n    while (line := self.buf.peek_line()) is not None:\n        line = line.strip()\n        if len(line) == 0 or line.startswith(\"#\"):\n            # skip comments and blank lines\n            self.buf.next_line()\n            continue\n\n        if first:\n            if not line.lower().startswith('number of particles'):\n                raise ValueError(\"File does not start with Number of particles.\"\n                                \" Is this an AtomEye CFG file?\")\n\n        try:\n            tag, value = line.split('=')\n        except ValueError:\n            try:\n                float(line.split(' ', 1)[0])\n                # started list of atoms\n                break\n            except ValueError:\n                raise ValueError(f\"Expected a tag-value pair at line {self.buf.line}: '{line}'\")\n\n        tag = tag.strip()\n        value = value.strip()\n        if first:\n            try:\n                value = int(value)\n            except ValueError:\n                raise ValueError(f\"Invalid # of elements '{value}' at line {self.buf.line}\") from None\n            n = value\n            first = False\n            self.buf.next_line()\n            continue\n\n        if tag.lower() in TAGS:\n            try:\n                value_tags[tag.lower()] = self.parse_value_with_unit(value)\n            except ValueError:\n                raise ValueError(f\"Invalid value '{value}' at line {self.buf.line}\") from None\n        elif (match := re.match(r'(.+)\\((\\d+),(\\d+)\\)', tag)):\n            try:\n                (tag, i, j) = (match[1].lower(), int(match[2]), int(match[3]))\n                if not (0 &lt; i &lt;= 3 and 0 &lt; j &lt;= 3):\n                    raise ValueError(f\"Invalid index ({i},{j}) for tag '{tag}' at line {self.buf.line}\")\n                if tag not in array_tags:\n                    array_tags[tag] = [[None] * 3, [None] * 3, [None] * 3]\n                try:\n                    val = self.parse_value_with_unit(value)[0]\n                    array_tags[tag][j-1][i-1] = val\n                    if tag == 'eta':\n                        array_tags[tag][i-1][j-1] = val\n                except ValueError:\n                    raise ValueError(f\"Invalid value '{value}' at line {self.buf.line}\") from None\n            except ValueError:\n                raise ValueError(f\"Invalid indexes in tag '{tag}' at line {self.buf.line}\") from None\n            if tag.lower() not in ARRAY_TAGS:\n                raise ValueError(f\"Unknown array tag '{tag}'\")\n        elif tag.lower() in ARRAY_TAGS:\n            raise ValueError(f\"Missing indexes for tag '{tag}' at line {self.buf.line}\")\n        else:\n            raise ValueError(f\"Unknown tag '{tag}' at line {self.buf.line}\")\n\n        self.buf.next_line()\n\n    if n is None:\n        raise ValueError(\"Empty CFG file\")\n\n    ndarray_tags: t.Dict[str, numpy.ndarray] = {}\n\n    for (tag, value) in array_tags.items():\n        for i in range(3):\n            for j in range(3):\n                if value[j][i] is None:\n                    raise ValueError(f\"Tag '{tag}' missing value for index ({i+1},{j+1})\")\n        ndarray_tags[tag] = numpy.array(value)\n\n    return (n, value_tags, ndarray_tags)\n</code></pre>"},{"location":"api/io/cfg/#atomlib.io.cfg.CFGParser.parse_value_with_unit","title":"<code>parse_value_with_unit(value)</code>","text":"Source code in <code>atomlib/io/cfg.py</code> <pre><code>def parse_value_with_unit(self, value: str) -&gt; t.Tuple[float, t.Optional[str]]:\n    segments = value.split(maxsplit=1)\n    if len(segments) == 1:\n        return (float(value), None)\n    value, unit = map(lambda s: s.strip(), segments)\n\n    if (match := re.match(r'\\[(.+)\\]', unit)):\n        unit = str(match[1])\n    else:\n        unit = unit.split(maxsplit=1)[0]\n\n    return (float(value), unit)\n</code></pre>"},{"location":"api/io/cfg/#atomlib.io.cfg.CFGParser.parse_atoms","title":"<code>parse_atoms(n)</code>","text":"Source code in <code>atomlib/io/cfg.py</code> <pre><code>def parse_atoms(self, n: int) -&gt; polars.DataFrame:\n    df = parse_whitespace_separated(self.buf, {\n        'mass': polars.Float64, 'symbol': polars.Utf8,\n        'coords': polars.Array(polars.Float64, 3),\n        'velocity': polars.Array(polars.Float64, 3),\n    })\n    df = df.with_columns(get_elem(df['symbol'])).select(\n        'elem', 'symbol', 'coords', 'velocity', 'mass'\n    )\n\n    if n != len(df):\n        raise ValueError(f\"# of atom rows doesn't match declared number ({len(df)} vs. {n})\")\n\n    return df\n</code></pre>"},{"location":"api/io/cif/","title":"<code>atomlib.io.cif</code>","text":"<p>IO for the CIF1.1 file format, specified here: https://www.iucr.org/resources/cif/spec/version1.1</p>"},{"location":"api/io/cif/#atomlib.io.cif.Value","title":"<code>Value = t.Union[int, float, str, None]</code>  <code>module-attribute</code>","text":""},{"location":"api/io/cif/#atomlib.io.cif.SYMMETRY_PARSER","title":"<code>SYMMETRY_PARSER: Parser[SymmetryVec, SymmetryVec] = Parser([BinaryOrUnaryOp(['-'], sub, False, 5), BinaryOrUnaryOp(['+'], add, False, 5), BinaryOp(['*'], operator.mul, 6), BinaryOp(['/'], operator.truediv, 6)], SymmetryVec.parse)</code>  <code>module-attribute</code>","text":""},{"location":"api/io/cif/#atomlib.io.cif.CIF","title":"<code>CIF</code>  <code>dataclass</code>","text":"Source code in <code>atomlib/io/cif.py</code> <pre><code>@dataclass\nclass CIF:\n    data_blocks: t.Tuple[CIFDataBlock, ...]\n\n    def __post_init__(self):\n        # ensure that all data_blocks after the first have a name\n        for data_block in self.data_blocks[1:]:\n            if data_block.name is None:\n                data_block.name = \"\"\n\n    @staticmethod\n    def from_file(file: FileOrPath) -&gt; CIF:\n        return CIF(tuple(CIFDataBlock.from_file(file)))\n\n    def __len__(self) -&gt; int:\n        return self.data_blocks.__len__()\n\n    def get_block(self, block: t.Union[int, str]) -&gt; CIFDataBlock:\n        try:\n            if isinstance(block, int):\n                return self.data_blocks[block]\n            return next(b for b in self.data_blocks if b.name == block)\n        except (IndexError, StopIteration):\n            raise ValueError(f\"Couldn't find block '{block}' in CIF file. File has {len(self)} blocks.\")\n\n    def write(self, file: FileOrPath):\n        with open_file(file, 'w') as f:\n            print(f\"# generated by atomlib\", file=f, end=None)\n            for data_block in self.data_blocks:\n                print(file=f)\n                data_block._write(f)\n</code></pre>"},{"location":"api/io/cif/#atomlib.io.cif.CIF.data_blocks","title":"<code>data_blocks: t.Tuple[CIFDataBlock, ...]</code>  <code>instance-attribute</code>","text":""},{"location":"api/io/cif/#atomlib.io.cif.CIF.from_file","title":"<code>from_file(file)</code>  <code>staticmethod</code>","text":"Source code in <code>atomlib/io/cif.py</code> <pre><code>@staticmethod\ndef from_file(file: FileOrPath) -&gt; CIF:\n    return CIF(tuple(CIFDataBlock.from_file(file)))\n</code></pre>"},{"location":"api/io/cif/#atomlib.io.cif.CIF.get_block","title":"<code>get_block(block)</code>","text":"Source code in <code>atomlib/io/cif.py</code> <pre><code>def get_block(self, block: t.Union[int, str]) -&gt; CIFDataBlock:\n    try:\n        if isinstance(block, int):\n            return self.data_blocks[block]\n        return next(b for b in self.data_blocks if b.name == block)\n    except (IndexError, StopIteration):\n        raise ValueError(f\"Couldn't find block '{block}' in CIF file. File has {len(self)} blocks.\")\n</code></pre>"},{"location":"api/io/cif/#atomlib.io.cif.CIF.write","title":"<code>write(file)</code>","text":"Source code in <code>atomlib/io/cif.py</code> <pre><code>def write(self, file: FileOrPath):\n    with open_file(file, 'w') as f:\n        print(f\"# generated by atomlib\", file=f, end=None)\n        for data_block in self.data_blocks:\n            print(file=f)\n            data_block._write(f)\n</code></pre>"},{"location":"api/io/cif/#atomlib.io.cif.CIFDataBlock","title":"<code>CIFDataBlock</code>  <code>dataclass</code>","text":"Source code in <code>atomlib/io/cif.py</code> <pre><code>@dataclass\nclass CIFDataBlock:\n    name: t.Optional[str]  # None: no data_ block, empty string: unnamed \"data_\"\n\n    # data (including loops) in file order\n    data: t.Tuple[t.Union[t.Tuple[str, Value], CIFTable], ...]\n\n    # data flattened into a single dictionary. Created automatically from `data`\n    data_dict: t.Dict[str, t.Union[t.List[Value], Value]] = field(init=False)\n\n    def __post_init__(self):\n        # if we raise here, make sure the object state is fine\n        self.data_dict = None  # type: ignore\n\n        data_values = {}\n\n        def _iter_data_values():\n            for d in self.data:\n                if isinstance(d, CIFTable):\n                    yield from d.data.items()\n                else:\n                    yield d\n\n        for (k, v) in _iter_data_values():\n            if k in data_values:\n                raise ValueError(f\"Duplicate key {k}\")\n            data_values[k] = v\n\n        self.data_dict = data_values\n\n    @staticmethod\n    def from_file(file: FileOrPath) -&gt; t.Iterator[CIFDataBlock]:\n        with open_file(file) as f:\n            yield from CifReader(f).parse()\n\n    @staticmethod\n    def from_atoms(atoms: HasAtoms) -&gt; CIFDataBlock:\n        data: t.List[t.Union[t.Tuple[str, Value], CIFTable]] = []\n\n        data.append(('audit_creation_method', 'Generated by atomlib'))\n\n        keys: t.Sequence[t.Tuple[str, t.Union[str, polars.Expr], t.Union[str, bool]]] = (\n            # col, expr, predicate (column or boolean)\n            ('atom_site_type_symbol', 'symbol', True),\n            ('atom_site_label', 'label', 'label'),\n            ('atom_site_occupancy', 'frac_occupancy', 'frac_occupancy'),\n            ('atom_site_Cartn_x', polars.col('coords').arr.get(0), True),\n            ('atom_site_Cartn_y', polars.col('coords').arr.get(1), True),\n            ('atom_site_Cartn_z', polars.col('coords').arr.get(2), True),\n            ('atom_site_U_iso_or_equiv', 'wobble', 'wobble'),\n        )\n        data.append(CIFTable({\n            key: atoms.select(expr).to_series().to_list() for (key, expr, pred) in keys\n            if (atoms.try_get_column(pred) is not None if isinstance(pred, str) else pred)\n        }))\n\n        return CIFDataBlock(\"\", tuple(data))\n\n    @staticmethod\n    def from_atomcell(atomcell: HasAtomCell) -&gt; CIFDataBlock:\n        atoms = atomcell.get_atoms('cell_box')\n        ortho = atomcell.get_transform('local', 'cell_box').to_linear()\n        (cell_size, cell_angle) = ortho_to_cell(ortho)\n        cell_angle *= 180./numpy.pi  # convert to degrees\n\n        data: t.List[t.Union[t.Tuple[str, Value], CIFTable]] = []\n\n        data.append(('audit_creation_method', 'Generated by atomlib'))\n\n        # symmetry information\n        data.append(CIFTable({\n            'space_group_symop_id': [1],\n            'space_group_symop_operation_xyz': ['x,y,z'],\n        }))\n\n        # cell information\n        data.append(('cell_length_a', cell_size[0]))\n        data.append(('cell_length_b', cell_size[1]))\n        data.append(('cell_length_c', cell_size[2]))\n        data.append(('cell_angle_alpha', cell_angle[0]))\n        data.append(('cell_angle_beta', cell_angle[1]))\n        data.append(('cell_angle_gamma', cell_angle[2]))\n        data.append(('cell_volume', ortho.det()))\n\n        keys: t.Sequence[t.Tuple[str, t.Union[str, polars.Expr], t.Union[str, bool]]] = (\n            # col, expr, predicate (column or boolean)\n            ('atom_site_type_symbol', 'symbol', True),\n            ('atom_site_label', 'label', 'label'),\n            ('atom_site_occupancy', 'frac_occupancy', 'frac_occupancy'),\n            ('atom_site_fract_x', polars.col('coords').arr.get(0), True),\n            ('atom_site_fract_y', polars.col('coords').arr.get(1), True),\n            ('atom_site_fract_z', polars.col('coords').arr.get(2), True),\n            ('atom_site_U_iso_or_equiv', 'wobble', 'wobble'),\n        )\n        data.append(CIFTable({\n            key: atoms.select(expr).to_series().to_list() for (key, expr, pred) in keys\n            if (atoms.try_get_column(pred) is not None if isinstance(pred, str) else pred)\n        }))\n\n        return CIFDataBlock(\"\", tuple(data))\n\n    def write(self, file: FileOrPath):\n        with open_file(file, 'w') as f:\n            self._write(f)\n\n    def _write(self, f: TextIOBase):\n        if self.name is not None:\n            print(f\"data_{self.name}\\n\", file=f)\n\n        for data in self.data:\n            if isinstance(data, CIFTable):\n                data._write(f)\n            else:\n                (name, value) = data\n                val = _format_val(value).rstrip()\n                if val.startswith(';'):\n                    # multiline string\n                    print(f\"_{name}\\n{val}\", file=f)\n                else:\n                    print(f\"_{name: &lt;28} {_format_val(value).rstrip()}\", file=f)\n\n    def stack_tags(self, *tags: str, dtype: t.Union[str, numpy.dtype, t.Iterable[t.Union[str, numpy.dtype]], None] = None,\n                   rename: t.Optional[t.Iterable[t.Optional[str]]] = None, required: t.Union[bool, t.Iterable[bool]] = True) -&gt; polars.DataFrame:\n        dtypes: t.Iterable[t.Optional[numpy.dtype]]\n        if dtype is None:\n            dtypes = repeat(None)\n        elif isinstance(dtype, (numpy.dtype, str)):\n            dtypes = (numpy.dtype(dtype),) * len(tags)\n        else:\n            dtypes = tuple(map(lambda ty: numpy.dtype(ty), dtype))\n            if len(dtypes) != len(tags):\n                raise ValueError(f\"dtype list of invalid length\")\n\n        if isinstance(required, bool):\n            required = repeat(required)\n\n        if rename is None:\n            rename = repeat(None)\n\n        d = {}\n        for (tag, ty, req, name) in zip(tags, dtypes, required, rename):\n            if tag not in self.data_dict:\n                if req:\n                    raise ValueError(f\"Tag '{tag}' missing from CIF file\")\n                continue\n            try:\n                arr = numpy.array(self.data_dict[tag], dtype=ty)\n                d[name or tag] = arr\n            except TypeError:\n                raise TypeError(f\"Tag '{tag}' of invalid or heterogeneous type.\")\n\n        if len(d) == 0:\n            return polars.DataFrame({})\n\n        l = len(next(iter(d.values())))\n        if any(len(arr) != l for arr in d.values()):\n            raise ValueError(f\"Tags of mismatching lengths: {tuple(map(len, d.values()))}\")\n\n        return polars.DataFrame(d)\n\n    def cell_size(self) -&gt; t.Optional[t.Tuple[float, float, float]]:\n        \"\"\"Return cell size (in angstroms).\"\"\"\n        try:\n            a = float(self['cell_length_a'])  # type: ignore\n            b = float(self['cell_length_b'])  # type: ignore\n            c = float(self['cell_length_c'])  # type: ignore\n            return (a, b, c)\n        except (ValueError, TypeError, KeyError):\n            return None\n\n    def cell_angle(self) -&gt; t.Optional[t.Tuple[float, float, float]]:\n        \"\"\"Return cell angle (in degrees).\"\"\"\n        try:\n            a = float(self['cell_angle_alpha'])  # type: ignore\n            b = float(self['cell_angle_beta'])   # type: ignore\n            g = float(self['cell_angle_gamma'])  # type: ignore\n            return (a, b, g)\n        except (ValueError, TypeError, KeyError):\n            return None\n\n    def get_symmetry(self) -&gt; t.Iterator[AffineTransform3D]:\n        syms = self.data_dict.get('space_group_symop_operation_xyz')\n        if syms is None:\n            # old name for symmetry\n            syms = self.data_dict.get('symmetry_equiv_pos_as_xyz')\n        if syms is None:\n            syms = ()\n        if not hasattr(syms, '__iter__'):\n            syms = (syms,)\n        return map(parse_symmetry, map(str, syms))  # type: ignore\n\n    def __getitem__(self, key: str) -&gt; t.Union[Value, t.List[Value]]:\n        return self.data_dict.__getitem__(key)\n</code></pre>"},{"location":"api/io/cif/#atomlib.io.cif.CIFDataBlock.name","title":"<code>name: t.Optional[str]</code>  <code>instance-attribute</code>","text":""},{"location":"api/io/cif/#atomlib.io.cif.CIFDataBlock.data","title":"<code>data: t.Tuple[t.Union[t.Tuple[str, Value], CIFTable], ...]</code>  <code>instance-attribute</code>","text":""},{"location":"api/io/cif/#atomlib.io.cif.CIFDataBlock.data_dict","title":"<code>data_dict: t.Dict[str, t.Union[t.List[Value], Value]] = field(init=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/io/cif/#atomlib.io.cif.CIFDataBlock.from_file","title":"<code>from_file(file)</code>  <code>staticmethod</code>","text":"Source code in <code>atomlib/io/cif.py</code> <pre><code>@staticmethod\ndef from_file(file: FileOrPath) -&gt; t.Iterator[CIFDataBlock]:\n    with open_file(file) as f:\n        yield from CifReader(f).parse()\n</code></pre>"},{"location":"api/io/cif/#atomlib.io.cif.CIFDataBlock.from_atoms","title":"<code>from_atoms(atoms)</code>  <code>staticmethod</code>","text":"Source code in <code>atomlib/io/cif.py</code> <pre><code>@staticmethod\ndef from_atoms(atoms: HasAtoms) -&gt; CIFDataBlock:\n    data: t.List[t.Union[t.Tuple[str, Value], CIFTable]] = []\n\n    data.append(('audit_creation_method', 'Generated by atomlib'))\n\n    keys: t.Sequence[t.Tuple[str, t.Union[str, polars.Expr], t.Union[str, bool]]] = (\n        # col, expr, predicate (column or boolean)\n        ('atom_site_type_symbol', 'symbol', True),\n        ('atom_site_label', 'label', 'label'),\n        ('atom_site_occupancy', 'frac_occupancy', 'frac_occupancy'),\n        ('atom_site_Cartn_x', polars.col('coords').arr.get(0), True),\n        ('atom_site_Cartn_y', polars.col('coords').arr.get(1), True),\n        ('atom_site_Cartn_z', polars.col('coords').arr.get(2), True),\n        ('atom_site_U_iso_or_equiv', 'wobble', 'wobble'),\n    )\n    data.append(CIFTable({\n        key: atoms.select(expr).to_series().to_list() for (key, expr, pred) in keys\n        if (atoms.try_get_column(pred) is not None if isinstance(pred, str) else pred)\n    }))\n\n    return CIFDataBlock(\"\", tuple(data))\n</code></pre>"},{"location":"api/io/cif/#atomlib.io.cif.CIFDataBlock.from_atomcell","title":"<code>from_atomcell(atomcell)</code>  <code>staticmethod</code>","text":"Source code in <code>atomlib/io/cif.py</code> <pre><code>@staticmethod\ndef from_atomcell(atomcell: HasAtomCell) -&gt; CIFDataBlock:\n    atoms = atomcell.get_atoms('cell_box')\n    ortho = atomcell.get_transform('local', 'cell_box').to_linear()\n    (cell_size, cell_angle) = ortho_to_cell(ortho)\n    cell_angle *= 180./numpy.pi  # convert to degrees\n\n    data: t.List[t.Union[t.Tuple[str, Value], CIFTable]] = []\n\n    data.append(('audit_creation_method', 'Generated by atomlib'))\n\n    # symmetry information\n    data.append(CIFTable({\n        'space_group_symop_id': [1],\n        'space_group_symop_operation_xyz': ['x,y,z'],\n    }))\n\n    # cell information\n    data.append(('cell_length_a', cell_size[0]))\n    data.append(('cell_length_b', cell_size[1]))\n    data.append(('cell_length_c', cell_size[2]))\n    data.append(('cell_angle_alpha', cell_angle[0]))\n    data.append(('cell_angle_beta', cell_angle[1]))\n    data.append(('cell_angle_gamma', cell_angle[2]))\n    data.append(('cell_volume', ortho.det()))\n\n    keys: t.Sequence[t.Tuple[str, t.Union[str, polars.Expr], t.Union[str, bool]]] = (\n        # col, expr, predicate (column or boolean)\n        ('atom_site_type_symbol', 'symbol', True),\n        ('atom_site_label', 'label', 'label'),\n        ('atom_site_occupancy', 'frac_occupancy', 'frac_occupancy'),\n        ('atom_site_fract_x', polars.col('coords').arr.get(0), True),\n        ('atom_site_fract_y', polars.col('coords').arr.get(1), True),\n        ('atom_site_fract_z', polars.col('coords').arr.get(2), True),\n        ('atom_site_U_iso_or_equiv', 'wobble', 'wobble'),\n    )\n    data.append(CIFTable({\n        key: atoms.select(expr).to_series().to_list() for (key, expr, pred) in keys\n        if (atoms.try_get_column(pred) is not None if isinstance(pred, str) else pred)\n    }))\n\n    return CIFDataBlock(\"\", tuple(data))\n</code></pre>"},{"location":"api/io/cif/#atomlib.io.cif.CIFDataBlock.write","title":"<code>write(file)</code>","text":"Source code in <code>atomlib/io/cif.py</code> <pre><code>def write(self, file: FileOrPath):\n    with open_file(file, 'w') as f:\n        self._write(f)\n</code></pre>"},{"location":"api/io/cif/#atomlib.io.cif.CIFDataBlock.stack_tags","title":"<code>stack_tags(*tags, dtype=None, rename=None, required=True)</code>","text":"Source code in <code>atomlib/io/cif.py</code> <pre><code>def stack_tags(self, *tags: str, dtype: t.Union[str, numpy.dtype, t.Iterable[t.Union[str, numpy.dtype]], None] = None,\n               rename: t.Optional[t.Iterable[t.Optional[str]]] = None, required: t.Union[bool, t.Iterable[bool]] = True) -&gt; polars.DataFrame:\n    dtypes: t.Iterable[t.Optional[numpy.dtype]]\n    if dtype is None:\n        dtypes = repeat(None)\n    elif isinstance(dtype, (numpy.dtype, str)):\n        dtypes = (numpy.dtype(dtype),) * len(tags)\n    else:\n        dtypes = tuple(map(lambda ty: numpy.dtype(ty), dtype))\n        if len(dtypes) != len(tags):\n            raise ValueError(f\"dtype list of invalid length\")\n\n    if isinstance(required, bool):\n        required = repeat(required)\n\n    if rename is None:\n        rename = repeat(None)\n\n    d = {}\n    for (tag, ty, req, name) in zip(tags, dtypes, required, rename):\n        if tag not in self.data_dict:\n            if req:\n                raise ValueError(f\"Tag '{tag}' missing from CIF file\")\n            continue\n        try:\n            arr = numpy.array(self.data_dict[tag], dtype=ty)\n            d[name or tag] = arr\n        except TypeError:\n            raise TypeError(f\"Tag '{tag}' of invalid or heterogeneous type.\")\n\n    if len(d) == 0:\n        return polars.DataFrame({})\n\n    l = len(next(iter(d.values())))\n    if any(len(arr) != l for arr in d.values()):\n        raise ValueError(f\"Tags of mismatching lengths: {tuple(map(len, d.values()))}\")\n\n    return polars.DataFrame(d)\n</code></pre>"},{"location":"api/io/cif/#atomlib.io.cif.CIFDataBlock.cell_size","title":"<code>cell_size()</code>","text":"<p>Return cell size (in angstroms).</p> Source code in <code>atomlib/io/cif.py</code> <pre><code>def cell_size(self) -&gt; t.Optional[t.Tuple[float, float, float]]:\n    \"\"\"Return cell size (in angstroms).\"\"\"\n    try:\n        a = float(self['cell_length_a'])  # type: ignore\n        b = float(self['cell_length_b'])  # type: ignore\n        c = float(self['cell_length_c'])  # type: ignore\n        return (a, b, c)\n    except (ValueError, TypeError, KeyError):\n        return None\n</code></pre>"},{"location":"api/io/cif/#atomlib.io.cif.CIFDataBlock.cell_angle","title":"<code>cell_angle()</code>","text":"<p>Return cell angle (in degrees).</p> Source code in <code>atomlib/io/cif.py</code> <pre><code>def cell_angle(self) -&gt; t.Optional[t.Tuple[float, float, float]]:\n    \"\"\"Return cell angle (in degrees).\"\"\"\n    try:\n        a = float(self['cell_angle_alpha'])  # type: ignore\n        b = float(self['cell_angle_beta'])   # type: ignore\n        g = float(self['cell_angle_gamma'])  # type: ignore\n        return (a, b, g)\n    except (ValueError, TypeError, KeyError):\n        return None\n</code></pre>"},{"location":"api/io/cif/#atomlib.io.cif.CIFDataBlock.get_symmetry","title":"<code>get_symmetry()</code>","text":"Source code in <code>atomlib/io/cif.py</code> <pre><code>def get_symmetry(self) -&gt; t.Iterator[AffineTransform3D]:\n    syms = self.data_dict.get('space_group_symop_operation_xyz')\n    if syms is None:\n        # old name for symmetry\n        syms = self.data_dict.get('symmetry_equiv_pos_as_xyz')\n    if syms is None:\n        syms = ()\n    if not hasattr(syms, '__iter__'):\n        syms = (syms,)\n    return map(parse_symmetry, map(str, syms))  # type: ignore\n</code></pre>"},{"location":"api/io/cif/#atomlib.io.cif.CIFTable","title":"<code>CIFTable</code>  <code>dataclass</code>","text":"Source code in <code>atomlib/io/cif.py</code> <pre><code>@dataclass\nclass CIFTable:\n    data: t.Dict[str, t.List[Value]]\n\n    def _write(self, f: TextIOBase):\n        print(f\"\\nloop_\", file=f)\n        for tag in self.data.keys():\n            print(f\" _{tag}\", file=f)\n\n        for row in zip(*self.data.values()):\n            print(f' {\"  \".join(map(_format_val, row))}', file=f)\n\n        print(file=f)\n</code></pre>"},{"location":"api/io/cif/#atomlib.io.cif.CIFTable.data","title":"<code>data: t.Dict[str, t.List[Value]]</code>  <code>instance-attribute</code>","text":""},{"location":"api/io/cif/#atomlib.io.cif.SymmetryVec","title":"<code>SymmetryVec</code>","text":"Source code in <code>atomlib/io/cif.py</code> <pre><code>class SymmetryVec:\n    @classmethod\n    def parse(cls, s: str) -&gt; SymmetryVec:\n        if s[0] in ('x', 'y', 'z'):\n            a = numpy.zeros((4,))\n            a[('x', 'y', 'z').index(s[0])] += 1.\n            return cls(a)\n        return cls(float(s))\n\n    def __init__(self, val: t.Union[float, NDArray[numpy.floating]]):\n       self.inner: t.Union[float, NDArray[numpy.floating]] = val\n\n    def is_scalar(self) -&gt; bool:\n        return isinstance(self.inner, float)\n\n    def to_vec(self) -&gt; NDArray[numpy.floating]:\n        if isinstance(self.inner, (int, float)):\n            vec = numpy.zeros((4,))\n            vec[3] = self.inner\n            return vec\n        return self.inner\n\n    def __add__(self, rhs: SymmetryVec) -&gt; SymmetryVec:\n        if self.is_scalar() and rhs.is_scalar():\n            return SymmetryVec(self.inner + rhs.inner)\n        return SymmetryVec(rhs.to_vec() + self.to_vec())\n\n    def __neg__(self) -&gt; SymmetryVec:\n        return SymmetryVec(-self.inner)\n\n    def __pos__(self) -&gt; SymmetryVec:\n        return self\n\n    def __sub__(self, rhs: SymmetryVec) -&gt; SymmetryVec:\n        if self.is_scalar() and rhs.is_scalar():\n            return SymmetryVec(self.inner - rhs.inner)\n        return SymmetryVec(rhs.to_vec() - self.to_vec())\n\n    def __mul__(self, rhs: SymmetryVec) -&gt; SymmetryVec:\n        if not self.is_scalar() and not rhs.is_scalar():\n            raise ValueError(\"Can't multiply two symmetry directions\")\n        return SymmetryVec(rhs.inner * self.inner)\n\n    def __truediv__(self, rhs: SymmetryVec) -&gt; SymmetryVec:\n        if not self.is_scalar() and not rhs.is_scalar():\n            raise ValueError(\"Can't divide two symmetry directions\")\n        return SymmetryVec(rhs.inner / self.inner)\n</code></pre>"},{"location":"api/io/cif/#atomlib.io.cif.SymmetryVec.inner","title":"<code>inner: t.Union[float, NDArray[numpy.floating]] = val</code>  <code>instance-attribute</code>","text":""},{"location":"api/io/cif/#atomlib.io.cif.SymmetryVec.parse","title":"<code>parse(s)</code>  <code>classmethod</code>","text":"Source code in <code>atomlib/io/cif.py</code> <pre><code>@classmethod\ndef parse(cls, s: str) -&gt; SymmetryVec:\n    if s[0] in ('x', 'y', 'z'):\n        a = numpy.zeros((4,))\n        a[('x', 'y', 'z').index(s[0])] += 1.\n        return cls(a)\n    return cls(float(s))\n</code></pre>"},{"location":"api/io/cif/#atomlib.io.cif.SymmetryVec.is_scalar","title":"<code>is_scalar()</code>","text":"Source code in <code>atomlib/io/cif.py</code> <pre><code>def is_scalar(self) -&gt; bool:\n    return isinstance(self.inner, float)\n</code></pre>"},{"location":"api/io/cif/#atomlib.io.cif.SymmetryVec.to_vec","title":"<code>to_vec()</code>","text":"Source code in <code>atomlib/io/cif.py</code> <pre><code>def to_vec(self) -&gt; NDArray[numpy.floating]:\n    if isinstance(self.inner, (int, float)):\n        vec = numpy.zeros((4,))\n        vec[3] = self.inner\n        return vec\n    return self.inner\n</code></pre>"},{"location":"api/io/cif/#atomlib.io.cif.CifReader","title":"<code>CifReader</code>","text":"Source code in <code>atomlib/io/cif.py</code> <pre><code>class CifReader:\n    def __init__(self, file: TextIOBase):\n        self.line = 0\n        self._file: TextIOBase = file\n        self._buf: t.Optional[str] = None\n        self._after_eol = True\n        self._eof = False\n\n    def parse(self) -&gt; t.Iterator[CIFDataBlock]:\n        while True:\n            line = self.line\n            word = self.peek_word()\n            if word is None:\n                return\n            if word.lower().startswith('data_'):\n                self.next_word()\n                name = word[len('data_'):]\n            elif word.startswith('_'):\n                name = None\n            else:\n                raise ValueError(f\"While parsing line {line}: Unexpected token {word}\")\n\n            yield self.parse_datablock(name)\n\n    def after_eol(self) -&gt; bool:\n        \"\"\"\n        Returns whether the current token (the one that will be returned\n        by the next peek() or next()) is after a newline.\n        \"\"\"\n        return self._after_eol\n\n    def peek_line(self) -&gt; t.Optional[str]:\n        buf = self._try_fill_buf()\n        return buf\n\n    def next_line(self) -&gt; t.Optional[str]:\n        line = self.peek_line()\n        self._buf = None\n        return line\n\n    def next_until(self, marker: str) -&gt; t.Optional[str]:\n        \"\"\"\n        Collect words until `marker`. Because of the weirdness of CIF,\n        `marker` must occur immediately before a whitespace boundary.\n        \"\"\"\n        s = \"\"\n        buf = self._try_fill_buf()\n        if buf is None:\n            return None\n        while not (match := re.search(re.escape(marker) + r'(?=\\s|$)', buf)):\n            s += buf\n            buf = self._try_fill_buf(True)\n            if buf is None:\n                return None\n        s += buf[:match.end()]\n        self._buf = buf[match.end():]\n        if len(self._buf) == 0 or self._buf.isspace():\n            self._buf = None\n        return s\n\n    def peek_word(self) -&gt; t.Optional[str]:\n        while True:\n            buf = self._try_fill_buf()\n            if buf is None:\n                return None\n            buf = buf.lstrip()\n            if len(buf) == 0 or buf.isspace() or buf.startswith('#'):\n                # eat comment or blank line\n                self._buf = None\n                continue\n            break\n\n        #print(f\"buf: '{buf}'\")\n        return buf.split(maxsplit=1)[0]\n\n    def next_word(self) -&gt; t.Optional[str]:\n        w = self.peek_word()\n        if w is None:\n            return None\n        assert self._buf is not None\n        self._buf = self._buf.lstrip()[len(w)+1:].lstrip()\n        if len(self._buf) == 0 or self._buf.isspace():\n            # eat whitespace at end of line\n            self._buf = None\n            self._after_eol = True\n        else:\n            self._after_eol = False\n        return w\n\n    def _try_fill_buf(self, force: bool = False) -&gt; t.Optional[str]:\n        if force:\n            self._buf = None\n        if self._buf is None:\n            try:\n                self._buf = next(self._file)\n                self.line += 1\n            except StopIteration:\n                pass\n        return self._buf\n\n    def parse_bare(self) -&gt; t.Union[int, float, str]:\n        w = self.next_word()\n        if w is None:\n            raise ValueError(\"Unexpected EOF while parsing value.\")\n        if _INT_RE.fullmatch(w):\n            return int(w)  # may raise\n        if (m := _FLOAT_RE.fullmatch(w)):\n            if m[1] != '.':\n                return float(m[1])  # may raise\n        return w\n\n    def parse_datablock(self, name: t.Optional[str] = None) -&gt; CIFDataBlock:\n        logging.debug(f\"parse datablock '{name}'\")\n        #data: t.Dict[str, t.Union[t.List[Value], Value]] = {}\n\n        data: t.List[t.Union[CIFTable, t.Tuple[str, Value]]] = []\n\n        while True:\n            word = self.peek_word()\n            if word is None:\n                break\n            if word.lower() == 'loop_':\n                self.next_word()\n                data.append(self.parse_loop())\n            elif word.startswith('_'):\n                self.next_word()\n                (k, v) = (word[1:], self.parse_value())\n                logging.debug(f\"{k} = {v}\")\n                data.append((k, v))\n            else:\n                break\n\n        return CIFDataBlock(name, tuple(data))\n\n    def eat_saveframe(self):\n        line = self.line\n        while True:\n            w = self.next_word()\n            if w is None:\n                raise ValueError(f\"EOF before end of save frame starting at line {line}\")\n            if w.lower() == 'save_':\n                break\n\n    def parse_loop(self) -&gt; CIFTable:\n        line = self.line\n        tags = []\n        while True:\n            w = self.peek_word()\n            if w is None:\n                raise ValueError(f\"EOF before loop values at line {line}\")\n            if w.startswith('_'):\n                self.next_word()\n                tags.append(w[1:])\n            else:\n                break\n\n        vals: t.Tuple[t.List[Value], ...] = tuple([] for _ in tags)\n        i = 0\n\n        while True:\n            w = self.peek_word()\n            if w is None or w.startswith('_') or w.endswith('_'):\n                break\n            vals[i].append(self.parse_value())\n            i = (i + 1) % len(tags)\n\n        if i != 0:\n            n_vals = sum(map(len, vals))\n            raise ValueError(f\"While parsing loop at line {line}: \"\n                            f\"Got {n_vals} vals, expected a multiple of {len(tags)}\")\n\n        return CIFTable(dict(zip(tags, vals)))\n\n    def parse_value(self) -&gt; Value:\n        logging.debug(f\"parse_value\")\n        w = self.peek_word()\n        assert w is not None\n        if w in ('.', '?'):\n            self.next_word()\n            return None\n\n        if self.after_eol() and w == ';':\n            return self.parse_text_field()\n\n        if w[0] in ('\"', \"'\"):\n            return self.parse_quoted()\n\n        return self.parse_bare()\n\n    def parse_text_field(self) -&gt; str:\n        line = self.line\n        l = self.next_line()\n        assert l is not None\n        s = l.lstrip().removeprefix(';').lstrip()\n        while True:\n            l = self.next_line()\n            if l is None:\n                raise ValueError(f\"While parsing text field at line {line}: Unexpected EOF\")\n            if l.strip() == ';':\n                break\n            s += l\n        return s.rstrip()\n\n    def parse_quoted(self) -&gt; str:\n        line = self.line\n        w = self.peek_word()\n        assert w is not None\n        quote = w[0]\n        if quote not in ('\"', \"'\"):\n            raise ValueError(f\"While parsing string at line {line}: Invalid quote char {quote}\")\n\n        s = self.next_until(quote)\n        if s is None:\n            raise ValueError(f\"While parsing string {w}... at line {line}: Unexpected EOF\")\n        return s.lstrip()[1:-1]\n</code></pre>"},{"location":"api/io/cif/#atomlib.io.cif.CifReader.line","title":"<code>line = 0</code>  <code>instance-attribute</code>","text":""},{"location":"api/io/cif/#atomlib.io.cif.CifReader.parse","title":"<code>parse()</code>","text":"Source code in <code>atomlib/io/cif.py</code> <pre><code>def parse(self) -&gt; t.Iterator[CIFDataBlock]:\n    while True:\n        line = self.line\n        word = self.peek_word()\n        if word is None:\n            return\n        if word.lower().startswith('data_'):\n            self.next_word()\n            name = word[len('data_'):]\n        elif word.startswith('_'):\n            name = None\n        else:\n            raise ValueError(f\"While parsing line {line}: Unexpected token {word}\")\n\n        yield self.parse_datablock(name)\n</code></pre>"},{"location":"api/io/cif/#atomlib.io.cif.CifReader.after_eol","title":"<code>after_eol()</code>","text":"<p>Returns whether the current token (the one that will be returned by the next peek() or next()) is after a newline.</p> Source code in <code>atomlib/io/cif.py</code> <pre><code>def after_eol(self) -&gt; bool:\n    \"\"\"\n    Returns whether the current token (the one that will be returned\n    by the next peek() or next()) is after a newline.\n    \"\"\"\n    return self._after_eol\n</code></pre>"},{"location":"api/io/cif/#atomlib.io.cif.CifReader.peek_line","title":"<code>peek_line()</code>","text":"Source code in <code>atomlib/io/cif.py</code> <pre><code>def peek_line(self) -&gt; t.Optional[str]:\n    buf = self._try_fill_buf()\n    return buf\n</code></pre>"},{"location":"api/io/cif/#atomlib.io.cif.CifReader.next_line","title":"<code>next_line()</code>","text":"Source code in <code>atomlib/io/cif.py</code> <pre><code>def next_line(self) -&gt; t.Optional[str]:\n    line = self.peek_line()\n    self._buf = None\n    return line\n</code></pre>"},{"location":"api/io/cif/#atomlib.io.cif.CifReader.next_until","title":"<code>next_until(marker)</code>","text":"<p>Collect words until <code>marker</code>. Because of the weirdness of CIF, <code>marker</code> must occur immediately before a whitespace boundary.</p> Source code in <code>atomlib/io/cif.py</code> <pre><code>def next_until(self, marker: str) -&gt; t.Optional[str]:\n    \"\"\"\n    Collect words until `marker`. Because of the weirdness of CIF,\n    `marker` must occur immediately before a whitespace boundary.\n    \"\"\"\n    s = \"\"\n    buf = self._try_fill_buf()\n    if buf is None:\n        return None\n    while not (match := re.search(re.escape(marker) + r'(?=\\s|$)', buf)):\n        s += buf\n        buf = self._try_fill_buf(True)\n        if buf is None:\n            return None\n    s += buf[:match.end()]\n    self._buf = buf[match.end():]\n    if len(self._buf) == 0 or self._buf.isspace():\n        self._buf = None\n    return s\n</code></pre>"},{"location":"api/io/cif/#atomlib.io.cif.CifReader.peek_word","title":"<code>peek_word()</code>","text":"Source code in <code>atomlib/io/cif.py</code> <pre><code>def peek_word(self) -&gt; t.Optional[str]:\n    while True:\n        buf = self._try_fill_buf()\n        if buf is None:\n            return None\n        buf = buf.lstrip()\n        if len(buf) == 0 or buf.isspace() or buf.startswith('#'):\n            # eat comment or blank line\n            self._buf = None\n            continue\n        break\n\n    #print(f\"buf: '{buf}'\")\n    return buf.split(maxsplit=1)[0]\n</code></pre>"},{"location":"api/io/cif/#atomlib.io.cif.CifReader.next_word","title":"<code>next_word()</code>","text":"Source code in <code>atomlib/io/cif.py</code> <pre><code>def next_word(self) -&gt; t.Optional[str]:\n    w = self.peek_word()\n    if w is None:\n        return None\n    assert self._buf is not None\n    self._buf = self._buf.lstrip()[len(w)+1:].lstrip()\n    if len(self._buf) == 0 or self._buf.isspace():\n        # eat whitespace at end of line\n        self._buf = None\n        self._after_eol = True\n    else:\n        self._after_eol = False\n    return w\n</code></pre>"},{"location":"api/io/cif/#atomlib.io.cif.CifReader.parse_bare","title":"<code>parse_bare()</code>","text":"Source code in <code>atomlib/io/cif.py</code> <pre><code>def parse_bare(self) -&gt; t.Union[int, float, str]:\n    w = self.next_word()\n    if w is None:\n        raise ValueError(\"Unexpected EOF while parsing value.\")\n    if _INT_RE.fullmatch(w):\n        return int(w)  # may raise\n    if (m := _FLOAT_RE.fullmatch(w)):\n        if m[1] != '.':\n            return float(m[1])  # may raise\n    return w\n</code></pre>"},{"location":"api/io/cif/#atomlib.io.cif.CifReader.parse_datablock","title":"<code>parse_datablock(name=None)</code>","text":"Source code in <code>atomlib/io/cif.py</code> <pre><code>def parse_datablock(self, name: t.Optional[str] = None) -&gt; CIFDataBlock:\n    logging.debug(f\"parse datablock '{name}'\")\n    #data: t.Dict[str, t.Union[t.List[Value], Value]] = {}\n\n    data: t.List[t.Union[CIFTable, t.Tuple[str, Value]]] = []\n\n    while True:\n        word = self.peek_word()\n        if word is None:\n            break\n        if word.lower() == 'loop_':\n            self.next_word()\n            data.append(self.parse_loop())\n        elif word.startswith('_'):\n            self.next_word()\n            (k, v) = (word[1:], self.parse_value())\n            logging.debug(f\"{k} = {v}\")\n            data.append((k, v))\n        else:\n            break\n\n    return CIFDataBlock(name, tuple(data))\n</code></pre>"},{"location":"api/io/cif/#atomlib.io.cif.CifReader.eat_saveframe","title":"<code>eat_saveframe()</code>","text":"Source code in <code>atomlib/io/cif.py</code> <pre><code>def eat_saveframe(self):\n    line = self.line\n    while True:\n        w = self.next_word()\n        if w is None:\n            raise ValueError(f\"EOF before end of save frame starting at line {line}\")\n        if w.lower() == 'save_':\n            break\n</code></pre>"},{"location":"api/io/cif/#atomlib.io.cif.CifReader.parse_loop","title":"<code>parse_loop()</code>","text":"Source code in <code>atomlib/io/cif.py</code> <pre><code>def parse_loop(self) -&gt; CIFTable:\n    line = self.line\n    tags = []\n    while True:\n        w = self.peek_word()\n        if w is None:\n            raise ValueError(f\"EOF before loop values at line {line}\")\n        if w.startswith('_'):\n            self.next_word()\n            tags.append(w[1:])\n        else:\n            break\n\n    vals: t.Tuple[t.List[Value], ...] = tuple([] for _ in tags)\n    i = 0\n\n    while True:\n        w = self.peek_word()\n        if w is None or w.startswith('_') or w.endswith('_'):\n            break\n        vals[i].append(self.parse_value())\n        i = (i + 1) % len(tags)\n\n    if i != 0:\n        n_vals = sum(map(len, vals))\n        raise ValueError(f\"While parsing loop at line {line}: \"\n                        f\"Got {n_vals} vals, expected a multiple of {len(tags)}\")\n\n    return CIFTable(dict(zip(tags, vals)))\n</code></pre>"},{"location":"api/io/cif/#atomlib.io.cif.CifReader.parse_value","title":"<code>parse_value()</code>","text":"Source code in <code>atomlib/io/cif.py</code> <pre><code>def parse_value(self) -&gt; Value:\n    logging.debug(f\"parse_value\")\n    w = self.peek_word()\n    assert w is not None\n    if w in ('.', '?'):\n        self.next_word()\n        return None\n\n    if self.after_eol() and w == ';':\n        return self.parse_text_field()\n\n    if w[0] in ('\"', \"'\"):\n        return self.parse_quoted()\n\n    return self.parse_bare()\n</code></pre>"},{"location":"api/io/cif/#atomlib.io.cif.CifReader.parse_text_field","title":"<code>parse_text_field()</code>","text":"Source code in <code>atomlib/io/cif.py</code> <pre><code>def parse_text_field(self) -&gt; str:\n    line = self.line\n    l = self.next_line()\n    assert l is not None\n    s = l.lstrip().removeprefix(';').lstrip()\n    while True:\n        l = self.next_line()\n        if l is None:\n            raise ValueError(f\"While parsing text field at line {line}: Unexpected EOF\")\n        if l.strip() == ';':\n            break\n        s += l\n    return s.rstrip()\n</code></pre>"},{"location":"api/io/cif/#atomlib.io.cif.CifReader.parse_quoted","title":"<code>parse_quoted()</code>","text":"Source code in <code>atomlib/io/cif.py</code> <pre><code>def parse_quoted(self) -&gt; str:\n    line = self.line\n    w = self.peek_word()\n    assert w is not None\n    quote = w[0]\n    if quote not in ('\"', \"'\"):\n        raise ValueError(f\"While parsing string at line {line}: Invalid quote char {quote}\")\n\n    s = self.next_until(quote)\n    if s is None:\n        raise ValueError(f\"While parsing string {w}... at line {line}: Unexpected EOF\")\n    return s.lstrip()[1:-1]\n</code></pre>"},{"location":"api/io/cif/#atomlib.io.cif.parse_symmetry","title":"<code>parse_symmetry(s)</code>","text":"Source code in <code>atomlib/io/cif.py</code> <pre><code>def parse_symmetry(s: str) -&gt; AffineTransform3D:\n    axes = s.split(',')\n    if not len(axes) == 3:\n        raise ValueError(f\"Error parsing symmetry expression '{s}': Expected 3 values, got {len(axes)}\")\n\n    axes = [SYMMETRY_PARSER.parse(StringIO(ax)).eval(lambda v: v).to_vec() for ax in axes]\n    axes.append(numpy.array([0., 0., 0., 1.]))\n    return AffineTransform3D(numpy.stack(axes, axis=0))\n</code></pre>"},{"location":"api/io/lmp/","title":"<code>atomlib.io.lmp</code>","text":""},{"location":"api/io/lmp/#atomlib.io.lmp.LMP","title":"<code>LMP</code>  <code>dataclass</code>","text":"Source code in <code>atomlib/io/lmp.py</code> <pre><code>@dataclass\nclass LMP:\n    comment: t.Optional[str]\n    headers: t.Dict[str, t.Any]\n    sections: t.Tuple[LMPSection, ...]\n\n    def get_cell(self) -&gt; Cell:\n        dims = numpy.array([\n            self.headers.get(f\"{c}lo {c}hi\", (-0.5, 0.5))\n            for c in \"xyz\"\n        ])\n        origin = dims[:, 0]\n        tilts = self.headers.get(\"xy xz yz\", (0., 0., 0.))\n\n        ortho = numpy.diag(dims[:, 1] - dims[:, 0])\n        (ortho[0, 1], ortho[0, 2], ortho[1, 2]) = tilts\n\n        return Cell.from_ortho(LinearTransform3D(ortho).translate(origin))\n\n    def get_atoms(self, type_map: t.Optional[t.Dict[int, t.Union[str, int]]] = None) -&gt; AtomCell:\n        if type_map is not None:\n            try:\n                type_map_df = polars.DataFrame({\n                    'type': polars.Series(type_map.keys(), dtype=polars.Int32),\n                    'elem': polars.Series(list(map(get_elem, type_map.values())), dtype=polars.UInt8),\n                    'symbol': polars.Series([get_sym(v) if isinstance(v, int) else v for v in type_map.values()], dtype=polars.Utf8),\n                })\n            except ValueError as e:\n                raise ValueError(\"Invalid type map\") from e\n        else:\n            type_map_df = None\n\n        cell = self.get_cell()\n\n        def _apply_type_labels(df: polars.DataFrame, section_name: str, labels: t.Optional[polars.DataFrame] = None) -&gt; polars.DataFrame:\n            if labels is not None:\n                #df = df.with_columns(polars.col('type').replace(d, default=polars.col('type').cast(polars.Int32, strict=False), return_dtype=polars.Int32))\n                df = df.with_columns(polars.col('type').replace(labels['symbol'], labels['type'], default=polars.col('type').cast(polars.Int32, strict=False), return_dtype=polars.Int32))\n                if df['type'].is_null().any():\n                    raise ValueError(f\"While parsing section {section_name}: Unknown atom label or invalid atom type\")\n            try:\n                return df.with_columns(polars.col('type').cast(polars.Int32))\n            except polars.ComputeError:\n                raise ValueError(f\"While parsing section {section_name}: Invalid atom type(s)\")\n\n        atoms: t.Optional[polars.DataFrame] = None\n        labels: t.Optional[polars.DataFrame] = None\n        masses: t.Optional[polars.DataFrame] = None\n        velocities = None\n\n        for section in self.sections:\n            start_line = section.start_line + 1\n\n            if section.name == 'Atoms':\n                if section.style not in (None, 'atomic'):\n                    # TODO support other styles\n                    raise ValueError(f\"Only 'atomic' atom_style is supported, instead got '{section.style}'\")\n\n                atoms = parse_whitespace_separated(section.body, {\n                    'i': polars.Int64, 'type': polars.Utf8,\n                    'coords': polars.Array(polars.Float64, 3),\n                }, start_line=start_line)\n                atoms = _apply_type_labels(atoms, 'Atoms', labels)\n            elif section.name == 'Atom Type Labels':\n                labels = parse_whitespace_separated(section.body, {'type': polars.Int32, 'symbol': polars.Utf8}, start_line=start_line)\n            elif section.name == 'Masses':\n                masses = parse_whitespace_separated(section.body, {'type': polars.Utf8, 'mass': polars.Float64}, start_line=start_line)\n                masses = _apply_type_labels(masses, 'Masses', labels)\n            elif section.name == 'Velocities':\n                velocities = parse_whitespace_separated(section.body, {\n                    'i': polars.Int64, 'velocity': polars.Array(polars.Float64, 3),\n                }, start_line=start_line)\n\n        # now all 'type's should be in Int32\n\n        if atoms is None:\n            if self.headers['atoms'] &gt; 0:\n                raise ValueError(\"Missing required section 'Atoms'\")\n            return AtomCell(Atoms.empty(), cell=cell, frame='local')\n\n        # next we need to assign element symbols\n        # first, if type_map is specified, use that:\n        #if type_map_elem is not None and type_map_sym is not None:\n        if type_map_df is not None:\n            try:\n                atoms = checked_left_join(atoms, type_map_df, on='type')\n            except CheckedJoinError as e:\n                raise ValueError(f\"Missing type_map specification for atom type(s): {', '.join(map(repr, e.missing_keys))}\")\n        elif labels is not None:\n            try:\n                labels = labels.with_columns(get_elem(labels['symbol']))\n            except ValueError as e:\n                raise ValueError(\"Failed to auto-detect elements from type labels. Please pass 'type_map' explicitly\") from e\n            try:\n                atoms = checked_left_join(atoms, labels, 'type')\n            except CheckedJoinError as e:\n                raise ValueError(f\"Missing labels for atom type(s): {', '.join(map(repr, e.missing_keys))}\")\n        # otherwise we have no way\n        else:\n            raise ValueError(\"Failed to auto-detect elements from type labels. Please pass 'type_map' explicitly\")\n\n        if velocities is not None:\n            # join velocities\n            try:\n                # TODO use join_asof here?\n                atoms = checked_left_join(atoms, velocities, 'i')\n            except CheckedJoinError as e:\n                raise ValueError(f\"Missing velocities for {len(e.missing_keys)}/{len(atoms)} atoms\")\n\n        if masses is not None:\n            # join masses\n            try:\n                atoms = checked_left_join(atoms, masses, 'type')\n            except CheckedJoinError as e:\n                raise ValueError(f\"Missing masses for atom type(s): {', '.join(map(repr, e.missing_keys))}\")\n\n        return AtomCell(atoms, cell=cell, frame='local')\n\n    @staticmethod\n    def from_atoms(atoms: HasAtoms) -&gt; LMP:\n        if isinstance(atoms, HasAtomCell):\n            # we're basically converting everything to the ortho frame, but including the affine shift\n\n            # transform affine shift into ortho frame\n            origin = atoms.get_transform('ortho', 'local').to_linear().round_near_zero() \\\n                .transform(atoms.get_cell().affine.translation())\n\n            # get the orthogonalization transform only, without affine\n            ortho = atoms.get_transform('ortho', 'cell_box').to_linear().round_near_zero().inner\n\n            # get atoms in ortho frame, and then add the affine shift\n            frame = atoms.get_atoms('ortho').transform_atoms(AffineTransform3D.translate(origin)) \\\n                .round_near_zero().with_type()\n        else:\n            bbox = atoms.bbox_atoms()\n            ortho = numpy.diag(bbox.size)\n            origin = bbox.min\n\n            frame = atoms.get_atoms('local').with_type()\n\n        types = frame.unique(subset='type')\n        types = types.with_mass().sort('type')\n\n        now = localtime()\n        comment = f\"# Generated by atomlib on {now.isoformat(' ', 'seconds')}\"\n\n        headers = {}\n        sections = []\n\n        headers['atoms'] = len(frame)\n        headers['atom types'] = len(types)\n\n        for (s, low, diff) in zip(('x', 'y', 'z'), origin, ortho.diagonal()):\n            headers[f\"{s}lo {s}hi\"] = (low, low + diff)\n\n        headers['xy xz yz'] = (ortho[0, 1], ortho[0, 2], ortho[1, 2])\n\n        body = [\n            f\" {ty:8} {sym:&gt;4}\\n\"\n            for (ty, sym) in types.select('type', 'symbol').rows()\n        ]\n        sections.append(LMPSection(\"Atom Type Labels\", tuple(body)))\n\n        if 'mass' in types:\n            body = [\n                f\" {ty:8} {mass:14.7f}  # {sym}\\n\"\n                for (ty, sym, mass) in types.select(('type', 'symbol', 'mass')).rows()\n            ]\n            sections.append(LMPSection(\"Masses\", tuple(body)))\n\n        body = [\n            f\" {i+1:8} {ty:4} {x:14.7f} {y:14.7f} {z:14.7f}\\n\"\n            for (i, (ty, (x, y, z))) in enumerate(frame.select(('type', 'coords')).rows())\n        ]\n        sections.append(LMPSection(\"Atoms\", tuple(body), 'atomic'))\n\n        if (velocities := frame.velocities()) is not None:\n            body = [\n                f\" {i+1:8} {v_x:14.7f} {v_y:14.7f} {v_z:14.7f}\\n\"\n                for (i, (v_x, v_y, v_z)) in enumerate(velocities)\n            ]\n            sections.append(LMPSection(\"Velocities\", tuple(body)))\n\n        return LMP(comment, headers, tuple(sections))\n\n    @staticmethod\n    def from_file(file: FileOrPath) -&gt; LMP:\n        with open_file(file, 'r') as f:\n            return LMPReader(f).parse()\n\n    def write(self, file: FileOrPath):\n        with open_file(file, 'w') as f:\n            print((self.comment or \"\") + '\\n', file=f)\n\n            # print headers\n            for (name, val) in self.headers.items():\n                val = _HEADER_FMT.get(name, lambda s: f\"{s:8}\")(val)\n                print(f\" {val} {name}\", file=f)\n\n            # print sections\n            for section in self.sections:\n                l = section.name\n                if section.style is not None:\n                    l += f'  # {section.style}'\n                print(f\"\\n{l}\\n\", file=f)\n\n                f.writelines(section.body)\n</code></pre>"},{"location":"api/io/lmp/#atomlib.io.lmp.LMP.comment","title":"<code>comment: t.Optional[str]</code>  <code>instance-attribute</code>","text":""},{"location":"api/io/lmp/#atomlib.io.lmp.LMP.headers","title":"<code>headers: t.Dict[str, t.Any]</code>  <code>instance-attribute</code>","text":""},{"location":"api/io/lmp/#atomlib.io.lmp.LMP.sections","title":"<code>sections: t.Tuple[LMPSection, ...]</code>  <code>instance-attribute</code>","text":""},{"location":"api/io/lmp/#atomlib.io.lmp.LMP.get_cell","title":"<code>get_cell()</code>","text":"Source code in <code>atomlib/io/lmp.py</code> <pre><code>def get_cell(self) -&gt; Cell:\n    dims = numpy.array([\n        self.headers.get(f\"{c}lo {c}hi\", (-0.5, 0.5))\n        for c in \"xyz\"\n    ])\n    origin = dims[:, 0]\n    tilts = self.headers.get(\"xy xz yz\", (0., 0., 0.))\n\n    ortho = numpy.diag(dims[:, 1] - dims[:, 0])\n    (ortho[0, 1], ortho[0, 2], ortho[1, 2]) = tilts\n\n    return Cell.from_ortho(LinearTransform3D(ortho).translate(origin))\n</code></pre>"},{"location":"api/io/lmp/#atomlib.io.lmp.LMP.get_atoms","title":"<code>get_atoms(type_map=None)</code>","text":"Source code in <code>atomlib/io/lmp.py</code> <pre><code>def get_atoms(self, type_map: t.Optional[t.Dict[int, t.Union[str, int]]] = None) -&gt; AtomCell:\n    if type_map is not None:\n        try:\n            type_map_df = polars.DataFrame({\n                'type': polars.Series(type_map.keys(), dtype=polars.Int32),\n                'elem': polars.Series(list(map(get_elem, type_map.values())), dtype=polars.UInt8),\n                'symbol': polars.Series([get_sym(v) if isinstance(v, int) else v for v in type_map.values()], dtype=polars.Utf8),\n            })\n        except ValueError as e:\n            raise ValueError(\"Invalid type map\") from e\n    else:\n        type_map_df = None\n\n    cell = self.get_cell()\n\n    def _apply_type_labels(df: polars.DataFrame, section_name: str, labels: t.Optional[polars.DataFrame] = None) -&gt; polars.DataFrame:\n        if labels is not None:\n            #df = df.with_columns(polars.col('type').replace(d, default=polars.col('type').cast(polars.Int32, strict=False), return_dtype=polars.Int32))\n            df = df.with_columns(polars.col('type').replace(labels['symbol'], labels['type'], default=polars.col('type').cast(polars.Int32, strict=False), return_dtype=polars.Int32))\n            if df['type'].is_null().any():\n                raise ValueError(f\"While parsing section {section_name}: Unknown atom label or invalid atom type\")\n        try:\n            return df.with_columns(polars.col('type').cast(polars.Int32))\n        except polars.ComputeError:\n            raise ValueError(f\"While parsing section {section_name}: Invalid atom type(s)\")\n\n    atoms: t.Optional[polars.DataFrame] = None\n    labels: t.Optional[polars.DataFrame] = None\n    masses: t.Optional[polars.DataFrame] = None\n    velocities = None\n\n    for section in self.sections:\n        start_line = section.start_line + 1\n\n        if section.name == 'Atoms':\n            if section.style not in (None, 'atomic'):\n                # TODO support other styles\n                raise ValueError(f\"Only 'atomic' atom_style is supported, instead got '{section.style}'\")\n\n            atoms = parse_whitespace_separated(section.body, {\n                'i': polars.Int64, 'type': polars.Utf8,\n                'coords': polars.Array(polars.Float64, 3),\n            }, start_line=start_line)\n            atoms = _apply_type_labels(atoms, 'Atoms', labels)\n        elif section.name == 'Atom Type Labels':\n            labels = parse_whitespace_separated(section.body, {'type': polars.Int32, 'symbol': polars.Utf8}, start_line=start_line)\n        elif section.name == 'Masses':\n            masses = parse_whitespace_separated(section.body, {'type': polars.Utf8, 'mass': polars.Float64}, start_line=start_line)\n            masses = _apply_type_labels(masses, 'Masses', labels)\n        elif section.name == 'Velocities':\n            velocities = parse_whitespace_separated(section.body, {\n                'i': polars.Int64, 'velocity': polars.Array(polars.Float64, 3),\n            }, start_line=start_line)\n\n    # now all 'type's should be in Int32\n\n    if atoms is None:\n        if self.headers['atoms'] &gt; 0:\n            raise ValueError(\"Missing required section 'Atoms'\")\n        return AtomCell(Atoms.empty(), cell=cell, frame='local')\n\n    # next we need to assign element symbols\n    # first, if type_map is specified, use that:\n    #if type_map_elem is not None and type_map_sym is not None:\n    if type_map_df is not None:\n        try:\n            atoms = checked_left_join(atoms, type_map_df, on='type')\n        except CheckedJoinError as e:\n            raise ValueError(f\"Missing type_map specification for atom type(s): {', '.join(map(repr, e.missing_keys))}\")\n    elif labels is not None:\n        try:\n            labels = labels.with_columns(get_elem(labels['symbol']))\n        except ValueError as e:\n            raise ValueError(\"Failed to auto-detect elements from type labels. Please pass 'type_map' explicitly\") from e\n        try:\n            atoms = checked_left_join(atoms, labels, 'type')\n        except CheckedJoinError as e:\n            raise ValueError(f\"Missing labels for atom type(s): {', '.join(map(repr, e.missing_keys))}\")\n    # otherwise we have no way\n    else:\n        raise ValueError(\"Failed to auto-detect elements from type labels. Please pass 'type_map' explicitly\")\n\n    if velocities is not None:\n        # join velocities\n        try:\n            # TODO use join_asof here?\n            atoms = checked_left_join(atoms, velocities, 'i')\n        except CheckedJoinError as e:\n            raise ValueError(f\"Missing velocities for {len(e.missing_keys)}/{len(atoms)} atoms\")\n\n    if masses is not None:\n        # join masses\n        try:\n            atoms = checked_left_join(atoms, masses, 'type')\n        except CheckedJoinError as e:\n            raise ValueError(f\"Missing masses for atom type(s): {', '.join(map(repr, e.missing_keys))}\")\n\n    return AtomCell(atoms, cell=cell, frame='local')\n</code></pre>"},{"location":"api/io/lmp/#atomlib.io.lmp.LMP.from_atoms","title":"<code>from_atoms(atoms)</code>  <code>staticmethod</code>","text":"Source code in <code>atomlib/io/lmp.py</code> <pre><code>@staticmethod\ndef from_atoms(atoms: HasAtoms) -&gt; LMP:\n    if isinstance(atoms, HasAtomCell):\n        # we're basically converting everything to the ortho frame, but including the affine shift\n\n        # transform affine shift into ortho frame\n        origin = atoms.get_transform('ortho', 'local').to_linear().round_near_zero() \\\n            .transform(atoms.get_cell().affine.translation())\n\n        # get the orthogonalization transform only, without affine\n        ortho = atoms.get_transform('ortho', 'cell_box').to_linear().round_near_zero().inner\n\n        # get atoms in ortho frame, and then add the affine shift\n        frame = atoms.get_atoms('ortho').transform_atoms(AffineTransform3D.translate(origin)) \\\n            .round_near_zero().with_type()\n    else:\n        bbox = atoms.bbox_atoms()\n        ortho = numpy.diag(bbox.size)\n        origin = bbox.min\n\n        frame = atoms.get_atoms('local').with_type()\n\n    types = frame.unique(subset='type')\n    types = types.with_mass().sort('type')\n\n    now = localtime()\n    comment = f\"# Generated by atomlib on {now.isoformat(' ', 'seconds')}\"\n\n    headers = {}\n    sections = []\n\n    headers['atoms'] = len(frame)\n    headers['atom types'] = len(types)\n\n    for (s, low, diff) in zip(('x', 'y', 'z'), origin, ortho.diagonal()):\n        headers[f\"{s}lo {s}hi\"] = (low, low + diff)\n\n    headers['xy xz yz'] = (ortho[0, 1], ortho[0, 2], ortho[1, 2])\n\n    body = [\n        f\" {ty:8} {sym:&gt;4}\\n\"\n        for (ty, sym) in types.select('type', 'symbol').rows()\n    ]\n    sections.append(LMPSection(\"Atom Type Labels\", tuple(body)))\n\n    if 'mass' in types:\n        body = [\n            f\" {ty:8} {mass:14.7f}  # {sym}\\n\"\n            for (ty, sym, mass) in types.select(('type', 'symbol', 'mass')).rows()\n        ]\n        sections.append(LMPSection(\"Masses\", tuple(body)))\n\n    body = [\n        f\" {i+1:8} {ty:4} {x:14.7f} {y:14.7f} {z:14.7f}\\n\"\n        for (i, (ty, (x, y, z))) in enumerate(frame.select(('type', 'coords')).rows())\n    ]\n    sections.append(LMPSection(\"Atoms\", tuple(body), 'atomic'))\n\n    if (velocities := frame.velocities()) is not None:\n        body = [\n            f\" {i+1:8} {v_x:14.7f} {v_y:14.7f} {v_z:14.7f}\\n\"\n            for (i, (v_x, v_y, v_z)) in enumerate(velocities)\n        ]\n        sections.append(LMPSection(\"Velocities\", tuple(body)))\n\n    return LMP(comment, headers, tuple(sections))\n</code></pre>"},{"location":"api/io/lmp/#atomlib.io.lmp.LMP.from_file","title":"<code>from_file(file)</code>  <code>staticmethod</code>","text":"Source code in <code>atomlib/io/lmp.py</code> <pre><code>@staticmethod\ndef from_file(file: FileOrPath) -&gt; LMP:\n    with open_file(file, 'r') as f:\n        return LMPReader(f).parse()\n</code></pre>"},{"location":"api/io/lmp/#atomlib.io.lmp.LMP.write","title":"<code>write(file)</code>","text":"Source code in <code>atomlib/io/lmp.py</code> <pre><code>def write(self, file: FileOrPath):\n    with open_file(file, 'w') as f:\n        print((self.comment or \"\") + '\\n', file=f)\n\n        # print headers\n        for (name, val) in self.headers.items():\n            val = _HEADER_FMT.get(name, lambda s: f\"{s:8}\")(val)\n            print(f\" {val} {name}\", file=f)\n\n        # print sections\n        for section in self.sections:\n            l = section.name\n            if section.style is not None:\n                l += f'  # {section.style}'\n            print(f\"\\n{l}\\n\", file=f)\n\n            f.writelines(section.body)\n</code></pre>"},{"location":"api/io/lmp/#atomlib.io.lmp.LMPSection","title":"<code>LMPSection</code>  <code>dataclass</code>","text":"Source code in <code>atomlib/io/lmp.py</code> <pre><code>@dataclass\nclass LMPSection:\n    name: str\n    body: t.Tuple[str, ...]\n    style: t.Optional[str] = None\n    start_line: int = 0\n</code></pre>"},{"location":"api/io/lmp/#atomlib.io.lmp.LMPSection.name","title":"<code>name: str</code>  <code>instance-attribute</code>","text":""},{"location":"api/io/lmp/#atomlib.io.lmp.LMPSection.body","title":"<code>body: t.Tuple[str, ...]</code>  <code>instance-attribute</code>","text":""},{"location":"api/io/lmp/#atomlib.io.lmp.LMPSection.style","title":"<code>style: t.Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/io/lmp/#atomlib.io.lmp.LMPSection.start_line","title":"<code>start_line: int = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/io/lmp/#atomlib.io.lmp.LMPReader","title":"<code>LMPReader</code>","text":"Source code in <code>atomlib/io/lmp.py</code> <pre><code>class LMPReader:\n    def __init__(self, f: TextIOBase):\n        self.line = 0\n        self._file: TextIOBase = f\n        self._buf: t.Optional[str] = None\n\n    def _split_comment(self, line: str) -&gt; t.Tuple[str, t.Optional[str]]:\n        split = _COMMENT_RE.split(line, maxsplit=1)\n        return (split[0], split[1] if len(split) &gt; 1 else None)\n\n    def parse(self) -&gt; LMP:\n        # parse comment\n        comment = self.next_line(skip_blank=False)\n        if comment is None:\n            raise ValueError(\"Unexpected EOF (file is blank)\")\n        if comment.isspace():\n            comment = None\n        else:\n            comment = comment[:-1]\n\n        headers = self.parse_headers()\n        sections = self.parse_sections(headers)\n\n        return LMP(comment, headers, sections)\n\n    def parse_headers(self) -&gt; t.Dict[str, t.Any]:\n        headers: t.Dict[str, t.Any] = {}\n        while True:\n            line = self.peek_line()\n            if line is None:\n                break\n            body = self._split_comment(line)[0]\n\n            if (match := _HEADER_KW_RE.search(body)) is None:\n                # probably a body\n                break\n            self.next_line()\n\n            name = match[0]\n            value = body[:match.start(0)].strip()\n\n            try:\n                if name in _HEADER_PARSE:\n                    value = _HEADER_PARSE[name](value)\n            except Exception as e:\n                raise ValueError(f\"While parsing header '{name}' at line {self.line}: Failed to parse value '{value}\") from e\n\n            #print(f\"header {name} =&gt; {value} (type {type(value)})\")\n            headers[name] = value\n\n        return headers\n\n    def parse_sections(self, headers: t.Dict[str, t.Any]) -&gt; t.Tuple[LMPSection, ...]:\n        first = True\n\n        sections: t.List[LMPSection] = []\n\n        while True:\n            start_line = self.line\n            line = self.next_line()\n            if line is None:\n                break\n            name, comment = self._split_comment(line)\n            name = name.strip()\n\n            try:\n                n_lines_header = _SECTION_KWS[name]\n            except KeyError:\n                if first:\n                    raise ValueError(f\"While parsing line {self.line}: Unknown header or section keyword '{line}'\") from None\n                else:\n                    raise ValueError(f\"While parsing line {self.line}: Unknown section keyword '{line}'\") from None\n\n            try:\n                if n_lines_header is None:\n                    # special case for PairIJ Coeffs:\n                    n = int(headers['atom types'])\n                    n_lines = (n * (n + 1)) // 2\n                else:\n                    n_lines = int(headers[n_lines_header])\n            except KeyError:\n                raise ValueError(f\"While parsing body section '{name}' at line {self.line}: \"\n                                 f\"Missing required header '{n_lines_header or 'atom types'}'\") from None\n\n            style = comment if name in _SECTION_STYLE_KWS else None\n            if style is not None:\n                style = style.strip()\n\n            #print(f\"section '{name}' @ {self.line}, {n_lines} lines, style {style}\")\n\n            lines = self.collect_lines(n_lines)\n            if lines is None:\n                raise ValueError(f\"While parsing body section '{name}' starting at line {self.line}: \"\n                                 f\"Unexpected EOF before {n_lines} lines were read\")\n\n            sections.append(LMPSection(\n                name, tuple(lines), style, start_line\n            ))\n            first = False\n\n        return tuple(sections)\n\n    def _try_fill_buf(self, skip_blank: bool = True) -&gt; t.Optional[str]:\n        if self._buf is None:\n            try:\n                # skip blank lines\n                while True:\n                    self._buf = next(self._file)\n                    self.line += 1\n                    if not (skip_blank and self._buf.isspace()):\n                        break\n            except StopIteration:\n                pass\n        return self._buf\n\n    def peek_line(self, skip_blank: bool = True) -&gt; t.Optional[str]:\n        return self._try_fill_buf(skip_blank)\n\n    def next_line(self, skip_blank: bool = True) -&gt; t.Optional[str]:\n        line = self._try_fill_buf(skip_blank)\n        self._buf = None\n        return line\n\n    def collect_lines(self, n: int) -&gt; t.Optional[t.List[str]]:\n        assert self._buf is None\n        lines = []\n        try:\n            for _ in range(n):\n                while True:\n                    l = next(self._file)\n                    if not l.isspace():\n                        lines.append(l)\n                        break\n        except StopIteration:\n            return None\n        self.line += n\n        return lines\n</code></pre>"},{"location":"api/io/lmp/#atomlib.io.lmp.LMPReader.line","title":"<code>line = 0</code>  <code>instance-attribute</code>","text":""},{"location":"api/io/lmp/#atomlib.io.lmp.LMPReader.parse","title":"<code>parse()</code>","text":"Source code in <code>atomlib/io/lmp.py</code> <pre><code>def parse(self) -&gt; LMP:\n    # parse comment\n    comment = self.next_line(skip_blank=False)\n    if comment is None:\n        raise ValueError(\"Unexpected EOF (file is blank)\")\n    if comment.isspace():\n        comment = None\n    else:\n        comment = comment[:-1]\n\n    headers = self.parse_headers()\n    sections = self.parse_sections(headers)\n\n    return LMP(comment, headers, sections)\n</code></pre>"},{"location":"api/io/lmp/#atomlib.io.lmp.LMPReader.parse_headers","title":"<code>parse_headers()</code>","text":"Source code in <code>atomlib/io/lmp.py</code> <pre><code>def parse_headers(self) -&gt; t.Dict[str, t.Any]:\n    headers: t.Dict[str, t.Any] = {}\n    while True:\n        line = self.peek_line()\n        if line is None:\n            break\n        body = self._split_comment(line)[0]\n\n        if (match := _HEADER_KW_RE.search(body)) is None:\n            # probably a body\n            break\n        self.next_line()\n\n        name = match[0]\n        value = body[:match.start(0)].strip()\n\n        try:\n            if name in _HEADER_PARSE:\n                value = _HEADER_PARSE[name](value)\n        except Exception as e:\n            raise ValueError(f\"While parsing header '{name}' at line {self.line}: Failed to parse value '{value}\") from e\n\n        #print(f\"header {name} =&gt; {value} (type {type(value)})\")\n        headers[name] = value\n\n    return headers\n</code></pre>"},{"location":"api/io/lmp/#atomlib.io.lmp.LMPReader.parse_sections","title":"<code>parse_sections(headers)</code>","text":"Source code in <code>atomlib/io/lmp.py</code> <pre><code>def parse_sections(self, headers: t.Dict[str, t.Any]) -&gt; t.Tuple[LMPSection, ...]:\n    first = True\n\n    sections: t.List[LMPSection] = []\n\n    while True:\n        start_line = self.line\n        line = self.next_line()\n        if line is None:\n            break\n        name, comment = self._split_comment(line)\n        name = name.strip()\n\n        try:\n            n_lines_header = _SECTION_KWS[name]\n        except KeyError:\n            if first:\n                raise ValueError(f\"While parsing line {self.line}: Unknown header or section keyword '{line}'\") from None\n            else:\n                raise ValueError(f\"While parsing line {self.line}: Unknown section keyword '{line}'\") from None\n\n        try:\n            if n_lines_header is None:\n                # special case for PairIJ Coeffs:\n                n = int(headers['atom types'])\n                n_lines = (n * (n + 1)) // 2\n            else:\n                n_lines = int(headers[n_lines_header])\n        except KeyError:\n            raise ValueError(f\"While parsing body section '{name}' at line {self.line}: \"\n                             f\"Missing required header '{n_lines_header or 'atom types'}'\") from None\n\n        style = comment if name in _SECTION_STYLE_KWS else None\n        if style is not None:\n            style = style.strip()\n\n        #print(f\"section '{name}' @ {self.line}, {n_lines} lines, style {style}\")\n\n        lines = self.collect_lines(n_lines)\n        if lines is None:\n            raise ValueError(f\"While parsing body section '{name}' starting at line {self.line}: \"\n                             f\"Unexpected EOF before {n_lines} lines were read\")\n\n        sections.append(LMPSection(\n            name, tuple(lines), style, start_line\n        ))\n        first = False\n\n    return tuple(sections)\n</code></pre>"},{"location":"api/io/lmp/#atomlib.io.lmp.LMPReader.peek_line","title":"<code>peek_line(skip_blank=True)</code>","text":"Source code in <code>atomlib/io/lmp.py</code> <pre><code>def peek_line(self, skip_blank: bool = True) -&gt; t.Optional[str]:\n    return self._try_fill_buf(skip_blank)\n</code></pre>"},{"location":"api/io/lmp/#atomlib.io.lmp.LMPReader.next_line","title":"<code>next_line(skip_blank=True)</code>","text":"Source code in <code>atomlib/io/lmp.py</code> <pre><code>def next_line(self, skip_blank: bool = True) -&gt; t.Optional[str]:\n    line = self._try_fill_buf(skip_blank)\n    self._buf = None\n    return line\n</code></pre>"},{"location":"api/io/lmp/#atomlib.io.lmp.LMPReader.collect_lines","title":"<code>collect_lines(n)</code>","text":"Source code in <code>atomlib/io/lmp.py</code> <pre><code>def collect_lines(self, n: int) -&gt; t.Optional[t.List[str]]:\n    assert self._buf is None\n    lines = []\n    try:\n        for _ in range(n):\n            while True:\n                l = next(self._file)\n                if not l.isspace():\n                    lines.append(l)\n                    break\n    except StopIteration:\n        return None\n    self.line += n\n    return lines\n</code></pre>"},{"location":"api/io/lmp/#atomlib.io.lmp.write_lmp","title":"<code>write_lmp(atoms, f)</code>","text":"Source code in <code>atomlib/io/lmp.py</code> <pre><code>def write_lmp(atoms: HasAtoms, f: FileOrPath):\n    LMP.from_atoms(atoms).write(f)\n    return\n</code></pre>"},{"location":"api/io/mp_api/","title":"<code>atomlib.io.mp_api</code>","text":""},{"location":"api/io/mp_api/#atomlib.io.mp_api.get_api_key","title":"<code>get_api_key(key=None)</code>","text":"Source code in <code>atomlib/io/mp_api.py</code> <pre><code>def get_api_key(key: t.Optional[str] = None) -&gt; str:\n    try:\n        return environ['MP_API_KEY']\n    except KeyError:\n        raise RuntimeError(\"No materials project API key specified. \"\n                           \"Either pass `api_key` or set `MP_API_KEY` in your environment.\") from None\n</code></pre>"},{"location":"api/io/mp_api/#atomlib.io.mp_api.get_api_endpoint","title":"<code>get_api_endpoint()</code>","text":"Source code in <code>atomlib/io/mp_api.py</code> <pre><code>def get_api_endpoint() -&gt; str:\n    return environ.get(\"MP_API_ENDPOINT\") or \"https://api.materialsproject.org/\"\n</code></pre>"},{"location":"api/io/mp_api/#atomlib.io.mp_api.resolve_id","title":"<code>resolve_id(id)</code>","text":"Source code in <code>atomlib/io/mp_api.py</code> <pre><code>def resolve_id(id: t.Union[str, int]) -&gt; str:\n    if isinstance(id, int):\n        return str(id)\n    if id.lower().startswith('mp-'):\n        return id[3:]\n    return id\n</code></pre>"},{"location":"api/io/mp_api/#atomlib.io.mp_api.load_materials_project","title":"<code>load_materials_project(id, *, api_key=None, api_endpoint=None)</code>","text":"Source code in <code>atomlib/io/mp_api.py</code> <pre><code>def load_materials_project(id: t.Union[str, int], *, api_key: t.Optional[str] = None,\n                           api_endpoint: t.Optional[str] = None) -&gt; AtomCell:\n    id = resolve_id(id)\n    api_key = api_key or get_api_key()\n    if len(api_key) != 32:\n        raise RuntimeError(\"Materials project API key must be a 32-character alphanumeric string. \"\n                           f\"Instead got '{api_key}' of length '{len(api_key)}'.\")\n    api_endpoint = (api_endpoint or get_api_endpoint()).rstrip('/')\n\n    logging.info(f\"Fetching structure mp-{id} from materials project...\")\n    response: requests.Response = requests.get(\n        api_endpoint + f'/materials/core/mp-{id}/',\n        headers={'X-Api-Key': api_key},\n        params={'_fields': 'structure'}\n    )\n    try:\n        response.raise_for_status()\n    except requests.HTTPError as e:\n        raise ValueError(f\"Failed to fetch structure 'mp-{id}'\") from e\n    try:\n        data = response.json()['data'][0]\n        structure = data['structure']\n    except (KeyError, ValueError, TypeError) as e:\n        raise ValueError(f\"Unexpected API response: {response}\") from e\n\n    ortho = LinearTransform3D(numpy.array(structure['lattice']['matrix']).T)\n    sites = structure['sites']\n\n    rows = []\n    for site in sites:\n        (x, y, z) = site['xyz']\n        for species in site['species']:\n            rows.append({\n                'symbol': site['label'],\n                'elem': get_elem(species['element']),\n                'x': x, 'y': y, 'z': z,\n                'frac': species['occu'],\n                **site['properties'],\n            })\n\n    frame = Atoms(rows, orient='row')\n    return AtomCell.from_ortho(frame, ortho)\n</code></pre>"},{"location":"api/io/mslice/","title":"<code>atomlib.io.mslice</code>","text":"<p>IO support for the pyMultislicer XML file format.</p> <p>Writes mslice files with the help of a user-supplied template.</p>"},{"location":"api/io/mslice/#atomlib.io.mslice.ElementTree","title":"<code>ElementTree = et._ElementTree</code>  <code>module-attribute</code>","text":""},{"location":"api/io/mslice/#atomlib.io.mslice.Element","title":"<code>Element = et._Element</code>  <code>module-attribute</code>","text":""},{"location":"api/io/mslice/#atomlib.io.mslice.MSliceFile","title":"<code>MSliceFile = t.Union[ElementTree, FileOrPath]</code>  <code>module-attribute</code>","text":""},{"location":"api/io/mslice/#atomlib.io.mslice.DEFAULT_TEMPLATE_PATH","title":"<code>DEFAULT_TEMPLATE_PATH = files('atomlib.data') / 'template.mslice'</code>  <code>module-attribute</code>","text":""},{"location":"api/io/mslice/#atomlib.io.mslice.DEFAULT_TEMPLATE","title":"<code>DEFAULT_TEMPLATE: t.Optional[ElementTree] = None</code>  <code>module-attribute</code>","text":""},{"location":"api/io/mslice/#atomlib.io.mslice.default_template","title":"<code>default_template()</code>","text":"Source code in <code>atomlib/io/mslice.py</code> <pre><code>def default_template() -&gt; ElementTree:\n    global DEFAULT_TEMPLATE\n\n    if DEFAULT_TEMPLATE is None:\n        with DEFAULT_TEMPLATE_PATH.open('r') as f:  # type: ignore\n            DEFAULT_TEMPLATE = t.cast(ElementTree, et.parse(f, None))\n\n    return deepcopy(DEFAULT_TEMPLATE)\n</code></pre>"},{"location":"api/io/mslice/#atomlib.io.mslice.convert_xml_value","title":"<code>convert_xml_value(val, ty)</code>","text":"<p>Convert an XML value <code>val</code> to a Python type determined by the XML type name <code>ty</code>.</p> Source code in <code>atomlib/io/mslice.py</code> <pre><code>def convert_xml_value(val, ty):\n    \"\"\"Convert an XML value `val` to a Python type determined by the XML type name `ty`.\"\"\"\n    if ty == 'string':\n        ty = 'str'\n    elif ty == 'int16' or ty == 'int32':\n        val = val.split('.')[0]\n        ty = 'int'\n    elif ty == 'bool':\n        val = int(val)\n\n    return getattr(builtins, ty)(val)\n</code></pre>"},{"location":"api/io/mslice/#atomlib.io.mslice.parse_xml_object","title":"<code>parse_xml_object(obj)</code>","text":"<p>Parse the attributes of a passed XML object.</p> Source code in <code>atomlib/io/mslice.py</code> <pre><code>def parse_xml_object(obj: Element) -&gt; t.Dict[str, t.Any]:\n    \"\"\"Parse the attributes of a passed XML object.\"\"\"\n    params = {}\n    for attr in t.cast(t.Iterator[Element], obj.iter(None)):\n        if attr.tag == 'attribute':\n            params[attr.attrib['name']] = convert_xml_value(attr.text, attr.attrib['type'])\n        elif attr.tag == 'relationship':\n            # todo give this a better API\n            if 'idrefs' in attr.attrib:\n                params[f\"{attr.attrib['name']}ID\"] = attr.attrib['idrefs']\n    return params\n</code></pre>"},{"location":"api/io/mslice/#atomlib.io.mslice.find_xml_object","title":"<code>find_xml_object(xml, typename)</code>","text":"<p>Find and parse XML objects named <code>typename</code>, flattening them into a single Dict.</p> Source code in <code>atomlib/io/mslice.py</code> <pre><code>def find_xml_object(xml: Element, typename: str) -&gt; t.Dict[str, t.Any]:\n    \"\"\"Find and parse XML objects named `typename`, flattening them into a single Dict.\"\"\"\n    params = {}\n    for obj in xml.findall(f\".//*[@type='{typename}']\", None):\n        params.update(parse_xml_object(obj))\n    return params\n</code></pre>"},{"location":"api/io/mslice/#atomlib.io.mslice.find_xml_object_list","title":"<code>find_xml_object_list(xml, typename)</code>","text":"<p>Find and parse a list of XML objects named <code>typename</code>.</p> Source code in <code>atomlib/io/mslice.py</code> <pre><code>def find_xml_object_list(xml: Element, typename: str) -&gt; t.List[t.Any]:\n    \"\"\"Find and parse a list of XML objects named `typename`.\"\"\"\n    return [parse_xml_object(obj) for obj in xml.findall(f\".//*[@type='{typename}']\", None)]\n</code></pre>"},{"location":"api/io/mslice/#atomlib.io.mslice.find_xml_object_dict","title":"<code>find_xml_object_dict(xml, typename, key='id')</code>","text":"<p>Find and parse XML objects named <code>typename</code>, combining them into a dict.</p> Source code in <code>atomlib/io/mslice.py</code> <pre><code>def find_xml_object_dict(xml: Element, typename: str, key: str = \"id\") -&gt; t.Dict[str, t.Any]:\n    \"\"\"Find and parse XML objects named `typename`, combining them into a dict.\"\"\"\n    return {\n        obj.attrib[key]: parse_xml_object(obj)\n        for obj in xml.findall(f\".//*[@type='{typename}']\", None)\n    }\n</code></pre>"},{"location":"api/io/mslice/#atomlib.io.mslice.read_mslice","title":"<code>read_mslice(path)</code>","text":"Source code in <code>atomlib/io/mslice.py</code> <pre><code>def read_mslice(path: MSliceFile) -&gt; AtomCell:\n    tree: ElementTree\n    if isinstance(path, ElementTree):\n        tree = path\n    else:\n        with open_file(path, 'r') as temp:\n            tree = et.parse(temp, None)\n\n    xml: Element = tree.getroot()\n\n    structure = find_xml_object(xml, \"STRUCTURE\")\n    structure_atoms = find_xml_object_list(xml, \"STRUCTUREATOM\")\n\n    n_cells = tuple(structure.get(k, 1) for k in ('repeata', 'repeatb', 'repeatc'))\n    cell_size = tuple(structure[k] for k in ('aparam', 'bparam', 'cparam'))\n\n    atoms = Atoms(\n        polars.from_dicts(structure_atoms, schema={\n            'atomicnumber': polars.UInt8,\n            'x': polars.Float64, 'y': polars.Float64, 'z': polars.Float64,\n            'wobble': polars.Float64, 'fracoccupancy': polars.Float64,\n        })\n        .rename({'atomicnumber': 'elem', 'fracoccupancy': 'frac_occupancy'}) \\\n        # 1d sigma -&gt; &lt;u^2&gt;\n        .with_columns((3. * polars.col('wobble')**2).alias('wobble'))\n    )\n    cell = Cell.from_ortho(LinearTransform3D.scale(cell_size), n_cells, [True, True, False])\n\n    return AtomCell(atoms, cell, frame='cell_frac')\n</code></pre>"},{"location":"api/io/mslice/#atomlib.io.mslice.write_mslice","title":"<code>write_mslice(cell, f, template=None, *, slice_thickness=None, scan_points=None, scan_extent=None, noise_sigma=None, conv_angle=None, energy=None, defocus=None, tilt=None, tds=None, n_cells=None)</code>","text":"<p>Write a structure to an mslice file. The structure must be orthogonal and aligned with the local coordinate system. It should be periodic in X and Y.</p> <p><code>template</code> may be a file, path, or ElementTree containing an existing mslice file. Its structure will be modified to make the final output. If not specified, a default template will be used.</p> <p>Additional options modify simulation properties. If an option is not specified, the template's properties are used.</p> Source code in <code>atomlib/io/mslice.py</code> <pre><code>def write_mslice(cell: HasAtomCell, f: BinaryFileOrPath, template: t.Optional[MSliceFile] = None, *,\n                 slice_thickness: t.Optional[float] = None,  # angstrom\n                 scan_points: t.Optional[ArrayLike] = None,\n                 scan_extent: t.Optional[ArrayLike] = None,\n                 noise_sigma: t.Optional[float] = None,  # angstrom\n                 conv_angle: t.Optional[float] = None,  # mrad\n                 energy: t.Optional[float] = None,  # keV\n                 defocus: t.Optional[float] = None,  # angstrom\n                 tilt: t.Optional[t.Tuple[float, float]] = None,  # (mrad, mrad)\n                 tds: t.Optional[bool] = None,\n                 n_cells: t.Optional[ArrayLike] = None):\n    \"\"\"\n    Write a structure to an mslice file. The structure must be orthogonal and aligned\n    with the local coordinate system. It should be periodic in X and Y.\n\n    ``template`` may be a file, path, or ElementTree containing an existing mslice file.\n    Its structure will be modified to make the final output. If not specified, a default\n    template will be used.\n\n    Additional options modify simulation properties. If an option is not specified, the\n    template's properties are used.\n    \"\"\"\n    #if not issubclass(type(cell), HasAtomCell):\n    #    raise TypeError(\"mslice format requires an AtomCell.\")\n\n    if not cell.is_orthogonal_in_local():\n        raise ValueError(\"mslice requires an orthogonal AtomCell.\")\n\n    if not numpy.all(cell.pbc[:2]):\n        warn(\"AtomCell may not be periodic\", UserWarning, stacklevel=2)\n\n    box_size = cell._box_size_in_local()\n\n    # get atoms in local frame (which we verified aligns with the cell's axes)\n    # then scale into fractional coordinates\n    atoms = cell.get_atoms('linear') \\\n        .transform(AffineTransform3D.scale(1/box_size)) \\\n        .with_wobble().with_occupancy()\n\n    out: ElementTree\n    if template is None:\n        out = default_template()\n    elif not isinstance(template, ElementTree):\n        with open_file(template, 'r') as temp:\n            out = et.parse(temp, None)\n    else:\n        out = deepcopy(template)\n\n    # TODO clean up this code\n    db: t.Optional[Element] = out.getroot() if out.getroot().tag == 'database' else out.find(\"./database\", None)\n    if db is None:\n        raise ValueError(\"Couldn't find 'database' tag in template.\")\n\n    struct = db.find(\".//object[@type='STRUCTURE']\", None)\n    if struct is None:\n        raise ValueError(\"Couldn't find STRUCTURE object in template.\")\n\n    params = db.find(\".//object[@type='SIMPARAMETERS']\", None)\n    if params is None:\n        raise ValueError(\"Couldn't find SIMPARAMETERS object in template.\")\n\n    microscope = db.find(\".//object[@type='MICROSCOPE']\", None)\n    if microscope is None:\n        raise ValueError(\"Couldn't find MICROSCOPE object in template.\")\n\n    scan = db.find(\".//object[@type='SCAN']\", None)\n    aberrations = db.findall(\".//object[@type='ABERRATION']\", None)\n\n    def set_attr(struct: Element, name: str, type: str, val: str):\n        node = t.cast(t.Optional[Element], struct.find(f\".//attribute[@name='{name}']\", None))\n        if node is None:\n            node = t.cast(Element, et.Element('attribute', dict(name=name, type=type), None))\n            struct.append(node)\n        else:\n            node.attrib['type'] = type\n        node.text = val  # type: ignore\n\n    def parse_xml_object(obj: Element) -&gt; t.Dict[str, t.Any]:\n        \"\"\"Parse the attributes of a passed XML object.\"\"\"\n        params = {}\n        for attr in obj.iterchildren(None):\n            if attr.tag == 'attribute':\n                params[attr.attrib['name']] = convert_xml_value(attr.text, attr.attrib['type'])\n            elif attr.tag == 'relationship':\n                # todo give this a better API\n                if 'idrefs' in attr.attrib:\n                    params[f\"{attr.attrib['name']}ID\"] = attr.attrib['idrefs']\n        return params\n\n    # TODO how to store atoms in unexploded form\n    (n_a, n_b, n_c) = map(str, (1, 1, 1) if n_cells is None else numpy.asarray(n_cells).astype(int))\n    set_attr(struct, 'repeata', 'int16', n_a)\n    set_attr(struct, 'repeatb', 'int16', n_b)\n    set_attr(struct, 'repeatc', 'int16', n_c)\n\n    (a, b, c) = map(lambda v: f\"{v:.8g}\", box_size)\n    set_attr(struct, 'aparam', 'float', a)\n    set_attr(struct, 'bparam', 'float', b)\n    set_attr(struct, 'cparam', 'float', c)\n\n    if tilt is not None:\n        (tiltx, tilty) = tilt\n        set_attr(struct, 'tiltx', 'float', f\"{tiltx:.4g}\")\n        set_attr(struct, 'tilty', 'float', f\"{tilty:.4g}\")\n\n    if slice_thickness is not None:\n        set_attr(params, 'slicethickness', 'float', f\"{float(slice_thickness):.8g}\")\n    if tds is not None:\n        set_attr(params, 'includetds', 'bool', str(int(bool(tds))))\n    if conv_angle is not None:\n        set_attr(microscope, 'aperture', 'float', f\"{float(conv_angle):.8g}\")\n    if energy is not None:\n        set_attr(microscope, 'kv', 'float', f\"{float(energy):.8g}\")\n    if noise_sigma is not None:\n        if scan is None:\n            raise ValueError(\"New scan specification required for 'noise_sigma'.\")\n        set_attr(scan, 'noise_sigma', 'float', f\"{float(noise_sigma):.8g}\")\n\n    if defocus is not None:\n        for aberration in aberrations:\n            obj = parse_xml_object(aberration)\n            if obj['n'] == 1 and obj['m'] == 0:\n                set_attr(aberration, 'cnma', 'float', f\"{float(defocus):.8g}\")  # A, + is over\n                set_attr(aberration, 'cnmb', 'float', \"0.0\")\n                break\n        else:\n            raise ValueError(\"Couldn't find defocus aberration to modify.\")\n\n    if scan_points is not None:\n        (nx, ny) = numpy.broadcast_to(scan_points, 2,).astype(int)\n        if scan is not None:\n            set_attr(scan, 'nx', 'int16', str(nx))\n            set_attr(scan, 'ny', 'int16', str(ny))\n        else:\n            set_attr(params, 'numscanx', 'int16', str(nx))\n            set_attr(params, 'numscany', 'int16', str(ny))\n\n    if scan_extent is not None:\n        scan_extent = numpy.asarray(scan_extent, dtype=float)\n        try:\n            if scan_extent.ndim &lt; 2:\n                if not scan_extent.shape == (4,):\n                    scan_extent = numpy.broadcast_to(scan_extent, (2,))\n                    scan_extent = numpy.stack(((0., 0.), scan_extent), axis=-1)\n            else:\n                scan_extent = numpy.broadcast_to(scan_extent, (2, 2))\n        except ValueError as e:\n            raise ValueError(f\"Invalid scan_extent '{scan_extent}'. Expected an array of shape (2,), (4,), or (2, 2).\") from e\n\n        if scan is not None:\n            names = ('x_i', 'x_f', 'y_i', 'y_f')\n            elem = scan\n        else:\n            names = ('intx', 'finx', 'inty', 'finy')\n            elem = params\n\n        for (name, val) in zip(names, scan_extent.ravel()):\n            set_attr(elem, name, 'float', f\"{float(val):.8g}\")\n\n    # remove existing atoms\n    for elem in db.findall(\"./object[@type='STRUCTUREATOM']\", None):\n        db.remove(elem)\n\n    # &lt;u^2&gt; -&gt; 1d sigma\n    atoms = atoms.with_wobble((polars.col('wobble') / 3.).sqrt())\n    rows = atoms.select(('elem', 'coords', 'wobble', 'frac_occupancy')).rows()\n    for (i, (elem, (x, y, z), wobble, frac_occupancy)) in enumerate(rows):\n        e = _atom_elem(i, elem, x, y, z, wobble, frac_occupancy)\n        db.append(e)\n\n    et.indent(db, space=\"    \", level=0)  # type: ignore\n\n    with open_file_binary(f, 'w') as f:\n        doctype = b\"\"\"&lt;!DOCTYPE database SYSTEM \"file:///System/Library/DTDs/CoreData.dtd\"&gt;\\n\"\"\"\n        out.write(f, encoding='UTF-8', xml_declaration=True, standalone=True, doctype=doctype)  # type: ignore\n        f.write(b'\\n')\n</code></pre>"},{"location":"api/io/qe/","title":"<code>atomlib.io.qe</code>","text":""},{"location":"api/io/qe/#atomlib.io.qe.write_qe","title":"<code>write_qe(atomcell, f, pseudo=None)</code>","text":"Source code in <code>atomlib/io/qe.py</code> <pre><code>def write_qe(atomcell: HasAtomCell, f: FileOrPath, pseudo: t.Optional[t.Mapping[str, str]] = None):\n    if not isinstance(atomcell, HasAtomCell):\n        raise TypeError(\"'qe' format requires an AtomCell.\")\n\n    atoms = atomcell.wrap().get_atoms('cell_frac').with_mass()\n\n    types = atoms.select(('symbol', 'mass')).unique(subset='symbol').sort('mass')\n    if pseudo is not None:\n        types = types.with_columns(polars.col('symbol').cast(polars.Utf8).map_dict(dict(pseudo), return_dtype=polars.Utf8).alias('pot'))\n    else:\n        types = types.with_columns(polars.col('symbol').apply(lambda sym: f\"{sym}.UPF\").alias('pot'))\n\n    with open_file(f, 'w') as f:\n        print(f\"&amp;SYSTEM ibrav=0 nat={len(atoms)} ntyp={len(types)}\", file=f)\n\n        ortho = atomcell.get_transform('local', 'cell_box').to_linear().inner\n        print(f\"\\nCELL_PARAMETERS angstrom\", file=f)\n        for row in ortho.T:\n            print(f\"  {row[0]:12.8f} {row[1]:12.8f} {row[2]:12.8f}\", file=f)\n\n        print(f\"\\nATOMIC_SPECIES\", file=f)\n        for (symbol, mass, pot) in types.select(('symbol', 'mass', 'pot')).rows():\n            print(f\"{symbol:&gt;4} {mass:10.3f}  {pot}\", file=f)\n\n        print(f\"\\nATOMIC_POSITIONS crystal\", file=f)\n        for (symbol, (x, y, z)) in atoms.select(('symbol', 'coords')).rows():\n            print(f\"{symbol:&gt;4} {x:.8f} {y:.8f} {z:.8f}\", file=f)\n</code></pre>"},{"location":"api/io/xsf/","title":"<code>atomlib.io.xsf</code>","text":"<p>IO for XCrySDen's XSF format. (http://www.xcrysden.org/doc/XSF.html)</p>"},{"location":"api/io/xsf/#atomlib.io.xsf.Periodicity","title":"<code>Periodicity = t.Literal['crystal', 'slab', 'polymer', 'molecule']</code>  <code>module-attribute</code>","text":""},{"location":"api/io/xsf/#atomlib.io.xsf.XSF","title":"<code>XSF</code>  <code>dataclass</code>","text":"Source code in <code>atomlib/io/xsf.py</code> <pre><code>@dataclass\nclass XSF:\n    periodicity: Periodicity = 'crystal'\n    primitive_cell: t.Optional[LinearTransform3D] = None\n    conventional_cell: t.Optional[LinearTransform3D] = None\n\n    prim_coords: t.Optional[polars.DataFrame] = None\n    conv_coords: t.Optional[polars.DataFrame] = None\n    atoms: t.Optional[polars.DataFrame] = None\n\n    def get_atoms(self) -&gt; polars.DataFrame:\n        if self.prim_coords is not None:\n            return self.prim_coords\n        if self.atoms is not None:\n            return self.atoms\n        if self.conv_coords is not None:\n            raise NotImplementedError()  # TODO untransform conv_coords by conventional_cell?\n        raise ValueError(\"No coordinates specified in XSF file.\")\n\n    def get_pbc(self) -&gt; NDArray[numpy.bool_]:\n        return _periodicity_to_pbc(self.periodicity)\n\n    @staticmethod\n    def from_cell(cell: HasAtomCell) -&gt; XSF:\n        ortho = cell.get_transform('local', 'cell_box').to_linear()\n        return XSF(\n            primitive_cell=ortho,\n            conventional_cell=ortho,\n            prim_coords=cell.get_atoms('linear').inner,\n            periodicity=_pbc_to_periodicity(cell.pbc)\n        )\n\n    @staticmethod\n    def from_atoms(atoms: HasAtoms) -&gt; XSF:\n        return XSF(\n            periodicity='molecule',\n            atoms=atoms.get_atoms('local').inner\n        )\n\n    @staticmethod\n    def from_file(file: FileOrPath) -&gt; XSF:\n        logging.info(f\"Loading XSF {file.name if hasattr(file, 'name') else file!r}...\")  # type: ignore\n        with open_file(file) as f:\n            return XSFParser(f).parse()\n\n    def __post_init__(self):\n        if self.prim_coords is None and self.conv_coords is None and self.atoms is None:\n            raise ValueError(\"Error: No coordinates are specified (atoms, primitive, or conventional).\")\n\n        if self.prim_coords is not None and self.conv_coords is not None:\n            logging.warn(\"Warning: Both 'primcoord' and 'convcoord' are specified. 'convcoord' will be ignored.\")\n        elif self.conv_coords is not None and self.conventional_cell is None:\n            raise ValueError(\"If 'convcoord' is specified, 'convvec' must be specified as well.\")\n\n        if self.periodicity == 'molecule':\n            if self.atoms is None:\n                raise ValueError(\"'atoms' must be specified for molecules.\")\n\n    def write(self, path: FileOrPath):\n        with open_file(path, 'w') as f:\n            print(self.periodicity.upper(), file=f)\n            if self.primitive_cell is not None:\n                print('PRIMVEC', file=f)\n                self._write_cell(f, self.primitive_cell)\n            if self.conventional_cell is not None:\n                print('CONVVEC', file=f)\n                self._write_cell(f, self.conventional_cell)\n            print(file=f)\n\n            if self.prim_coords is not None:\n                print(\"PRIMCOORD\", file=f)\n                print(f\"{len(self.prim_coords)} 1\", file=f)\n                self._write_coords(f, self.prim_coords)\n            if self.conv_coords is not None:\n                print(\"CONVCOORD\", file=f)\n                print(f\"{len(self.conv_coords)} 1\", file=f)\n                self._write_coords(f, self.conv_coords)\n            if self.atoms is not None:\n                print(\"ATOMS\", file=f)\n                self._write_coords(f, self.atoms)\n\n    def _write_cell(self, f: TextIOBase, cell: LinearTransform3D):\n        for row in cell.inner.T:\n            for val in row:\n                f.write(f\"{val:12.7f}\")\n            f.write('\\n')\n\n    def _write_coords(self, f: TextIOBase, coords: polars.DataFrame):\n        for (elem, [x, y, z]) in coords.select(['elem', 'coords']).rows():\n            print(f\"{elem:2d} {x:11.6f} {y:11.6f} {z:11.6f}\", file=f)\n        print(file=f)\n</code></pre>"},{"location":"api/io/xsf/#atomlib.io.xsf.XSF.periodicity","title":"<code>periodicity: Periodicity = 'crystal'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/io/xsf/#atomlib.io.xsf.XSF.primitive_cell","title":"<code>primitive_cell: t.Optional[LinearTransform3D] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/io/xsf/#atomlib.io.xsf.XSF.conventional_cell","title":"<code>conventional_cell: t.Optional[LinearTransform3D] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/io/xsf/#atomlib.io.xsf.XSF.prim_coords","title":"<code>prim_coords: t.Optional[polars.DataFrame] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/io/xsf/#atomlib.io.xsf.XSF.conv_coords","title":"<code>conv_coords: t.Optional[polars.DataFrame] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/io/xsf/#atomlib.io.xsf.XSF.atoms","title":"<code>atoms: t.Optional[polars.DataFrame] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/io/xsf/#atomlib.io.xsf.XSF.get_atoms","title":"<code>get_atoms()</code>","text":"Source code in <code>atomlib/io/xsf.py</code> <pre><code>def get_atoms(self) -&gt; polars.DataFrame:\n    if self.prim_coords is not None:\n        return self.prim_coords\n    if self.atoms is not None:\n        return self.atoms\n    if self.conv_coords is not None:\n        raise NotImplementedError()  # TODO untransform conv_coords by conventional_cell?\n    raise ValueError(\"No coordinates specified in XSF file.\")\n</code></pre>"},{"location":"api/io/xsf/#atomlib.io.xsf.XSF.get_pbc","title":"<code>get_pbc()</code>","text":"Source code in <code>atomlib/io/xsf.py</code> <pre><code>def get_pbc(self) -&gt; NDArray[numpy.bool_]:\n    return _periodicity_to_pbc(self.periodicity)\n</code></pre>"},{"location":"api/io/xsf/#atomlib.io.xsf.XSF.from_cell","title":"<code>from_cell(cell)</code>  <code>staticmethod</code>","text":"Source code in <code>atomlib/io/xsf.py</code> <pre><code>@staticmethod\ndef from_cell(cell: HasAtomCell) -&gt; XSF:\n    ortho = cell.get_transform('local', 'cell_box').to_linear()\n    return XSF(\n        primitive_cell=ortho,\n        conventional_cell=ortho,\n        prim_coords=cell.get_atoms('linear').inner,\n        periodicity=_pbc_to_periodicity(cell.pbc)\n    )\n</code></pre>"},{"location":"api/io/xsf/#atomlib.io.xsf.XSF.from_atoms","title":"<code>from_atoms(atoms)</code>  <code>staticmethod</code>","text":"Source code in <code>atomlib/io/xsf.py</code> <pre><code>@staticmethod\ndef from_atoms(atoms: HasAtoms) -&gt; XSF:\n    return XSF(\n        periodicity='molecule',\n        atoms=atoms.get_atoms('local').inner\n    )\n</code></pre>"},{"location":"api/io/xsf/#atomlib.io.xsf.XSF.from_file","title":"<code>from_file(file)</code>  <code>staticmethod</code>","text":"Source code in <code>atomlib/io/xsf.py</code> <pre><code>@staticmethod\ndef from_file(file: FileOrPath) -&gt; XSF:\n    logging.info(f\"Loading XSF {file.name if hasattr(file, 'name') else file!r}...\")  # type: ignore\n    with open_file(file) as f:\n        return XSFParser(f).parse()\n</code></pre>"},{"location":"api/io/xsf/#atomlib.io.xsf.XSF.write","title":"<code>write(path)</code>","text":"Source code in <code>atomlib/io/xsf.py</code> <pre><code>def write(self, path: FileOrPath):\n    with open_file(path, 'w') as f:\n        print(self.periodicity.upper(), file=f)\n        if self.primitive_cell is not None:\n            print('PRIMVEC', file=f)\n            self._write_cell(f, self.primitive_cell)\n        if self.conventional_cell is not None:\n            print('CONVVEC', file=f)\n            self._write_cell(f, self.conventional_cell)\n        print(file=f)\n\n        if self.prim_coords is not None:\n            print(\"PRIMCOORD\", file=f)\n            print(f\"{len(self.prim_coords)} 1\", file=f)\n            self._write_coords(f, self.prim_coords)\n        if self.conv_coords is not None:\n            print(\"CONVCOORD\", file=f)\n            print(f\"{len(self.conv_coords)} 1\", file=f)\n            self._write_coords(f, self.conv_coords)\n        if self.atoms is not None:\n            print(\"ATOMS\", file=f)\n            self._write_coords(f, self.atoms)\n</code></pre>"},{"location":"api/io/xsf/#atomlib.io.xsf.XSFParser","title":"<code>XSFParser</code>","text":"Source code in <code>atomlib/io/xsf.py</code> <pre><code>class XSFParser:\n    def __init__(self, file: TextIOBase):\n        self._file: TextIOBase = file\n        self._peek_line: t.Optional[str] = None\n        self.lineno = 0\n\n    def skip_line(self, line: t.Optional[str]) -&gt; bool:\n        return line is None or line.isspace() or line.lstrip().startswith('#')\n\n    def peek_line(self) -&gt; t.Optional[str]:\n        try:\n            while self.skip_line(self._peek_line):\n                self._peek_line = next(self._file)\n                self.lineno += 1\n            return self._peek_line\n        except StopIteration:\n            return None\n\n    def next_line(self) -&gt; t.Optional[str]:\n        line = self.peek_line()\n        self._peek_line = None\n        return line\n\n    def parse_atoms(self, expected_length: t.Optional[int] = None) -&gt; polars.DataFrame:\n        zs = []\n        coords = []\n        words = None\n\n        while (line := self.peek_line()):\n            words = line.split()\n            if len(words) == 0:\n                continue\n            if words[0].isalpha():\n                break\n            self.next_line()\n            try:\n                z = int(words[0])\n                if z &lt; 0 or z &gt; 118:\n                    raise ValueError()\n            except (ValueError, TypeError):\n                raise ValueError(f\"Invalid atomic number '{words[0]}'\") from None\n\n            try:\n                coords.append(numpy.array(list(map(float, words[1:]))))\n                zs.append(z)\n            except (ValueError, TypeError):\n                raise ValueError(f\"Invalid atomic coordinates '{' '.join(words[1:])}'\") from None\n\n        if expected_length is not None:\n            if not expected_length == len(zs):\n                logging.warn(f\"Warning: List length {len(zs)} doesn't match declared length {expected_length}\")\n        elif len(zs) == 0:\n            raise ValueError(f\"Expected atom list after keyword 'ATOMS'. Got '{line or 'EOF'}' instead.\")\n\n        if len(zs) == 0:\n            return polars.DataFrame({}, schema=['elem', 'x', 'y', 'z'])  # type: ignore\n\n        coord_lens = list(map(len, coords))\n        if not all(l == coord_lens[0] for l in coord_lens[1:]):\n            raise ValueError(\"Mismatched atom dimensions.\")\n        if coord_lens[0] &lt; 3:\n            raise ValueError(\"Expected at least 3 coordinates per atom.\")\n\n        coords = numpy.stack(coords, axis=0)[:, :3]\n        (x, y, z) = map(lambda a: a[:, 0], numpy.split(coords, 3, axis=1))\n\n        return polars.DataFrame({'elem': zs, 'x': x, 'y': y, 'z': z})\n\n    def parse_coords(self) -&gt; polars.DataFrame:\n        line = self.next_line()\n        if line is None:\n            raise ValueError(\"Unexpected EOF before atom list\")\n        words = line.split()\n        try:\n            if not len(words) == 2:\n                raise ValueError()\n            (n, _) = map(int, words)\n        except (ValueError, TypeError):\n            raise ValueError(f\"Invalid atom list length: {line}\") from None\n\n        return self.parse_atoms(n)\n\n    def parse_lattice(self) -&gt; LinearTransform3D:\n        rows = []\n        for _ in range(3):\n            line = self.next_line()\n            if line is None:\n                raise ValueError(\"Unexpected EOF in vector section.\")\n            words = line.split()\n            try:\n                if not len(words) == 3:\n                    raise ValueError()\n                row = numpy.array(list(map(float, words)))\n                rows.append(row)\n            except (ValueError, TypeError):\n                raise ValueError(f\"Invalid lattice vector: {line}\") from None\n\n        matrix = numpy.stack(rows, axis=-1)\n        return LinearTransform3D(matrix)\n\n    def eat_sandwich(self, keyword: str):\n        begin_keyword = 'begin_' + keyword\n        end_keyword = 'end_' + keyword\n        lineno = self.lineno\n\n        while (line := self.next_line()):\n            keyword = line.lstrip().split(maxsplit=1)[0].lower()\n            if keyword.lower() == begin_keyword:\n                # recurse to inner (identical) section\n                self.eat_sandwich(keyword)\n                continue\n            if keyword.lower() == end_keyword:\n                break\n        else:\n            raise ValueError(f\"Unclosed section '{keyword}' opened at line {lineno}\")\n\n    def parse(self) -&gt; XSF:\n        data: t.Dict[str, t.Any] = {}\n        periodicity: Periodicity = 'molecule'\n\n        while (line := self.next_line()):\n            keyword = line.lstrip().split(maxsplit=1)[0].lower()\n            logging.debug(f\"Parsing keyword {keyword}\")\n\n            if keyword == 'animsteps':\n                raise ValueError(\"Animated XSF files are not supported.\")\n            elif keyword == 'atoms':\n                data['atoms'] = self.parse_atoms()\n            elif keyword in ('primcoord', 'convcoord'):\n                data[keyword] = self.parse_coords()\n            elif keyword in ('primvec', 'convvec'):\n                data[keyword] = self.parse_lattice()\n            elif keyword in ('crystal', 'slab', 'polymer', 'molecule'):\n                periodicity = keyword\n            elif keyword.startswith('begin_'):\n                self.eat_sandwich(keyword.removeprefix('begin_'))\n            elif keyword.startswith('end_'):\n                raise ValueError(f\"Unopened section close keyword '{keyword}'\")\n            else:\n                raise ValueError(f\"Unexpected keyword '{keyword.upper()}'.\")\n\n        if len(data) == 0:\n            raise ValueError(\"Unexpected EOF while parsing XSF file.\")\n\n        # most validation is performed in XSF\n        return XSF(\n            periodicity, atoms=data.get('atoms'),\n            prim_coords=data.get('primcoord'),\n            conv_coords=data.get('convcoord'),\n            primitive_cell=data.get('primvec'),\n            conventional_cell=data.get('convvec'),\n        )\n</code></pre>"},{"location":"api/io/xsf/#atomlib.io.xsf.XSFParser.lineno","title":"<code>lineno = 0</code>  <code>instance-attribute</code>","text":""},{"location":"api/io/xsf/#atomlib.io.xsf.XSFParser.skip_line","title":"<code>skip_line(line)</code>","text":"Source code in <code>atomlib/io/xsf.py</code> <pre><code>def skip_line(self, line: t.Optional[str]) -&gt; bool:\n    return line is None or line.isspace() or line.lstrip().startswith('#')\n</code></pre>"},{"location":"api/io/xsf/#atomlib.io.xsf.XSFParser.peek_line","title":"<code>peek_line()</code>","text":"Source code in <code>atomlib/io/xsf.py</code> <pre><code>def peek_line(self) -&gt; t.Optional[str]:\n    try:\n        while self.skip_line(self._peek_line):\n            self._peek_line = next(self._file)\n            self.lineno += 1\n        return self._peek_line\n    except StopIteration:\n        return None\n</code></pre>"},{"location":"api/io/xsf/#atomlib.io.xsf.XSFParser.next_line","title":"<code>next_line()</code>","text":"Source code in <code>atomlib/io/xsf.py</code> <pre><code>def next_line(self) -&gt; t.Optional[str]:\n    line = self.peek_line()\n    self._peek_line = None\n    return line\n</code></pre>"},{"location":"api/io/xsf/#atomlib.io.xsf.XSFParser.parse_atoms","title":"<code>parse_atoms(expected_length=None)</code>","text":"Source code in <code>atomlib/io/xsf.py</code> <pre><code>def parse_atoms(self, expected_length: t.Optional[int] = None) -&gt; polars.DataFrame:\n    zs = []\n    coords = []\n    words = None\n\n    while (line := self.peek_line()):\n        words = line.split()\n        if len(words) == 0:\n            continue\n        if words[0].isalpha():\n            break\n        self.next_line()\n        try:\n            z = int(words[0])\n            if z &lt; 0 or z &gt; 118:\n                raise ValueError()\n        except (ValueError, TypeError):\n            raise ValueError(f\"Invalid atomic number '{words[0]}'\") from None\n\n        try:\n            coords.append(numpy.array(list(map(float, words[1:]))))\n            zs.append(z)\n        except (ValueError, TypeError):\n            raise ValueError(f\"Invalid atomic coordinates '{' '.join(words[1:])}'\") from None\n\n    if expected_length is not None:\n        if not expected_length == len(zs):\n            logging.warn(f\"Warning: List length {len(zs)} doesn't match declared length {expected_length}\")\n    elif len(zs) == 0:\n        raise ValueError(f\"Expected atom list after keyword 'ATOMS'. Got '{line or 'EOF'}' instead.\")\n\n    if len(zs) == 0:\n        return polars.DataFrame({}, schema=['elem', 'x', 'y', 'z'])  # type: ignore\n\n    coord_lens = list(map(len, coords))\n    if not all(l == coord_lens[0] for l in coord_lens[1:]):\n        raise ValueError(\"Mismatched atom dimensions.\")\n    if coord_lens[0] &lt; 3:\n        raise ValueError(\"Expected at least 3 coordinates per atom.\")\n\n    coords = numpy.stack(coords, axis=0)[:, :3]\n    (x, y, z) = map(lambda a: a[:, 0], numpy.split(coords, 3, axis=1))\n\n    return polars.DataFrame({'elem': zs, 'x': x, 'y': y, 'z': z})\n</code></pre>"},{"location":"api/io/xsf/#atomlib.io.xsf.XSFParser.parse_coords","title":"<code>parse_coords()</code>","text":"Source code in <code>atomlib/io/xsf.py</code> <pre><code>def parse_coords(self) -&gt; polars.DataFrame:\n    line = self.next_line()\n    if line is None:\n        raise ValueError(\"Unexpected EOF before atom list\")\n    words = line.split()\n    try:\n        if not len(words) == 2:\n            raise ValueError()\n        (n, _) = map(int, words)\n    except (ValueError, TypeError):\n        raise ValueError(f\"Invalid atom list length: {line}\") from None\n\n    return self.parse_atoms(n)\n</code></pre>"},{"location":"api/io/xsf/#atomlib.io.xsf.XSFParser.parse_lattice","title":"<code>parse_lattice()</code>","text":"Source code in <code>atomlib/io/xsf.py</code> <pre><code>def parse_lattice(self) -&gt; LinearTransform3D:\n    rows = []\n    for _ in range(3):\n        line = self.next_line()\n        if line is None:\n            raise ValueError(\"Unexpected EOF in vector section.\")\n        words = line.split()\n        try:\n            if not len(words) == 3:\n                raise ValueError()\n            row = numpy.array(list(map(float, words)))\n            rows.append(row)\n        except (ValueError, TypeError):\n            raise ValueError(f\"Invalid lattice vector: {line}\") from None\n\n    matrix = numpy.stack(rows, axis=-1)\n    return LinearTransform3D(matrix)\n</code></pre>"},{"location":"api/io/xsf/#atomlib.io.xsf.XSFParser.eat_sandwich","title":"<code>eat_sandwich(keyword)</code>","text":"Source code in <code>atomlib/io/xsf.py</code> <pre><code>def eat_sandwich(self, keyword: str):\n    begin_keyword = 'begin_' + keyword\n    end_keyword = 'end_' + keyword\n    lineno = self.lineno\n\n    while (line := self.next_line()):\n        keyword = line.lstrip().split(maxsplit=1)[0].lower()\n        if keyword.lower() == begin_keyword:\n            # recurse to inner (identical) section\n            self.eat_sandwich(keyword)\n            continue\n        if keyword.lower() == end_keyword:\n            break\n    else:\n        raise ValueError(f\"Unclosed section '{keyword}' opened at line {lineno}\")\n</code></pre>"},{"location":"api/io/xsf/#atomlib.io.xsf.XSFParser.parse","title":"<code>parse()</code>","text":"Source code in <code>atomlib/io/xsf.py</code> <pre><code>def parse(self) -&gt; XSF:\n    data: t.Dict[str, t.Any] = {}\n    periodicity: Periodicity = 'molecule'\n\n    while (line := self.next_line()):\n        keyword = line.lstrip().split(maxsplit=1)[0].lower()\n        logging.debug(f\"Parsing keyword {keyword}\")\n\n        if keyword == 'animsteps':\n            raise ValueError(\"Animated XSF files are not supported.\")\n        elif keyword == 'atoms':\n            data['atoms'] = self.parse_atoms()\n        elif keyword in ('primcoord', 'convcoord'):\n            data[keyword] = self.parse_coords()\n        elif keyword in ('primvec', 'convvec'):\n            data[keyword] = self.parse_lattice()\n        elif keyword in ('crystal', 'slab', 'polymer', 'molecule'):\n            periodicity = keyword\n        elif keyword.startswith('begin_'):\n            self.eat_sandwich(keyword.removeprefix('begin_'))\n        elif keyword.startswith('end_'):\n            raise ValueError(f\"Unopened section close keyword '{keyword}'\")\n        else:\n            raise ValueError(f\"Unexpected keyword '{keyword.upper()}'.\")\n\n    if len(data) == 0:\n        raise ValueError(\"Unexpected EOF while parsing XSF file.\")\n\n    # most validation is performed in XSF\n    return XSF(\n        periodicity, atoms=data.get('atoms'),\n        prim_coords=data.get('primcoord'),\n        conv_coords=data.get('convcoord'),\n        primitive_cell=data.get('primvec'),\n        conventional_cell=data.get('convvec'),\n    )\n</code></pre>"},{"location":"api/io/xyz/","title":"<code>atomlib.io.xyz</code>","text":"<p>IO for the informal XYZ file format.</p> <p>Partially supports the extended XYZ format, described here: https://atomsk.univ-lille.fr/doc/en/format_xyz.html</p>"},{"location":"api/io/xyz/#atomlib.io.xyz.XYZFormat","title":"<code>XYZFormat = t.Literal['xyz', 'exyz']</code>  <code>module-attribute</code>","text":""},{"location":"api/io/xyz/#atomlib.io.xyz.XYZ","title":"<code>XYZ</code>  <code>dataclass</code>","text":"Source code in <code>atomlib/io/xyz.py</code> <pre><code>@dataclass\nclass XYZ:\n    atoms: polars.DataFrame\n    comment: t.Optional[str] = None\n    params: t.Dict[str, str] = field(default_factory=dict)\n\n    @staticmethod\n    def from_atoms(atoms: HasAtoms) -&gt; XYZ:\n        params = {}\n        if isinstance(atoms, HasAtomCell):\n            coords = atoms.get_cell().to_ortho().to_linear().inner.ravel()\n            lattice_str = \" \".join((f\"{c:.8f}\" for c in coords))\n            params['Lattice'] = lattice_str\n\n            pbc_str = \" \".join(str(int(v)) for v in atoms.get_cell().pbc)\n            params['pbc'] = pbc_str\n\n        return XYZ(\n            atoms.get_atoms('local')._get_frame(),\n            params=params\n        )\n\n    @staticmethod\n    def from_file(file: FileOrPath) -&gt; XYZ:\n        logging.info(f\"Loading XYZ {file.name if hasattr(file, 'name') else file!r}...\")  # type: ignore\n\n        with open_file(file, 'r') as f:\n            try:\n                # TODO be more gracious about whitespace here\n                length = int(f.readline())\n            except ValueError:\n                raise ValueError(f\"Error parsing XYZ file: Invalid length\") from None\n            except IOError as e:\n                raise IOError(f\"Error parsing XYZ file: {e}\") from None\n\n            comment = f.readline().rstrip('\\n')\n            # TODO handle if there's not a gap here\n\n            try:\n                params = ExtXYZParser(comment).parse()\n            except ValueError:\n                params = None\n\n            schema = _get_columns_from_params(params)\n\n            df = parse_whitespace_separated(f, schema, start_line=1)\n\n            # map atomic numbers -&gt; symbols (on columns which are Int8)\n            df = df.with_columns(\n                get_sym(df.select(polars.col('symbol').cast(polars.Int8, strict=False)).to_series())\n                    .fill_null(df['symbol']).alias('symbol')\n            )\n            # ensure all symbols are recognizable (this will raise ValueError if not)\n            get_elem(df['symbol'])\n\n            if length &lt; len(df):\n                warnings.warn(f\"Warning: truncating structure of length {len(df)} \"\n                            f\"to match declared length of {length}\")\n                df = df[:length]\n            elif length &gt; len(df):\n                warnings.warn(f\"Warning: structure length {len(df)} doesn't match \"\n                            f\"declared length {length}.\\nData could be corrupted.\")\n\n            try:\n                params = ExtXYZParser(comment).parse()\n                return XYZ(df, comment, params)\n            except ValueError:\n                pass\n\n            return XYZ(df, comment)\n\n    def write(self, file: FileOrPath, fmt: XYZFormat = 'exyz'):\n        with open_file(file, 'w', newline='\\r\\n') as f:\n\n            f.write(f\"{len(self.atoms)}\\n\")\n            if len(self.params) &gt; 0 and fmt == 'exyz':\n                f.write(\" \".join(_param_strings(self.params)))\n            else:\n                f.write(self.comment or \"\")\n            f.write(\"\\n\")\n\n            # not my best work\n            col_space = (3, 12, 12, 12)\n            f.writelines(\n                \"\".join(\n                    f\"{val:&lt; {space}.8f}\" if isinstance(val, float) else f\"{val:&lt;{space}}\" for (val, space) in zip(_flatten(row), col_space)\n                ).strip() + '\\n' for row in self.atoms.select(('symbol', 'coords')).rows()\n            )\n\n    def cell_matrix(self) -&gt; t.Optional[NDArray[numpy.float_]]:\n        if (s := self.params.get('Lattice')) is None:\n            return None\n\n        try:\n            items = list(map(float, s.split()))\n            if not len(items) == 9:\n                raise ValueError(\"Invalid length\")\n            return numpy.array(items, dtype=numpy.float_).reshape((3, 3)).T\n        except ValueError:\n            warnings.warn(f\"Warning: Invalid format for key 'Lattice=\\\"{s}\\\"'\")\n        return None\n\n    def pbc(self) -&gt; t.Optional[NDArray[numpy.bool_]]:\n        if (s := self.params.get('pbc')) is None:\n            return None\n\n        val_map = {'0': False, 'f': False, '1': True, 't': True}\n        try:\n            items = [val_map[v.lower()] for v in s.split()]\n            if not len(items) == 3:\n                raise ValueError(\"Invalid length\")\n            return numpy.array(items, dtype=numpy.bool_)\n        except ValueError:\n            warnings.warn(f\"Warning: Invalid format for key 'pbc=\\\"{s}\\\"'\")\n        return None\n</code></pre>"},{"location":"api/io/xyz/#atomlib.io.xyz.XYZ.atoms","title":"<code>atoms: polars.DataFrame</code>  <code>instance-attribute</code>","text":""},{"location":"api/io/xyz/#atomlib.io.xyz.XYZ.comment","title":"<code>comment: t.Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/io/xyz/#atomlib.io.xyz.XYZ.params","title":"<code>params: t.Dict[str, str] = field(default_factory=dict)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/io/xyz/#atomlib.io.xyz.XYZ.from_atoms","title":"<code>from_atoms(atoms)</code>  <code>staticmethod</code>","text":"Source code in <code>atomlib/io/xyz.py</code> <pre><code>@staticmethod\ndef from_atoms(atoms: HasAtoms) -&gt; XYZ:\n    params = {}\n    if isinstance(atoms, HasAtomCell):\n        coords = atoms.get_cell().to_ortho().to_linear().inner.ravel()\n        lattice_str = \" \".join((f\"{c:.8f}\" for c in coords))\n        params['Lattice'] = lattice_str\n\n        pbc_str = \" \".join(str(int(v)) for v in atoms.get_cell().pbc)\n        params['pbc'] = pbc_str\n\n    return XYZ(\n        atoms.get_atoms('local')._get_frame(),\n        params=params\n    )\n</code></pre>"},{"location":"api/io/xyz/#atomlib.io.xyz.XYZ.from_file","title":"<code>from_file(file)</code>  <code>staticmethod</code>","text":"Source code in <code>atomlib/io/xyz.py</code> <pre><code>@staticmethod\ndef from_file(file: FileOrPath) -&gt; XYZ:\n    logging.info(f\"Loading XYZ {file.name if hasattr(file, 'name') else file!r}...\")  # type: ignore\n\n    with open_file(file, 'r') as f:\n        try:\n            # TODO be more gracious about whitespace here\n            length = int(f.readline())\n        except ValueError:\n            raise ValueError(f\"Error parsing XYZ file: Invalid length\") from None\n        except IOError as e:\n            raise IOError(f\"Error parsing XYZ file: {e}\") from None\n\n        comment = f.readline().rstrip('\\n')\n        # TODO handle if there's not a gap here\n\n        try:\n            params = ExtXYZParser(comment).parse()\n        except ValueError:\n            params = None\n\n        schema = _get_columns_from_params(params)\n\n        df = parse_whitespace_separated(f, schema, start_line=1)\n\n        # map atomic numbers -&gt; symbols (on columns which are Int8)\n        df = df.with_columns(\n            get_sym(df.select(polars.col('symbol').cast(polars.Int8, strict=False)).to_series())\n                .fill_null(df['symbol']).alias('symbol')\n        )\n        # ensure all symbols are recognizable (this will raise ValueError if not)\n        get_elem(df['symbol'])\n\n        if length &lt; len(df):\n            warnings.warn(f\"Warning: truncating structure of length {len(df)} \"\n                        f\"to match declared length of {length}\")\n            df = df[:length]\n        elif length &gt; len(df):\n            warnings.warn(f\"Warning: structure length {len(df)} doesn't match \"\n                        f\"declared length {length}.\\nData could be corrupted.\")\n\n        try:\n            params = ExtXYZParser(comment).parse()\n            return XYZ(df, comment, params)\n        except ValueError:\n            pass\n\n        return XYZ(df, comment)\n</code></pre>"},{"location":"api/io/xyz/#atomlib.io.xyz.XYZ.write","title":"<code>write(file, fmt='exyz')</code>","text":"Source code in <code>atomlib/io/xyz.py</code> <pre><code>def write(self, file: FileOrPath, fmt: XYZFormat = 'exyz'):\n    with open_file(file, 'w', newline='\\r\\n') as f:\n\n        f.write(f\"{len(self.atoms)}\\n\")\n        if len(self.params) &gt; 0 and fmt == 'exyz':\n            f.write(\" \".join(_param_strings(self.params)))\n        else:\n            f.write(self.comment or \"\")\n        f.write(\"\\n\")\n\n        # not my best work\n        col_space = (3, 12, 12, 12)\n        f.writelines(\n            \"\".join(\n                f\"{val:&lt; {space}.8f}\" if isinstance(val, float) else f\"{val:&lt;{space}}\" for (val, space) in zip(_flatten(row), col_space)\n            ).strip() + '\\n' for row in self.atoms.select(('symbol', 'coords')).rows()\n        )\n</code></pre>"},{"location":"api/io/xyz/#atomlib.io.xyz.XYZ.cell_matrix","title":"<code>cell_matrix()</code>","text":"Source code in <code>atomlib/io/xyz.py</code> <pre><code>def cell_matrix(self) -&gt; t.Optional[NDArray[numpy.float_]]:\n    if (s := self.params.get('Lattice')) is None:\n        return None\n\n    try:\n        items = list(map(float, s.split()))\n        if not len(items) == 9:\n            raise ValueError(\"Invalid length\")\n        return numpy.array(items, dtype=numpy.float_).reshape((3, 3)).T\n    except ValueError:\n        warnings.warn(f\"Warning: Invalid format for key 'Lattice=\\\"{s}\\\"'\")\n    return None\n</code></pre>"},{"location":"api/io/xyz/#atomlib.io.xyz.XYZ.pbc","title":"<code>pbc()</code>","text":"Source code in <code>atomlib/io/xyz.py</code> <pre><code>def pbc(self) -&gt; t.Optional[NDArray[numpy.bool_]]:\n    if (s := self.params.get('pbc')) is None:\n        return None\n\n    val_map = {'0': False, 'f': False, '1': True, 't': True}\n    try:\n        items = [val_map[v.lower()] for v in s.split()]\n        if not len(items) == 3:\n            raise ValueError(\"Invalid length\")\n        return numpy.array(items, dtype=numpy.bool_)\n    except ValueError:\n        warnings.warn(f\"Warning: Invalid format for key 'pbc=\\\"{s}\\\"'\")\n    return None\n</code></pre>"},{"location":"api/io/xyz/#atomlib.io.xyz.ExtXYZParser","title":"<code>ExtXYZParser</code>","text":"Source code in <code>atomlib/io/xyz.py</code> <pre><code>class ExtXYZParser:\n    def __init__(self, comment: str):\n        self._tokens = list(filter(len, _EXT_TOKEN_RE.split(comment)))\n        self._tokens.reverse()\n\n    def peek(self) -&gt; t.Optional[str]:\n        return None if len(self._tokens) == 0 else self._tokens[-1]\n\n    def next(self) -&gt; str:\n        return self._tokens.pop()\n\n    def skip_wspace(self):\n        word = self.peek()\n        while word is not None and word.isspace():\n            self.next()\n            word = self.peek()\n\n    def parse(self) -&gt; t.Dict[str, str]:\n        self.skip_wspace()\n        d = {}\n        while len(self._tokens) &gt; 0:\n            key = self.parse_val()\n            eq = self.next()\n            if not eq == \"=\":\n                raise ValueError(f\"Expected key-value separator, instead got '{eq}'\")\n            val = self.parse_val()\n            d[key] = val\n            self.skip_wspace()\n        return d\n\n    def parse_val(self) -&gt; str:\n        token = self.peek()\n        if token == \"=\":\n            raise ValueError(\"Expected value, instead got '='\")\n        if not token == \"\\\"\":\n            return self.next()\n\n        # quoted string\n        self.next()\n        words = []\n        while not (word := self.peek()) == \"\\\"\":\n            if word is None:\n                raise ValueError(\"EOF while parsing string value\")\n            words += self.next()\n        self.next()\n        return \"\".join(words)\n</code></pre>"},{"location":"api/io/xyz/#atomlib.io.xyz.ExtXYZParser.peek","title":"<code>peek()</code>","text":"Source code in <code>atomlib/io/xyz.py</code> <pre><code>def peek(self) -&gt; t.Optional[str]:\n    return None if len(self._tokens) == 0 else self._tokens[-1]\n</code></pre>"},{"location":"api/io/xyz/#atomlib.io.xyz.ExtXYZParser.next","title":"<code>next()</code>","text":"Source code in <code>atomlib/io/xyz.py</code> <pre><code>def next(self) -&gt; str:\n    return self._tokens.pop()\n</code></pre>"},{"location":"api/io/xyz/#atomlib.io.xyz.ExtXYZParser.skip_wspace","title":"<code>skip_wspace()</code>","text":"Source code in <code>atomlib/io/xyz.py</code> <pre><code>def skip_wspace(self):\n    word = self.peek()\n    while word is not None and word.isspace():\n        self.next()\n        word = self.peek()\n</code></pre>"},{"location":"api/io/xyz/#atomlib.io.xyz.ExtXYZParser.parse","title":"<code>parse()</code>","text":"Source code in <code>atomlib/io/xyz.py</code> <pre><code>def parse(self) -&gt; t.Dict[str, str]:\n    self.skip_wspace()\n    d = {}\n    while len(self._tokens) &gt; 0:\n        key = self.parse_val()\n        eq = self.next()\n        if not eq == \"=\":\n            raise ValueError(f\"Expected key-value separator, instead got '{eq}'\")\n        val = self.parse_val()\n        d[key] = val\n        self.skip_wspace()\n    return d\n</code></pre>"},{"location":"api/io/xyz/#atomlib.io.xyz.ExtXYZParser.parse_val","title":"<code>parse_val()</code>","text":"Source code in <code>atomlib/io/xyz.py</code> <pre><code>def parse_val(self) -&gt; str:\n    token = self.peek()\n    if token == \"=\":\n        raise ValueError(\"Expected value, instead got '='\")\n    if not token == \"\\\"\":\n        return self.next()\n\n    # quoted string\n    self.next()\n    words = []\n    while not (word := self.peek()) == \"\\\"\":\n        if word is None:\n            raise ValueError(\"EOF while parsing string value\")\n        words += self.next()\n    self.next()\n    return \"\".join(words)\n</code></pre>"},{"location":"api/io/xyz/#atomlib.io.xyz.batched","title":"<code>batched(iterable, n)</code>","text":"Source code in <code>atomlib/io/xyz.py</code> <pre><code>def batched(iterable: t.Iterable[T], n: int) -&gt; t.Iterator[t.Tuple[T, ...]]:\n    if n &lt; 1:\n        raise ValueError('n must be at least one')\n    it = iter(iterable)\n    while batch := tuple(islice(it, n)):\n        yield batch\n</code></pre>"},{"location":"using/coords/","title":"Coordinate systems","text":"<p>Under construction</p>"},{"location":"using/getting_started/","title":"Getting started","text":"<p><code>atomlib</code> is a package for creating, modifying, and controlling atomic structures. It focuses on flexibilty, correctness, and the preservation of structure metadata, while still managing to support a wide variety of file formats.</p>"}]}