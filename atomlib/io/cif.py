"""
IO for the CIF1.1 file format, specified here: https://www.iucr.org/resources/cif/spec/version1.1
"""

from __future__ import annotations

from dataclasses import dataclass, field
from io import TextIOBase, StringIO
from itertools import repeat
import operator
import re
import logging
import typing as t

import numpy
import polars
from numpy.typing import NDArray

from ..transform import AffineTransform3D
from ..expr import Parser, BinaryOp, BinaryOrUnaryOp, sub
from ..util import open_file, FileOrPath


Value = t.Union[int, float, str, None]
_INT_RE = re.compile(r'[-+]?\d+')
# float regex with uncertainty
_FLOAT_RE = re.compile(r'([-+]?\d*(\.\d*)?(e[-+]?\d+)?)(\(\d+\))?', re.I)


def _format_val(val: Value) -> str:
    if val is None:
        return '.'
    if isinstance(val, float):
        return f"{val:.8f}"
    if isinstance(val, str):
        if len(val.splitlines()) > 1 or re.search(r'"\'', val) is not None:
            # multi-line string
            return f";\n{val}\n;"

        if re.search(r'\s', val) is not None:
            # whitespace, quote string
            val = f"'{val}'"

        return f"{val:<3}"  # auto pad to 3 chars (for element symbols)

    return str(val)


@dataclass
class CIF:
    data_blocks: t.Tuple[CIFDataBlock, ...]

    def __post_init__(self):
        # ensure that all data_blocks after the first have a name
        for data_block in self.data_blocks[1:]:
            if data_block.name is None:
                data_block.name = ""

    @staticmethod
    def from_file(file: FileOrPath) -> CIF:
        return CIF(tuple(CIFDataBlock.from_file(file)))

    def __len__(self) -> int:
        return self.data_blocks.__len__()

    def get_block(self, block: t.Union[int, str]) -> CIFDataBlock:
        try:
            if isinstance(block, int):
                return self.data_blocks[block]
            return next(b for b in self.data_blocks if b.name == block)
        except (IndexError, StopIteration):
            raise ValueError(f"Couldn't find block '{block}' in CIF file. File has {len(self)} blocks.")

    def write(self, file: FileOrPath):
        with open_file(file, 'w') as f:
            print(f"# generated by atomlib", file=f, end=None)
            for data_block in self.data_blocks:
                print(file=f)
                data_block._write(f)

@dataclass
class CIFDataBlock:
    name: t.Optional[str]  # None: no data_ block, empty string: unnamed "data_"

    # data (including loops) in file order
    data: t.Tuple[t.Union[t.Tuple[str, Value], CIFTable], ...]

    # data flattened into a single dictionary. Created automatically from `data`
    data_dict: t.Dict[str, t.Union[t.List[Value], Value]] = field(init=False)

    def __post_init__(self):
        # if we raise here, make sure the object state is fine
        self.data_dict = None  # type: ignore

        data_values = {}

        def _iter_data_values():
            for d in self.data:
                if isinstance(d, CIFTable):
                    yield from d.data.items()
                else:
                    yield d

        for (k, v) in _iter_data_values():
            if k in data_values:
                raise ValueError(f"Duplicate key {k}")
            data_values[k] = v

        self.data_dict = data_values

    @staticmethod
    def from_file(file: FileOrPath) -> t.Iterator[CIFDataBlock]:
        with open_file(file) as f:
            yield from CifReader(f).parse()

    def write(self, file: FileOrPath):
        with open_file(file, 'w') as f:
            self._write(f)

    def _write(self, f: TextIOBase):
        if self.name is not None:
            print(f"data_{self.name}\n", file=f)

        for data in self.data:
            if isinstance(data, CIFTable):
                data._write(f)
            else:
                (name, value) = data
                val = _format_val(value).rstrip()
                if val.startswith(';'):
                    # multiline string
                    print(f"_{name}\n{val}", file=f)
                else:
                    print(f"_{name: <28} {_format_val(value).rstrip()}", file=f)

    def stack_tags(self, *tags: str, dtype: t.Union[str, numpy.dtype, t.Iterable[t.Union[str, numpy.dtype]], None] = None,
                   rename: t.Optional[t.Iterable[t.Optional[str]]] = None, required: t.Union[bool, t.Iterable[bool]] = True) -> polars.DataFrame:
        dtypes: t.Iterable[t.Optional[numpy.dtype]]
        if dtype is None:
            dtypes = repeat(None)
        elif isinstance(dtype, (numpy.dtype, str)):
            dtypes = (numpy.dtype(dtype),) * len(tags)
        else:
            dtypes = tuple(map(lambda ty: numpy.dtype(ty), dtype))
            if len(dtypes) != len(tags):
                raise ValueError(f"dtype list of invalid length")

        if isinstance(required, bool):
            required = repeat(required)

        if rename is None:
            rename = repeat(None)

        d = {}
        for (tag, ty, req, name) in zip(tags, dtypes, required, rename):
            if tag not in self.data_dict:
                if req:
                    raise ValueError(f"Tag '{tag}' missing from CIF file")
                continue
            try:
                arr = numpy.array(self.data_dict[tag], dtype=ty)
                d[name or tag] = arr
            except TypeError:
                raise TypeError(f"Tag '{tag}' of invalid or heterogeneous type.")

        if len(d) == 0:
            return polars.DataFrame({})

        l = len(next(iter(d.values())))
        if any(len(arr) != l for arr in d.values()):
            raise ValueError(f"Tags of mismatching lengths: {tuple(map(len, d.values()))}")

        return polars.DataFrame(d)

    def cell_size(self) -> t.Optional[t.Tuple[float, float, float]]:
        """Return cell size (in angstroms)."""
        try:
            a = float(self['cell_length_a'])  # type: ignore
            b = float(self['cell_length_b'])  # type: ignore
            c = float(self['cell_length_c'])  # type: ignore
            return (a, b, c)
        except (ValueError, TypeError, KeyError):
            return None

    def cell_angle(self) -> t.Optional[t.Tuple[float, float, float]]:
        """Return cell angle (in degrees)."""
        try:
            a = float(self['cell_angle_alpha'])  # type: ignore
            b = float(self['cell_angle_beta'])   # type: ignore
            g = float(self['cell_angle_gamma'])  # type: ignore
            return (a, b, g)
        except (ValueError, TypeError, KeyError):
            return None

    def get_symmetry(self) -> t.Iterator[AffineTransform3D]:
        syms = self.data_dict.get('symmetry_equiv_pos_as_xyz', None)
        if syms is None:
            syms = ()
        if not hasattr(syms, '__iter__'):
            syms = (syms,)
        return map(parse_symmetry, map(str, syms))  # type: ignore

    def __getitem__(self, key: str) -> t.Union[Value, t.List[Value]]:
        return self.data_dict.__getitem__(key)


@dataclass
class CIFTable:
    data: t.Dict[str, t.List[Value]]

    def _write(self, f: TextIOBase):
        print(f"\nloop_", file=f)
        for tag in self.data.keys():
            print(f" _{tag}", file=f)

        for row in zip(*self.data.values()):
            print(f' {"  ".join(map(_format_val, row))}', file=f)

        print(file=f)

"""
@dataclass
class CIF:
    name: t.Optional[str]
    data: t.Dict[str, t.Union[t.List[Value], Value]]

    @staticmethod
    def from_file(file: FileOrPath) -> t.Iterator[CIF]:
        with open_file(file) as f:
            yield from CifReader(f).parse()

    def stack_tags(self, *tags: str, dtype: t.Union[str, numpy.dtype, t.Iterable[t.Union[str, numpy.dtype]], None] = None,
                   rename: t.Optional[t.Iterable[t.Optional[str]]] = None, required: t.Union[bool, t.Iterable[bool]] = True) -> polars.DataFrame:
        dtypes: t.Iterable[t.Optional[numpy.dtype]]
        if dtype is None:
            dtypes = repeat(None)
        elif isinstance(dtype, (numpy.dtype, str)):
            dtypes = (numpy.dtype(dtype),) * len(tags)
        else:
            dtypes = tuple(map(lambda ty: numpy.dtype(ty), dtype))
            if len(dtypes) != len(tags):
                raise ValueError(f"dtype list of invalid length")

        if isinstance(required, bool):
            required = repeat(required)

        if rename is None:
            rename = repeat(None)

        d = {}
        for (tag, ty, req, name) in zip(tags, dtypes, required, rename):
            if tag not in self.data:
                if req:
                    raise ValueError(f"Tag '{tag}' missing from CIF file")
                continue
            try:
                arr = numpy.array(self.data[tag], dtype=ty)
                d[name or tag] = arr
            except TypeError:
                raise TypeError(f"Tag '{tag}' of invalid or heterogeneous type.")

        if len(d) == 0:
            return polars.DataFrame({})

        l = len(next(iter(d.values())))
        if any(len(arr) != l for arr in d.values()):
            raise ValueError(f"Tags of mismatching lengths: {tuple(map(len, d.values()))}")

        return polars.DataFrame(d)

    def cell_size(self) -> t.Optional[t.Tuple[float, float, float]]:
        \"""Return cell size (in angstroms).\"""
        try:
            a = float(self['cell_length_a'])  # type: ignore
            b = float(self['cell_length_b'])  # type: ignore
            c = float(self['cell_length_c'])  # type: ignore
            return (a, b, c)
        except (ValueError, TypeError, KeyError):
            return None

    def cell_angle(self) -> t.Optional[t.Tuple[float, float, float]]:
        \"""Return cell angle (in degrees).\"""
        try:
            a = float(self['cell_angle_alpha'])  # type: ignore
            b = float(self['cell_angle_beta'])   # type: ignore
            g = float(self['cell_angle_gamma'])  # type: ignore
            return (a, b, g)
        except (ValueError, TypeError, KeyError):
            return None

    def get_symmetry(self) -> t.Iterator[AffineTransform3D]:
        syms = self.data.get('symmetry_equiv_pos_as_xyz', None)
        if syms is None:
            syms = ()
        if not hasattr(syms, '__iter__'):
            syms = (syms,)
        return map(parse_symmetry, map(str, syms))  # type: ignore

    def __getitem__(self, key: str) -> t.Union[Value, t.List[Value]]:
        return self.data.__getitem__(key)
"""


class SymmetryVec:
    @classmethod
    def parse(cls, s: str) -> SymmetryVec:
        if s[0] in ('x', 'y', 'z'):
            a = numpy.zeros((4,))
            a[('x', 'y', 'z').index(s[0])] += 1.
            return cls(a)
        return cls(float(s))

    def __init__(self, val: t.Union[float, NDArray[numpy.floating]]):
       self.inner: t.Union[float, NDArray[numpy.floating]] = val

    def is_scalar(self) -> bool:
        return isinstance(self.inner, float)

    def to_vec(self) -> NDArray[numpy.floating]:
        if isinstance(self.inner, (int, float)):
            vec = numpy.zeros((4,))
            vec[3] = self.inner
            return vec
        return self.inner

    def __add__(self, rhs: SymmetryVec) -> SymmetryVec:
        if self.is_scalar() and rhs.is_scalar():
            return SymmetryVec(self.inner + rhs.inner)
        return SymmetryVec(rhs.to_vec() + self.to_vec())

    def __neg__(self) -> SymmetryVec:
        return SymmetryVec(-self.inner)

    def __sub__(self, rhs: SymmetryVec) -> SymmetryVec:
        if self.is_scalar() and rhs.is_scalar():
            return SymmetryVec(self.inner - rhs.inner)
        return SymmetryVec(rhs.to_vec() - self.to_vec())

    def __mul__(self, rhs: SymmetryVec) -> SymmetryVec:
        if not self.is_scalar() and not rhs.is_scalar():
            raise ValueError("Can't multiply two symmetry directions")
        return SymmetryVec(rhs.inner * self.inner)

    def __truediv__(self, rhs: SymmetryVec) -> SymmetryVec:
        if not self.is_scalar() and not rhs.is_scalar():
            raise ValueError("Can't divide two symmetry directions")
        return SymmetryVec(rhs.inner / self.inner)


SYMMETRY_PARSER: Parser[SymmetryVec, SymmetryVec] = Parser([
    BinaryOrUnaryOp(['-'], sub, False, 5),
    BinaryOp(['+'], operator.add, 5),
    BinaryOp(['*'], operator.mul, 6),
    BinaryOp(['/'], operator.truediv, 6),
], SymmetryVec.parse)


def parse_symmetry(s: str) -> AffineTransform3D:
    axes = s.split(',')
    if not len(axes) == 3:
        raise ValueError(f"Error parsing symmetry expression '{s}': Expected 3 values, got {len(axes)}")

    axes = [SYMMETRY_PARSER.parse(StringIO(ax)).eval(lambda v: v).to_vec() for ax in axes]
    axes.append(numpy.array([0., 0., 0., 1.]))
    return AffineTransform3D(numpy.stack(axes, axis=0))


class CifReader:
    def __init__(self, file: TextIOBase):
        self.line = 0
        self._file: TextIOBase = file
        self._buf: t.Optional[str] = None
        self._after_eol = True
        self._eof = False

    def parse(self) -> t.Iterator[CIFDataBlock]:
        while True:
            line = self.line
            word = self.peek_word()
            if word is None:
                return
            if word.lower().startswith('data_'):
                self.next_word()
                name = word[len('data_'):]
            elif word.startswith('_'):
                name = None
            else:
                raise ValueError(f"While parsing line {line}: Unexpected token {word}")

            yield self.parse_datablock(name)

    def after_eol(self) -> bool:
        """
        Returns whether the current token (the one that will be returned
        by the next peek() or next()) is after a newline.
        """
        return self._after_eol

    def peek_line(self) -> t.Optional[str]:
        buf = self._try_fill_buf()
        return buf

    def next_line(self) -> t.Optional[str]:
        line = self.peek_line()
        self._buf = None
        return line

    def next_until(self, marker: str) -> t.Optional[str]:
        """
        Collect words until `marker`. Because of the weirdness of CIF,
        `marker` must occur immediately before a whitespace boundary.
        """
        s = ""
        buf = self._try_fill_buf()
        if buf is None:
            return None
        while not (match := re.search(re.escape(marker) + r'(?=\s|$)', buf)):
            s += buf
            buf = self._try_fill_buf(True)
            if buf is None:
                return None
        s += buf[:match.end()]
        self._buf = buf[match.end():]
        if len(self._buf) == 0 or self._buf.isspace():
            self._buf = None
        return s

    def peek_word(self) -> t.Optional[str]:
        while True:
            buf = self._try_fill_buf()
            if buf is None:
                return None
            buf = buf.lstrip()
            if len(buf) == 0 or buf.isspace() or buf.startswith('#'):
                # eat comment or blank line
                self._buf = None
                continue
            break

        #print(f"buf: '{buf}'")
        return buf.split(maxsplit=1)[0]

    def next_word(self) -> t.Optional[str]:
        w = self.peek_word()
        if w is None:
            return None
        assert self._buf is not None
        self._buf = self._buf.lstrip()[len(w)+1:].lstrip()
        if len(self._buf) == 0 or self._buf.isspace():
            # eat whitespace at end of line
            self._buf = None
            self._after_eol = True
        else:
            self._after_eol = False
        return w

    def _try_fill_buf(self, force: bool = False) -> t.Optional[str]:
        if force:
            self._buf = None
        if self._buf is None:
            try:
                self._buf = next(self._file)
                self.line += 1
            except StopIteration:
                pass
        return self._buf
    
    def parse_bare(self) -> t.Union[int, float, str]:
        w = self.next_word()
        if w is None:
            raise ValueError("Unexpected EOF while parsing value.")
        if _INT_RE.fullmatch(w):
            return int(w)  # may raise
        if (m := _FLOAT_RE.fullmatch(w)):
            if m[1] != '.':
                return float(m[1])  # may raise
        return w

    def parse_datablock(self, name: t.Optional[str] = None) -> CIFDataBlock:
        logging.debug(f"parse datablock '{name}'")
        #data: t.Dict[str, t.Union[t.List[Value], Value]] = {}

        data: t.List[t.Union[CIFTable, t.Tuple[str, Value]]] = []

        while True:
            word = self.peek_word()
            if word is None:
                break
            if word.lower() == 'loop_':
                self.next_word()
                data.append(self.parse_loop())
            elif word.startswith('_'):
                self.next_word()
                (k, v) = (word[1:], self.parse_value())
                logging.debug(f"{k} = {v}")
                data.append((k, v))
            else:
                break

        return CIFDataBlock(name, tuple(data))

    def eat_saveframe(self):
        line = self.line
        while True:
            w = self.next_word()
            if w is None:
                raise ValueError(f"EOF before end of save frame starting at line {line}")
            if w.lower() == 'save_':
                break

    def parse_loop(self) -> CIFTable:
        line = self.line
        tags = []
        while True:
            w = self.peek_word()
            if w is None:
                raise ValueError(f"EOF before loop values at line {line}")
            if w.startswith('_'):
                self.next_word()
                tags.append(w[1:])
            else:
                break

        vals: t.Tuple[t.List[Value], ...] = tuple([] for _ in tags)
        i = 0

        while True:
            w = self.peek_word()
            if w is None or w.startswith('_') or w.endswith('_'):
                break
            vals[i].append(self.parse_value())
            i = (i + 1) % len(tags)

        if i != 0:
            n_vals = sum(map(len, vals))
            raise ValueError(f"While parsing loop at line {line}: "
                            f"Got {n_vals} vals, expected a multiple of {len(tags)}")

        return CIFTable(dict(zip(tags, vals)))

    def parse_value(self) -> Value:
        logging.debug(f"parse_value")
        w = self.peek_word()
        assert w is not None
        if w in ('.', '?'):
            self.next_word()
            return None

        if self.after_eol() and w == ';':
            return self.parse_text_field()

        if w[0] in ('"', "'"):
            return self.parse_quoted()

        return self.parse_bare()

    def parse_text_field(self) -> str:
        line = self.line
        l = self.next_line()
        assert l is not None
        s = l.lstrip().removeprefix(';').lstrip()
        while True:
            l = self.next_line()
            if l is None:
                raise ValueError(f"While parsing text field at line {line}: Unexpected EOF")
            if l.strip() == ';':
                break
            s += l
        return s.rstrip()

    def parse_quoted(self) -> str:
        line = self.line
        w = self.peek_word()
        assert w is not None
        quote = w[0]
        if quote not in ('"', "'"):
            raise ValueError(f"While parsing string at line {line}: Invalid quote char {quote}")

        s = self.next_until(quote)
        if s is None:
            raise ValueError(f"While parsing string {w}... at line {line}: Unexpected EOF")
        return s.lstrip()[1:-1]
